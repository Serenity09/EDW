globals
//globals from Boolean:
constant boolean LIBRARY_Boolean=true
//endglobals from Boolean
//globals from ConfigurationMode:
constant boolean LIBRARY_ConfigurationMode=true
constant integer DEV= 0
constant integer TEST= 1
constant integer RELEASE= 2
		
constant integer CONFIGURATION_PROFILE= 2
		
constant boolean FORCE_SETTING_MENU= false
//endglobals from ConfigurationMode
//globals from DestructableGlobals:
constant boolean LIBRARY_DestructableGlobals=true
constant integer FOOT_SWITCH= 'B005'
constant integer FOOT_SWITCH_SIZE= 64
//endglobals from DestructableGlobals
//globals from Draw:
constant boolean LIBRARY_Draw=true
//endglobals from Draw
//globals from DummyCaster:
constant boolean LIBRARY_DummyCaster=true
constant integer UNITS_DUMMY_CASTER= 'n001'
    
    
constant player DummyCaster___PLAYER_OWNER= Player(15)
unit DummyCaster___u
//endglobals from DummyCaster
//globals from EDWQuests:
constant boolean LIBRARY_EDWQuests=true
//endglobals from EDWQuests
//globals from ErrorMessage:
constant boolean LIBRARY_ErrorMessage=true
//endglobals from ErrorMessage
//globals from Event:
constant boolean LIBRARY_Event=true
real Event___q=0
//endglobals from Event
//globals from FilterFuncs:
constant boolean LIBRARY_FilterFuncs=true
filterfunc GreenOrBrown
filterfunc PlayerOwned
filterfunc Green
filterfunc Brown
filterfunc NotMazer
//endglobals from FilterFuncs
//globals from FooBar:
constant boolean LIBRARY_FooBar=true
//endglobals from FooBar
//globals from FourSeasons1:
constant boolean LIBRARY_FourSeasons1=true
//endglobals from FourSeasons1
//globals from GameGlobalConstants:
constant boolean LIBRARY_GameGlobalConstants=true
        //number of human players
constant integer NumberPlayers= 8
        
group TempGroup= CreateGroup()
group SwapGroup
//endglobals from GameGlobalConstants
//globals from GameMessage:
constant boolean LIBRARY_GameMessage=true
constant string SPEAKER_COLOR= "FFBD33"
constant string DEFAULT_TEXT_COLOR= "fcf0e5"
constant string STERN_TEXT_COLOR= "4f4f4f"
constant string HAPPY_TEXT_COLOR= "dcefd5"
constant string SAD_TEXT_COLOR= "c1c9ff"
constant string ANGRY_TEXT_COLOR= "772929"
		
constant string INTRO_TEXT_COLOR= HAPPY_TEXT_COLOR
constant string DOORS_TEXT_COLOR= HAPPY_TEXT_COLOR
constant string EASY_ICE_WORLD_COLOR= "a7abf2"
constant string HARD_ICE_WORLD_COLOR= "bdd3f0"
constant string PLATFORMING_WORLD_COLOR= "f7870f"
constant string FOUR_SEASONS_WORLD_COLOR= HAPPY_TEXT_COLOR
constant string LAND_WORLD_COLOR= "67e676"
		
constant string TOGGLE_ON_COLOR= "5cb85c"
constant string TOGGLE_OFF_COLOR= "d9534f"
		
constant string DISABLED_COLOR= "bbbbbb"
        
constant string PRIMARY_SPEAKER_NAME= "SARGE"
constant string SECONDARY_SPEAKER_NAME= "Cupcake"
        
constant string FINAL_BOSS_PRE_REVEAL= "???"
constant string FINAL_BOSS_NAME= "???"
        
constant real DEFAULT_TINY_TEXT_SPEED= 1.0
constant real DEFAULT_SHORT_TEXT_SPEED= 3.0
constant real DEFAULT_MEDIUM_TEXT_SPEED= 5.0
constant real DEFAULT_LONG_TEXT_SPEED= 8.0
//endglobals from GameMessage
//globals from GroupUtils:
constant boolean LIBRARY_GroupUtils=true
constant integer GroupUtils___MAX_RECYCLE_COUNT= 100
constant integer GroupUtils___PRELOAD_COUNT= 5
group array GroupUtils___recycle
integer GroupUtils___count
//endglobals from GroupUtils
//globals from HandleList:
constant boolean LIBRARY_HandleList=true
//endglobals from HandleList
//globals from IStartable:
constant boolean LIBRARY_IStartable=true
//endglobals from IStartable
//globals from LevelIDGlobals:
constant boolean LIBRARY_LevelIDGlobals=true
constant integer TEMP_LEVEL_ID= 1000
		
constant integer INTRO_LEVEL_ID= 1
constant integer DOORS_LEVEL_ID= 2
        
constant integer IW1_LEVEL_ID= 3
constant integer IW2_LEVEL_ID= 10
constant integer IW3_LEVEL_ID= 17
constant integer IW4_LEVEL_ID= 24
constant integer IW5_LEVEL_ID= 31
		
constant integer IWB1_LEVEL_ID= 4
		
constant integer LW1_LEVEL_ID= 5
constant integer LW2_LEVEL_ID= 12
		
constant integer FS1_LEVEL_ID= 7
		
constant integer PW1_LEVEL_ID= 9
constant integer PW2_LEVEL_ID= 16
constant integer PW3_LEVEL_ID= 23
constant integer PW4_LEVEL_ID= 30
		
constant integer BRICK_BREAK_LEVEL_ID= 100
		
constant integer TESTDH_LEVEL_ID= 66
constant integer TESTP_LEVEL_ID= 67
//endglobals from LevelIDGlobals
//globals from ListModule:
constant boolean LIBRARY_ListModule=true
//endglobals from ListModule
//globals from ORDER:
constant boolean LIBRARY_ORDER=true
    //strange ones at bottom
constant integer ORDER_OFFSET=851970
    
constant integer ORDER_absorb=852529
constant integer ORDER_acidbomb=852662
constant integer ORDER_acolyteharvest=852185
constant integer ORDER_AImove=851988
constant integer ORDER_ambush=852131
constant integer ORDER_ancestralspirit=852490
constant integer ORDER_ancestralspirittarget=852491
constant integer ORDER_animatedead=852217
constant integer ORDER_antimagicshell=852186
constant integer ORDER_attack=851983
constant integer ORDER_attackground=851984
constant integer ORDER_attackonce=851985
constant integer ORDER_attributemodskill=852576
constant integer ORDER_auraunholy=852215
constant integer ORDER_auravampiric=852216
constant integer ORDER_autodispel=852132
constant integer ORDER_autodispeloff=852134
constant integer ORDER_autodispelon=852133
constant integer ORDER_autoentangle=852505
constant integer ORDER_autoentangleinstant=852506
constant integer ORDER_autoharvestgold=852021
constant integer ORDER_autoharvestlumber=852022
constant integer ORDER_avatar=852086
constant integer ORDER_avengerform=852531
constant integer ORDER_awaken=852466
constant integer ORDER_banish=852486
constant integer ORDER_barkskin=852135
constant integer ORDER_barkskinoff=852137
constant integer ORDER_barkskinon=852136
constant integer ORDER_battleroar=852099
constant integer ORDER_battlestations=852099
constant integer ORDER_bearform=852138
constant integer ORDER_berserk=852100
constant integer ORDER_blackarrow=852577
constant integer ORDER_blackarrowoff=852579
constant integer ORDER_blackarrowon=852578
constant integer ORDER_blight=852187
constant integer ORDER_blink=852525
constant integer ORDER_blizzard=852089
constant integer ORDER_bloodlust=852101
constant integer ORDER_bloodlustoff=852103
constant integer ORDER_bloodluston=852102
constant integer ORDER_board=852043
constant integer ORDER_breathoffire=852580
constant integer ORDER_breathoffrost=852560
constant integer ORDER_build=851994
constant integer ORDER_burrow=852533
constant integer ORDER_cannibalize=852188
constant integer ORDER_carrionscarabs=852551
constant integer ORDER_carrionscarabsinstant=852554
constant integer ORDER_carrionscarabsoff=852553
constant integer ORDER_carrionscarabson=852552
constant integer ORDER_carrionswarm=852218
constant integer ORDER_chainlightning=852119
constant integer ORDER_channel=852600
constant integer ORDER_charm=852581
constant integer ORDER_chemicalrage=852663
constant integer ORDER_cloudoffog=852473
constant integer ORDER_clusterrockets=852652
constant integer ORDER_coldarrows=852244
constant integer ORDER_coldarrowstarg=852243
constant integer ORDER_controlmagic=852474
constant integer ORDER_corporealform=852493
constant integer ORDER_corrosivebreath=852140
constant integer ORDER_coupleinstant=852508
constant integer ORDER_coupletarget=852507
constant integer ORDER_creepanimatedead=852246
constant integer ORDER_creepdevour=852247
constant integer ORDER_creepheal=852248
constant integer ORDER_creephealoff=852250
constant integer ORDER_creephealon=852249
constant integer ORDER_creepthunderbolt=852252
constant integer ORDER_creepthunderclap=852253
constant integer ORDER_cripple=852189
constant integer ORDER_curse=852190
constant integer ORDER_curseoff=852192
constant integer ORDER_curseon=852191
constant integer ORDER_cyclone=852144
constant integer ORDER_darkconversion=852228
constant integer ORDER_darkportal=852229
constant integer ORDER_darkritual=852219
constant integer ORDER_darksummoning=852220
constant integer ORDER_deathanddecay=852221
constant integer ORDER_deathcoil=852222
constant integer ORDER_deathpact=852223
constant integer ORDER_decouple=852509
constant integer ORDER_defend=852055
constant integer ORDER_detectaoe=852015
constant integer ORDER_detonate=852145
constant integer ORDER_devour=852104
constant integer ORDER_devourmagic=852536
constant integer ORDER_disassociate=852240
constant integer ORDER_disenchant=852495
constant integer ORDER_dismount=852470
constant integer ORDER_dispel=852057
constant integer ORDER_divineshield=852090
constant integer ORDER_doom=852583
constant integer ORDER_drain=852487
constant integer ORDER_dreadlordinferno=852224
constant integer ORDER_dropitem=852001
constant integer ORDER_drunkenhaze=852585
constant integer ORDER_earthquake=852121
constant integer ORDER_eattree=852146
constant integer ORDER_elementalfury=852586
constant integer ORDER_ensnare=852106
constant integer ORDER_ensnareoff=852108
constant integer ORDER_ensnareon=852107
constant integer ORDER_entangle=852147
constant integer ORDER_entangleinstant=852148
constant integer ORDER_entanglingroots=852171
constant integer ORDER_etherealform=852496
constant integer ORDER_evileye=852105
constant integer ORDER_faeriefire=852149
constant integer ORDER_faeriefireoff=852151
constant integer ORDER_faeriefireon=852150
constant integer ORDER_fanofknives=852526
constant integer ORDER_farsight=852122
constant integer ORDER_fingerofdeath=852230
constant integer ORDER_firebolt=852231
constant integer ORDER_flamestrike=852488
constant integer ORDER_flamingarrows=852174
constant integer ORDER_flamingarrowstarg=852173
constant integer ORDER_flamingattack=852540
constant integer ORDER_flamingattacktarg=852539
constant integer ORDER_flare=852060
constant integer ORDER_forceboard=852044
constant integer ORDER_forceofnature=852176
constant integer ORDER_forkedlightning=852586
constant integer ORDER_freezingbreath=852195
constant integer ORDER_frenzy=852561
constant integer ORDER_frenzyoff=852563
constant integer ORDER_frenzyon=852562
constant integer ORDER_frostarmor=852225
constant integer ORDER_frostarmoroff=852459
constant integer ORDER_frostarmoron=852458
constant integer ORDER_frostnova=852226
constant integer ORDER_getitem=851981
constant integer ORDER_gold2lumber=852233
constant integer ORDER_grabtree=852511
constant integer ORDER_harvest=852018
constant integer ORDER_heal=852063
constant integer ORDER_healingspray=852664
constant integer ORDER_healingward=852109
constant integer ORDER_healingwave=852501
constant integer ORDER_healoff=852065
constant integer ORDER_healon=852064
constant integer ORDER_hex=852502
constant integer ORDER_holdposition=851993
constant integer ORDER_holybolt=852092
constant integer ORDER_howlofterror=852588
constant integer ORDER_humanbuild=851995
constant integer ORDER_immolation=852177
constant integer ORDER_impale=852555
constant integer ORDER_incineratearrow=852670
constant integer ORDER_incineratearrowoff=852672
constant integer ORDER_incineratearrowon=852671
constant integer ORDER_inferno=852232
constant integer ORDER_innerfire=852066
constant integer ORDER_innerfireoff=852068
constant integer ORDER_innerfireon=852067
constant integer ORDER_instant=852200
constant integer ORDER_invisibility=852069
constant integer ORDER_lavamonster=852667
constant integer ORDER_lightningshield=852110
constant integer ORDER_load=852046
constant integer ORDER_loadarcher= 852142
constant integer ORDER_loadcorpse=852050
constant integer ORDER_loadcorpseinstant=852053
constant integer ORDER_locustswarm=852556
constant integer ORDER_lumber2gold=852234
constant integer ORDER_magicdefense=852478
constant integer ORDER_magicleash=852480
constant integer ORDER_magicundefense=852479
constant integer ORDER_manaburn=852179
constant integer ORDER_manaflareoff=852513
constant integer ORDER_manaflareon=852512
constant integer ORDER_manashieldoff=852590
constant integer ORDER_manashieldon=852589
constant integer ORDER_massteleport=852093
constant integer ORDER_mechanicalcritter=852564
constant integer ORDER_metamorphosis=852180
constant integer ORDER_militia=852072
constant integer ORDER_militiaconvert=852071
constant integer ORDER_militiaoff=852073
constant integer ORDER_militiaunconvert=852651
constant integer ORDER_mindrot=852565
constant integer ORDER_mirrorimage=852123
constant integer ORDER_monsoon=852591
constant integer ORDER_mount=852469
constant integer ORDER_mounthippogryph=852143
constant integer ORDER_move=851986
constant integer ORDER_nagabuild=852467
constant integer ORDER_neutraldetectaoe=852023
constant integer ORDER_neutralinteract=852566
constant integer ORDER_neutralspell=852630
constant integer ORDER_nightelfbuild=851997
constant integer ORDER_orcbuild=851996
constant integer ORDER_parasite=852601
constant integer ORDER_parasiteoff=852603
constant integer ORDER_parasiteon=852602
constant integer ORDER_patrol=851990
constant integer ORDER_phaseshift=852514
constant integer ORDER_phaseshiftinstant=852517
constant integer ORDER_phaseshiftoff=852516
constant integer ORDER_phaseshifton=852515
constant integer ORDER_phoenixfire=852481
constant integer ORDER_phoenixmorph=852482
constant integer ORDER_poisonarrows=852255
constant integer ORDER_poisonarrowstarg=852254
constant integer ORDER_polymorph=852074
constant integer ORDER_possession=852196
constant integer ORDER_preservation=852568
constant integer ORDER_purge=852111
constant integer ORDER_rainofchaos=852237
constant integer ORDER_rainoffire=852238
constant integer ORDER_raisedead=852197
constant integer ORDER_raisedeadoff=852199
constant integer ORDER_raisedeadon=852198
constant integer ORDER_ravenform=852155
constant integer ORDER_recharge=852157
constant integer ORDER_rechargeoff=852159
constant integer ORDER_rechargeon=852158
constant integer ORDER_rejuvination=852160
constant integer ORDER_renew=852161
constant integer ORDER_renewoff=852163
constant integer ORDER_renewon=852162
constant integer ORDER_repair=852024
constant integer ORDER_repairoff=852026
constant integer ORDER_repairon=852025
constant integer ORDER_replenish=852542
constant integer ORDER_replenishlife=852545
constant integer ORDER_replenishlifeoff=852547
constant integer ORDER_replenishlifeon=852546
constant integer ORDER_replenishmana=852548
constant integer ORDER_replenishmanaoff=852550
constant integer ORDER_replenishmanaon=852549
constant integer ORDER_replenishoff=852544
constant integer ORDER_replenishon=852543
constant integer ORDER_request_hero=852239
constant integer ORDER_requestsacrifice=852201
constant integer ORDER_restoration=852202
constant integer ORDER_restorationoff=852204
constant integer ORDER_restorationon=852203
constant integer ORDER_resumebuild=851999
constant integer ORDER_resumeharvesting=852017
constant integer ORDER_resurrection=852094
constant integer ORDER_returnresources=852020
constant integer ORDER_revenge=852241
constant integer ORDER_revive=852039
constant integer ORDER_roar=852164
constant integer ORDER_robogoblin=852656
constant integer ORDER_root=852165
constant integer ORDER_sacrifice=852205
constant integer ORDER_sanctuary=852569
constant integer ORDER_scout=852181
constant integer ORDER_selfdestruct=852040
constant integer ORDER_selfdestructoff=852042
constant integer ORDER_selfdestructon=852041
constant integer ORDER_sentinel=852182
constant integer ORDER_setrally=851980
constant integer ORDER_shadowsight=852570
constant integer ORDER_shadowstrike=852527
constant integer ORDER_shockwave=852125
constant integer ORDER_silence=852592
constant integer ORDER_sleep=852227
constant integer ORDER_slow=852075
constant integer ORDER_slowoff=852077
constant integer ORDER_slowon=852076
constant integer ORDER_smart=851971
constant integer ORDER_soulburn=852668
constant integer ORDER_soulpreservation=852242
constant integer ORDER_spellshield=852571
constant integer ORDER_spellshieldaoe=852572
constant integer ORDER_spellsteal=852483
constant integer ORDER_spellstealoff=852485
constant integer ORDER_spellstealon=852484
constant integer ORDER_spies=852235
constant integer ORDER_spiritlink=852499
constant integer ORDER_spiritofvengeance=852528
constant integer ORDER_spirittroll=852573
constant integer ORDER_spiritwolf=852126
constant integer ORDER_stampede=852593
constant integer ORDER_standdown=852113
constant integer ORDER_starfall=852183
constant integer ORDER_stasistrap=852114
constant integer ORDER_steal=852574
constant integer ORDER_stomp=852127
constant integer ORDER_stoneform=852206
constant integer ORDER_stop=851972
constant integer ORDER_submerge=852604
constant integer ORDER_summonfactory=852658
constant integer ORDER_summongrizzly=852594
constant integer ORDER_summonphoenix=852489
constant integer ORDER_summonquillbeast=852595
constant integer ORDER_summonwareagle=852596
constant integer ORDER_tankdroppilot=852079
constant integer ORDER_tankloadpilot=852080
constant integer ORDER_tankpilot=852081
constant integer ORDER_taunt=852520
constant integer ORDER_thunderbolt=852095
constant integer ORDER_thunderclap=852096
constant integer ORDER_tornado=852597
constant integer ORDER_townbelloff=852083
constant integer ORDER_townbellon=852082
constant integer ORDER_tranquility=852184
constant integer ORDER_transmute=852665
constant integer ORDER_unavatar=852087
constant integer ORDER_unavengerform=852532
constant integer ORDER_unbearform=852139
constant integer ORDER_unburrow=852534
constant integer ORDER_uncoldarrows=852245
constant integer ORDER_uncorporealform=852494
constant integer ORDER_undeadbuild=851998
constant integer ORDER_undefend=852056
constant integer ORDER_undivineshield=852091
constant integer ORDER_unetherealform=852497
constant integer ORDER_unflamingarrows=852175
constant integer ORDER_unflamingattack=852541
constant integer ORDER_unholyfrenzy=852209
constant integer ORDER_unimmolation=852178
constant integer ORDER_unload=852047
constant integer ORDER_unloadall=852048
constant integer ORDER_unloadallcorpses=852054
constant integer ORDER_unloadallinstant=852049
constant integer ORDER_unpoisonarrows=852256
constant integer ORDER_unravenform=852156
constant integer ORDER_unrobogoblin=852657
constant integer ORDER_unroot=852166
constant integer ORDER_unstableconcoction=852500
constant integer ORDER_unstoneform=852207
constant integer ORDER_unsubmerge=852605
constant integer ORDER_unsummon=852210
constant integer ORDER_unwindwalk=852130
constant integer ORDER_vengeance=852521
constant integer ORDER_vengeanceinstant=852524
constant integer ORDER_vengeanceoff=852523
constant integer ORDER_vengeanceon=852522
constant integer ORDER_volcano=852669
constant integer ORDER_voodoo=852503
constant integer ORDER_ward=852504
constant integer ORDER_waterelemental=852097
constant integer ORDER_wateryminion=852598
constant integer ORDER_web=852211
constant integer ORDER_weboff=852213
constant integer ORDER_webon=852212
constant integer ORDER_whirlwind=852128
constant integer ORDER_windwalk=852129
constant integer ORDER_wispharvest=852214
    
constant integer ORDER_scrollofspeed=852285
constant integer ORDER_cancel=851976
constant integer ORDER_moveslot1=852002
constant integer ORDER_moveslot2=852003
constant integer ORDER_moveslot3=852004
constant integer ORDER_moveslot4=852005
constant integer ORDER_moveslot5=852006
constant integer ORDER_moveslot6=852007
constant integer ORDER_useslot1=852008
constant integer ORDER_useslot2=852009
constant integer ORDER_useslot3=852010
constant integer ORDER_useslot4=852011
constant integer ORDER_useslot5=852012
constant integer ORDER_useslot6=852013
constant integer ORDER_skillmenu=852000
constant integer ORDER_stunned=851973

constant integer ORDER_instant1=851991
constant integer ORDER_instant2=851987
constant integer ORDER_instant3=851975
constant integer ORDER_instant4=852019
//endglobals from ORDER
//globals from PermanentAlloc:
constant boolean LIBRARY_PermanentAlloc=true
//endglobals from PermanentAlloc
//globals from PlatformerGlobals:
constant boolean LIBRARY_PlatformerGlobals=true
constant real PlatformerGlobals_RADIUS= 22.
constant real PlatformerGlobals_SAFE_X= - 12000.0
constant real PlatformerGlobals_SAFE_Y= 12000.0
        
constant real PlatformerGlobals_GAMELOOP_TIMESTEP= .0350
    //private constant real GAMELOOP_TIMESTEP     = .0500 //.031250000
constant real PlatformerGlobals_TERRAINLOOP_TIMESTEP= .0700
    
    //TODO 1-2 timers for handling gravity and x/y falloff (friction)
//endglobals from PlatformerGlobals
//globals from PreventSave:
constant boolean LIBRARY_PreventSave=true
boolean GameAllowSave= false
dialog PreventSave___Dialog= DialogCreate()
timer PreventSave___Timer= CreateTimer()
player PreventSave___localplayer
//endglobals from PreventSave
//globals from RunningGlobals:
constant boolean LIBRARY_RunningGlobals=true
        //default movespeed of the player owned mazing unit
constant real DefaultMoveSpeed= 320.0
        
constant real FastGrassSpeed= 520.0
constant real MediumGrassSpeed= 400.0
constant real SlowGrassSpeed= 160.0
		
constant real RoadSpeed= MediumGrassSpeed
//endglobals from RunningGlobals
//globals from Stack:
constant boolean LIBRARY_Stack=true
//endglobals from Stack
//globals from Table:
constant boolean LIBRARY_Table=true
integer Table___less= 0
integer Table___more= 8190
    //Configure it if you use more than 8190 "key" variables in your map (this will never happen though).
    
hashtable Table___ht= InitHashtable()
constant integer Table___sizeK=6
constant integer Table___listK=7
//endglobals from Table
//globals from TimerUtils:
constant boolean LIBRARY_TimerUtils=true
        //How to tweak timer utils:
        // USE_HASH_TABLE = true  (new blue)
        //  * SAFEST
        //  * SLOWEST (though hash tables are kind of fast)
        //
        // USE_HASH_TABLE = false, USE_FLEXIBLE_OFFSET = true  (orange)
        //  * kinda safe (except there is a limit in the number of timers)
        //  * ALMOST FAST
        //
        // USE_HASH_TABLE = false, USE_FLEXIBLE_OFFSET = false (red)
        //  * THE FASTEST (though is only  faster than the previous method
        //                  after using the optimizer on the map)
        //  * THE LEAST SAFE ( you may have to tweak OFSSET manually for it to
        //                     work)
        //
constant boolean TimerUtils___USE_HASH_TABLE= true
constant boolean TimerUtils___USE_FLEXIBLE_OFFSET= false

constant integer TimerUtils___OFFSET= 0x100000
integer TimerUtils___VOFFSET= TimerUtils___OFFSET
              
        //Timers to preload at map init:
constant integer TimerUtils___QUANTITY= 128
        
        //Changing this  to something big will allow you to keep recycling
        // timers even when there are already AN INCREDIBLE AMOUNT of timers in
        // the stack. But it will make things far slower so that's probably a bad idea...
constant integer TimerUtils___ARRAY_SIZE= 8190

// processed:         integer array TimerUtils___data[TimerUtils___ARRAY_SIZE]
hashtable TimerUtils___ht
// processed:         timer array TimerUtils___tT[TimerUtils___ARRAY_SIZE]
integer TimerUtils___tN= 0
constant integer TimerUtils___HELD=0x28829022
        //use a totally random number here, the more improbable someone uses it, the better.
        
boolean TimerUtils___didinit= false
//endglobals from TimerUtils
//globals from UnitDefaultRadius:
constant boolean LIBRARY_UnitDefaultRadius=true
//endglobals from UnitDefaultRadius
//globals from UnitGlobals:
constant boolean LIBRARY_UnitGlobals=true
        //mazer type
constant integer MAZER= 'Edem'
constant integer TEAM_REVIVE_UNIT_ID= 'rTEM'
        
        //patrols
        //should be filtered in (does collide)
constant integer LGUARD= 'e002'
constant integer GUARD= 'e000'
        
constant integer ICETROLL= 'n002'
		
constant integer SPIRITWALKER= 'o002'
		
constant integer CLAWMAN= 'e00U'
        
constant integer TANK= 'h001'
constant integer TRUCK= 'h003'
constant integer FIRETRUCK= 'h005'
constant integer AMBULANCE= 'h006'
constant integer JEEP= 'h004'
constant integer PASSENGERCAR= 'h007'
constant integer CORVETTE= 'h002'
constant integer POLICECAR= 'h008'
		
		
        //attacking units
        //should be filtered out (not collide)
constant integer ROGTHT= 'n000'
        
        //unmoving obstacles
        //should be filtered in (does collide)
constant integer REGRET= 'e003'
constant integer LMEMORY= 'e004'
constant integer GUILT= 'e005'
		
constant integer GREENFROG= 'n003'
constant integer ORANGEFROG= 'n007'
constant integer PURPLEFROG= 'n006'
constant integer TURQOISEFROG= 'n005'
constant integer REDFROG= 'n004'
        
        //mortars
        //should be filtered out (not collide)
constant integer SMLMORT= 'h000'
        
        //targets
        //should be filtered out (not collide)
constant integer SMLTARG= 'e006'
constant integer MEDTARG= 'e007'
constant integer LRGTARG= 'e008'
        
        //wisp wheel wisps
        //case to case on whether or not to filter
constant integer WWWISP= 'e009'
constant integer WWSKUL= 'e00A'
        
        //keys and barriers
constant integer KEYR= 'e00D'
constant integer RKEY= 'e00C'
constant integer RFIRE= 'e00B'
constant integer BKEY= 'e00F'
constant integer BFIRE= 'e00E'
constant integer GKEY= 'e00H'
constant integer GFIRE= 'e00G'
        
constant integer BLACKHOLE= 's666'
constant real BLACKHOLE_TIMESTEP= 1.5
constant real BLACKHOLE_MAXRADIUS= 5 * 128
		
constant integer BRICK= 'h009'
constant integer GOLD_BRICK= 'h00A'
constant integer PADDLE= 'h00B'
		
constant integer TELEPORT= 'eTEL'
        
		
constant integer INACTIVE_UNIT_OPACITY= 100
//endglobals from UnitGlobals
//globals from Vector2:
constant boolean LIBRARY_Vector2=true
//endglobals from Vector2
//globals from locust:
constant boolean LIBRARY_locust=true
//endglobals from locust
//globals from ContinueGlobals:
constant boolean LIBRARY_ContinueGlobals=true
        //how many continues a player currently has
// processed:         integer array NumberContinues[NumberPlayers]
        //when a unit dies, its revived in its appropriate Revives rect
// processed:         rect array Revives[NumberPlayers]
// processed:         fogmodifier array Vision1[100]
        //how many continues to give a player when they enter a level if current mode is rewards system
// processed:         integer array ContinuesRewardsSys[100]
        //how many continues to give a player if current mode is par-for-the-course system
// processed:         integer array ContinuesParSys[100]
        
constant integer STARTING_CONTINUES= 3
        
        
constant real REVIVE_PAUSE_TIME_PLATFORMING= .25
        
        //constant real REVIVE_WAIT_AFTER_DEATH = 4.
constant real REVIVE_WAIT_AFTER_DEATH= 1.
//endglobals from ContinueGlobals
//globals from GameModesGlobals:
constant boolean LIBRARY_GameModesGlobals=true
constant integer GameModesGlobals_SOLO= 0
constant integer GameModesGlobals_TEAMALL= 1
constant integer GameModesGlobals_TEAMRANDOM= 2

constant integer GameModesGlobals_EASY= 0
constant integer GameModesGlobals_HARD= 1
constant integer GameModesGlobals_CHEAT= 2
	
constant integer VICTORY_SCORE_15= 0
constant integer VICTORY_SCORE_25= 1
constant integer VICTORY_TIME_20= 2
constant integer VICTORY_TIME_30= 3
	
constant real REVIVE_PAUSE_TIME_ASAP= 2.5
constant real REVIVE_PAUSE_TIME_NONASAP= 1.5
	
integer GameMode= GameModesGlobals_SOLO
integer RewardMode= GameModesGlobals_EASY
boolean MinigamesMode= false
boolean RespawnASAPMode= false
    
integer VictoryTime= 45 * 60
integer VictoryScore= 20
	
real RespawnPauseTime= REVIVE_PAUSE_TIME_NONASAP
//endglobals from GameModesGlobals
//globals from GetUnitCollision:
constant boolean LIBRARY_GetUnitCollision=true
integer GetUnitCollision__uc
//endglobals from GetUnitCollision
//globals from IndexedUnit:
constant boolean LIBRARY_IndexedUnit=true
//endglobals from IndexedUnit
//globals from MemoryAnalysis:
constant boolean LIBRARY_MemoryAnalysis=true
constant boolean MemoryAnalysis__TRACE= false
//endglobals from MemoryAnalysis
//globals from PatternSpawn:
constant boolean LIBRARY_PatternSpawn=true
constant boolean PatternSpawn___DEBUG_PATTERN= false
//endglobals from PatternSpawn
//globals from PlatformerProfile:
constant boolean LIBRARY_PlatformerProfile=true
constant integer PlatformerProfile_DefaultProfileID= 1
        //public constant integer             CrazyIceProfileID = 2
constant integer PlatformerProfile_MoonProfileID= 2
        
constant integer PlatformerProfile__vJUMPSPEED= 800
constant integer PlatformerProfile__hJUMPSPEED= 785
constant real PlatformerProfile__v2hJUMPSPEED= .8500
constant integer PlatformerProfile__xFALLOFF= 50
constant integer PlatformerProfile__yFALLOFF= 30
        //private constant integer   XTERMINAL       = 350      //default cap before x velocity starts falling off much faster
constant integer PlatformerProfile__YTERMINAL= 515
constant integer PlatformerProfile__GRAVITYACCEL= - 35
constant integer PlatformerProfile__MOVESPEED= 370
constant real PlatformerProfile__MOVESPEEDOFFSET= .07500
//endglobals from PlatformerProfile
//globals from PlatformerUnitGlobals:
constant boolean LIBRARY_PlatformerUnitGlobals=true
constant integer PLATFORMERWISP= 'ewsp'
	
constant integer GRAVITY= 'e00J'
constant integer BOUNCER= 'e00K'
constant integer UBOUNCE= 'e00L'
constant integer RBOUNCE= 'e00M'
constant integer DBOUNCE= 'e00N'
constant integer LBOUNCE= 'e00O'
    
constant integer SUPERSPEED= 'e00Q'
    
constant real BOUNCER_SPEED= 925 * PlatformerGlobals_GAMELOOP_TIMESTEP
constant real BOUNCER_MAX_SPEED= 1600 * PlatformerGlobals_GAMELOOP_TIMESTEP
constant real DIR_BOUNCER_SPEED= 1000 * PlatformerGlobals_GAMELOOP_TIMESTEP
constant real DIR_BOUNCER_RESPAWN_TIME= 3.
    
constant real SUPERSPEED_SPEED= 5000 * PlatformerGlobals_GAMELOOP_TIMESTEP
//endglobals from PlatformerUnitGlobals
//globals from RSnowMovement:
constant boolean LIBRARY_RSnowMovement=true
// processed: 	real array RSFacing[NumberPlayers]
	//constant real MAXRSVELOCITY = 10
	
real RSnowMovement___TIMESTEP= .035
real RSnowMovement___ACCELERATION= 8.5 * RSnowMovement___TIMESTEP
//endglobals from RSnowMovement
//globals from RelativeVector2:
constant boolean LIBRARY_RelativeVector2=true
//endglobals from RelativeVector2
//globals from SkatingGlobals:
constant boolean LIBRARY_SkatingGlobals=true
constant real SlowIceSpeed= 8.5
constant real MediumIceSpeed= 12.5
constant real FastIceSpeed= 17.5
        //if a unit has an increased speed due to a booster, then this is the rate that it returns to normal speed
        //this must be greater than 1, the larger it is the quicker the return to normal speed
constant real SkateFallOff= 1.01
        
        //the factor of speed to carry over from any icetype to sand
constant real ICE2MOMENTUMFACTOR= .5

// processed:         real array SkateSpeed[NumberPlayers]
// processed:         real array VelocityX[NumberPlayers]
// processed:         real array VelocityY[NumberPlayers]
                
// processed:         boolean array CanSteer[NumberPlayers]
//endglobals from SkatingGlobals
//globals from TerrainGlobals:
constant boolean LIBRARY_TerrainGlobals=true
        //terrain name and tileset : its effect    
constant integer FASTICE= 'Idki'
constant integer MEDIUMICE= 'Glav'
constant integer SLOWICE= 'Iice'
constant integer ABYSS= 'Oaby'
constant integer LAVA= 'Dlav'
constant integer RTILE= 'Ztil'
constant integer LEAVES= 'Alvd'
constant integer VINES= 'Avin'
constant integer LRGBRICKS= 'cZc1'
constant integer SAND= 'Zsan'
constant integer SNOW= 'cWc1'
constant integer RSNOW= 'Nsnr'
constant integer D_GRASS= 'Lgrd'
constant integer GRASS= 'cLc1'
constant integer ROAD= 'Nrck'
        
constant integer NOEFFECT= 'Agrd'
        
        //redefines to make platformer naming convention more memorable
constant integer DEATH= LAVA
constant integer WALL= NOEFFECT
constant integer PLATFORMING= LRGBRICKS
constant integer PATHABLE= ABYSS
constant integer OCEAN= MEDIUMICE
constant integer DGRASS= D_GRASS
constant integer BOOST= RTILE
constant integer SLIPSTREAM= LEAVES
        
        //2 terrain types ago
        //integer array PreviousTerrainType2[NumberPlayers]
        //1 terrain type ago
        //integer array PreviousTerrainType[NumberPlayers]
// processed:         integer array PreviousTerrainTypedx[NumberPlayers]
        
constant integer TERRAIN_QUADRANT_SIZE= 64
constant integer TERRAIN_TILE_SIZE= 128
        
constant real TERRAIN_QUADRANT_ROUND= .5
//endglobals from TerrainGlobals
//globals from Alloc:
constant boolean LIBRARY_Alloc=true
//endglobals from Alloc
//globals from ComplexTerrainPathing:
constant boolean LIBRARY_ComplexTerrainPathing=true
constant real SIN_45= .7071
    
    //public constant integer Recycled = -99
    
    //public constant integer None = 0
constant integer ComplexTerrainPathing_Inside= 20
    
    //all square terrain are the same, 128x128, centered on midpoint
constant integer ComplexTerrainPathing_Square= 10
    
    //similar to a square block, but instead of being 128x128 it's 64x64
    //i think these are needed because a single diagonal tile can be part square, part diagonal depending on what other tiles are around it
constant integer ComplexTerrainPathing_Left= - 1
constant integer ComplexTerrainPathing_Right= - 2
constant integer ComplexTerrainPathing_Top= - 3
constant integer ComplexTerrainPathing_Bottom= - 4
    
constant integer ComplexTerrainPathing_NE= 1
constant integer ComplexTerrainPathing_SE= 2
constant integer ComplexTerrainPathing_SW= 3
constant integer ComplexTerrainPathing_NW= 4
    
integer ComplexTerrainPathing_Up_UnitVector
integer ComplexTerrainPathing_Down_UnitVector
integer ComplexTerrainPathing_Left_UnitVector
integer ComplexTerrainPathing_Right_UnitVector
    
integer ComplexTerrainPathing_NE_UnitVector
integer ComplexTerrainPathing_SE_UnitVector
integer ComplexTerrainPathing_SW_UnitVector
integer ComplexTerrainPathing_NW_UnitVector
	
constant boolean ComplexTerrainPathing__DEBUG_NATURAL= false
	
constant boolean ComplexTerrainPathing__DEBUG_UNNATURAL_NE= false
constant boolean ComplexTerrainPathing__DEBUG_UNNATURAL_NW= false
constant boolean ComplexTerrainPathing__DEBUG_UNNATURAL_SW= false
constant boolean ComplexTerrainPathing__DEBUG_UNNATURAL_SE= false
//endglobals from ComplexTerrainPathing
//globals from DisposableUnit:
constant boolean LIBRARY_DisposableUnit=true
constant boolean DisposableUnit___DEBUG_DISPOSE= false
//endglobals from DisposableUnit
//globals from IceSteering:
constant boolean LIBRARY_IceSteering=true
//endglobals from IceSteering
//globals from MnT:
constant boolean LIBRARY_MnT=true
constant integer MnT___MAX_VALID_TARGET_ATTEMPTS= 20

	//how long to wait between firing each mortar... must be synced with object editor to prevent multiple shots
constant real MnT___MnTTimeStep= 2.2
    //timer used for all MnT pairs
timer MnT___MnTTimer= CreateTimer()
    //the target cannot be placed on this terrain type
constant integer MnT___IllegalTerrainType= ABYSS
	
constant boolean MnT___DEBUG_VALID_TARGET= false
//endglobals from MnT
//globals from PlatformerOcean:
constant boolean LIBRARY_PlatformerOcean=true
constant real PlatformerOcean_GRAVITYPERCENT= .35
        
constant real PlatformerOcean__OPPOSITIONDIFFERENCE= .9
real PlatformerOcean_OCEAN_MOTION= 2
constant real PlatformerOcean_XVELOCITYONJUMP= .7
constant real PlatformerOcean_V2H= 0.1
constant real PlatformerOcean_VJUMP= 1
constant real PlatformerOcean_HJUMP= .7
constant real PlatformerOcean_MS= .15
constant real PlatformerOcean_XFALLOFF= .12
constant real PlatformerOcean_YFALLOFF= 1.
constant real PlatformerOcean_TVX= .75
constant real PlatformerOcean_TVY= .6
constant real PlatformerOcean_MSOFF= 0.1
constant real PlatformerOcean_ENTRANCE_VEL= .4
        
constant real PlatformerOcean__MAX_VELOCITY= TERRAIN_QUADRANT_SIZE / 4
        
constant real PlatformerOcean_TIMESTEP= .25
        
timer PlatformerOcean__Timer
integer PlatformerOcean_Platformers
//endglobals from PlatformerOcean
//globals from PlatformerTerrainEffectGlobals:
constant boolean LIBRARY_PlatformerTerrainEffectGlobals=true

constant real VINES_SLOWDOWNPERCENT= .2
constant real VINES_MOVESPEEDPERCENT= .75
        
constant real BOOST_SPEED= 1300 * PlatformerGlobals_GAMELOOP_TIMESTEP
        
constant real SAND_FALLOFF= 3
        
constant real GRASS_MS= 1.25
constant real GRASS_TVY= .25
constant real DGRASS_MS= 1.5
constant real DGRASS_TVY= .4

        //TODO make constant once default jump is finalized
real JUMPHEIGHTINOCEAN= 440 * PlatformerGlobals_GAMELOOP_TIMESTEP
constant real OCEAN_JUMP_COOLDOWN= .50
        
        
        //needs to be compatible with GetNextDiagonal assumptions -- namely won't change more than 1 quadrant per loop
        //constant real DIAGONAL_MAXCHANGE = TERRAIN_QUADRANT_SIZE - 4
constant real PLATFORMING_MAXCHANGE= 1200. * PlatformerGlobals_GAMELOOP_TIMESTEP
constant boolean PLATFORMING_CHECK_HALFWAY= false
        
constant real VELOCITY_HARDSTOP_THRESHOLD= PLATFORMING_MAXCHANGE - 18.
		
constant real DIAGONAL_ESCAPEDISTANCE= 10
constant real DIAGONAL_STICKYDISTANCE= PLATFORMING_MAXCHANGE - 10

        //used to sample multiple points when the player is moving very fast
        //constant real PATHING_SEGMENT_SIZE = 30
        //constant real DIAGONAL_NOMANUALESCAPEDISTANCE = 30
        
constant real IN_DIAGONAL_OFFSET=64.00000
constant real LEAVE_DIAGONAL_OFFSET=1.5
constant real DIAGONAL_TERRAIN_CHECK_OFFSET= TERRAIN_QUADRANT_SIZE / 4
        //constant real   TERRAIN_DEADZONE_OFFSET=.51
//endglobals from PlatformerTerrainEffectGlobals
//globals from RelayPatternSpawn:
constant boolean LIBRARY_RelayPatternSpawn=true
//endglobals from RelayPatternSpawn
//globals from TerrainHelpers:
constant boolean LIBRARY_TerrainHelpers=true
group TerrainHelpers___NearbyUnits= CreateGroup()
//endglobals from TerrainHelpers
//globals from UnitLocalVisibility:
constant boolean LIBRARY_UnitLocalVisibility=true
//endglobals from UnitLocalVisibility
//globals from MovementSpeedHelpers:
constant boolean LIBRARY_MovementSpeedHelpers=true
//endglobals from MovementSpeedHelpers
//globals from Recycle:
constant boolean LIBRARY_Recycle=true
constant integer Recycle_MAX_SINGLE_INSTANCE_COUNT= 100
constant real Recycle_SAFE_X= - 15000
constant real Recycle_SAFE_Y= 15000
constant real Recycle___SAFE_TYPE_OFFSET= 64.
		
constant integer Recycle_BUFFER_UNIT_COUNT= 5
constant boolean Recycle___HIDE_RECYCLED_UNITS= true
constant boolean Recycle___USE_SAFE_SET_POSITION= true
constant boolean Recycle___MOVE_WITH_SET_POSITION= false
constant integer Recycle___SET_POSITION_MODE= 2
		
//endglobals from Recycle
//globals from SimpleList:
constant boolean LIBRARY_SimpleList=true
//endglobals from SimpleList
//globals from SpecialEffect:
constant boolean LIBRARY_SpecialEffect=true
constant boolean SpecialEffect_ENABLED= true
constant boolean SpecialEffect_APPLY_LOCAL= false
		
constant string SpecialEffect_OVERHEAD= "overhead"
constant string SpecialEffect_HEAD= "head"
constant string SpecialEffect_CHEST= "chest"
constant string SpecialEffect_LEFT_HAND= "left,hand"
constant string SpecialEffect_RIGHT_HAND= "right,hand"
constant string SpecialEffect_LEFT_FOOT= "left,foot"
constant string SpecialEffect_RIGHT_FOOT= "right,foot"
constant string SpecialEffect_ORIGIN= "origin"
constant string SpecialEffect_WEAPON= "weapon"
//endglobals from SpecialEffect
//globals from BoundedSpoke:
constant boolean LIBRARY_BoundedSpoke=true
constant player BoundedSpoke_SPOKE_PLAYER= Player(11)
        
constant real BoundedSpoke_TIMESTEP= .1
constant real BoundedSpoke___DEFAULT_ROTATION_SPEED= bj_PI / 10 * BoundedSpoke_TIMESTEP
//endglobals from BoundedSpoke
//globals from BoundedWheel:
constant boolean LIBRARY_BoundedWheel=true
constant player BoundedWheel_WISP_WHEEL_PLAYER= Player(10)
        
constant real BoundedWheel_TIMEOUT= .1
constant real BoundedWheel___DEFAULT_ROTATION_SPEED= bj_PI / 50 * BoundedWheel_TIMEOUT
//endglobals from BoundedWheel
//globals from BrickBreaker:
constant boolean LIBRARY_BrickBreaker=true
real BRICK_WIDTH= 200.
real BRICK_HALF_WIDTH= BRICK_WIDTH / 2.
real BRICK_HEIGHT= 32.
real BRICK_HALF_HEIGHT= BRICK_HEIGHT / 2.
		
real BRICK_BUFFER= 16.
real BRICK_HALF_BUFFER= BRICK_BUFFER / 2.
		
real PADDLE_HALF_WIDTH= 210.
real PADDLE_HALF_HEIGHT= 36.
//endglobals from BrickBreaker
//globals from Cinema:
constant boolean LIBRARY_Cinema=true
    //amount of time before the message should start fading
    //WC3 implements a positive buffer of about 3 seconds under the hood of this function
    //probably should not cause a negative result -- see the shortest message time in GameStart
constant real MESSAGE_ALIVE_BUFFER= - 2.
constant real DEFAULT_CONVERSATION_BUFFER= 2.
    
constant boolean Cinema___DEBUG_DESTROY= false
	
integer EventCinematic
integer EventUser
//endglobals from Cinema
//globals from Deferred:
constant boolean LIBRARY_Deferred=true
//endglobals from Deferred
//globals from DrunkWalker:
constant boolean LIBRARY_DrunkWalker=true
constant integer DrunkWalker_MAXIMUM_VALID_LOCATION_ATTEMPTS= 12
constant real DrunkWalker_STOP_TIMEOUT_BUFFER_MINIMUM= .3
constant real DrunkWalker_STOP_TIMEOUT_BUFFER_MAXIMUM= .7
		
constant real DrunkWalker___IDEAL_BEER_MODEL_RADIUS= 80.
constant real DrunkWalker___STATIC_BEER_VFX_SCALE= 1.75
constant real DrunkWalker___STATIC_BEER_VFX_HEIGHT= 50.
constant real DrunkWalker___PCT_BEFORE_ANGRY= .75
		
constant boolean DrunkWalker___DEBUG_EXCEED_DESTINATION_ATTEMPT= false
//endglobals from DrunkWalker
//globals from EDWEffects:
constant boolean LIBRARY_EDWEffects=true
//endglobals from EDWEffects
//globals from EDWPatternSpawnDefinitions:
constant boolean LIBRARY_EDWPatternSpawnDefinitions=true
//endglobals from EDWPatternSpawnDefinitions
//globals from EDWRelayPatternSpawnDefinitions:
constant boolean LIBRARY_EDWRelayPatternSpawnDefinitions=true
		// private constant real LW2_RG1_BASEMS = 1.5 * TERRAIN_TILE_SIZE
		// private constant real LW2_RG2_BASEMS = 2. * TERRAIN_TILE_SIZE
		// private constant real LW2_RG3_BASEMS = 3. * TERRAIN_TILE_SIZE
constant real EDWRelayPatternSpawnDefinitions___LW2_RG1_BASEMS= .5 * RoadSpeed
constant real EDWRelayPatternSpawnDefinitions___LW2_RG2_BASEMS= .75 * RoadSpeed
constant real EDWRelayPatternSpawnDefinitions___LW2_RG3_BASEMS= 1.5 * RoadSpeed
constant real EDWRelayPatternSpawnDefinitions___LW2_RG4_BASEMS= 1.5 * TERRAIN_TILE_SIZE
//endglobals from EDWRelayPatternSpawnDefinitions
//globals from LavaDamage:
constant boolean LIBRARY_LavaDamage=true
real LavaDamage___TIMESTEP= .5
constant real LavaDamage___LAVARATE= 350 * LavaDamage___TIMESTEP
		
constant string LavaDamage___DEATH_FX= "Abilities\\Spells\\Human\\MarkOfChaos\\MarkOfChaosTarget.mdl"
		
constant boolean LavaDamage___DEBUG_DELTA= false
//endglobals from LavaDamage
//globals from PlatformerBounce:
constant boolean LIBRARY_PlatformerBounce=true
constant real PlatformerBounce__TIMESTEP= .1500
	
constant string PlatformerBounce_TERRAIN_SUPERBOUNCE_FX= "Abilities\\Spells\\Undead\\AnimateDead\\AnimateDeadTarget.mdl"
//endglobals from PlatformerBounce
//globals from PlatformerIce:
constant boolean LIBRARY_PlatformerIce=true
constant real PlatformerIce_TIMESTEP= .1
        
        //properties that are applied in the main physics loop should be relative to that timestep
constant real PlatformerIce_SLOW_MS= .25
constant real PlatformerIce_SLOW_XFALLOFF= .1
constant real PlatformerIce_SLOW_YFALLOFF= .1
constant real PlatformerIce_SLOW_OPPOSITIONDIFFERENCE= .1
        
real PlatformerIce_SLOW_VELOCITY= 20 * PlatformerIce_TIMESTEP
real PlatformerIce_SLOW_MAX_VELOCITY= PLATFORMING_MAXCHANGE / 1.25
        
        //properties applied in this timer loop should be relative to it's timestep
        
        
constant real PlatformerIce_FAST_MS= .1
constant real PlatformerIce_FAST_XFALLOFF= .01
constant real PlatformerIce_FAST_YFALLOFF= .01
constant real PlatformerIce_FAST_OPPOSITIONDIFFERENCE= 0
        
real PlatformerIce_FAST_VELOCITY= 40 * PlatformerIce_TIMESTEP
real PlatformerIce_FAST_MAX_VELOCITY= PLATFORMING_MAXCHANGE * 4.
        
real PlatformerIce_HYBRID_VELOCITY= ( PlatformerIce_SLOW_VELOCITY * SIN_45 + PlatformerIce_FAST_VELOCITY * SIN_45 ) / 2
real PlatformerIce_HYBRID_OPP_VELOCITY= ( PlatformerIce_SLOW_VELOCITY * PlatformerIce_SLOW_OPPOSITIONDIFFERENCE * SIN_45 + PlatformerIce_FAST_VELOCITY * PlatformerIce_FAST_OPPOSITIONDIFFERENCE * SIN_45 ) / 2
        
timer PlatformerIce__Timer
integer PlatformerIce_Platformers
boolean array PlatformerIce_IsOnIce
		
constant boolean PlatformerIce__DEBUG_ICE_LOOP= false
//endglobals from PlatformerIce
//globals from PlatformerPropertyEquation:
constant boolean LIBRARY_PlatformerPropertyEquation=true
constant boolean PlatformerPropertyEquation_ADD_ADJUSTMENT= true
constant boolean PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT= false
//endglobals from PlatformerPropertyEquation
//globals from PlatformerSlipStream:
constant boolean LIBRARY_PlatformerSlipStream=true
integer PlatformerSlipStream__l
timer PlatformerSlipStream__t= CreateTimer()
        
constant real PlatformerSlipStream_TIMEOUT= .08
constant real PlatformerSlipStream_OFFSET= 30 * PlatformerSlipStream_TIMEOUT
//endglobals from PlatformerSlipStream
//globals from PlayerUtils:
constant boolean LIBRARY_PlayerUtils=true
constant trigger PlayerUtils___LEAVER_SENTINEL= CreateTrigger()
            
player array PlayerUtils___IndexedPlayers
integer PlayerUtils___ACTIVE_PLAYERS_COUNT= 0
integer PlayerUtils___ACTIVE_HUMAN_PLAYERS_COUNT= 0
integer PlayerUtils___ACTIVE_COMPUTER_PLAYERS_COUNT= 0
            
            //only really need the first player, will always iterate from there
integer PlayerUtils_PlayerList= 0
integer PlayerUtils_FirstPlayer= 0
//endglobals from PlayerUtils
//globals from RelayGenerator:
constant boolean LIBRARY_RelayGenerator=true
constant real RelayGenerator___RELAY_MOVEMENT_TIMESTEP= .03500
constant real RelayGenerator___OVERCLOCK_RESTART_BUFFER= 0.0
		
constant integer RelayGenerator___RELAY_PLAYER= 10
        
        //these have to be opposite for functionality to work, and it'll be faster if they're set this way to make computations off of (always interested in inverse)
constant integer RelayGenerator___LEFT= 1
constant integer RelayGenerator___RIGHT= - 1
constant integer RelayGenerator___DOWN= 1
constant integer RelayGenerator___UP= - 1
        
        //all of these can be made instance variables for more flexibility
constant real RelayGenerator___UNIT_DESTINATION_BUFFER= TERRAIN_QUADRANT_SIZE / 4.
constant integer RelayGenerator___UNIT_SIDE_BUFFER= 0
        
        //has to be around 64 or the bot left corner of rect won't register units
constant real RelayGenerator___TURN_RECT_BUFFER= TERRAIN_TILE_SIZE
//endglobals from RelayGenerator
//globals from RespawningUnit:
constant boolean LIBRARY_RespawningUnit=true
//endglobals from RespawningUnit
//globals from SimpleGenerator:
constant boolean LIBRARY_SimpleGenerator=true
constant real SimpleGenerator___BUFFER= 64
constant real SimpleGenerator___MOVEMENT_UPDATE_TIMESTEP= .035
    //private constant real DESPAWN_CHECK_TIMESTEP = .5
	
constant real SimpleGenerator___MOVEMENT_ANIMATION_EXTRASLOW= 50.
    
constant player SimpleGenerator___GENERATOR_PLAYER= Player(10)
	
constant boolean SimpleGenerator___DEBUG_MOVE_LOOP= false
constant boolean SimpleGenerator___DEBUG_SPAWN_LOOP= false
constant boolean SimpleGenerator___DEBUG_START= false
//endglobals from SimpleGenerator
//globals from SimplePatrol:
constant boolean LIBRARY_SimplePatrol=true
real SimplePatrol___DESTINATION_FLEX= 16.
real SimplePatrol___DESTINATION_TIME_DELTA= .035
//endglobals from SimplePatrol
//globals from SynchronizedGroup:
constant boolean LIBRARY_SynchronizedGroup=true
constant real SynchronizedGroup___TIMESTEP= .2
constant real SynchronizedGroup___DESTINATION_TOLERANCE= 32.
//endglobals from SynchronizedGroup
//globals from TeamSaveLocation:
constant boolean LIBRARY_TeamSaveLocation=true
integer TeamSaveLocation_ActiveSaves
//endglobals from TeamSaveLocation
//globals from WeightedList:
constant boolean LIBRARY_WeightedList=true
//endglobals from WeightedList
//globals from Wheel:
constant boolean LIBRARY_Wheel=true
constant player Wheel_WISP_WHEEL_PLAYER= Player(11)
        
constant real Wheel_TIMEOUT= .1
constant real Wheel___DEFAULT_ROTATION_SPEED= bj_PI / 50 * Wheel_TIMEOUT
//endglobals from Wheel
//globals from isMoving:
constant boolean LIBRARY_isMoving=true
constant real TOLERANCE= 25
		
		//1.5 tiles
constant real TELEPORT_MAXDISTANCE= 20
constant real TELEPORT_EXACTDISTANCE= TERRAIN_TILE_SIZE * 3
		
constant string isMoving___TELEPORT_MOVEMENT_FROM_FX= "Abilities\\Spells\\NightElf\\Blink\\BlinkCaster.mdl"
constant string isMoving___TELEPORT_MOVEMENT_TO_FX= "Abilities\\Spells\\NightElf\\Blink\\BlinkTarget.mdl"
		// private constant string TELEPORT_MOVEMENT_FX = "Abilities\\Spells\\NightElf\\Blink\\BlinkTarget.mdl"
		// private constant string TELEPORT_MOVEMENT_FX = "Abilities\\Spells\\NightElf\\Blink\\BlinkCaster.mdl"
		// private constant string TELEPORT_MOVEMENT_FROM_FX = "Abilities\\Spells\\Undead\\VampiricAura\\VampiricAuraTarget.mdl"
		// private constant string TELEPORT_MOVEMENT_TO_FX = "Abilities\\Spells\\NightElf\\Starfall\\StarfallTarget.mdl"
		// private constant string TELEPORT_MOVEMENT_TO_FX = "Abilities\\Spells\\Undead\\VampiricAura\\VampiricAuraTarget.mdl"
		
constant boolean isMoving___DEBUG_STOP_MOVEMENT= false
//endglobals from isMoving
//globals from All:
constant boolean LIBRARY_All=true
integer array All___CountFinished
integer array All___CountWaiting
//endglobals from All
//globals from Any:
constant boolean LIBRARY_Any=true
//endglobals from Any
//globals from MazerGlobals:
constant boolean LIBRARY_MazerGlobals=true
        //group of the playing mazers
integer StandardMazingUsers
        //array of the playing mazers
// processed:         unit array MazersArray[NumberPlayers]
        //units that represents the revive circle
// processed:         unit array PlayerReviveCircles[NumberPlayers]
        //a player's score
        //integer array Score[NumberPlayers]
        //the current "color" the unit is, for passing through color gate purposes
        //0: none, 1: red, 2: blue, 3: green
// processed:         integer array MazerColor[NumberPlayers]
constant integer KEY_NONE= 0
constant integer KEY_RED= 1
constant integer KEY_BLUE= 2
constant integer KEY_GREEN= 3
        
        //level each mazer is on
// processed:         integer array MazerOnLevel[NumberPlayers]
        //can this unit be killed by abyss?
// processed:         boolean array AbyssImmune[NumberPlayers]
        //standard camera setup
// processed:         camerasetup array DefaultCamera[NumberPlayers]
// processed:         boolean array DefaultCameraTracking[NumberPlayers]
        
// processed:         boolean array MobImmune[NumberPlayers]
// processed:         boolean array CanReviveOthers[NumberPlayers]

        //array of rotation cameras
        //RotationCameraAdvanced array RotationCameras[NumberPlayers]
        
// processed:         boolean array isMoving[NumberPlayers]
// processed:         real array OrderDestinationX[NumberPlayers]
// processed:         real array OrderDestinationY[NumberPlayers]
        
// processed:         boolean array UseTeleportMovement[NumberPlayers]
		       
        //keeps track of playername, level, continues and score
multiboard PlayerStats
        //number of regular mazers
integer NumberMazing= 0
        
        
constant real MazerGlobals_SAFE_X= - 12050.0
constant real MazerGlobals_SAFE_Y= 12050.0
        
constant real MazerGlobals_REVIVE_CIRCLE_SAFE_X= - 15755
constant real MazerGlobals_REVIVE_CIRCLE_SAFE_Y= 15505
		
constant boolean MazerGlobals___FORCE_DEBUG_TELE= false
constant integer MazerGlobals___DEBUG_TELE_ITEM_ID= 'I001'
//endglobals from MazerGlobals
//globals from RespawningGateway:
constant boolean LIBRARY_RespawningGateway=true
constant real RespawningGateway___ACTIVATION_CHECK_TIMESTEP= .2
constant real RespawningGateway___REPSAWN_TEXTTAG_VERTICAL_OFFSET= 128.
constant real RespawningGateway___RESPAWN_TEXTTAG_FONT_SIZE= 24.
//endglobals from RespawningGateway
//globals from SyncRequest:
constant boolean LIBRARY_SyncRequest=true
constant boolean SyncRequest___PRIVATE_EVENT= true
constant string SyncRequest___EVENT_PREFIX= "E"
constant string SyncRequest___DATA_DELIMITER= ","
//endglobals from SyncRequest
//globals from VisualVote:
constant boolean LIBRARY_VisualVote=true
constant real VisualVote_MENU_DESTROY_TIMEOUT= .5
constant integer VisualVote_CONTAINER_BORDER_MARGIN= 64
        
constant integer VisualVote_COLUMN_MARGIN_RIGHT= 128
constant integer VisualVote_COLUMN_MARGIN_BOTTOM= 128
        
constant integer VisualVote_DISABLED_PLAYER_ID= 8
constant integer VisualVote_VOTE_PLAYER_ID= 10
constant integer VisualVote_VOTE_UNIT_ID= 'eVOT'
constant integer VisualVote_PLAYER_VOTE_UNIT_ID= 'eVOT'
constant integer VisualVote_VOTE_UNIT_OFFSET= - 64
constant integer VisualVote_PLAYER_VOTE_UNIT_OFFSET= - 32
        
constant real VisualVote_TEXT_OFFSET_HEIGHT= 0
constant real VisualVote_TEXT_HEIGHT= 4
constant integer VisualVote_TEXT_OPTION_SIZE= 14
constant integer VisualVote_TEXT_HEADER1_SIZE= 20
constant integer VisualVote_TEXT_HEADER2_SIZE= 16
        
integer VisualVote_LastFinishedMenu
//endglobals from VisualVote
//globals from EDWPowerup:
constant boolean LIBRARY_EDWPowerup=true
constant player POWERUP_PLAYER= Player(11)
        
        
constant integer POWERUP_MARKER= 'pMRK'
        
constant integer POWERUP_SOLO_INVULN= 'pSIN'
constant real EDWPowerup___SOLO_INVULN_TIME= 5.0
        
constant integer POWERUP_TEAM_INVULN= 'pTIN'
constant real EDWPowerup___TEAM_INVULN_TIME= 15.0
        
constant integer POWERUP_TEAM_ADDCONT= 'pTCT'
constant integer EDWPowerup___TEAM_ADDCONT_COUNT= 2
		
constant integer POWERUP_TEAM_STEALCONT= 'e00I'
constant integer EDWPowerup___TEAM_STEALCONT_COUNT= 1
		
constant integer POWERUP_TEAM_ADDSCORE= 'e00P'
constant integer EDWPowerup___TEAM_ADDSCORE_COUNT= 2
		
constant integer POWERUP_TEAM_STEALSCORE= 'e00T'
constant integer EDWPowerup___TEAM_STEALSCORE_COUNT= 1
//endglobals from EDWPowerup
//globals from IceMovement:
constant boolean LIBRARY_IceMovement=true
constant real DEGREE_TO_RADIANS= 0.01745
    
constant real IceMovement___TIMEOUT= .035
    
constant real IceMovement___VELOCITY_FALLOFF= 1
constant real IceMovement___VELOCITY_CUTOFF= IceMovement___VELOCITY_FALLOFF + .5
	
constant real IceMovement___NPC_SKATE_SPEED= 9
	
timer IceMovement___t
group IceMovement___g
//endglobals from IceMovement
//globals from MazingCollision:
constant boolean LIBRARY_MazingCollision=true
    //private timer tc
unit MazingCollision___CollidingMazer
group MazingCollision___NearbyUnits= CreateGroup()
// processed:     unit array MazingCollision___LastCollidedUnit[NumberPlayers]
    
constant real MazingCollision___COLLISION_TIME= 1.0000
constant real MazingCollision___REVIVE_PAUSE_TIME= 1.0000
    
constant real MazingCollision___MAIN_TIMESTEP= .05
constant real MazingCollision___P2P_TIMESTEP= .15
    
    
    //should be slightly more than CollisLrgRadius to be less buggy
    //constant real CollisMaxRadius = 137.00
    
    //right now this also means the collision size for revive circles, since that's the only things its used for. will need to modify P2PCollisionIter and provide sizes for the different unitIds
constant real P2P_MAX_COLLISION_SIZE= 90
constant real P2P_REVIVE_PAUSE_TIME= 2
    
    //used to group units of similar sizes together
    // constant real CollisSmlRadius = 45.00
    // constant real CollisMedRadius = 80.00
constant real CollisLrgRadius= 135.00
    
constant real MazingCollision___COLLISION_TIMESTEP= .05
		
constant boolean MazingCollision___DEBUG_RECTANGLE_COLLISION= false
	// private constant boolean DEBUG_UNMATCHED_ID = false
constant boolean MazingCollision___APPLY_RECTANGLE_COLLISION= true
//endglobals from MazingCollision
//globals from SandMovement:
constant boolean LIBRARY_SandMovement=true
constant real SandMovement___TIMESTEP= .035
constant real SandMovement___ACCELERATION= 5.75 * SandMovement___TIMESTEP
constant real SandMovement___FALLOFF= 1.05
	
constant real SandMovement___FX_TIMESTEP= .75
	
constant real SandMovement_MOVESPEED= 200
	
constant string SAND_MOVEMENT_FX= "war3mapImported\\SlidingDust.mdx"
constant real SAND_FX_THRESHOLD_START= 7.
constant real SAND_FX_THRESHOLD_STOP= 1.5
//endglobals from SandMovement
//globals from SnowMovement:
constant boolean LIBRARY_SnowMovement=true
constant real SnowMovement___TIMESTEP= 0.035
    
constant real SnowMovement___OPPOSITION_BONUS= 1.5
constant real SnowMovement___ACCELERATION= 5.0000 * SnowMovement___TIMESTEP
//endglobals from SnowMovement
//globals from IceSkater:
constant boolean LIBRARY_IceSkater=true
constant real IceSkater___TIMESTEP= .1
constant real IceSkater___TURN_SMOOTH_DURATION= 0.0
constant player IceSkater___NPC_SKATE_PLAYER= Player(10)
constant real IceSkater___AXIS_BUFFER= 2. * TERRAIN_TILE_SIZE
				
timer IceSkater___t= CreateTimer()
//endglobals from IceSkater
//globals from SuperFastMovement:
constant boolean LIBRARY_SuperFastMovement=true
constant real SuperFastSpeed= 10
real SuperFastMovement___TIMESTEP= .035
//endglobals from SuperFastMovement
//globals from StandardGameLoop:
constant boolean LIBRARY_StandardGameLoop=true
constant real StandardGameLoop___STD_TERRAIN_OFFSET= 32.
constant real StandardGameLoop___STD_DIAGONAL_TERRAIN_OFFSET= 32. * SIN_45
		
timer StandardGameLoop_GameLoopTimer= CreateTimer()
constant real StandardGameLoop___TIMESTEP= .05
		
constant boolean StandardGameLoop___DEBUG_TERRAIN_CHANGE= false
constant boolean StandardGameLoop___DEBUG_BEST_TERRAIN= false
		
constant string StandardGameLoop_LAVA_MOVEMENT_FX= "Abilities\\Spells\\Orc\\LiquidFire\\Liquidfire.mdl"
constant string StandardGameLoop_VINES_MOVEMENT_FX= "Abilities\\Spells\\Human\\slow\\slowtarget.mdl"
			
		//public constant string PLATFORMING_FX = "Abilities\\Spells\\Human\\Polymorph\\PolyMorphTarget.mdl"
constant string StandardGameLoop_PLATFORMING_FX= "Abilities\\Spells\\Human\\Polymorph\\PolyMorphDoneGround.mdl"
//endglobals from StandardGameLoop
//globals from Platformer:
constant boolean LIBRARY_Platformer=true
constant integer Platformer___KEY_UP= 2
constant integer Platformer___KEY_RIGHT= 1
constant integer Platformer___KEY_LEFT= - 1
constant integer Platformer___KEY_DOWN= - 2
    
constant real Platformer___CAMERA_APPLY_TIMESTEP= 1.
    
constant boolean Platformer___PRESSED= true
constant boolean Platformer___RELEASED= false
    
constant integer Platformer___vjBUFFER= 40
constant integer Platformer___hjBUFFER= 40
    
constant real Platformer___tOFFSET= 30.0
constant real Platformer___wOFFSET= 1.5
    
constant integer Platformer___xMINVELOCITY= 1
constant real Platformer___hJUMPCUTOFF= 1.0
constant real Platformer___INSTANT_MS= 1.25
    
constant boolean Platformer___APPLY_TERRAIN_KILL= true
	
constant boolean Platformer___DEBUG_CREATE= false
constant boolean Platformer___DEBUG_GAMEMODE= false
	
constant boolean Platformer___DEBUG_PHYSICS_LOOP= false
constant boolean Platformer___DEBUG_PHYSICS_LOOP_DELTA= false
	
constant boolean Platformer___DEBUG_POSITION= false
    
constant boolean Platformer___DEBUG_VELOCITY= false
constant boolean Platformer___DEBUG_VELOCITY_TERRAIN= false
constant boolean Platformer___DEBUG_VELOCITY_FALLOFF= false
constant boolean Platformer___DEBUG_VELOCITY_DIAGONAL= false
    
constant boolean Platformer___DEBUG_SQUARE= false
	
constant boolean Platformer___DEBUG_DIAGONAL= false
    
constant boolean Platformer___DEBUG_DIAGONAL_TRANSITION= false
constant boolean Platformer___DEBUG_DIAGONAL_TRANSITION_TERRAIN_METADATA= false
constant boolean Platformer___DEBUG_DIAGONAL_ESCAPE_CHECK= false
constant boolean Platformer___DEBUG_DIAGONAL_ESCAPE= false
constant boolean Platformer___DEBUG_DIAGONAL_START= false
constant boolean Platformer___DEBUG_DIAGONAL_START_CHECK= false
	
constant boolean Platformer___BUFFER_STICKY_TRANSITION_ESCAPE= LEAVE_DIAGONAL_OFFSET > 0
	
constant boolean Platformer___DEBUG_TERRAIN_KILL= false
constant boolean Platformer___DEBUG_TERRAIN_CHANGE= false
constant boolean Platformer___DEBUG_GRASS_GRAVITY= false
constant boolean Platformer___DEBUG_JUMPING= false
	
constant boolean Platformer___DEBUG_CAMERA= false
	
	//public constant string STANDARD_FX = "Abilities\\Spells\\Human\\Polymorph\\PolyMorphTarget.mdl"
constant string Platformer_TERRAIN_STANDARD_FX= "Abilities\\Spells\\Human\\Polymorph\\PolyMorphDoneGround.mdl"
constant string Platformer_TERRAIN_VINES_FX= "Abilities\\Spells\\NightElf\\EntanglingRoots\\EntanglingRootsTarget.mdl"
	
constant string Platformer_VERTICAL_JUMP_FX= "Abilities\\Spells\\Human\\Polymorph\\PolyMorphTarget.mdl"
	//public constant string VERTICAL_JUMP_FX = "Abilities\\Spells\\Human\\Polymorph\\PolyMorphDoneGround.mdl"
constant string Platformer_NON_VERTICAL_JUMP_FX= "Abilities\\Spells\\Orc\\FeralSpirit\\feralspirittarget.mdl"
constant string Platformer_OCEAN_JUMP_FX= "Abilities\\Spells\\Other\\CrushingWave\\CrushingWaveDamage.mdl"
	
constant string Platformer_TERRAIN_KILL_FX= "Abilities\\Spells\\Other\\Incinerate\\FireLordDeathExplode.mdl"
constant string Platformer_DEBUG_TERRAIN_KILL_FX= "Abilities\\Spells\\Other\\Incinerate\\FireLordDeathExplode.mdl"
//endglobals from Platformer
//globals from EDWVFXPreload:
constant boolean LIBRARY_EDWVFXPreload=true
//endglobals from EDWVFXPreload
//globals from InGameCommands:
constant boolean LIBRARY_InGameCommands=true
//endglobals from InGameCommands
//globals from User:
constant boolean LIBRARY_User=true
integer TriggerUser
	
constant boolean User___DEBUG_AFK= false
constant real User___CAMERA_TARGET_POSITION_FLEX= 50.
	
constant real User___CAMERA_TARGET_POSITION_PAUSE_X_FLEX= 8.5 * TERRAIN_TILE_SIZE
constant real User___CAMERA_TARGET_POSITION_PAUSE_Y_FLEX= 5.5 * TERRAIN_TILE_SIZE
constant real User___CAMERA_TARGET_POSITION_PAUSE_Y_TOP_FLEX= User___CAMERA_TARGET_POSITION_PAUSE_Y_FLEX + 1.
constant real User___CAMERA_TARGET_POSITION_PAUSE_Y_BOTTOM_FLEX= User___CAMERA_TARGET_POSITION_PAUSE_Y_FLEX - 1.
	
constant real User___AFK_CAMERA_CHECK_TIMEOUT= 1.
constant real User___AFK_CAMERA_DEBUG_TIMEOUT= 5.
constant real User___AFK_CAMERA_MAX_TIMEOUT= 120.
constant real User___AFK_CAMERA_MIN_TIMEOUT= 15.
constant real User___AFK_CAMERA_DELTA_TIMEOUT= .75
	
constant real User___AFK_PAN_CAMERA_DURATION= 2.
constant real User___AFK_UNPAUSE_BUFFER= 3.
	
constant real User___AFK_MANUAL_CHECK_FACTOR= .75
constant string User___AFK_SYNC_EVENT_PREFIX= "AFK"
	
constant real User___AFK_PLATFORMER_CLOCK= .5
constant real User___AFK_PLATFORMER_DEATH_CLOCK_START= 5.
	
constant real User___SMALL_FONT_SIZE= 0.024
	
constant string User_LOCAL_CAMERA_IDLE_TIME_EVENT_PREFIX= "CAM"
	
constant boolean User___DEBUG_GAMEMODE_CHANGE= false
constant boolean User___DEBUG_ACTIVE_EFFECT_CHANGE= false
constant boolean User___DEBUG_CAMERA= false
//endglobals from User
//globals from Blackhole:
constant boolean LIBRARY_Blackhole=true
constant player BLACKHOLE_PLAYER= Player(11)
        
constant real Blackhole___CHECK_TIMESTEP= .2
constant real Blackhole___PULL_TIMESTEP= .035
timer Blackhole___CheckTimer
timer Blackhole___PullTimer
        
constant real Blackhole___BLACKHOLE_MAXRADIUS= 5 * 128
constant real Blackhole_BLACKHOLE_EVENT_HORIZON= 96
		
constant boolean Blackhole___DEBUG= false
//endglobals from Blackhole
//globals from CameraTrackingEvents:
constant boolean LIBRARY_CameraTrackingEvents=true
trigger CameraTrackingEvents___EscapeKeyEvent
//endglobals from CameraTrackingEvents
//globals from EDWCollectibleResolveHandlers:
constant boolean LIBRARY_EDWCollectibleResolveHandlers=true
constant real EDWCollectibleResolveHandlers___ADVANCE_LEVEL_PAN_CAMERA_DURATION= 1.
constant real EDWCollectibleResolveHandlers___ADVANCE_LEVEL_FROGGER_SFX_DURATION= 2.5
//endglobals from EDWCollectibleResolveHandlers
//globals from Teams:
constant boolean LIBRARY_Teams=true
constant real Teams___VOTE_TOP_LEFT_X= - 15000
constant real Teams___VOTE_TOP_LEFT_Y= - 4220
	
	//stable gamestates, a user in one of these gamestates will not transition to another one without a user or npc action
	//all these gamemodes should be >= 0
constant integer Teams_GAMEMODE_STANDARD= 0
constant integer Teams_GAMEMODE_PLATFORMING= 1
constant integer Teams_GAMEMODE_STANDARD_PAUSED= 10
constant integer Teams_GAMEMODE_PLATFORMING_PAUSED= 11
constant integer Teams_GAMEMODE_DEAD= 101
	
	//special gamestates that support unstable transitions. IE a user will never intentionally be left in one of these states indefinitely
	//all these gamemodes should be < 0
constant integer Teams_GAMEMODE_DYING= - 1
constant integer Teams_GAMEMODE_HIDDEN= - 2
constant integer Teams___GAMEMODE_INIT= - 1032132
    
constant real Teams_MULTIBOARD_HIDE_DELAY= 2.
	
integer TriggerTeam
//endglobals from Teams
//globals from EDWGameTime:
constant boolean LIBRARY_EDWGameTime=true
timer EDWGameTime___t= null
constant integer EDWGameTime___TIMEOUT= 60
real EDWGameTime___currentTime= 0
//endglobals from EDWGameTime
//globals from EDWPlayerSlots:
constant boolean LIBRARY_EDWPlayerSlots=true
//endglobals from EDWPlayerSlots
//globals from Levels:
constant boolean LIBRARY_Levels=true
		
constant integer WorldCount= 7
// processed: 		rect array Levels___DoorRects[WorldCount]
		
constant real Levels_TRANSFER_TIMER_TIMEOUT= .05
constant real Levels_CINEMATIC_TIMER_TIMEOUT= .5
        
constant real Levels_EASY_SCORE_MODIFIER= 1.
constant real Levels_HARD_SCORE_MODIFIER= 1.25
constant real Levels_EASY_CONTINUE_MODIFIER= 1.5
constant integer Levels_EASY_MAX_CONTINUE_ROLLOVER= 3
constant integer Levels_HARD_MAX_CONTINUE_ROLLOVER= 1
constant real Levels_HARD_CONTINUE_MODIFIER= .8
        
constant real Levels___LEVEL_TRANSFER_MESSAGE_DELAY= 2.5
constant real Levels___LEVEL_TRANSFER_FADE_DURATION= 1.5
constant real Levels___LEVEL_TRANSFER_UNPAUSE_DELAY= 1.
		
constant boolean Levels___DEBUG_START_STOP= false
constant boolean Levels___DEBUG_LEVEL_CHANGE= false
constant boolean Levels___DEBUG_CHECKPOINT_CHANGE= false
		
		//used with events
integer EventCurrentLevel
integer EventPreviousLevel
		
integer EventCheckpoint
		
constant real Levels___DEFAULT_MAX_COLLISION_SIZE= 137.
//endglobals from Levels
//globals from BossLevel:
constant boolean LIBRARY_BossLevel=true
constant real BossLevel___BOSS_BEHAVIOR_TIMEOUT= .5
//endglobals from BossLevel
//globals from Collectible:
constant boolean LIBRARY_Collectible=true
constant real Collectible___COLLECTIBLE_COLLISION_TIMEOUT= .15
constant player Collectible___COLLECTIBLE_PLAYER= Player(9)
//endglobals from Collectible
//globals from Continues:
constant boolean LIBRARY_Continues=true
//endglobals from Continues
//globals from EDWPlayerStart:
constant boolean LIBRARY_EDWPlayerStart=true
//endglobals from EDWPlayerStart
//globals from FastLoad:
constant boolean LIBRARY_FastLoad=true
constant integer FastLoad___UNLOADED= 0
constant integer FastLoad___LOADING= 1
constant integer FastLoad___LOADED= 2
		
constant real FastLoad___OVERCLOCK_LOADED_EXTRA_WAIT= 1.
		
constant boolean FastLoad___DEBUG_OVERCLOCK_PROGRESS= false
//endglobals from FastLoad
//globals from IW1:
constant boolean LIBRARY_IW1=true
//endglobals from IW1
//globals from IW2:
constant boolean LIBRARY_IW2=true
//endglobals from IW2
//globals from IW3:
constant boolean LIBRARY_IW3=true
//endglobals from IW3
//globals from IW4:
constant boolean LIBRARY_IW4=true
//endglobals from IW4
//globals from IW5:
constant boolean LIBRARY_IW5=true
//endglobals from IW5
//globals from IWB1:
constant boolean LIBRARY_IWB1=true
//endglobals from IWB1
//globals from IntroWorld:
constant boolean LIBRARY_IntroWorld=true
//endglobals from IntroWorld
//globals from LW1:
constant boolean LIBRARY_LW1=true
//endglobals from LW1
//globals from LW2:
constant boolean LIBRARY_LW2=true
//endglobals from LW2
//globals from Minigame:
constant boolean LIBRARY_Minigame=true
constant string Minigame___MINIGAME_SAVE_NAME= "MINI"
//endglobals from Minigame
//globals from PW1:
constant boolean LIBRARY_PW1=true
//endglobals from PW1
//globals from PW2:
constant boolean LIBRARY_PW2=true
//endglobals from PW2
//globals from PW3:
constant boolean LIBRARY_PW3=true
//endglobals from PW3
//globals from PW4:
constant boolean LIBRARY_PW4=true
//endglobals from PW4
//globals from EDWLevels:
constant boolean LIBRARY_EDWLevels=true
//endglobals from EDWLevels
//globals from EDWLevelContent:
constant boolean LIBRARY_EDWLevelContent=true
//endglobals from EDWLevelContent
//globals from EDWCinematicContent:
constant boolean LIBRARY_EDWCinematicContent=true
//endglobals from EDWCinematicContent
//globals from EDWVisualVote:
constant boolean LIBRARY_EDWVisualVote=true
        //public VisualVote_voteMenu MyMenu
        
constant real EDWVisualVote___VOTE_TIME_ROUND_ONE= 10
constant real EDWVisualVote___VOTE_TIME_ROUND_TWO= 10
		
constant integer EDWVisualVote___DEBUG_DIFFICULTY_MODE= GameModesGlobals_HARD
constant boolean EDWVisualVote___DEBUG_USE_FULL_VISIBILITY= true
//endglobals from EDWVisualVote
//globals from EDWGameStart:
constant boolean LIBRARY_EDWGameStart=true
constant real GAME_INIT_TIME_INITIAL= 0.01
        //constant real GAME_INIT_TIME_STEP = .5
		
boolean EDWGameStart___FinishedPreLoad= false
boolean EDWGameStart___FinishedPostLoad= false
		
constant boolean EDWGameStart___DEBUG_PRELOAD= false
constant boolean EDWGameStart___DEBUG_PRELOAD_FULL= false
constant boolean EDWGameStart___DEBUG_POSTLOAD= false
//endglobals from EDWGameStart
    // Generated
rect gg_rct_HubWorld_R= null
rect gg_rct_IntroWorld_R1= null
rect gg_rct_Rect_012= null
rect gg_rct_Rect_013= null
rect gg_rct_Rect_014= null
rect gg_rct_Rect_015= null
rect gg_rct_Rect_016= null
rect gg_rct_Rect_017= null
rect gg_rct_IntroWorld_R2= null
rect gg_rct_Rect_027= null
rect gg_rct_Rect_028= null
rect gg_rct_Rect_029= null
rect gg_rct_Rect_030= null
rect gg_rct_Rect_031= null
rect gg_rct_Rect_032= null
rect gg_rct_IntroWorld_Mortar1= null
rect gg_rct_IntroWorld_Target1= null
rect gg_rct_Rect_037= null
rect gg_rct_Rect_038= null
rect gg_rct_Rect_039= null
rect gg_rct_Rect_040= null
rect gg_rct_Rect_041= null
rect gg_rct_Rect_042= null
rect gg_rct_Rect_043= null
rect gg_rct_Rect_044= null
rect gg_rct_Rect_045= null
rect gg_rct_Rect_046= null
rect gg_rct_Rect_047= null
rect gg_rct_Rect_048= null
rect gg_rct_Rect_049= null
rect gg_rct_Rect_050= null
rect gg_rct_Rect_052= null
rect gg_rct_IWR_1_1= null
rect gg_rct_Rect_056= null
rect gg_rct_Rect_057= null
rect gg_rct_Rect_058= null
rect gg_rct_Rect_059= null
rect gg_rct_Rect_060= null
rect gg_rct_Rect_061= null
rect gg_rct_Rect_062= null
rect gg_rct_Rect_063= null
rect gg_rct_Rect_064= null
rect gg_rct_Rect_065= null
rect gg_rct_Rect_066= null
rect gg_rct_Rect_067= null
rect gg_rct_IWCP_1_1= null
rect gg_rct_IWR_1_2= null
rect gg_rct_IWR_2_1= null
rect gg_rct_Rect_071= null
rect gg_rct_Rect_072= null
rect gg_rct_Rect_073= null
rect gg_rct_Rect_074= null
rect gg_rct_Rect_075= null
rect gg_rct_Rect_076= null
rect gg_rct_Rect_077= null
rect gg_rct_Rect_078= null
rect gg_rct_Rect_079= null
rect gg_rct_Rect_080= null
rect gg_rct_Rect_081= null
rect gg_rct_Rect_082= null
rect gg_rct_Rect_083= null
rect gg_rct_Rect_084= null
rect gg_rct_Rect_085= null
rect gg_rct_Rect_086= null
rect gg_rct_Rect_087= null
rect gg_rct_Rect_088= null
rect gg_rct_IWCP_2_1= null
rect gg_rct_IWR_2_2= null
rect gg_rct_Rect_092= null
rect gg_rct_IWCP_2_2= null
rect gg_rct_IWR_2_3= null
rect gg_rct_Rect_095= null
rect gg_rct_Rect_096= null
rect gg_rct_Rect_097= null
rect gg_rct_Rect_098= null
rect gg_rct_Rect_099= null
rect gg_rct_Rect_100= null
rect gg_rct_Rect_101= null
rect gg_rct_Rect_102= null
rect gg_rct_Rect_105= null
rect gg_rct_Rect_106= null
rect gg_rct_Rect_107= null
rect gg_rct_Rect_108= null
rect gg_rct_IW2_Target1= null
rect gg_rct_IW2_Mortar1= null
rect gg_rct_IW2_Mortar2= null
rect gg_rct_IW2_End= null
rect gg_rct_IW1_End= null
rect gg_rct_IWR_3_1= null
rect gg_rct_IW1_Target1= null
rect gg_rct_IW1_Target2= null
rect gg_rct_IW1_Target3= null
rect gg_rct_IW1_Mortar1= null
rect gg_rct_IW1_Mortar2= null
rect gg_rct_IW1_Mortar3= null
rect gg_rct_LWR_1_1= null
rect gg_rct_IntroWorld_Vision= null
rect gg_rct_IW_Entrance= null
rect gg_rct_IW3_End= null
rect gg_rct_Rect_124= null
rect gg_rct_Rect_125= null
rect gg_rct_Rect_126= null
rect gg_rct_Rect_127= null
rect gg_rct_Rect_128= null
rect gg_rct_Rect_129= null
rect gg_rct_Rect_130= null
rect gg_rct_Rect_131= null
rect gg_rct_Rect_132= null
rect gg_rct_Rect_133= null
rect gg_rct_Rect_134= null
rect gg_rct_Rect_135= null
rect gg_rct_Rect_136= null
rect gg_rct_Rect_137= null
rect gg_rct_Rect_138= null
rect gg_rct_Rect_139= null
rect gg_rct_Rect_140= null
rect gg_rct_Rect_141= null
rect gg_rct_Rect_142= null
rect gg_rct_Rect_143= null
rect gg_rct_Rect_144= null
rect gg_rct_Rect_145= null
rect gg_rct_Rect_146= null
rect gg_rct_Rect_147= null
rect gg_rct_Rect_148= null
rect gg_rct_Rect_149= null
rect gg_rct_Rect_150= null
rect gg_rct_Rect_151= null
rect gg_rct_Rect_152= null
rect gg_rct_Rect_153= null
rect gg_rct_Rect_154= null
rect gg_rct_Rect_155= null
rect gg_rct_Rect_156= null
rect gg_rct_Rect_157= null
rect gg_rct_Rect_158= null
rect gg_rct_Rect_159= null
rect gg_rct_Rect_160= null
rect gg_rct_Rect_161= null
rect gg_rct_Rect_162= null
rect gg_rct_Rect_163= null
rect gg_rct_Rect_164= null
rect gg_rct_Rect_165= null
rect gg_rct_Rect_166= null
rect gg_rct_Rect_167= null
rect gg_rct_Rect_168= null
rect gg_rct_Rect_169= null
rect gg_rct_Rect_170= null
rect gg_rct_Rect_171= null
rect gg_rct_Rect_172= null
rect gg_rct_Rect_173= null
rect gg_rct_Rect_174= null
rect gg_rct_Rect_175= null
rect gg_rct_Rect_176= null
rect gg_rct_Rect_177= null
rect gg_rct_Rect_178= null
rect gg_rct_Rect_179= null
rect gg_rct_Rect_180= null
rect gg_rct_Rect_181= null
rect gg_rct_Rect_182= null
rect gg_rct_Rect_183= null
rect gg_rct_Rect_184= null
rect gg_rct_Rect_185= null
rect gg_rct_Rect_186= null
rect gg_rct_Rect_187= null
rect gg_rct_Rect_188= null
rect gg_rct_Rect_189= null
rect gg_rct_Rect_190= null
rect gg_rct_Rect_191= null
rect gg_rct_Rect_192= null
rect gg_rct_Rect_193= null
rect gg_rct_Rect_194= null
rect gg_rct_Rect_195= null
rect gg_rct_Rect_196= null
rect gg_rct_Rect_197= null
rect gg_rct_Rect_198= null
rect gg_rct_Rect_199= null
rect gg_rct_Rect_200= null
rect gg_rct_Rect_201= null
rect gg_rct_Rect_202= null
rect gg_rct_Rect_203= null
rect gg_rct_Rect_204= null
rect gg_rct_Rect_205= null
rect gg_rct_IWCP_3_2= null
rect gg_rct_Rect_207= null
rect gg_rct_Rect_208= null
rect gg_rct_Rect_209= null
rect gg_rct_Rect_210= null
rect gg_rct_Rect_211= null
rect gg_rct_Rect_212= null
rect gg_rct_Rect_213= null
rect gg_rct_Rect_214= null
rect gg_rct_Rect_215= null
rect gg_rct_Rect_216= null
rect gg_rct_Rect_217= null
rect gg_rct_Rect_218= null
rect gg_rct_Rect_219= null
rect gg_rct_Rect_220= null
rect gg_rct_Rect_221= null
rect gg_rct_Rect_222= null
rect gg_rct_Rect_223= null
rect gg_rct_Rect_224= null
rect gg_rct_Rect_225= null
rect gg_rct_Rect_226= null
rect gg_rct_Rect_227= null
rect gg_rct_Rect_228= null
rect gg_rct_Rect_229= null
rect gg_rct_Rect_230= null
rect gg_rct_Rect_231= null
rect gg_rct_Rect_232= null
rect gg_rct_Rect_233= null
rect gg_rct_Rect_234= null
rect gg_rct_Rect_235= null
rect gg_rct_Rect_236= null
rect gg_rct_Rect_237= null
rect gg_rct_Rect_238= null
rect gg_rct_Rect_239= null
rect gg_rct_Rect_240= null
rect gg_rct_Rect_241= null
rect gg_rct_Rect_242= null
rect gg_rct_LWR_2_1= null
rect gg_rct_LW_Entrance= null
rect gg_rct_LW1_End= null
rect gg_rct_HubWorld_Vision= null
rect gg_rct_IntroWorldCP_1_1= null
rect gg_rct_IntroWorldCP_1_2= null
rect gg_rct_IntroWorld_R3= null
rect gg_rct_IW1_Vision= null
rect gg_rct_IW2_Vision= null
rect gg_rct_IW3_Vision= null
rect gg_rct_LW1_Vision= null
rect gg_rct_LW2_Vision= null
rect gg_rct_SargeIntro1= null
rect gg_rct_temp2= null
rect gg_rct_temp3= null
rect gg_rct_temp4= null
rect gg_rct_IntroWorld_End= null
rect gg_rct_IWCP_3_1= null
rect gg_rct_IWR_3_2= null
rect gg_rct_IWR_3_3= null
rect gg_rct_IWCP_3_3= null
rect gg_rct_IWR_3_4= null
rect gg_rct_Rect_271= null
rect gg_rct_Rect_272= null
rect gg_rct_Rect_273= null
rect gg_rct_Rect_274= null
rect gg_rct_Rect_275= null
rect gg_rct_Rect_276= null
rect gg_rct_Rect_277= null
rect gg_rct_Rect_278= null
rect gg_rct_test_plat= null
rect gg_rct_Rect_280= null
rect gg_rct_Rect_281= null
rect gg_rct_IW2_Target2= null
rect gg_rct_PWR_1_1= null
rect gg_rct_Rect_284= null
rect gg_rct_Rect_285= null
rect gg_rct_Rect_288= null
rect gg_rct_Rect_289= null
rect gg_rct_PWCP_1_1= null
rect gg_rct_PWR_1_2= null
rect gg_rct_PW_Entrance= null
rect gg_rct_Rect_291= null
rect gg_rct_Rect_292= null
rect gg_rct_Rect_293= null
rect gg_rct_Rect_294= null
rect gg_rct_Rect_297= null
rect gg_rct_Rect_298= null
rect gg_rct_Rect_299= null
rect gg_rct_Rect_300= null
rect gg_rct_Rect_303= null
rect gg_rct_Rect_304= null
rect gg_rct_Rect_305= null
rect gg_rct_Rect_306= null
rect gg_rct_Rect_311= null
rect gg_rct_Rect_312= null
rect gg_rct_Rect_313= null
rect gg_rct_Rect_314= null
rect gg_rct_Rect_315= null
rect gg_rct_Rect_319= null
rect gg_rct_Rect_320= null
rect gg_rct_Rect_321= null
rect gg_rct_Rect_322= null
rect gg_rct_Rect_327= null
rect gg_rct_Rect_328= null
rect gg_rct_Rect_335= null
rect gg_rct_Rect_336= null
rect gg_rct_Rect_337= null
rect gg_rct_Rect_338= null
rect gg_rct_Rect_339= null
rect gg_rct_Rect_340= null
rect gg_rct_Rect_343= null
rect gg_rct_Rect_344= null
rect gg_rct_IW5_Drunks_3= null
rect gg_rct_IW5_Drunks_2= null
rect gg_rct_IW5_Drunks_1= null
rect gg_rct_PWCP_1_2= null
rect gg_rct_PWR_1_3= null
rect gg_rct_PW1_Vision= null
rect gg_rct_Rect_351= null
rect gg_rct_Rect_352= null
rect gg_rct_PWR_2_1= null
rect gg_rct_PWCP_2_1= null
rect gg_rct_PW1_End= null
rect gg_rct_PWR_2_2= null
rect gg_rct_Rect_357= null
rect gg_rct_Rect_358= null
rect gg_rct_Rect_359= null
rect gg_rct_Rect_360= null
rect gg_rct_PW2_Target= null
rect gg_rct_PW2_Mortar= null
rect gg_rct_IntroWorldCP_1_2a= null
rect gg_rct_IntroWorld_R3a= null
rect gg_rct_IW3_Drunks_1= null
rect gg_rct_IW3_Drunks_2= null
rect gg_rct_Region_380= null
rect gg_rct_PWR_2_3= null
rect gg_rct_PWCP_2_2= null
rect gg_rct_IWR_4_1= null
rect gg_rct_IW4_Vision= null
rect gg_rct_IWCP_4_1= null
rect gg_rct_IWR_4_2= null
rect gg_rct_IWCP_4_2= null
rect gg_rct_IWR_4_3= null
rect gg_rct_IW4_Drunks= null
rect gg_rct_IW4_End= null
rect gg_rct_IWR_5_1= null
rect gg_rct_IWCP_5_1= null
rect gg_rct_IWR_5_2= null
rect gg_rct_IW5_End= null
rect gg_rct_IW5_Vision= null
rect gg_rct_PW2_Vision= null
rect gg_rct_PWCP_1_3= null
rect gg_rct_PWR_1_4= null
rect gg_rct_SW_Entrance= null
rect gg_rct_SWR_1_1= null
rect gg_rct_SWR_2_1= null
rect gg_rct_PWR_3_1= null
rect gg_rct_PW2_End= null
rect gg_rct_PW3_Vision= null
rect gg_rct_Rect_295= null
rect gg_rct_Rect_296= null
rect gg_rct_PW2_Drunks_3= null
rect gg_rct_PW2_Drunks_1= null
rect gg_rct_PW2_Drunks_2= null
rect gg_rct_PW2_Drunks_4= null
rect gg_rct_PWR_2_5= null
rect gg_rct_PWCP_2_4= null
rect gg_rct_Region_331= null
rect gg_rct_Region_332= null
rect gg_rct_PW3_MassCreate= null
rect gg_rct_PWCP_3_2= null
rect gg_rct_PWR_3_3= null
rect gg_rct_PWCP_3_3= null
rect gg_rct_PWR_3_4= null
rect gg_rct_PWCP_2_3= null
rect gg_rct_PWR_2_4= null
rect gg_rct_PWCP_3_1= null
rect gg_rct_PWR_3_2= null
rect gg_rct_SboxIceR= null
rect gg_rct_IceTutorial= null
rect gg_rct_FS_1_Drunks= null
rect gg_rct_FS_Entrance= null
rect gg_rct_FSR_1_1= null
rect gg_rct_Region_403= null
rect gg_rct_FS1_Vision= null
rect gg_rct_FS1_End= null
rect gg_rct_SargeIntro2= null
rect gg_rct_SargeFireWarning= null
rect gg_rct_SargeFoundRed= null
rect gg_rct_SargeBeatRed= null
rect gg_rct_SargeVines= null
rect gg_rct_SargeCheckpoint= null
rect gg_rct_SargePlatformingTile= null
rect gg_rct_SargePlatformingMovement= null
rect gg_rct_SargeJump= null
rect gg_rct_SargeWallJump= null
rect gg_rct_FSCP_1_1= null
rect gg_rct_FSR_1_2= null
rect gg_rct_Region_120= null
rect gg_rct_Region_258= null
rect gg_rct_Region_258_Copy= null
rect gg_rct_PW3_End= null
rect gg_rct_SargeOcean_1= null
rect gg_rct_SargeOcean_2= null
rect gg_rct_SargeOcean_3= null
rect gg_rct_SargeOcean_4= null
rect gg_rct_SargeInconvenient= null
rect gg_rct_SargeBlue= null
rect gg_rct_EIWR_1_1= null
rect gg_rct_EIWCP_1_1= null
rect gg_rct_EIWR_1_2= null
rect gg_rct_EIW1_End= null
rect gg_rct_IW1Runes= null
rect gg_rct_IW1Listen= null
rect gg_rct_IW1Becky= null
rect gg_rct_IW1Cage= null
rect gg_rct_IW2Yikes= null
rect gg_rct_IW3Deal= null
rect gg_rct_EIW1_Vision= null
rect gg_rct_PW3Sniff= null
rect gg_rct_IW4QuestionMark= null
rect gg_rct_IW4Performance= null
rect gg_rct_IW3_Target1= null
rect gg_rct_IW3_Mortar1= null
rect gg_rct_PWR_4_1= null
rect gg_rct_PW4_Vision= null
rect gg_rct_PW4_End= null
rect gg_rct_LW1_Generator1= null
rect gg_rct_LW1_Generator2= null
rect gg_rct_LW1_Generator3= null
rect gg_rct_LW1_Generator4= null
rect gg_rct_LW1_Generator6= null
rect gg_rct_Region_246= null
rect gg_rct_Region_247= null
rect gg_rct_Region_439= null
rect gg_rct_Region_440= null
rect gg_rct_Region_441= null
rect gg_rct_Region_442= null
rect gg_rct_LWCP_1_1= null
rect gg_rct_LWR_1_2= null
rect gg_rct_Region_445= null
rect gg_rct_Region_446= null
rect gg_rct_Region_447= null
rect gg_rct_Region_448= null
rect gg_rct_Region_449= null
rect gg_rct_Region_450= null
rect gg_rct_Region_451= null
rect gg_rct_Region_452= null
rect gg_rct_Region_453= null
rect gg_rct_Region_454= null
rect gg_rct_Region_455= null
rect gg_rct_Region_456= null
rect gg_rct_Region_459= null
rect gg_rct_Region_461= null
rect gg_rct_Region_462= null
rect gg_rct_Region_463= null
rect gg_rct_Region_464= null
rect gg_rct_Region_466= null
rect gg_rct_Region_467= null
rect gg_rct_Region_468= null
rect gg_rct_Region_469= null
rect gg_rct_Region_470= null
rect gg_rct_Region_471= null
rect gg_rct_Region_472= null
rect gg_rct_Region_473= null
rect gg_rct_Region_474= null
rect gg_rct_Region_475= null
rect gg_rct_Region_476= null
rect gg_rct_Region_477= null
rect gg_rct_Region_478= null
rect gg_rct_Region_479= null
rect gg_rct_Region_438= null
rect gg_rct_Region_480= null
rect gg_rct_Region_481= null
rect gg_rct_Region_482= null
rect gg_rct_Region_483= null
rect gg_rct_Region_484= null
rect gg_rct_Region_485= null
rect gg_rct_Region_486= null
rect gg_rct_Region_487= null
rect gg_rct_SargeHeart= null
rect gg_rct_EIW_Entrance= null
rect gg_rct_LW2_End= null
rect gg_rct_LW2_RG1= null
rect gg_rct_LW2_RG2= null
rect gg_rct_LW2_RG3= null
rect gg_rct_LW2_C1= null
rect gg_rct_LW2_C2= null
rect gg_rct_LW2_WW2= null
rect gg_rct_LW2_C4= null
rect gg_rct_LW2_RG4= null
rect gg_rct_LW2_WW1= null
rect gg_rct_LW2_SG1_3= null
rect gg_rct_LW2_SG1_2= null
rect gg_rct_LW2_SG1_1= null
rect gg_rct_LW2_SG1_4= null
rect gg_rct_LW2_SG2_3= null
rect gg_rct_LW2_SG2_2= null
rect gg_rct_LW2_SG2_1= null
rect gg_rct_LW2_SG2_4= null
rect gg_rct_LW2_SG3_3= null
rect gg_rct_LW2_SG3_4= null
rect gg_rct_LW2_SG3_1= null
rect gg_rct_LW2_SG3_2= null
rect gg_rct_LW2_SG4_3= null
rect gg_rct_LW2_SG4_4= null
rect gg_rct_LW2_SG4_1= null
rect gg_rct_LW2_SG4_2= null
rect gg_rct_LW2_P1_1= null
rect gg_rct_LW2_P1_2= null
rect gg_rct_LW2_C5= null
rect gg_rct_IW2_TC1= null
rect gg_rct_IW2_Target3= null
rect gg_rct_IW2_Target4= null
rect gg_rct_IW3_Target2= null
rect gg_rct_IW3_Target3= null
rect gg_rct_LW2_WW3= null
rect gg_rct_IntroWorld_TC1= null
rect gg_rct_LW2_Mortar3= null
rect gg_rct_LW2_Mortar2= null
rect gg_rct_LW2_Mortar1= null
rect gg_rct_LW2_Target3= null
rect gg_rct_LW2_Target2= null
rect gg_rct_LW2_Target1= null
rect gg_rct_LWR_1_2a= null
rect gg_rct_LWCP_1_1a= null
rect gg_rct_PW3_Vision2= null
rect gg_rct_HubWorld_Vision2= null
rect gg_rct_HubWorld_Vision3= null
rect gg_rct_HubWorld_Vision4= null
rect gg_rct_HubWorld_Vision5= null
rect gg_rct_PW4_Vision2= null
rect gg_rct_LW2_C1b= null
rect gg_rct_BB_Revive= null
rect gg_rct_BB_Vision= null
rect gg_rct_BB_Bricks1= null
sound gg_snd_ReceiveGold= null
sound gg_snd_FroggerPS1Victory_EDW= null
trigger gg_trg_Alloc= null
trigger gg_trg_PermanentAlloc= null
trigger gg_trg_Error_Message= null
trigger gg_trg_Memory_Analysis= null
trigger gg_trg_Boolean= null
trigger gg_trg_PlayerUtils= null
trigger gg_trg_PreventSave= null
trigger gg_trg_FocusCamera= null
trigger gg_trg_SoundUtils= null
trigger gg_trg_GroupUtils= null
trigger gg_trg_DummyCaster= null
trigger gg_trg_locust= null
trigger gg_trg_FilterFuncs= null
trigger gg_trg_TimerUtils= null
trigger gg_trg_TextTag= null
trigger gg_trg_Vector2= null
trigger gg_trg_RelativeVector2= null
trigger gg_trg_SimpleList= null
trigger gg_trg_Stack= null
trigger gg_trg_WeightedList= null
trigger gg_trg_Table= null
trigger gg_trg_ListModule= null
trigger gg_trg_HandleList= null
trigger gg_trg_TileReplacer= null
trigger gg_trg_SyncRequest= null
trigger gg_trg_Event= null
trigger gg_trg_Deferred= null
trigger gg_trg_All= null
trigger gg_trg_Any= null
trigger gg_trg_GameGlobalConstants= null
trigger gg_trg_GameModesGlobals= null
trigger gg_trg_UnitGlobals= null
trigger gg_trg_ContinueGlobals= null
trigger gg_trg_MazerGlobals= null
trigger gg_trg_PlatformerGlobals= null
trigger gg_trg_PlatformerTerrainEffectGlobals= null
trigger gg_trg_PlatformerUnitGlobals= null
trigger gg_trg_TerrainGlobals= null
trigger gg_trg_SkatingGlobals= null
trigger gg_trg_RunningGlobals= null
trigger gg_trg_LevelIDGlobals= null
trigger gg_trg_DestructableGlobals= null
trigger gg_trg_OrderID= null
trigger gg_trg_TTypes= null
trigger gg_trg_ConfigurationMode= null
trigger gg_trg_EDWGameStart= null
trigger gg_trg_EDWPlayerStart= null
trigger gg_trg_EDWPlayerSlots= null
trigger gg_trg_EDWGameTime= null
trigger gg_trg_EDWVisualVote= null
trigger gg_trg_EDWLevels= null
trigger gg_trg_EDWLevelContent= null
trigger gg_trg_EDWVFXPreload= null
trigger gg_trg_EDWEffects= null
trigger gg_trg_EDWCinematicContent= null
trigger gg_trg_EDWPowerup= null
trigger gg_trg_EDWCollectibleResolveHandlers= null
trigger gg_trg_TerrainHelpers= null
trigger gg_trg_User= null
trigger gg_trg_Teams= null
trigger gg_trg_TeamSaveLocation= null
trigger gg_trg_Continues= null
trigger gg_trg_Cinema= null
trigger gg_trg_GameMessage= null
trigger gg_trg_VisualVote= null
trigger gg_trg_CameraTrackingEvents= null
trigger gg_trg_CameraLibrary_Advanced= null
trigger gg_trg_Level= null
trigger gg_trg_BossLevel= null
trigger gg_trg_Minigame= null
trigger gg_trg_Collision_Iteration= null
trigger gg_trg_IStartable= null
trigger gg_trg_IndexedUnit= null
trigger gg_trg_DisposableUnit= null
trigger gg_trg_Recycle= null
trigger gg_trg_RespawningUnit= null
trigger gg_trg_PatternSpawn= null
trigger gg_trg_EDWPatternSpawnDefinitions= null
trigger gg_trg_RelayPatternSpawn= null
trigger gg_trg_EDWRelayPatternSpawnDefinitions= null
trigger gg_trg_RelayGenerator= null
trigger gg_trg_SimpleGenerator= null
trigger gg_trg_Wheel= null
trigger gg_trg_BoundedWheel= null
trigger gg_trg_BoundedSpoke= null
trigger gg_trg_Blackhole= null
trigger gg_trg_Collectible= null
trigger gg_trg_DrunkWalker= null
trigger gg_trg_FastLoad= null
trigger gg_trg_IceSkater= null
trigger gg_trg_MortarAndTarget= null
trigger gg_trg_RespawningGateway= null
trigger gg_trg_SynchronizedMoveGroup= null
trigger gg_trg_SimplePatrol= null
trigger gg_trg_UnitDefaultRadius= null
trigger gg_trg_UnitLocalVisibility= null
trigger gg_trg_UnitMovementSpeedHelpers= null
trigger gg_trg_Game_Loop_With_Effects= null
trigger gg_trg_Lava_Damage= null
trigger gg_trg_TerrainVFX= null
trigger gg_trg_ComboTerrain= null
trigger gg_trg_Ice_Movement_Advanced= null
trigger gg_trg_Steering= null
trigger gg_trg_IsMoving= null
trigger gg_trg_SuperFastMovement= null
trigger gg_trg_Sand_Movement= null
trigger gg_trg_Snow_Movement= null
trigger gg_trg_RSnow_Movement= null
trigger gg_trg_Platformer= null
trigger gg_trg_ComplexTerrainPathing= null
trigger gg_trg_Platformer_Property_Equation= null
trigger gg_trg_Platformer_Profile= null
trigger gg_trg_PlatformerBounce= null
trigger gg_trg_PlatformerOcean= null
trigger gg_trg_Platformer_Ice= null
trigger gg_trg_Platformer_SlipStream= null
trigger gg_trg_Quests= null
trigger gg_trg_IntroWorld= null
trigger gg_trg_HubWorld_Run= null
trigger gg_trg_HubWorld_Stop= null
trigger gg_trg_IW1= null
trigger gg_trg_IW2= null
trigger gg_trg_IW3= null
trigger gg_trg_IW4= null
trigger gg_trg_IW5= null
trigger gg_trg_IWB_1= null
trigger gg_trg_LW1= null
trigger gg_trg_LW2= null
trigger gg_trg_PW1= null
trigger gg_trg_PW2= null
trigger gg_trg_PW3= null
trigger gg_trg_PW4= null
trigger gg_trg_FS1= null
trigger gg_trg_BrickBreaker= null
trigger gg_trg_In_Game_Commands= null
trigger gg_trg_Drawing= null
trigger gg_trg_GetUnitCollision= null
trigger gg_trg_LevelReturn= null
trigger gg_trg_blackhole_test= null
trigger gg_trg_test_revive_region= null
trigger gg_trg_Rounding= null
trigger gg_trg_dummycast_test= null
trigger gg_trg_String_Parser= null
trigger gg_trg_Ascii= null
trigger gg_trg_Cmd= null
trigger gg_trg_demo= null
unit gg_unit_Edem_0001= null
unit gg_unit_Edem_0002= null
unit gg_unit_Edem_0014= null
unit gg_unit_Edem_0015= null
unit gg_unit_Edem_0016= null
unit gg_unit_Edem_0017= null
unit gg_unit_Edem_0018= null
unit gg_unit_Edem_0019= null
trigger gg_trg_FooBar= null

trigger l__library_init

//JASSHelper struct globals:
constant integer si__DummyCaster=1
constant integer si__ErrorMessage__Fields=2
constant string s__ErrorMessage__Fields_COLOR_RED= "|cffff0000"
constant string s__ErrorMessage__Fields_COLOR_YELLOW= "|cffffff00"
string s__ErrorMessage__Fields_lastError= null
constant integer si__Event=3
integer s__Event_w=0
trigger array s__Event_e
constant integer si__RectList=4
integer array s__RectList_min
integer array s__RectList_max
hashtable s__RectList_contents
rect s__RectList_tempObject
rect s__RectList_DEFAULT_VALUE
integer array s__RectList_Alloc___recycler
constant integer si__IStartable=5
integer si__IStartable_F=0
integer si__IStartable_I=0
integer array si__IStartable_V
integer array si__IStartable_type
trigger array st__IStartable_onDestroy
integer array s__IStartable_ParentLevel
trigger array st__IStartable_Start
trigger array st__IStartable_Stop
trigger array st__IStartable_destroy
constant integer si__Stack=6
integer si__Stack_F=0
integer si__Stack_I=0
integer array si__Stack_V
constant integer s__Stack_EMPTY=0x28829022
integer array s__Stack_size
integer array s__Stack_top
integer s__Stack_free= 1
integer array s__Stack_next
integer array s__Stack_value
constant integer si__Table___dex=7
constant integer si__Table___handles=8
constant integer si__Table___agents=9
constant integer si__Table___reals=10
constant integer si__Table___booleans=11
constant integer si__Table___strings=12
constant integer si__Table___integers=13
constant integer si__Table___players=14
constant integer si__Table___widgets=15
constant integer si__Table___destructables=16
constant integer si__Table___items=17
constant integer si__Table___units=18
constant integer si__Table___abilitys=19
constant integer si__Table___timers=20
constant integer si__Table___triggers=21
constant integer si__Table___triggerconditions=22
constant integer si__Table___triggeractions=23
constant integer si__Table___events=24
constant integer si__Table___forces=25
constant integer si__Table___groups=26
constant integer si__Table___locations=27
constant integer si__Table___rects=28
constant integer si__Table___boolexprs=29
constant integer si__Table___sounds=30
constant integer si__Table___effects=31
constant integer si__Table___unitpools=32
constant integer si__Table___itempools=33
constant integer si__Table___quests=34
constant integer si__Table___questitems=35
constant integer si__Table___defeatconditions=36
constant integer si__Table___timerdialogs=37
constant integer si__Table___leaderboards=38
constant integer si__Table___multiboards=39
constant integer si__Table___multiboarditems=40
constant integer si__Table___trackables=41
constant integer si__Table___dialogs=42
constant integer si__Table___buttons=43
constant integer si__Table___texttags=44
constant integer si__Table___lightnings=45
constant integer si__Table___images=46
constant integer si__Table___ubersplats=47
constant integer si__Table___regions=48
constant integer si__Table___fogstates=49
constant integer si__Table___fogmodifiers=50
constant integer si__Table___hashtables=51
constant integer si__Table=52
constant integer si__TableArray=53
integer s__TableArray_tempTable
integer s__TableArray_tempEnd
constant integer si__HashTable=54
constant integer si__vector2=55
real array s__vector2_x
real array s__vector2_y
integer array s__vector2_Alloc___recycler
constant integer si__GetUnitCollision__init=56
constant integer si__IndexedUnit=57
unit array s__IndexedUnit_Unit
integer array s__IndexedUnit_ParentStartable
real array s__IndexedUnit_MoveSpeed
boolean array s__IndexedUnit_Collideable
boolean array s__IndexedUnit_RectangularGeometry
real array s__IndexedUnit_Radius
real array s__IndexedUnit_Scale
integer array s__IndexedUnit_R
integer array s__IndexedUnit_G
integer array s__IndexedUnit_B
integer array s__IndexedUnit_A
integer array s__IndexedUnit_Alloc___recycler
constant integer si__PatternSpawn=58
integer array s__PatternSpawn_SpawnCB
integer array s__PatternSpawn_CycleCount
integer array s__PatternSpawn_CurrentCycle
integer array s__PatternSpawn_CycleVariations
integer array s__PatternSpawn_Data
integer s__PatternSpawn_c= 1
constant integer si__LinePatternSpawn=59
integer array s__LinePatternSpawn_SpawnOrigin
real array s__LinePatternSpawn_SpawnLineAngle
real array s__LinePatternSpawn_SpawnLineLength
real array s__LinePatternSpawn_SpawnOffset
integer array s__LinePatternSpawn_PatternSpawn
constant integer si__PlatformerProfile=60
integer s__PlatformerProfile_instanceCount= 0
real array s__PlatformerProfile_TerminalVelocityY
real array s__PlatformerProfile_XFalloff
real array s__PlatformerProfile_YFalloff
real array s__PlatformerProfile_MoveSpeed
real array s__PlatformerProfile_MoveSpeedVelOffset
real array s__PlatformerProfile_GravitationalAccel
real array s__PlatformerProfile_vJumpSpeed
real array s__PlatformerProfile_v2hJumpRatio
real array s__PlatformerProfile_hJumpSpeed
constant integer si__RSnowMovement=61
group s__RSnowMovement_g= null
timer s__RSnowMovement_t= null
constant integer si__relativeVector2=62
integer array s__relativeVector2_Parent
constant integer si__ComplexTerrainPathingResult=63
integer s__ComplexTerrainPathingResult_instanceCount= 0
integer s__ComplexTerrainPathingResult_recycle= 0
integer array s__ComplexTerrainPathingResult_recycleNext
integer array s__ComplexTerrainPathingResult_TerrainPathingForPoint
integer array s__ComplexTerrainPathingResult_RelevantXTerrainTypeID
integer array s__ComplexTerrainPathingResult_RelevantYTerrainTypeID
integer array s__ComplexTerrainPathingResult_QuadrantForPoint
real array s__ComplexTerrainPathingResult_TerrainMidpointX
real array s__ComplexTerrainPathingResult_TerrainMidpointY
constant integer si__DisposableUnit=64
integer array s__DisposableUnit_TrackedStartable
constant integer si__MortarNTarget=65
unit array s__MortarNTarget_Mortar
unit array s__MortarNTarget_Target
real array s__MortarNTarget_minX
real array s__MortarNTarget_maxX
real array s__MortarNTarget_minY
real array s__MortarNTarget_maxY
boolean s__MortarNTarget_List__destroying= false
boolean array s__MortarNTarget_List__inlist
integer s__MortarNTarget_count= 0
integer array s__MortarNTarget_next
integer array s__MortarNTarget_prev
constant integer si__RelayPatternSpawn=66
integer array s__RelayPatternSpawn_Parent
integer array s__RelayPatternSpawn_Pattern
constant integer si__Recycle_UnitRecycler=67
integer array s__Recycle_UnitRecycler_uID
group array s__Recycle_UnitRecycler_uStack
integer array s__Recycle_UnitRecycler_count
player array s__Recycle_UnitRecycler_defaultOwner
real array s__Recycle_UnitRecycler_facing
hashtable s__Recycle_UnitRecycler_Recyclers= InitHashtable()
unit s__Recycle_UnitRecycler_MostRecent
integer s__Recycle_UnitRecycler_c= 1
constant integer si__SimpleList_ListNode=68
integer array s__SimpleList_ListNode_value
integer array s__SimpleList_ListNode_prev
integer array s__SimpleList_ListNode_next
integer array s__SimpleList_ListNode_Alloc___recycler
constant integer si__SimpleList_List=69
integer array s__SimpleList_List_count
integer array s__SimpleList_List_first
integer array s__SimpleList_List_last
integer array s__SimpleList_List_Alloc___recycler
constant integer si__IndexedListNode=70
integer array s__IndexedListNode_index
integer array s__IndexedListNode_base
constant integer si__IndexedList=71
integer array s__IndexedList_indexedNodes
integer array s__IndexedList_base
constant integer si__TimedEffect=72
effect array s__TimedEffect_Effect
integer array s__TimedEffect_Alloc___recycler
constant integer si__UserActiveTimedEffect=73
integer array s__UserActiveTimedEffect_Viewer
constant integer si__BoundedSpoke=74
real array s__BoundedSpoke_LayerOffset
real array s__BoundedSpoke_InitialOffset
real array s__BoundedSpoke_MinAngle
real array s__BoundedSpoke_MaxAngle
real array s__BoundedSpoke_CurrentRotationSpeed
integer array s__BoundedSpoke_Center
real array s__BoundedSpoke_CurrentAngle
integer array s__BoundedSpoke_Units
timer s__BoundedSpoke_Timer
integer s__BoundedSpoke_ActiveSpokes
constant integer si__BoundedWheel=75
real array s__BoundedWheel_MinAngle
real array s__BoundedWheel_MaxAngle
constant integer si__BrickBreaker=76
constant integer si__CinemaCallbackModel=77
integer array s__CinemaCallbackModel_Cinematic
integer array s__CinemaCallbackModel_CurrentMessage
integer array s__CinemaCallbackModel_User
timer array s__CinemaCallbackModel_Timer
integer array s__CinemaCallbackModel_Alloc___recycler
constant integer si__CinemaMessage=78
unit array s__CinemaMessage_Source
string array s__CinemaMessage_Text
real array s__CinemaMessage_MessageTime
real array s__CinemaMessage_NextMessageBuffer
integer array s__CinemaMessage_Alloc___recycler
constant integer si__Cinematic=79
rect array s__Cinematic_ActivationArea
integer array s__Cinematic_ActivationCondition
boolean array s__Cinematic_Individual
boolean array s__Cinematic_PauseViewers
integer array s__Cinematic_PreviousViewers
integer array s__Cinematic_CinemaMessages
integer array s__Cinematic_Priority
integer s__Cinematic_OnCinemaEnd
integer array s__Cinematic_ParentLevel
integer array s__Cinematic_Alloc___recycler
constant integer si__DeferredAwaiter=80
integer array s__DeferredAwaiter_Parent
integer array s__DeferredAwaiter_Success
integer array s__DeferredAwaiter_Progress
integer array s__DeferredAwaiter_CallbackData
integer array s__DeferredAwaiter_Promise
integer array s__DeferredAwaiter_Alloc___recycler
constant integer si__Deferred=81
boolean array s__Deferred_Resolved
integer array s__Deferred_Result
integer array s__Deferred_Cancel
integer array s__Deferred_Waiting
integer array s__Deferred_Alloc___recycler
constant integer si__DrunkWalker_DrunkWalker=82
integer array s__DrunkWalker_DrunkWalker_Parent
real array s__DrunkWalker_DrunkWalker_TimeAlive
unit array s__DrunkWalker_DrunkWalker_Walker
effect array s__DrunkWalker_DrunkWalker_beer
timer array s__DrunkWalker_DrunkWalker_t
integer array s__DrunkWalker_DrunkWalker_Alloc___recycler
constant integer si__DrunkWalker_DrunkWalkerSpawn=83
integer array s__DrunkWalker_DrunkWalkerSpawn_Drunks
rect array s__DrunkWalker_DrunkWalkerSpawn_SpawnArea
real array s__DrunkWalker_DrunkWalkerSpawn_SpawnTimeout
real array s__DrunkWalker_DrunkWalkerSpawn_WalkerLife
integer array s__DrunkWalker_DrunkWalkerSpawn_uID
real array s__DrunkWalker_DrunkWalkerSpawn_MinDistance
timer array s__DrunkWalker_DrunkWalkerSpawn_t
constant integer si__LavaDamage=84
integer s__LavaDamage_players
real array s__LavaDamage_pctTimeApplied
timer s__LavaDamage_t= null
constant integer si__PlatformerBounce=85
timer s__PlatformerBounce_BounceTimer= CreateTimer()
integer s__PlatformerBounce_ActivePlatformers
constant integer si__PlatformerPropertyAdjustment=86
integer array s__PlatformerPropertyAdjustment_TerrainID
real array s__PlatformerPropertyAdjustment_Value
integer array s__PlatformerPropertyAdjustment_Alloc___recycler
constant integer si__PlatformerPropertyEquation=87
integer array s__PlatformerPropertyEquation_AdditiveAdjustments
integer array s__PlatformerPropertyEquation_MultiplicativeAdjustments
integer array s__PlatformerPropertyEquation_Alloc___recycler
constant integer si__RelayUnit=88
integer array s__RelayUnit_LaneNumber
integer array s__RelayUnit_CurrentTurn
integer array s__RelayUnit_CurrentDestination
integer array s__RelayUnit_Alloc___recycler
constant integer si__RelayTurn=89
integer array s__RelayTurn_FirstLane
integer array s__RelayTurn_FirstLaneX
integer array s__RelayTurn_FirstLaneY
integer array s__RelayTurn_Direction
real array s__RelayTurn_Distance
integer array s__RelayTurn_Center
rect array s__RelayTurn_Area
integer array s__RelayTurn_Alloc___recycler
constant integer si__RelayGenerator=90
integer array s__RelayGenerator_SpawnPattern
integer array s__RelayGenerator_SpawnCenter
integer array s__RelayGenerator_Diameter
real array s__RelayGenerator_UnitLaneSize
integer array s__RelayGenerator_UnitIDToRelayUnitID
real array s__RelayGenerator_UnitTimeout
real array s__RelayGenerator_OverclockFactor
timer array s__RelayGenerator_UnitTimer
group array s__RelayGenerator_Units
integer array s__RelayGenerator_Turns
integer array s__RelayGenerator_CachedTurnDestinations
integer s__RelayGenerator_ActiveRelays
timer s__RelayGenerator_MovementTimer
constant integer si__RespawningUnit=91
integer array s__RespawningUnit_position
integer array s__RespawningUnit_uID
real array s__RespawningUnit_facing
integer array s__RespawningUnit_Alloc___recycler
constant integer si__AutoRespawningUnit=92
constant integer si__SimpleGenerator=93
integer array s__SimpleGenerator_SpawnPattern
real array s__SimpleGenerator_SpawnDirection
real array s__SimpleGenerator_EndCoordinate
timer array s__SimpleGenerator_SpawnTimer
real array s__SimpleGenerator_OverclockFactor
real array s__SimpleGenerator_SpawnTimeStep
group array s__SimpleGenerator_SpawnedUnits
real array s__SimpleGenerator_SpawnMoveSpeed
timer s__SimpleGenerator_MoveTimer
integer s__SimpleGenerator_ActiveWidgets
constant integer si__SimplePatrol=94
unit array s__SimplePatrol_Unit
integer array s__SimplePatrol_UnitID
real array s__SimplePatrol_MoveSpeed
integer array s__SimplePatrol_OnDestination
real array s__SimplePatrol_MoveAngle
integer array s__SimplePatrol_DestinationA
integer array s__SimplePatrol_DestinationB
timer s__SimplePatrol_DestinationTimer
integer s__SimplePatrol_ActivePatrols
constant integer si__SynchronizedUnit=95
unit array s__SynchronizedUnit_Unit
integer array s__SynchronizedUnit_UnitID
real array s__SynchronizedUnit_MoveSpeed
boolean array s__SynchronizedUnit_Ready
integer array s__SynchronizedUnit_CurrentOrder
integer array s__SynchronizedUnit_AllOrders
integer array s__SynchronizedUnit_ParentGroup
integer array s__SynchronizedUnit_Alloc___recycler
constant integer si__SynchronizedGroup=96
integer array s__SynchronizedGroup_AllUnits
integer s__SynchronizedGroup_ActiveGroups
timer s__SynchronizedGroup_t
constant integer si__PlayerSaveLocation=97
integer array s__PlayerSaveLocation_PlayerID
integer array s__PlayerSaveLocation_GameMode
real array s__PlayerSaveLocation_LocationX
real array s__PlayerSaveLocation_LocationY
integer array s__PlayerSaveLocation_KeyColor
integer array s__PlayerSaveLocation_Alloc___recycler
constant integer si__TeamSaveLocation=98
string array s__TeamSaveLocation_SaveName
integer array s__TeamSaveLocation_TeamID
integer array s__TeamSaveLocation_LevelID
integer array s__TeamSaveLocation_CheckpointID
integer array s__TeamSaveLocation_ContinueCount
integer array s__TeamSaveLocation_PlayerSaves
integer array s__TeamSaveLocation_Alloc___recycler
constant integer si__WeightedListNode=99
integer array s__WeightedListNode_value
real array s__WeightedListNode_weight
integer array s__WeightedListNode_prev
integer array s__WeightedListNode_next
integer array s__WeightedListNode_Alloc___recycler
constant integer si__WeightedList=100
integer array s__WeightedList_count
real array s__WeightedList_totalWeight
integer array s__WeightedList_first
integer array s__WeightedList_last
integer array s__WeightedList_Alloc___recycler
constant integer si__Wheel=101
integer array s__Wheel_SpokeCount
integer array s__Wheel_LayerCount
real array s__Wheel_AngleBetween
real array s__Wheel_DistanceBetween
real array s__Wheel_InitialOffset
real array s__Wheel_RotationSpeed
integer array s__Wheel_Center
real array s__Wheel_InitialAngle
real array s__Wheel_CurrentAngle
integer array s__Wheel_Units
timer s__Wheel_Timer
integer s__Wheel_ActiveWheels
constant integer si__IsMoving=102
trigger s__IsMoving_Click= CreateTrigger()
trigger s__IsMoving_StopEvent= CreateTrigger()
integer s__IsMoving_DestinationUsers
timer s__IsMoving_DestinationTimer= CreateTimer()
constant integer si__RespawningGateway=103
integer array s__RespawningGateway_WallUnitID
unit array s__RespawningGateway_WallUnit
integer array s__RespawningGateway_WallRespawnData
rect array s__RespawningGateway_ActivationArea
destructable array s__RespawningGateway_ActivationDoodad
integer array s__RespawningGateway_RespawnTime
integer array s__RespawningGateway_RespawnTimeRemaining
texttag array s__RespawningGateway_RespawnTimeTag
integer s__RespawningGateway_ActiveGateways
timer s__RespawningGateway_ActiveGatewayTimer
constant integer si__SyncRequest=104
string array s__SyncRequest_RequestData
constant integer si__VisualVote_voteBorder=105
constant integer s__VisualVote_voteBorder_LIGHTNING_BLUE= 0
constant integer si__VisualVote_voteInfo=106
integer array s__VisualVote_voteInfo_parent
unit array s__VisualVote_voteInfo_playerVoteUnit
integer array s__VisualVote_voteInfo_Alloc___recycler
constant integer si__VisualVote_voteOption=107
integer array s__VisualVote_voteOption_parent
texttag array s__VisualVote_voteOption_gameText
string array s__VisualVote_voteOption_text
boolean array s__VisualVote_voteOption_enabled
string array s__VisualVote_voteOption_onVoteWinCallback
integer array s__VisualVote_voteOption_playerVotesKeys
integer array s__VisualVote_voteOption_playerVotes
unit array s__VisualVote_voteOption_voteUnit
integer array s__VisualVote_voteOption_Alloc___recycler
constant integer si__VisualVote_voteContainer=108
integer array s__VisualVote_voteContainer_parent
integer array s__VisualVote_voteContainer_options
integer array s__VisualVote_voteContainer_optionCount
texttag array s__VisualVote_voteContainer_gameText
string array s__VisualVote_voteContainer_text
boolean array s__VisualVote_voteContainer_multipick
boolean array s__VisualVote_voteContainer_allowDeselect
boolean array s__VisualVote_voteContainer_required
boolean array s__VisualVote_voteContainer_enabled
real array s__VisualVote_voteContainer_marginTop
real array s__VisualVote_voteContainer_marginBottom
integer array s__VisualVote_voteContainer_defaultOption
integer array s__VisualVote_voteContainer_Alloc___recycler
constant integer si__VisualVote_voteColumn=109
real array s__VisualVote_voteColumn_columnWidth
integer array s__VisualVote_voteColumn_parent
integer array s__VisualVote_voteColumn_voteContainers
integer array s__VisualVote_voteColumn_voteContainerCount
integer array s__VisualVote_voteColumn_topLeft
integer array s__VisualVote_voteColumn_botRight
integer array s__VisualVote_voteColumn_Alloc___recycler
constant integer si__VisualVote_voteMenu=110
integer si__VisualVote_voteMenu_F=0
integer si__VisualVote_voteMenu_I=0
integer array si__VisualVote_voteMenu_V
integer array s__VisualVote_voteMenu_topLeft
integer array s__VisualVote_voteMenu_botRight
integer array s__VisualVote_voteMenu_forPlayers
string array s__VisualVote_voteMenu_onOptionExecuteFinish
string array s__VisualVote_voteMenu_onDestroyFinish
integer array s__VisualVote_voteMenu_voteColumns
integer array s__VisualVote_voteMenu_voteColumnCount
boolean array s__VisualVote_voteMenu_rendered
boolean array s__VisualVote_voteMenu_enabled
real array s__VisualVote_voteMenu_initialTime
timerdialog array s__VisualVote_voteMenu_td
boolean s__VisualVote_voteMenu_List__destroying= false
boolean array s__VisualVote_voteMenu_List__inlist
integer s__VisualVote_voteMenu_count= 0
integer array s__VisualVote_voteMenu_next
integer array s__VisualVote_voteMenu_prev
constant integer si__InWorldPowerup=111
unit array s__InWorldPowerup_Unit
integer array s__InWorldPowerup_TeamsUsed
integer s__InWorldPowerup_AllPowerups
integer array s__InWorldPowerup_Alloc___recycler
constant integer si__SandMovement=112
timer s__SandMovement_MovementTimer= CreateTimer()
timer s__SandMovement_FXTimer= CreateTimer()
integer s__SandMovement_SandUsers
constant integer si__SnowMovement=113
group s__SnowMovement_g= null
timer s__SnowMovement_t= null
constant integer si__IceSkater___Destination=114
integer array s__IceSkater___Destination_Position
integer array s__IceSkater___Destination_QuadrantDirection
real array s__IceSkater___Destination_AngleFromPrevious
integer array s__IceSkater___Destination_Alloc___recycler
constant integer si__IceSkater=115
integer array s__IceSkater_Destinations
integer array s__IceSkater_CurrentDestination
unit array s__IceSkater_SkateUnit
real array s__IceSkater_CurrentAngleDelta
real array s__IceSkater_MaxAngleDelta
real array s__IceSkater_AngleChangeRate
integer array s__IceSkater_CurrentAngleDirection
integer s__IceSkater_ActiveSkaters
constant integer si__SuperFastMovement=116
integer s__SuperFastMovement_SuperFastUsers
timer s__SuperFastMovement_t= CreateTimer()
constant integer si__Platformer=117
boolean array s__Platformer_IsPlatforming
integer array s__Platformer_PID
unit array s__Platformer_Unit
integer array s__Platformer_LastHorizontalKey
boolean array s__Platformer_LeftKey
boolean array s__Platformer_RightKey
integer array s__Platformer_HorizontalAxisState
camerasetup s__Platformer_PlatformingCamera
integer array s__Platformer_BaseProfile
real array s__Platformer_XPosition
real array s__Platformer_YPosition
real array s__Platformer_YVelocity
real array s__Platformer_XVelocity
real array s__Platformer_TerminalVelocityY
integer array s__Platformer_TVYEquation
real array s__Platformer_XFalloff
integer array s__Platformer_XFalloffEquation
real array s__Platformer_YFalloff
integer array s__Platformer_YFalloffEquation
real array s__Platformer_MoveSpeed
integer array s__Platformer_MSEquation
real array s__Platformer_MoveSpeedVelOffset
real array s__Platformer_GravitationalAccel
integer array s__Platformer_GravityEquation
real array s__Platformer_vJumpSpeed
real array s__Platformer_v2hJumpRatio
real array s__Platformer_hJumpSpeed
boolean array s__Platformer_CanOceanJump
integer array s__Platformer_TerrainDX
integer array s__Platformer_XTerrainPushedAgainst
integer array s__Platformer_XAppliedTerrainPushedAgainst
integer array s__Platformer_YTerrainPushedAgainst
integer array s__Platformer_YAppliedTerrainPushedAgainst
integer array s__Platformer_PushedAgainstVector
boolean array s__Platformer_OnDiagonal
integer array s__Platformer_DiagonalPathing
real array s__Platformer_PhysicsLoopDeltaApplied
timer s__Platformer_GameloopTimer
timer s__Platformer_TerrainloopTimer
timer s__Platformer_CameraTimer
integer s__Platformer_ActivePlatformers
integer array s__Platformer_Alloc___recycler
constant integer si__User=118
boolean array s__User_IsPlaying
boolean array s__User_IsAlive
boolean array s__User_IsAFK
integer array s__User_Deaths
unit array s__User_ActiveUnit
real array s__User_ActiveUnitRadius
integer array s__User_Platformer
integer array s__User_GameMode
integer array s__User_PreviousGameMode
integer array s__User_Team
integer array s__User_CinematicPlaying
integer array s__User_CinematicQueue
effect array s__User_ActiveEffect
timer array s__User_UnpauseTimer
real array s__User_AFKPlatformerDeathClock
integer s__User_ActivePlayers
trigger s__User_AFKSyncEvent
integer s__User_LocalCameraTargetPosition
real s__User_LocalCameraIdleTime
real s__User_LocalAFKThreshold
boolean array s__User_PlatformerStartStable
integer s__User_ToggleCameraTrackingTutorial
integer s__User_count= - 1
constant integer si__Blackhole=119
unit array s__Blackhole_BlackholeUnit
integer array s__Blackhole_PlayersInRange
integer s__Blackhole_ActiveBlackholes
constant integer si__WorldProgress=120
integer array s__WorldProgress_WorldID
integer array s__WorldProgress_FurthestLevel
integer s__WorldProgress_c= 1
constant integer si__Teams_MazingTeam=121
integer array s__Teams_MazingTeam_Users
integer array s__Teams_MazingTeam_FirstUser
integer array s__Teams_MazingTeam_LastEventUser
boolean array s__Teams_MazingTeam_IsTeamPlaying
rect array s__Teams_MazingTeam_Revive
integer array s__Teams_MazingTeam_ContinueCount
integer array s__Teams_MazingTeam_OnLevel
string array s__Teams_MazingTeam_TeamName
integer array s__Teams_MazingTeam_OnCheckpoint
integer array s__Teams_MazingTeam_Score
real array s__Teams_MazingTeam_Weight
integer array s__Teams_MazingTeam_DefaultGameMode
integer array s__Teams_MazingTeam_VoteMenu
integer array s__Teams_MazingTeam_AllWorldProgress
multiboard s__Teams_MazingTeam_PlayerStats
integer s__Teams_MazingTeam_NumberTeams= 0
integer s__Teams_MazingTeam_AllTeams
integer array s__Teams_MazingTeam_Alloc___recycler
constant integer si__Checkpoint=122
integer s__Checkpoint_c= 0
rect array s__Checkpoint_Gate
rect array s__Checkpoint_ReviveCenter
integer array s__Checkpoint_DefaultColor
integer array s__Checkpoint_DefaultGameMode
boolean array s__Checkpoint_RequiresSameGameMode
constant integer si__Levels___AnimatedLevelTransferData=123
integer array s__Levels___AnimatedLevelTransferData_Team
integer array s__Levels___AnimatedLevelTransferData_NextLevel
boolean array s__Levels___AnimatedLevelTransferData_UpdateProgress
integer array s__Levels___AnimatedLevelTransferData_Alloc___recycler
constant integer si__Levels_Level=124
string array s__Levels_Level_Name
integer array s__Levels_Level_RawContinues
integer array s__Levels_Level_RawScore
string array s__Levels_Level_StartFunction
string array s__Levels_Level_StopFunction
integer array s__Levels_Level_Startables
integer array s__Levels_Level_Boundaries
rect array s__Levels_Level_LevelEnd
integer array s__Levels_Level_Checkpoints
integer s__Levels_Level_CBTeam
integer array s__Levels_Level_NextLevel
integer array s__Levels_Level_PrevLevel
integer array s__Levels_Level_Cinematics
integer array s__Levels_Level_ActiveTeams
integer s__Levels_Level_ActiveLevels
integer array s__Levels_Level_OnLevelStart
integer array s__Levels_Level_OnLevelStop
integer array s__Levels_Level_OnCheckpointChange
real array s__Levels_Level_MaxCollisionSize
constant integer si__Boss=125
integer array s__Boss_UnitID
unit array s__Boss_Unit
integer array s__Boss_Behavior
integer array s__Boss_Alloc___recycler
constant integer si__BossLevel=126
integer array s__BossLevel_Boss
integer array s__BossLevel_OnCheckpoint
integer array s__BossLevel_CurrentTargets
integer array s__BossLevel_CurrentState
timer s__BossLevel_BehaviorTimer= CreateTimer()
integer s__BossLevel_ActiveBosses
constant integer si__Collectible=127
unit array s__Collectible_UncollectedUnit
real array s__Collectible_UncollectedUnitRadius
boolean array s__Collectible_ReturnToCheckpoint
integer s__Collectible_PermanentAlloc___c= 1
constant integer si__CollectibleTeam=128
integer array s__CollectibleTeam_Team
integer array s__CollectibleTeam_CollectibleDeferreds
integer array s__CollectibleTeam_AllCollected
integer array s__CollectibleTeam_Alloc___recycler
constant integer si__CollectibleSet=129
integer s__CollectibleSet_ActiveCollectibles
timer s__CollectibleSet_Timer
integer array s__CollectibleSet_Collectibles
integer array s__CollectibleSet_ActiveTeams
integer array s__CollectibleSet_OnAllCollected
constant integer si__FastLoad=130
integer array s__FastLoad_Checkpoint
timer array s__FastLoad_OverclockTimer
real array s__FastLoad_OverclockFactor
real array s__FastLoad_FastLoadTime
integer array s__FastLoad_LoadState
integer array s__FastLoad_AwaitingTeams
integer s__FastLoad_ActiveLoaders
constant integer si__Minigame=131
leaderboard s__Minigame_Scores
integer array s__TimerUtils___data
timer array s__TimerUtils___tT
integer array s__NumberContinues
rect array s__Revives
fogmodifier array s__Vision1
integer array s__ContinuesRewardsSys
integer array s__ContinuesParSys
real array s__RSFacing
real array s__SkateSpeed
real array s__VelocityX
real array s__VelocityY
boolean array s__CanSteer
integer array s__PreviousTerrainTypedx
unit array s__MazersArray
unit array s__PlayerReviveCircles
integer array s__MazerColor
integer array s__MazerOnLevel
boolean array s__AbyssImmune
camerasetup array s__DefaultCamera
boolean array s__DefaultCameraTracking
boolean array s__MobImmune
boolean array s__CanReviveOthers
boolean array s__isMoving
real array s__OrderDestinationX
real array s__OrderDestinationY
boolean array s__UseTeleportMovement
unit array s__MazingCollision___LastCollidedUnit
rect array s__Levels___DoorRects
trigger array s__s__Platformer_ArrowKeyTriggers
trigger array st__Wheel_Rotate
trigger st__Stack_onDestroy
trigger st__MortarNTarget_destroy
trigger st__Recycle_UnitRecycler_MakeWithFacing
trigger st__Recycle_UnitRecycler_Make
trigger st__Recycle_UnitRecycler_Release
trigger st__Recycle_UnitRecycler_GetRecycler
trigger st__SimpleList_List_add
trigger st__SimpleList_List_remove
trigger st__SimpleList_List_create
trigger st__CinemaCallbackModel_destroy
trigger st__Deferred_Remove
trigger st__Deferred_create
trigger st__Deferred_destroy
trigger st__DrunkWalker_DrunkWalker_drinkEffect
trigger st__DrunkWalker_DrunkWalker_destroy
trigger st__RelayGenerator_GetNumberLanes
trigger st__RelayGenerator_GetRadius
trigger st__SimpleGenerator_PeriodicSpawn
trigger st__Wheel_create
trigger st__VisualVote_voteContainer_clearVoteOptionsForPlayer
trigger st__VisualVote_voteMenu_applyPlayerVote
trigger st__VisualVote_voteMenu_checkPlayersFinishedVoting
trigger st__VisualVote_voteMenu_destroy
trigger st__InWorldPowerup_IsPowerupUnit
trigger st__InWorldPowerup_create
trigger st__User_SetActiveEffect
trigger st__User_ClearActiveEffect
trigger st__User_CreateUserTimedEffect
trigger st__User_OnCinemaEndCB
trigger st__User_CheckCinematicQueue
trigger st__User_DisplayMessage
trigger st__User_ApplyDefaultCameras
trigger st__User_ResetDefaultCamera
trigger st__User_ApplyDefaultSelections
trigger st__User_Pause
trigger st__User_RespawnAtRect
trigger st__User_SetKeyColor
trigger st__User_GetStylizedPlayerName
trigger st__User_SwitchGameModesDefaultLocation
trigger st__User_SwitchGameModes
trigger st__User_SetCurrentGameMode
trigger st__User_IsActiveUnitInRect
trigger st__User_ApplyAFKPlatformer
trigger st__Blackhole_WatchPlayer
trigger st__Blackhole_create
trigger st__Teams_MazingTeam_MoveRevive
trigger st__Teams_MazingTeam_RespawnTeamAtRect
trigger st__Teams_MazingTeam_PrintMessage
trigger st__Teams_MazingTeam_UpdateMultiboard
trigger st__Teams_MazingTeam_GetStylizedPlayerName
trigger st__Teams_MazingTeam_ComputeTeamWeights
trigger st__Teams_MazingTeam_GetRandomTeam
trigger st__Teams_MazingTeam_GetContinueCount
trigger st__Teams_MazingTeam_SetContinueCount
trigger st__Teams_MazingTeam_ChangeContinueCount
trigger st__Teams_MazingTeam_GetScore
trigger st__Teams_MazingTeam_ChangeScore
trigger st__Teams_MazingTeam_ApplyEndGameAll
trigger st__Teams_MazingTeam_PauseTeam
trigger st__Teams_MazingTeam_SetUnitLocalOpacityForTeam
trigger st__Teams_MazingTeam_PlaySoundForTeam
trigger st__Teams_MazingTeam_PanCameraForTeam
trigger st__Teams_MazingTeam_SetSharedControlForTeam
trigger st__Levels_Level_GetWeightedRandomInt
trigger st__Levels_Level_GetWorldID
trigger st__Levels_Level_RemoveGreenFromLevel
trigger st__Levels_Level_SetCheckpointForTeam
trigger st__Levels_Level_AnimatedSetCheckpointForTeam
trigger st__Levels_Level_SwitchLevels
trigger st__Levels_Level_SwitchLevelsAnimated
trigger array st___prototype3
boolean f__result_boolean
trigger array st___prototype8
trigger array st___prototype19
trigger array st___prototype29
group f__result_group
trigger array st___prototype54
integer f__result_integer
real f__arg_real1
real f__arg_real2
real f__arg_real3
unit f__arg_unit1
integer f__arg_integer1
integer f__arg_integer2
integer f__arg_integer3
string f__arg_string1
string f__arg_string2
boolean f__arg_boolean1
rect f__arg_rect1
sound f__arg_sound1
integer f__arg_this
unit f__result_unit
string f__result_string

endglobals


//Generated method caller for Levels_Level.GetWeightedRandomInt
function sc__Levels_Level_GetWeightedRandomInt takes integer this,integer lowBound,integer highBound returns integer
			return GetRandomInt(lowBound, highBound)
endfunction

//Generated method caller for Levels_Level.GetWorldID
function sc__Levels_Level_GetWorldID takes integer this returns integer
            //World levels follow this format
			if this >= 3 then //last level ID
                return ModuloInteger(this - 3, 7) + 1
			else
				return - this
            endif
endfunction

//Generated method caller for Levels_Level.RemoveGreenFromLevel
function sc__Levels_Level_RemoveGreenFromLevel takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__Levels_Level_RemoveGreenFromLevel)
endfunction

//Generated method caller for Levels_Level.SetCheckpointForTeam
function sc__Levels_Level_SetCheckpointForTeam takes integer this,integer mt,integer cpID returns nothing
    set f__arg_this=this
    set f__arg_integer1=mt
    set f__arg_integer2=cpID
    call TriggerEvaluate(st__Levels_Level_SetCheckpointForTeam)
endfunction

//Generated method caller for Levels_Level.AnimatedSetCheckpointForTeam
function sc__Levels_Level_AnimatedSetCheckpointForTeam takes integer this,integer mt,integer cpID returns nothing
    set f__arg_this=this
    set f__arg_integer1=mt
    set f__arg_integer2=cpID
    call TriggerEvaluate(st__Levels_Level_AnimatedSetCheckpointForTeam)
endfunction

//Generated method caller for Levels_Level.SwitchLevels
function sc__Levels_Level_SwitchLevels takes integer this,integer mt,integer nextLevel,integer activatingUser,boolean updateProgress returns nothing
    set f__arg_this=this
    set f__arg_integer1=mt
    set f__arg_integer2=nextLevel
    set f__arg_integer3=activatingUser
    set f__arg_boolean1=updateProgress
    call TriggerEvaluate(st__Levels_Level_SwitchLevels)
endfunction

//Generated method caller for Levels_Level.SwitchLevelsAnimated
function sc__Levels_Level_SwitchLevelsAnimated takes integer this,integer mt,integer nextLevel,boolean updateProgress returns nothing
    set f__arg_this=this
    set f__arg_integer1=mt
    set f__arg_integer2=nextLevel
    set f__arg_boolean1=updateProgress
    call TriggerEvaluate(st__Levels_Level_SwitchLevelsAnimated)
endfunction

//Generated method caller for Teams_MazingTeam.MoveRevive
function sc__Teams_MazingTeam_MoveRevive takes integer this,rect newlocation returns nothing
        call MoveRectTo(s__Teams_MazingTeam_Revive[this], GetRectCenterX(newlocation), GetRectCenterY(newlocation))
endfunction

//Generated method caller for Teams_MazingTeam.RespawnTeamAtRect
function sc__Teams_MazingTeam_RespawnTeamAtRect takes integer this,rect newlocation,boolean moveliving returns nothing
    set f__arg_this=this
    set f__arg_rect1=newlocation
    set f__arg_boolean1=moveliving
    call TriggerEvaluate(st__Teams_MazingTeam_RespawnTeamAtRect)
endfunction

//Generated method caller for Teams_MazingTeam.PrintMessage
function sc__Teams_MazingTeam_PrintMessage takes integer this,string message returns nothing
        local integer fp= s__Teams_MazingTeam_FirstUser[this]
        
        loop
        exitwhen fp == 0
            if GetLocalPlayer() == Player(s__SimpleList_ListNode_value[fp]) then
                call DisplayTextToPlayer(Player(s__SimpleList_ListNode_value[fp]), 0, 0, message)
            endif
        set fp=s__SimpleList_ListNode_next[fp]
        endloop
endfunction

//Generated method caller for Teams_MazingTeam.UpdateMultiboard
function sc__Teams_MazingTeam_UpdateMultiboard takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__Teams_MazingTeam_UpdateMultiboard)
endfunction

//Generated method caller for Teams_MazingTeam.GetStylizedPlayerName
function sc__Teams_MazingTeam_GetStylizedPlayerName takes integer this,integer pID returns string
    set f__arg_this=this
    set f__arg_integer1=pID
    call TriggerEvaluate(st__Teams_MazingTeam_GetStylizedPlayerName)
 return f__result_string
endfunction

//Generated method caller for Teams_MazingTeam.ComputeTeamWeights
function sc__Teams_MazingTeam_ComputeTeamWeights takes nothing returns nothing
    call TriggerEvaluate(st__Teams_MazingTeam_ComputeTeamWeights)
endfunction

//Generated method caller for Teams_MazingTeam.GetRandomTeam
function sc__Teams_MazingTeam_GetRandomTeam takes integer filter returns integer
    set f__arg_integer1=filter
    call TriggerEvaluate(st__Teams_MazingTeam_GetRandomTeam)
 return f__result_integer
endfunction

//Generated method caller for Teams_MazingTeam.GetContinueCount
function sc__Teams_MazingTeam_GetContinueCount takes integer this returns integer
		return s__Teams_MazingTeam_ContinueCount[this]
endfunction

//Generated method caller for Teams_MazingTeam.SetContinueCount
function sc__Teams_MazingTeam_SetContinueCount takes integer this,integer continueCount returns nothing
    set f__arg_this=this
    set f__arg_integer1=continueCount
    call TriggerEvaluate(st__Teams_MazingTeam_SetContinueCount)
endfunction

//Generated method caller for Teams_MazingTeam.ChangeContinueCount
function sc__Teams_MazingTeam_ChangeContinueCount takes integer this,integer continueOffset returns nothing
    set f__arg_this=this
    set f__arg_integer1=continueOffset
    call TriggerEvaluate(st__Teams_MazingTeam_ChangeContinueCount)
endfunction

//Generated method caller for Teams_MazingTeam.GetScore
function sc__Teams_MazingTeam_GetScore takes integer this returns integer
		return s__Teams_MazingTeam_Score[this]
endfunction

//Generated method caller for Teams_MazingTeam.ChangeScore
function sc__Teams_MazingTeam_ChangeScore takes integer this,integer scoreOffset returns nothing
    set f__arg_this=this
    set f__arg_integer1=scoreOffset
    call TriggerEvaluate(st__Teams_MazingTeam_ChangeScore)
endfunction

//Generated method caller for Teams_MazingTeam.ApplyEndGameAll
function sc__Teams_MazingTeam_ApplyEndGameAll takes integer victor returns nothing
    set f__arg_integer1=victor
    call TriggerEvaluate(st__Teams_MazingTeam_ApplyEndGameAll)
endfunction

//Generated method caller for Teams_MazingTeam.PauseTeam
function sc__Teams_MazingTeam_PauseTeam takes integer this,boolean flag returns nothing
    set f__arg_this=this
    set f__arg_boolean1=flag
    call TriggerEvaluate(st__Teams_MazingTeam_PauseTeam)
endfunction

//Generated method caller for Teams_MazingTeam.SetUnitLocalOpacityForTeam
function sc__Teams_MazingTeam_SetUnitLocalOpacityForTeam takes integer this,unit u,integer opacity returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    set f__arg_integer1=opacity
    call TriggerEvaluate(st__Teams_MazingTeam_SetUnitLocalOpacityForTeam)
endfunction

//Generated method caller for Teams_MazingTeam.PlaySoundForTeam
function sc__Teams_MazingTeam_PlaySoundForTeam takes integer this,sound sfx returns nothing
  local integer curPlayerNode= s__Teams_MazingTeam_FirstUser[this]
		
		loop
		exitwhen curPlayerNode == 0
			if GetLocalPlayer() == Player(s__SimpleList_ListNode_value[curPlayerNode]) then
				call StartSound(sfx)
			endif
		set curPlayerNode=s__SimpleList_ListNode_next[curPlayerNode]
		endloop
endfunction

//Generated method caller for Teams_MazingTeam.PanCameraForTeam
function sc__Teams_MazingTeam_PanCameraForTeam takes integer this,real x,real y,real duration returns nothing
    set f__arg_this=this
    set f__arg_real1=x
    set f__arg_real2=y
    set f__arg_real3=duration
    call TriggerEvaluate(st__Teams_MazingTeam_PanCameraForTeam)
endfunction

//Generated method caller for Teams_MazingTeam.SetSharedControlForTeam
function sc__Teams_MazingTeam_SetSharedControlForTeam takes integer this,integer user,boolean flag returns nothing
  local integer curPlayerNode= s__Teams_MazingTeam_FirstUser[this]
		
		loop
		exitwhen curPlayerNode == 0
			if s__SimpleList_ListNode_value[curPlayerNode] != user then
				call SetPlayerAlliance(Player(user), Player(s__SimpleList_ListNode_value[curPlayerNode]), ALLIANCE_SHARED_CONTROL, flag)
			endif
		set curPlayerNode=s__SimpleList_ListNode_next[curPlayerNode]
		endloop
endfunction

//Generated method caller for User.SetActiveEffect
function sc__User_SetActiveEffect takes integer this,string strEffect,string attachPoint returns nothing
    set f__arg_this=this
    set f__arg_string1=strEffect
    set f__arg_string2=attachPoint
    call TriggerEvaluate(st__User_SetActiveEffect)
endfunction

//Generated method caller for User.ClearActiveEffect
function sc__User_ClearActiveEffect takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__User_ClearActiveEffect)
endfunction

//Generated method caller for User.CreateUserTimedEffect
function sc__User_CreateUserTimedEffect takes integer this,string fxFileLocation,string attachPointName,real duration returns nothing
    set f__arg_this=this
    set f__arg_string1=fxFileLocation
    set f__arg_string2=attachPointName
    set f__arg_real1=duration
    call TriggerEvaluate(st__User_CreateUserTimedEffect)
endfunction

//Generated method caller for User.OnCinemaEndCB
function sc__User_OnCinemaEndCB takes nothing returns boolean
    call TriggerEvaluate(st__User_OnCinemaEndCB)
 return f__result_boolean
endfunction

//Generated method caller for User.CheckCinematicQueue
function sc__User_CheckCinematicQueue takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__User_CheckCinematicQueue)
endfunction

//Generated method caller for User.DisplayMessage
function sc__User_DisplayMessage takes integer this,string message,real duration returns nothing
        if s__User_IsPlaying[this] then
            if duration == 0 then
                call DisplayTextToPlayer(Player(this), 0, 0, message)
            else
                call DisplayTimedTextToPlayer(Player(this), 0, 0, duration, message)
            endif
        endif
endfunction

//Generated method caller for User.ApplyDefaultCameras
function sc__User_ApplyDefaultCameras takes integer this,real time returns nothing
    set f__arg_this=this
    set f__arg_real1=time
    call TriggerEvaluate(st__User_ApplyDefaultCameras)
endfunction

//Generated method caller for User.ResetDefaultCamera
function sc__User_ResetDefaultCamera takes integer this,real duration returns nothing
    set f__arg_this=this
    set f__arg_real1=duration
    call TriggerEvaluate(st__User_ResetDefaultCamera)
endfunction

//Generated method caller for User.ApplyDefaultSelections
function sc__User_ApplyDefaultSelections takes integer this returns nothing
		if s__User_GameMode[this] != Teams_GAMEMODE_PLATFORMING and s__User_GameMode[this] != Teams_GAMEMODE_PLATFORMING_PAUSED then
            if GetLocalPlayer() == Player(this) then
                call ClearSelection()
                if s__User_ActiveUnit[this] != null then
                    call SelectUnit(s__User_ActiveUnit[this], true)
                endif
            endif
        endif
endfunction

//Generated method caller for User.Pause
function sc__User_Pause takes integer this,boolean flag returns nothing
    set f__arg_this=this
    set f__arg_boolean1=flag
    call TriggerEvaluate(st__User_Pause)
endfunction

//Generated method caller for User.RespawnAtRect
function sc__User_RespawnAtRect takes integer this,rect r,boolean moveliving returns nothing
    set f__arg_this=this
    set f__arg_rect1=r
    set f__arg_boolean1=moveliving
    call TriggerEvaluate(st__User_RespawnAtRect)
endfunction

//Generated method caller for User.SetKeyColor
function sc__User_SetKeyColor takes integer this,integer keyColor returns nothing
		if s__MazerColor[this] != keyColor then
			set s__MazerColor[this]= keyColor
			
			if keyColor == KEY_RED then
				call SetUnitVertexColor(s__MazersArray[this], 255, 0, 0, 255)
			elseif keyColor == KEY_BLUE then
				call SetUnitVertexColor(s__MazersArray[this], 0, 0, 255, 255)
			elseif keyColor == KEY_GREEN then
				call SetUnitVertexColor(s__MazersArray[this], 0, 255, 0, 255)
			elseif keyColor == KEY_NONE then
				call SetUnitVertexColor(s__MazersArray[this], 255, 255, 255, 255)
			endif
		endif
endfunction

//Generated method caller for User.GetStylizedPlayerName
function sc__User_GetStylizedPlayerName takes integer this returns string
    set f__arg_this=this
    call TriggerEvaluate(st__User_GetStylizedPlayerName)
 return f__result_string
endfunction

//Generated method caller for User.SwitchGameModesDefaultLocation
function sc__User_SwitchGameModesDefaultLocation takes integer this,integer newGameMode returns nothing
    set f__arg_this=this
    set f__arg_integer1=newGameMode
    call TriggerEvaluate(st__User_SwitchGameModesDefaultLocation)
endfunction

//Generated method caller for User.SwitchGameModes
function sc__User_SwitchGameModes takes integer this,integer newGameMode,real x,real y returns nothing
    set f__arg_this=this
    set f__arg_integer1=newGameMode
    set f__arg_real1=x
    set f__arg_real2=y
    call TriggerEvaluate(st__User_SwitchGameModes)
endfunction

//Generated method caller for User.SetCurrentGameMode
function sc__User_SetCurrentGameMode takes integer this,integer newGameMode returns nothing
    set f__arg_this=this
    set f__arg_integer1=newGameMode
    call TriggerEvaluate(st__User_SetCurrentGameMode)
endfunction

//Generated method caller for User.IsActiveUnitInRect
function sc__User_IsActiveUnitInRect takes integer this,rect r returns boolean
        return GetUnitX(s__User_ActiveUnit[this]) >= GetRectMinX(r) and GetUnitX(s__User_ActiveUnit[this]) <= GetRectMaxX(r) and GetUnitY(s__User_ActiveUnit[this]) >= GetRectMinY(r) and GetUnitY(s__User_ActiveUnit[this]) <= GetRectMaxY(r)
endfunction

//Generated method caller for User.ApplyAFKPlatformer
function sc__User_ApplyAFKPlatformer takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__User_ApplyAFKPlatformer)
endfunction

//Generated method caller for IStartable.Start
function sc__IStartable_Start takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_Start[si__IStartable_type[this]])
endfunction

//Generated method executor for IStartable.Start
function sx__IStartable_Start takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IStartable_Start[si__IStartable_type[this]])
endfunction

//Generated method caller for IStartable.Stop
function sc__IStartable_Stop takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_Stop[si__IStartable_type[this]])
endfunction

//Generated method executor for IStartable.Stop
function sx__IStartable_Stop takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IStartable_Stop[si__IStartable_type[this]])
endfunction

//Generated method caller for IStartable.destroy
function sc__IStartable_destroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_destroy[si__IStartable_type[this]])
endfunction

//Generated method executor for IStartable.destroy
function sx__IStartable_destroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IStartable_destroy[si__IStartable_type[this]])
endfunction
//Generated destructor of IStartable
function sc__IStartable_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__IStartable_V[this]!=-1) then
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_onDestroy[si__IStartable_type[this]])
    set si__IStartable_V[this]=si__IStartable_F
    set si__IStartable_F=this
endfunction

//Generated method caller for InWorldPowerup.IsPowerupUnit
function sc__InWorldPowerup_IsPowerupUnit takes integer unitTypeID returns boolean
            return unitTypeID == POWERUP_SOLO_INVULN or unitTypeID == POWERUP_TEAM_INVULN or unitTypeID == POWERUP_TEAM_ADDCONT or unitTypeID == POWERUP_TEAM_STEALCONT or unitTypeID == POWERUP_TEAM_ADDSCORE or unitTypeID == POWERUP_TEAM_STEALSCORE
endfunction

//Generated method caller for InWorldPowerup.create
function sc__InWorldPowerup_create takes integer unitTypeID,real x,real y returns integer
    set f__arg_integer1=unitTypeID
    set f__arg_real1=x
    set f__arg_real2=y
    call TriggerEvaluate(st__InWorldPowerup_create)
 return f__result_integer
endfunction

//Generated method caller for VisualVote_voteMenu.applyPlayerVote
function sc__VisualVote_voteMenu_applyPlayerVote takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__VisualVote_voteMenu_applyPlayerVote)
endfunction

//Generated method caller for VisualVote_voteMenu.checkPlayersFinishedVoting
function sc__VisualVote_voteMenu_checkPlayersFinishedVoting takes integer this returns boolean
    set f__arg_this=this
    call TriggerEvaluate(st__VisualVote_voteMenu_checkPlayersFinishedVoting)
 return f__result_boolean
endfunction

//Generated method caller for VisualVote_voteMenu.destroy
function sc__VisualVote_voteMenu_destroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__VisualVote_voteMenu_destroy)
endfunction

//Generated allocator of VisualVote_voteMenu
function s__VisualVote_voteMenu__allocate takes nothing returns integer
 local integer this=si__VisualVote_voteMenu_F
    if (this!=0) then
        set si__VisualVote_voteMenu_F=si__VisualVote_voteMenu_V[this]
    else
        set si__VisualVote_voteMenu_I=si__VisualVote_voteMenu_I+1
        set this=si__VisualVote_voteMenu_I
    endif
    if (this>8190) then
        return 0
    endif

   set s__VisualVote_voteMenu_List__inlist[this]= false
   set s__VisualVote_voteMenu_next[this]= 0
   set s__VisualVote_voteMenu_prev[this]= 0
    set si__VisualVote_voteMenu_V[this]=-1
 return this
endfunction

//Generated destructor of VisualVote_voteMenu
function s__VisualVote_voteMenu_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__VisualVote_voteMenu_V[this]!=-1) then
        return
    endif
    set si__VisualVote_voteMenu_V[this]=si__VisualVote_voteMenu_F
    set si__VisualVote_voteMenu_F=this
endfunction

//Generated method caller for VisualVote_voteContainer.clearVoteOptionsForPlayer
function sc__VisualVote_voteContainer_clearVoteOptionsForPlayer takes integer this,integer pID returns nothing
    set f__arg_this=this
    set f__arg_integer1=pID
    call TriggerEvaluate(st__VisualVote_voteContainer_clearVoteOptionsForPlayer)
endfunction

//Generated method caller for RespawningGateway.Stop
function sc__RespawningGateway_Stop takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_Stop[103])
endfunction

//Generated method caller for RespawningGateway.Start
function sc__RespawningGateway_Start takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_Start[103])
endfunction

//Generated allocator of RespawningGateway
function s__RespawningGateway__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IStartable_F
    if (this!=0) then
        set si__IStartable_F=si__IStartable_V[this]
    else
        set si__IStartable_I=si__IStartable_I+1
        set this=si__IStartable_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IStartable_type[this]=103
    set kthis=this

    set si__IStartable_V[this]=-1
 return this
endfunction


//Generated method caller for Wheel.Rotate
function sc__Wheel_Rotate takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__Wheel_Rotate[si__IStartable_type[this]])
endfunction

//Generated method caller for Wheel.Stop
function sc__Wheel_Stop takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_Stop[101])
endfunction

//Generated method caller for Wheel.Start
function sc__Wheel_Start takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_Start[101])
endfunction

//Generated method caller for Wheel.create
function sc__Wheel_create takes real x,real y returns integer
    set f__arg_real1=x
    set f__arg_real2=y
    call TriggerEvaluate(st__Wheel_create)
 return f__result_integer
endfunction

//Generated allocator of Wheel
function s__Wheel__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IStartable_F
    if (this!=0) then
        set si__IStartable_F=si__IStartable_V[this]
    else
        set si__IStartable_I=si__IStartable_I+1
        set this=si__IStartable_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IStartable_type[this]=101
    set kthis=this

    set si__IStartable_V[this]=-1
 return this
endfunction


//Generated method caller for SynchronizedGroup.Stop
function sc__SynchronizedGroup_Stop takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_Stop[96])
endfunction

//Generated method caller for SynchronizedGroup.Start
function sc__SynchronizedGroup_Start takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_Start[96])
endfunction

//Generated allocator of SynchronizedGroup
function s__SynchronizedGroup__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IStartable_F
    if (this!=0) then
        set si__IStartable_F=si__IStartable_V[this]
    else
        set si__IStartable_I=si__IStartable_I+1
        set this=si__IStartable_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IStartable_type[this]=96
    set kthis=this

    set si__IStartable_V[this]=-1
 return this
endfunction


//Generated method caller for SimplePatrol.Start
function sc__SimplePatrol_Start takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_Start[94])
endfunction

//Generated method caller for SimplePatrol.Stop
function sc__SimplePatrol_Stop takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_Stop[94])
endfunction

//Generated allocator of SimplePatrol
function s__SimplePatrol__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IStartable_F
    if (this!=0) then
        set si__IStartable_F=si__IStartable_V[this]
    else
        set si__IStartable_I=si__IStartable_I+1
        set this=si__IStartable_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IStartable_type[this]=94
    set kthis=this

    set si__IStartable_V[this]=-1
 return this
endfunction


//Generated method caller for SimpleGenerator.PeriodicSpawn
function sc__SimpleGenerator_PeriodicSpawn takes nothing returns nothing
    call TriggerEvaluate(st__SimpleGenerator_PeriodicSpawn)
endfunction

//Generated method caller for SimpleGenerator.Start
function sc__SimpleGenerator_Start takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_Start[93])
endfunction

//Generated method caller for SimpleGenerator.Stop
function sc__SimpleGenerator_Stop takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_Stop[93])
endfunction

//Generated method caller for SimpleGenerator.destroy
function sc__SimpleGenerator_destroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_destroy[93])
endfunction

//Generated allocator of SimpleGenerator
function s__SimpleGenerator__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IStartable_F
    if (this!=0) then
        set si__IStartable_F=si__IStartable_V[this]
    else
        set si__IStartable_I=si__IStartable_I+1
        set this=si__IStartable_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IStartable_type[this]=93
    set kthis=this

    set si__IStartable_V[this]=-1
 return this
endfunction


//Generated method caller for RelayGenerator.GetNumberLanes
function sc__RelayGenerator_GetNumberLanes takes integer this returns integer
            //number lanes in a single tile = tile-size / lane-offset
            //number lanes total = lanes-single * spawn-diameter
            return R2I(s__RelayGenerator_Diameter[this] * TERRAIN_TILE_SIZE / s__RelayGenerator_UnitLaneSize[this]) - RelayGenerator___UNIT_SIDE_BUFFER * 2
endfunction

//Generated method caller for RelayGenerator.GetRadius
function sc__RelayGenerator_GetRadius takes integer this returns integer
			return R2I(s__RelayGenerator_Diameter[this] / 2.)
endfunction

//Generated method caller for RelayGenerator.Start
function sc__RelayGenerator_Start takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_Start[90])
endfunction

//Generated method caller for RelayGenerator.Stop
function sc__RelayGenerator_Stop takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_Stop[90])
endfunction

//Generated allocator of RelayGenerator
function s__RelayGenerator__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IStartable_F
    if (this!=0) then
        set si__IStartable_F=si__IStartable_V[this]
    else
        set si__IStartable_I=si__IStartable_I+1
        set this=si__IStartable_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IStartable_type[this]=90
    set kthis=this

    set si__IStartable_V[this]=-1
 return this
endfunction


//Generated method caller for DrunkWalker_DrunkWalkerSpawn.Stop
function sc__DrunkWalker_DrunkWalkerSpawn_Stop takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_Stop[83])
endfunction

//Generated method caller for DrunkWalker_DrunkWalkerSpawn.Start
function sc__DrunkWalker_DrunkWalkerSpawn_Start takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_Start[83])
endfunction

//Generated allocator of DrunkWalker_DrunkWalkerSpawn
function s__DrunkWalker_DrunkWalkerSpawn__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IStartable_F
    if (this!=0) then
        set si__IStartable_F=si__IStartable_V[this]
    else
        set si__IStartable_I=si__IStartable_I+1
        set this=si__IStartable_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IStartable_type[this]=83
    set kthis=this

    set si__IStartable_V[this]=-1
 return this
endfunction


//Generated method caller for DrunkWalker_DrunkWalker.drinkEffect
function sc__DrunkWalker_DrunkWalker_drinkEffect takes nothing returns nothing
    call TriggerEvaluate(st__DrunkWalker_DrunkWalker_drinkEffect)
endfunction

//Generated method caller for DrunkWalker_DrunkWalker.destroy
function sc__DrunkWalker_DrunkWalker_destroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__DrunkWalker_DrunkWalker_destroy)
endfunction

//Generated method caller for Deferred.Remove
function sc__Deferred_Remove takes integer this,integer awaiter returns nothing
    set f__arg_this=this
    set f__arg_integer1=awaiter
    call TriggerEvaluate(st__Deferred_Remove)
endfunction

//Generated method caller for Deferred.create
function sc__Deferred_create takes nothing returns integer
    call TriggerEvaluate(st__Deferred_create)
 return f__result_integer
endfunction

//Generated method caller for Deferred.destroy
function sc__Deferred_destroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__Deferred_destroy)
endfunction

//Generated method caller for CinemaCallbackModel.destroy
function sc__CinemaCallbackModel_destroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__CinemaCallbackModel_destroy)
endfunction

//Generated method caller for BoundedWheel.Rotate
function sc__BoundedWheel_Rotate takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__Wheel_Rotate[75])
endfunction

//Generated allocator of BoundedWheel
function s__BoundedWheel__allocate takes real x ,real y returns integer
 local integer this=sc__Wheel_create(x,y)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IStartable_type[this]=75
    set kthis=this

 return this
endfunction


//Generated method caller for BoundedSpoke.Stop
function sc__BoundedSpoke_Stop takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_Stop[74])
endfunction

//Generated method caller for BoundedSpoke.Start
function sc__BoundedSpoke_Start takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_Start[74])
endfunction

//Generated allocator of BoundedSpoke
function s__BoundedSpoke__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IStartable_F
    if (this!=0) then
        set si__IStartable_F=si__IStartable_V[this]
    else
        set si__IStartable_I=si__IStartable_I+1
        set this=si__IStartable_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IStartable_type[this]=74
    set kthis=this

    set si__IStartable_V[this]=-1
 return this
endfunction


//Generated method caller for SimpleList_List.add
function sc__SimpleList_List_add takes integer this,integer value returns nothing
    set f__arg_this=this
    set f__arg_integer1=value
    call TriggerEvaluate(st__SimpleList_List_add)
endfunction

//Generated method caller for SimpleList_List.remove
function sc__SimpleList_List_remove takes integer this,integer value returns nothing
    set f__arg_this=this
    set f__arg_integer1=value
    call TriggerEvaluate(st__SimpleList_List_remove)
endfunction

//Generated method caller for SimpleList_List.create
function sc__SimpleList_List_create takes nothing returns integer
    call TriggerEvaluate(st__SimpleList_List_create)
 return f__result_integer
endfunction

//Generated method caller for Recycle_UnitRecycler.MakeWithFacing
function sc__Recycle_UnitRecycler_MakeWithFacing takes integer this,real x,real y,real angle returns unit
    set f__arg_this=this
    set f__arg_real1=x
    set f__arg_real2=y
    set f__arg_real3=angle
    call TriggerEvaluate(st__Recycle_UnitRecycler_MakeWithFacing)
 return f__result_unit
endfunction

//Generated method caller for Recycle_UnitRecycler.Make
function sc__Recycle_UnitRecycler_Make takes integer this,real x,real y returns unit
    set f__arg_this=this
    set f__arg_real1=x
    set f__arg_real2=y
    call TriggerEvaluate(st__Recycle_UnitRecycler_Make)
 return f__result_unit
endfunction

//Generated method caller for Recycle_UnitRecycler.Release
function sc__Recycle_UnitRecycler_Release takes integer this,unit u returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerEvaluate(st__Recycle_UnitRecycler_Release)
endfunction

//Generated method caller for Recycle_UnitRecycler.GetRecycler
function sc__Recycle_UnitRecycler_GetRecycler takes integer unitTypeID returns integer
			return LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, unitTypeID)
endfunction

//Generated method caller for MortarNTarget.Start
function sc__MortarNTarget_Start takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_Start[65])
endfunction

//Generated method caller for MortarNTarget.Stop
function sc__MortarNTarget_Stop takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_Stop[65])
endfunction

//Generated method caller for MortarNTarget.onDestroy
function sc__MortarNTarget_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_onDestroy[65])
endfunction

//Generated allocator of MortarNTarget
function s__MortarNTarget__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IStartable_F
    if (this!=0) then
        set si__IStartable_F=si__IStartable_V[this]
    else
        set si__IStartable_I=si__IStartable_I+1
        set this=si__IStartable_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IStartable_type[this]=65
    set kthis=this

   set s__MortarNTarget_List__inlist[this]= false
   set s__MortarNTarget_next[this]= 0
   set s__MortarNTarget_prev[this]= 0
    set si__IStartable_V[this]=-1
 return this
endfunction


//Generated method caller for Stack.onDestroy
function sc__Stack_onDestroy takes integer this returns nothing
            local integer n
            // Remove all remaining indexes from the stack.
            loop
                // Get the top index.
                set n=s__Stack_top[this]
                exitwhen n == 0
                // Remove it from the stack.
                set s__Stack_top[this]=s__Stack_next[n]
                // Add it to the list of free indexes.
                set s__Stack_next[n]=s__Stack_free
                set s__Stack_free=n
            endloop
endfunction

//Generated allocator of Stack
function s__Stack__allocate takes nothing returns integer
 local integer this=si__Stack_F
    if (this!=0) then
        set si__Stack_F=si__Stack_V[this]
    else
        set si__Stack_I=si__Stack_I+1
        set this=si__Stack_I
    endif
    if (this>8190) then
        return 0
    endif

   set s__Stack_size[this]= 0
   set s__Stack_top[this]= 0
    set si__Stack_V[this]=-1
 return this
endfunction

//Generated destructor of Stack
function sc__Stack_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__Stack_V[this]!=-1) then
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__Stack_onDestroy)
    set si__Stack_V[this]=si__Stack_F
    set si__Stack_F=this
endfunction

//Generated method caller for FastLoad.Start
function sc__FastLoad_Start takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_Start[130])
endfunction

//Generated method caller for FastLoad.Stop
function sc__FastLoad_Stop takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_Stop[130])
endfunction

//Generated allocator of FastLoad
function s__FastLoad__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IStartable_F
    if (this!=0) then
        set si__IStartable_F=si__IStartable_V[this]
    else
        set si__IStartable_I=si__IStartable_I+1
        set this=si__IStartable_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IStartable_type[this]=130
    set kthis=this

    set si__IStartable_V[this]=-1
 return this
endfunction


//Generated method caller for IceSkater.Start
function sc__IceSkater_Start takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_Start[115])
endfunction

//Generated method caller for IceSkater.Stop
function sc__IceSkater_Stop takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_Stop[115])
endfunction

//Generated method caller for IceSkater.destroy
function sc__IceSkater_destroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_destroy[115])
endfunction

//Generated allocator of IceSkater
function s__IceSkater__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IStartable_F
    if (this!=0) then
        set si__IStartable_F=si__IStartable_V[this]
    else
        set si__IStartable_I=si__IStartable_I+1
        set this=si__IStartable_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IStartable_type[this]=115
    set kthis=this

    set si__IStartable_V[this]=-1
 return this
endfunction


//Generated method caller for Blackhole.WatchPlayer
function sc__Blackhole_WatchPlayer takes integer this,integer pID returns nothing
    set f__arg_this=this
    set f__arg_integer1=pID
    call TriggerEvaluate(st__Blackhole_WatchPlayer)
endfunction

//Generated method caller for Blackhole.Start
function sc__Blackhole_Start takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_Start[119])
endfunction

//Generated method caller for Blackhole.Stop
function sc__Blackhole_Stop takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_Stop[119])
endfunction

//Generated method caller for Blackhole.destroy
function sc__Blackhole_destroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_destroy[119])
endfunction

//Generated method caller for Blackhole.create
function sc__Blackhole_create takes real x,real y,boolean persist returns integer
    set f__arg_real1=x
    set f__arg_real2=y
    set f__arg_boolean1=persist
    call TriggerEvaluate(st__Blackhole_create)
 return f__result_integer
endfunction

//Generated allocator of Blackhole
function s__Blackhole__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IStartable_F
    if (this!=0) then
        set si__IStartable_F=si__IStartable_V[this]
    else
        set si__IStartable_I=si__IStartable_I+1
        set this=si__IStartable_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IStartable_type[this]=119
    set kthis=this

    set si__IStartable_V[this]=-1
 return this
endfunction


//Generated method caller for CollectibleSet.Start
function sc__CollectibleSet_Start takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_Start[129])
endfunction

//Generated method caller for CollectibleSet.Stop
function sc__CollectibleSet_Stop takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IStartable_Stop[129])
endfunction

//Generated allocator of CollectibleSet
function s__CollectibleSet__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IStartable_F
    if (this!=0) then
        set si__IStartable_F=si__IStartable_V[this]
    else
        set si__IStartable_I=si__IStartable_I+1
        set this=si__IStartable_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IStartable_type[this]=129
    set kthis=this

    set si__IStartable_V[this]=-1
 return this
endfunction

function sc___prototype3_execute takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerExecute(st___prototype3[i])
endfunction
function sc___prototype3_evaluate takes integer i,integer a1 returns boolean
    set f__arg_integer1=a1

    call TriggerEvaluate(st___prototype3[i])
 return f__result_boolean
endfunction
function sc___prototype8_execute takes integer i returns nothing

    call TriggerExecute(st___prototype8[i])
endfunction
function sc___prototype8_evaluate takes integer i returns nothing

    call TriggerEvaluate(st___prototype8[i])

endfunction
function sc___prototype19_execute takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerExecute(st___prototype19[i])
endfunction
function sc___prototype19_evaluate takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerEvaluate(st___prototype19[i])

endfunction
function sc___prototype29_execute takes integer i,integer a1,integer a2 returns nothing
    set f__arg_integer1=a1
    set f__arg_integer2=a2

    call TriggerExecute(st___prototype29[i])
endfunction
function sc___prototype29_evaluate takes integer i,integer a1,integer a2 returns group
    set f__arg_integer1=a1
    set f__arg_integer2=a2

    call TriggerEvaluate(st___prototype29[i])
 return f__result_group
endfunction
function sc___prototype54_execute takes integer i,integer a1,integer a2 returns nothing
    set f__arg_integer1=a1
    set f__arg_integer2=a2

    call TriggerExecute(st___prototype54[i])
endfunction
function sc___prototype54_evaluate takes integer i,integer a1,integer a2 returns integer
    set f__arg_integer1=a1
    set f__arg_integer2=a2

    call TriggerEvaluate(st___prototype54[i])
 return f__result_integer
endfunction

//library Boolean:
 function S2B takes string s returns boolean
		return s == "1" or s == "true"
	endfunction
 function B2S takes boolean b returns string
		if b then
			return "true"
		else
			return "false"
		endif
	endfunction
	
 function I2B takes integer i returns boolean
		return i != 0
	endfunction
 function B2I takes boolean b returns integer
		if b then
			return 1
		else
			return 0
		endif
	endfunction

//library Boolean ends
//library ConfigurationMode:
	
 function ShouldShowSettingVoteMenu takes nothing returns boolean
		return CONFIGURATION_PROFILE == RELEASE or FORCE_SETTING_MENU
	endfunction

//library ConfigurationMode ends
//library DestructableGlobals:

//library DestructableGlobals ends
//library Draw:
    function Draw_DrawLine takes real x1,real y1,real x2,real y2,real z returns nothing
        call AddLightningEx("MBUR", false, x1, y1, z, x2, y2, z)
    endfunction
    function Draw_DrawRegion takes rect r,real z returns nothing
        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Drawing region BL: " + R2S(GetRectMinX(r)) + ", " + R2S(GetRectMinY(r)) + "; TR: " + R2S(GetRectMaxX(r)) + ", " + R2S(GetRectMaxY(r)))
        
        call AddLightningEx("MBUR", false, GetRectMinX(r), GetRectMinY(r), z, GetRectMinX(r), GetRectMaxY(r), z)
        call AddLightningEx("MBUR", false, GetRectMinX(r), GetRectMinY(r), z, GetRectMaxX(r), GetRectMinY(r), z)
        call AddLightningEx("MBUR", false, GetRectMinX(r), GetRectMaxY(r), z, GetRectMaxX(r), GetRectMaxY(r), z)
        call AddLightningEx("MBUR", false, GetRectMaxX(r), GetRectMinY(r), z, GetRectMaxX(r), GetRectMaxY(r), z)
        
        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Done drawing region")
    endfunction

//library Draw ends
//library DummyCaster:

    
//Implemented from module DummyCaster___N:
        function s__DummyCaster_DummyCaster___N__onInit takes nothing returns nothing





                set DummyCaster___u=CreateUnit(DummyCaster___PLAYER_OWNER, UNITS_DUMMY_CASTER, 0, 0, 0)

            call SetUnitPosition(DummyCaster___u, 32256, 32256)
        endfunction
        function s__DummyCaster_prep takes integer a,player p,integer l returns nothing
            call UnitAddAbility(DummyCaster___u, a)
            if ( 1 < l ) then
                call SetUnitAbilityLevel(DummyCaster___u, a, l)
            endif
            if ( null != p ) then
                call SetUnitOwner(DummyCaster___u, p, false)
            endif
        endfunction
        function s__DummyCaster_finish takes integer a returns nothing
            call SetUnitOwner(DummyCaster___u, DummyCaster___PLAYER_OWNER, false)
            call UnitRemoveAbility(DummyCaster___u, a)
        endfunction
        function s__DummyCaster_cast takes integer this,player p,integer level,integer order,real x,real y returns boolean
            local boolean b
            call SetUnitX(DummyCaster___u, x)
            call SetUnitY(DummyCaster___u, y)
            call s__DummyCaster_prep(this , p , level)
            set b=IssueImmediateOrderById(DummyCaster___u, order)
            call s__DummyCaster_finish(this)
            call SetUnitPosition(DummyCaster___u, 32256, 32256)
            return b
        endfunction
        function s__DummyCaster_castTarget takes integer this,player p,integer level,integer order,widget t returns boolean
            local boolean b
            call s__DummyCaster_prep(this , p , level)
            set b=IssueTargetOrderById(DummyCaster___u, order, t)
            call s__DummyCaster_finish(this)
            return b
        endfunction
        function s__DummyCaster_castPoint takes integer this,player p,integer level,integer order,real x,real y returns boolean
            local boolean b
            call s__DummyCaster_prep(this , p , level)
            set b=IssuePointOrderById(DummyCaster___u, order, x, y)
            call s__DummyCaster_finish(this)
            return b
        endfunction

//library DummyCaster ends
//library EDWQuests:
	
 function EDWQuests__init takes nothing returns nothing
  local quest q= CreateQuest()
		
		//***********
		//Credits
		call QuestSetTitle(q, "Credits")
		call QuestSetDescription(q, "Thanks to my partner, who's endured this map's development.\n\nShout out to the old WC3 crew, whose names will be forever ideal: Pat1487, Achilles.42, Mazemasta77, Amazin[G], FFSlayer, Olonavy, hlw_rocer, popartica., Eat_Bacon_Daily, marksoccer, monkeys-forever, DoughnutMuffin, God[A]nt69, Makshak\n\nFull credits for the map can be found at: ")
		call QuestSetIconPath(q, "ReplaceableTextures\\CommandButtons\\BTNBookOfTheDead.blp")
		call QuestSetRequired(q, true)
		call QuestSetDiscovered(q, true)
		call QuestSetCompleted(q, true)
	endfunction

//library EDWQuests ends
//library ErrorMessage:
	
 function ErrorMessage__Pause takes nothing returns nothing
		call PauseGame(true)
	endfunction
	
 function ErrorMessage__ThrowMessage takes string libraryName,string functionName,string objectName,integer objectInstance,string description,string errorType,string color returns nothing
  local string str
		
  local string color_braces= "|cff66FF99"
  local string orange= "|cffff6600"
		
		set str="->\n-> " + color_braces + "{|r Library" + color_braces + "(" + orange + libraryName + color_braces + ")"
		if ( objectName != null ) then
			if ( objectInstance != 0 ) then
				set str=str + "|r.Object" + color_braces + "(" + orange + objectName + color_braces + " (|rinstance = " + orange + I2S(objectInstance) + color_braces + ") )|r.Method" + color_braces + "(" + orange + functionName + color_braces + ")"
			else
				set str=str + "|r.Object" + color_braces + "(" + orange + objectName + color_braces + ")|r.Method" + color_braces + "(" + orange + functionName + color_braces + ")"
			endif
		else
			set str=str + "|r.Function" + color_braces + "(" + orange + functionName + color_braces + ")"
		endif
		
		set str=str + color_braces + " }|r has thrown an exception of type " + color_braces + "(" + color + errorType + color_braces + ")|r."
		
		set s__ErrorMessage__Fields_lastError=str + "\n->\n->	" + color + description + "|r\n->"
	endfunction
	
 function ThrowError takes boolean expression,string libraryName,string functionName,string objectName,integer objectInstance,string description returns nothing
		if ( s__ErrorMessage__Fields_lastError != null ) then
			set objectInstance=1 / 0
		endif
	
		if ( expression ) then
			call ErrorMessage__ThrowMessage(libraryName , functionName , objectName , objectInstance , description , "Error" , s__ErrorMessage__Fields_COLOR_RED)
			call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, 60000, s__ErrorMessage__Fields_lastError)
			call TimerStart(CreateTimer(), 0, true, function ErrorMessage__Pause)
			set objectInstance=1 / 0
		endif
	endfunction
 function ThrowWarning takes boolean expression,string libraryName,string functionName,string objectName,integer objectInstance,string description returns nothing
		if ( s__ErrorMessage__Fields_lastError != null ) then
			set objectInstance=1 / 0
		endif
	
		if ( expression ) then
			call ErrorMessage__ThrowMessage(libraryName , functionName , objectName , objectInstance , description , "Warning" , s__ErrorMessage__Fields_COLOR_YELLOW)
			call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, 60000, s__ErrorMessage__Fields_lastError)
			set s__ErrorMessage__Fields_lastError=null
		endif
	endfunction

//library ErrorMessage ends
//library Event:
        function s__Event_create takes nothing returns integer
            set s__Event_w=s__Event_w + 1
            set s__Event_e[s__Event_w]=CreateTrigger()
            return s__Event_w
        endfunction
        function s__Event_registerTrigger takes integer this,trigger t returns nothing
            call TriggerRegisterVariableEvent(t, "Event___q", EQUAL, this)
        endfunction
        function s__Event_register takes integer this,boolexpr c returns nothing
            call TriggerAddCondition(s__Event_e[this], c)
        endfunction
        function s__Event_fire takes integer this returns nothing
            set Event___q=0
            set Event___q=this
            call TriggerEvaluate(s__Event_e[this])
        endfunction

//library Event ends
//library FilterFuncs:


function IsGreenBrown takes nothing returns boolean
    return GetPlayerId(GetOwningPlayer(GetFilterUnit())) == 10 or GetPlayerId(GetOwningPlayer(GetFilterUnit())) == 11
endfunction

function IsPlayerOwned takes nothing returns boolean
    return GetPlayerId(GetOwningPlayer(GetFilterUnit())) < 8
endfunction

function IsGreen takes nothing returns boolean
    return GetPlayerId(GetOwningPlayer(GetFilterUnit())) == 10
endfunction

function IsBrown takes nothing returns boolean
    return GetPlayerId(GetOwningPlayer(GetFilterUnit())) == 11
endfunction

function IsNotMazer takes nothing returns boolean
    return GetPlayerId(GetOwningPlayer(GetFilterUnit())) >= 8
endfunction

function FilterFuncInit takes nothing returns nothing
    set GreenOrBrown=Filter(function IsGreenBrown)
    set PlayerOwned=Filter(function IsPlayerOwned)
    set Green=Filter(function IsGreen)
    set Brown=Filter(function IsBrown)
    set NotMazer=Filter(function IsNotMazer)
endfunction


//library FilterFuncs ends
//library FooBar:

function FooBar__Init takes nothing returns nothing

endfunction


//library FooBar ends
//library FourSeasons1:
 function FourSeason1Start takes nothing returns nothing
	
	endfunction
	
 function FourSeason1Stop takes nothing returns nothing

	endfunction

//library FourSeasons1 ends
//library GameGlobalConstants:

//library GameGlobalConstants ends
//library GameMessage:
	
 function ColorMessage takes string message,string hexColor returns string
		return "|cFF" + hexColor + message + "|r"
	endfunction
 function ColorValue takes string value returns string
		return ColorMessage(value , SPEAKER_COLOR)
	endfunction
	
 function GetEDWSpeakerMessage takes string speaker,string message,string messageColor returns string
        if messageColor == null then
            return "|cFF" + SPEAKER_COLOR + speaker + "|r" + ": " + message
        else
            return "|cFF" + SPEAKER_COLOR + speaker + "|r: |cFF" + messageColor + message + "|r"
        endif
    endfunction

//library GameMessage ends
//library GroupUtils:
    
 function GroupUtils___initStack takes nothing returns nothing
		set GroupUtils___count=0
        loop
        exitwhen GroupUtils___count == GroupUtils___PRELOAD_COUNT
            set GroupUtils___recycle[GroupUtils___count]=CreateGroup()
        set GroupUtils___count=GroupUtils___count + 1
        endloop
    endfunction
 function GroupUtils___init takes nothing returns nothing
		call GroupUtils___initStack()
	endfunction
	
    function NewGroup takes nothing returns group
		if GroupUtils___count == 0 then
			call GroupUtils___initStack()
        endif
		
		set GroupUtils___count=GroupUtils___count - 1
		return GroupUtils___recycle[GroupUtils___count]
    endfunction
    function ReleaseGroup takes group g returns nothing






		
		call GroupClear(g)
		
		
		if GroupUtils___count == GroupUtils___MAX_RECYCLE_COUNT then
			call DestroyGroup(g)
		else
			set GroupUtils___recycle[GroupUtils___count]=g
			set GroupUtils___count=GroupUtils___count + 1
		endif
    endfunction
	
	//breaks horribly
	
	
	//oddly not a native and the only near equivalent bj, IsUnitGroupEmptyBJ, is wonky
 function IsGroupEmpty takes group g returns boolean
		return FirstOfGroup(g) == null
	endfunction
	//much faster than GroupAddGroup and doesn't have weird extras. leaves mergeGroup equivalent to its original state/order
 function MergeGroups takes group mergeTo,group mergeFrom returns nothing
  local unit u
  local group temp= NewGroup()
		
		loop
		set u=FirstOfGroup(mergeFrom)
		exitwhen u == null
			call GroupAddUnit(mergeTo, u)
		call GroupAddUnit(temp, u)
		call GroupRemoveUnit(mergeFrom, u)
		endloop
		
		//can't release a group and then update its external reference to local group temp
		//call ReleaseGroup(mergeFrom)
		set mergeFrom=temp
		
		set temp=null
		set u=null
	endfunction
	

//library GroupUtils ends
//library HandleList:
//==================================================================================
// List version 1.1
//----------------------------
//  Use this version in your map.
//==================================================================================
// - made by MaskedPoptart
// - imitates the functionality of ArrayLists (from Java)
//   using a hashtable.
//==================================================================================
//       Basic Usage:
//  set arr = IntegerList.create()      - instantiate a List of integers
//  arr.size                            - get the current number of elements
//  call arr.addLast(5732)              - add 5732 to the end of the list,
//                                        increase .size by 1
//  arr.removeLast()                    - remove the last element in the list,
//                                        decrease .size by 1, return removed element
//  arr.remove(6)                       - remove the 6th element, decrease .size by 1,
//                                        return removed element, shift elements down
//  arr[3]                              - get the element at index 3
//  set arr[23] = 815                   - replace the value at index 23 with 815
//  call arr.clear()                    - remove all objects from the list
//  call arr.destroy()                  - clear list and recycle the struct index
//
// WARNING:     Most attempts to work with indexes <0 or >=.size will fail and
//  generate an error message in debug mode. Returns default to 0 for integers/
//  reals, null for handles, false for booleans, etc.
//
// LEAK WARNING:    List does no automatic garbage collection. If a List
//  is the only place you store a variable, make sure the variable will not leak when
//  you remove it or replace it.
//===================================================================================
//    Credits:
// - Vexorian for JassHelper
// - Vexorian for Table 3.0 (which I used for reference)
// - All the other people who worked on JassNewGenPack
//===================================================================================   

  //runtextmacro List( "type",      "listType", "typeName"  )
  
//type = type of object to store. must be exact.
//listType = prefix to the List struct name. can be whatever you want.
//ex: Timer --> TimerList
//typeName = suffix in Save, Load hashtable functions. must be exact.
//ex: Str --> LoadStr
  
// //! runtextmacro List( "integer",   "Integer",  "Integer"       )
// //! runtextmacro List( "string",    "String",   "Str"           )
// //! runtextmacro List( "real",      "Real",     "Real"          )
// //! runtextmacro List( "boolean",   "Boolean",  "Boolean"       )

// //! runtextmacro List( "player",    "Player",   "PlayerHandle"  )
// //! runtextmacro List( "unit",      "Unit",     "UnitHandle"    )
// //! runtextmacro List( "item",      "Item",     "ItemHandle"    )
// //! runtextmacro List( "widget",    "Widget",   "WidgetHandle"  )
// //! runtextmacro List( "timer",     "Timer",    "TimerHandle"   )
// //! runtextmacro List( "effect",    "Effect",   "EffectHandle"  )
//textmacro instance: List( "rect",      "Rect",     "RectHandle"    )
        
//Implemented from module Alloc:
		
		

			

		
		
  function s__RectList_allocate takes nothing returns integer
   local integer this= s__RectList_Alloc___recycler[0]
			


			
			if ( s__RectList_Alloc___recycler[this] == 0 ) then
				set s__RectList_Alloc___recycler[0]=this + 1
			else
				set s__RectList_Alloc___recycler[0]=s__RectList_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__RectList_deallocate takes integer this returns nothing


			


			
			set s__RectList_Alloc___recycler[this]=s__RectList_Alloc___recycler[0]
			set s__RectList_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__RectList_Alloc___onInit takes nothing returns nothing
			set s__RectList_Alloc___recycler[0]=1
  endfunction
		
  function s__RectList_create takes nothing returns integer
   local integer new= s__RectList_allocate()
			
			set s__RectList_min[new]=- 1
			set s__RectList_max[new]=0
			
			return new
  endfunction
		
        function s__RectList_onInit takes nothing returns nothing
			set s__RectList_contents=InitHashtable()
            set s__RectList_DEFAULT_VALUE=LoadRectHandle(s__RectList_contents, 0, 0)
        endfunction
        
        function s__RectList_getActualIndex takes integer this,integer publicIndex returns integer
            return publicIndex + s__RectList_min[this] + 1
        endfunction
        
        function s__RectList_getPublicIndex takes integer this,integer actualIndex returns integer
            return actualIndex - s__RectList_min[this] - 1
        endfunction
        
        function s__RectList_isValidIndex takes integer this,integer actualIndex returns boolean
            return actualIndex > s__RectList_min[this] and actualIndex < s__RectList_max[this]
        endfunction
        
//---------------------USER METHODS------------------------

        function s__RectList__get_size takes integer this returns integer
            return s__RectList_max[this] - s__RectList_min[this] - 1
        endfunction
        
        function s__RectList_addStart takes integer this,rect object returns nothing
            call SaveRectHandle(s__RectList_contents, (this), s__RectList_min[this], object)
            set s__RectList_min[this]=s__RectList_min[this] - 1
        endfunction
        
        function s__RectList_addEnd takes integer this,rect object returns nothing
            call SaveRectHandle(s__RectList_contents, (this), s__RectList_max[this], object)
            set s__RectList_max[this]=s__RectList_max[this] + 1
        endfunction
        
        function s__RectList_removeStart takes integer this returns rect
            if ( s__RectList__get_size(this) > 0 ) then
                set s__RectList_min[this]=s__RectList_min[this] + 1
                return LoadRectHandle(s__RectList_contents, (this), s__RectList_min[this])
            endif
            return s__RectList_DEFAULT_VALUE
        endfunction
        
        function s__RectList_removeEnd takes integer this returns rect
            if ( s__RectList__get_size(this) > 0 ) then
                set s__RectList_max[this]=s__RectList_max[this] - 1
                return LoadRectHandle(s__RectList_contents, (this), s__RectList_max[this])
            endif
            return s__RectList_DEFAULT_VALUE
        endfunction
        
        function s__RectList__getindex takes integer this,integer index returns rect
            local integer actualIndex= s__RectList_getActualIndex(this,index)
            if ( s__RectList_isValidIndex(this,actualIndex) ) then
                return LoadRectHandle(s__RectList_contents, (this), actualIndex)
            endif
            return s__RectList_DEFAULT_VALUE
        endfunction
        
        function s__RectList__setindex takes integer this,integer index,rect object returns nothing
            local integer actualIndex= s__RectList_getActualIndex(this,index)
            if ( s__RectList_isValidIndex(this,actualIndex) ) then
                call SaveRectHandle(s__RectList_contents, (this), actualIndex, object)
            endif
        endfunction
        
        function s__RectList_add takes integer this,integer index,rect object returns nothing
            local integer i
            local integer actualIndex= s__RectList_getActualIndex(this,index)
            if ( actualIndex > s__RectList_min[this] and actualIndex <= s__RectList_max[this] ) then
                if ( actualIndex <= 0.5 * ( s__RectList_min[this] + s__RectList_max[this] ) ) then
                    set actualIndex=actualIndex - 1
                    set i=s__RectList_min[this]
                    loop
                        exitwhen i >= actualIndex
                        call SaveRectHandle(s__RectList_contents, (this), i, LoadRectHandle(s__RectList_contents, (this), i + 1))
                        set i=i + 1
                    endloop
                    set s__RectList_min[this]=s__RectList_min[this] - 1
                else
                    set i=s__RectList_max[this]
                    loop
                        exitwhen i <= actualIndex
                        call SaveRectHandle(s__RectList_contents, (this), i, LoadRectHandle(s__RectList_contents, (this), i - 1))
                        set i=i - 1
                    endloop
                    set s__RectList_max[this]=s__RectList_max[this] + 1
                endif
                call SaveRectHandle(s__RectList_contents, (this), actualIndex, object)
            endif
        endfunction
        
        function s__RectList_remove takes integer this,integer index returns rect
            local integer i
            local integer actualIndex= s__RectList_getActualIndex(this,index)
            if ( s__RectList_isValidIndex(this,actualIndex) ) then
                set s__RectList_tempObject=LoadRectHandle(s__RectList_contents, (this), actualIndex)
                set i=actualIndex
                if ( actualIndex <= 0.5 * ( s__RectList_min[this] + s__RectList_max[this] ) ) then
                    set s__RectList_min[this]=s__RectList_min[this] + 1
                    loop
                        exitwhen i <= s__RectList_min[this]
                        call SaveRectHandle(s__RectList_contents, (this), i, LoadRectHandle(s__RectList_contents, (this), i - 1))
                        set i=i - 1
                    endloop
                else
                    set s__RectList_max[this]=s__RectList_max[this] - 1
                    loop
                        exitwhen i >= s__RectList_max[this]
                        call SaveRectHandle(s__RectList_contents, (this), i, LoadRectHandle(s__RectList_contents, (this), i + 1))
                        set i=i + 1
                    endloop
                endif
                return s__RectList_tempObject
            endif
            return s__RectList_DEFAULT_VALUE
        endfunction
        
        function s__RectList_clear takes integer this returns nothing
            call FlushChildHashtable(s__RectList_contents, (this))
            set s__RectList_min[this]=- 1
            set s__RectList_max[this]=0
        endfunction
        
        function s__RectList_removeRange takes integer this,integer fromIndex,integer toIndex returns nothing
            local integer i
            local integer actualFromIndex= s__RectList_getActualIndex(this,fromIndex)
            local integer actualToIndex= s__RectList_getActualIndex(this,toIndex - 1)
            if ( s__RectList_isValidIndex(this,actualFromIndex) ) then
                if ( s__RectList_isValidIndex(this,actualToIndex) and toIndex > fromIndex ) then
                    if ( actualFromIndex - s__RectList_min[this] < s__RectList_max[this] - actualToIndex ) then
                        set i=actualFromIndex
                        loop
                            set i=i - 1
                            exitwhen i <= s__RectList_min[this]
                            call SaveRectHandle(s__RectList_contents, (this), i - fromIndex + toIndex, LoadRectHandle(s__RectList_contents, (this), i))
                        endloop
                        set s__RectList_min[this]=s__RectList_min[this] - fromIndex + toIndex
                    else
                        set i=actualToIndex
                        loop
                            set i=i + 1
                            exitwhen i >= s__RectList_max[this]
                            call SaveRectHandle(s__RectList_contents, (this), i + fromIndex - toIndex, LoadRectHandle(s__RectList_contents, (this), i))
                        endloop
                        set s__RectList_max[this]=s__RectList_max[this] + fromIndex - toIndex
                    endif
                endif
            endif
        endfunction
        
        function s__RectList_indexOf takes integer this,rect object returns integer
            local integer i= s__RectList_min[this]
            loop
                set i=i + 1
                exitwhen i >= s__RectList_max[this]
                if ( LoadRectHandle(s__RectList_contents, (this), i) == object ) then
                    return s__RectList_getPublicIndex(this,i)
                endif
            endloop
            return - 1
        endfunction
        
        function s__RectList_lastIndexOf takes integer this,rect object returns integer
            local integer i= s__RectList_max[this]
            loop
                set i=i - 1
                exitwhen i <= s__RectList_min[this]
                if ( LoadRectHandle(s__RectList_contents, (this), i) == object ) then
                    return s__RectList_getPublicIndex(this,i)
                endif
            endloop
            return - 1
        endfunction
        
        function s__RectList_swap takes integer this,integer index1,integer index2 returns nothing
            local integer actualIndex1= s__RectList_getActualIndex(this,index1)
            local integer actualIndex2= s__RectList_getActualIndex(this,index2)
            if ( s__RectList_isValidIndex(this,actualIndex1) ) then
                if ( s__RectList_isValidIndex(this,actualIndex2) ) then
                    set s__RectList_tempObject=LoadRectHandle(s__RectList_contents, (this), actualIndex1)
                    call SaveRectHandle(s__RectList_contents, (this), actualIndex1, LoadRectHandle(s__RectList_contents, (this), actualIndex2))
                    call SaveRectHandle(s__RectList_contents, (this), actualIndex2, s__RectList_tempObject)
                endif
            endif
        endfunction

        function s__RectList_exists takes integer this,integer index returns boolean
            return index >= 0 and index < s__RectList__get_size(this)
        endfunction
        
        function s__RectList_isEmpty takes integer this returns boolean
            return s__RectList_max[this] == 0
        endfunction
        
//------------------END USER METHODS----------------------
		
  function s__RectList_destroy takes integer this returns nothing
			call s__RectList_clear(this)
			call s__RectList_deallocate(this)
  endfunction
//end of: List( "rect",      "Rect",     "RectHandle"    )
// //! runtextmacro List( "group",     "Group",    "GroupHandle"   )
// //! runtextmacro List( "force",     "Force",    "ForceHandle"   )

// Add as many handle list types as you want, and comment out the ones you do not use
// so they do not take up unnecessary space in your map script.


//library HandleList ends
//library IStartable:

        
		
		//method Dispose takes nothing returns nothing

//library IStartable ends
//library LevelIDGlobals:

//library LevelIDGlobals ends
//library ListModule:
//===========================================================================
// Information:
//==============
//
//     This library provides the List module, which allows you to easily create
// a linked list of all of the allocated instances of a struct-type. Iterating
// through a linked list is about 12% faster than iteratating through an array
// in JASS. There is no faster method to iterate through a list of structs than
// the method used by this module. Aside from the marginal speed gain, the best
// use of this library is to hide some ugly low-level code from your structs.
// Rather than manually building and maintaining a list of struct instances,
// just implement the List module, and your code will become much prettier.
//
//===========================================================================
// How to use the List module:
//=============================
//
//     Using the List module is pretty simple. First, implement it in your
// struct (preferably at the top to avoid unnecessary TriggerEvaluate calls).
// In the struct's create method, you must call listAdd(). In the onDestroy
// method, you must also call listRemove(). An example is shown below:


//     The requirement to call listAdd() and listRemove() will be done away
// with once JassHelper supports module onDestroy and module onCreate, but
// for now, it is not too much of a burden.
//
//     Once this is done, your struct will gain all of the methods detailed
// in the API section. Below is an example of how to iterate through the list
// of allocated structs of the implementing struct-type:

//
//===========================================================================
// List module API:
//==================
//
// (readonly)(static) first -> thistype
//   This member contains the first instance of thistype in the list.
//
// (readonly)(static) last -> thistype
//   This member contains the last instance of thistype in the list.
//
// (readonly)(static) count -> integer
//   This member contains the number of allocated structs of thistype.
//
// (readonly) next -> thistype
//   This member contains the next instance of thistype in the list.
//
// (readonly) prev -> thistype
//   This member contains the previous instance of thistype in the list.
//
// listAdd()
//   This method adds this instance to the list of structs of thistype.
//   This should be called on each instance after it is allocated (within
//   the create method).
//
// listRemove()
//   This method removes this instance from the list of structs of thistype.
//   This should be called on each instance before it is destroyed (within
//   the onDestroy method).
//
// (static) listDestroy()
//   This method destroys all the structs of thistype within the list.
//
//===========================================================================



//library ListModule ends
//library ORDER:

//library ORDER ends
//library PermanentAlloc:

//library PermanentAlloc ends
//library PlatformerGlobals:

//library PlatformerGlobals ends
//library PreventSave:
//====================================
//  by TriggerHappy
//====================================
//
//  This library allows you to enable or disable game saving. 
//  It works by showing a dialog instantly before a game is saved which interrupts it.
//  It does nothing visually to the game that I've noticed.
//
//  You can toggle saving for a specific player with the PreventSave function.
//  Example:
//      call PreventSave(Player(0), true) - disables saving for player 0
//
//  You also can toggle for everybody by setting
//  GameAllowSave to true, or false.
//
//====================================
// Import Instructions
//====================================
//
//  Decide whether you want GUI or vJASS, then copy the triggers or script over to your map.
//  This script requires JassHelper which is included in JassNewGenPack.
//
//====================================
    
    
//====================================
// Do not edit below this line
//====================================
    
    
    function PreventSave takes player p,boolean flag returns nothing
        if ( p == PreventSave___localplayer ) then
            set GameAllowSave=not flag
        endif
    endfunction
    
    function PreventSave___Exit takes nothing returns nothing
        call DialogDisplay(PreventSave___localplayer, PreventSave___Dialog, false)
    endfunction
    
    function PreventSave___StopSave takes nothing returns boolean
        if not GameAllowSave then
            call DialogDisplay(PreventSave___localplayer, PreventSave___Dialog, true)
        endif
        call TimerStart(PreventSave___Timer, 0.00, false, function PreventSave___Exit)
        return false
    endfunction
    
    function PreventSave___onInit takes nothing returns nothing
        local trigger t= CreateTrigger()
        set PreventSave___localplayer=GetLocalPlayer()
        
        call TriggerRegisterGameEvent(t, EVENT_GAME_SAVE)
        call TriggerAddCondition(t, Condition(function PreventSave___StopSave))
    endfunction


//library PreventSave ends
//library RunningGlobals:

//library RunningGlobals ends
//library Stack:

//*****************************************************************
//*  STACK
//*
//*  written by: Anitarf
//*
//*  This is an efficient implementation of a stack in vJass. Since
//*  it is based on a linked list, I decided to add common list
//*  methods to the data structure so it can function both as
//*  a stack and a simple linked list.
//*
//*  As a linked list, it has less functionality than Ammorth's
//*  LinkedList, but is considerably faster. Note only that most of
//*  the list methods have O(n) time complexity so they may not be
//*  suitable for operations on very large lists, however due to
//*  their simplicity the list would need to be really large for
//*  this to become a problem.
//*
//*  All stack methods are of course O(1) and as fast as possible.
//*  If you just need a stack, this is definitely the best choice.
//*
//*   set s=Stack.create()  - Instanceates a new Stack object.
//*   call s.destroy()      - Destroys the Stack.
//*
//*  Stack syntax:
//*   call s.push(123)      - Pushes the value 123 on the stack.
//*                           A stack may contain multiple
//*                           instances of the same value.
//*   set i=s.peek()        - Reads the top value of the stack
//*                           and stores it to the variable i.
//*   set i=s.pop()         - Removes the top value from the stack
//*                           and stores it to the variable i.
//*   s.peek()==Stack.EMPTY - Checks if the stack is empty.
//*
//*  List syntax:
//*   call s.add(123)       - Adds the value 123 to the list.
//*                           A list may contain multiple
//*                           instances of the same value.
//*   s.size                - The total number of values on the list.
//*   s.contains(123)       - Checks if the value 123 is on the list.
//*   set n=s.count(123)    - Stores the number of times the value
//*                           123 is on the list to the variable n.
//*   call s.remove(123)    - Removes one instance of the value 123
//*                           from the list. Returns false if
//*                           the value was not found on the list.
//*   call s.purge(123)     - Removes all instances of the value 123
//*                           from the list. Returns the number of
//*                           values that were removed.
//*   set i=s.first         - Reads the first value from the list
//*                           and stores it to the variable i.
//*   set i=s.random        - Reads a random value from the list
//*                           and stores it to the variable i.
//*   set s2=s.copy()       - Makes a copy of the list and stores
//*                           it to the variable s2.
//*   call s.enum(Func,b)   - Calls function Func for all values
//*                           on the list. The function must follow
//*                           the Enum function interface.
//*                           b is a boolean value, if it is true
//*                           then the values will be enumerated
//*                           top to bottom, if false then bottom
//*                           to top.
//*****************************************************************

//processed:     function interface Stack_Enum takes integer value returns nothing

        // Use a totally random number here, the more improbable someone uses it, the better.
        // This is the value that is returned by .pop and .peek methods and .first and .random operators when called on an empty stack.

        // End of calibration.

        
        function s__Stack_push takes integer this,integer i returns nothing
            // Get an index from the list of free indexes.
            local integer n=s__Stack_free
            set s__Stack_free=s__Stack_next[n]
            // Extend the list of free indexes if needed.
            if s__Stack_free == 0 then
                set s__Stack_free=n + 1
            endif
            // Store the value to the index.
            set s__Stack_value[n]=i
            // Add index to the top of the stack.
            set s__Stack_next[n]=s__Stack_top[this]
            set s__Stack_top[this]=n
            set s__Stack_size[this]=s__Stack_size[this] + 1
        endfunction
        function s__Stack_pop takes integer this returns integer
            // Get the top index of stack.
            local integer n=s__Stack_top[this]
            // Safety check in case a user pops an empty stack.
            if n == 0 then
                return s__Stack_EMPTY
            endif
            // Remove the top index from stack.
            set s__Stack_top[this]=s__Stack_next[n]
            set s__Stack_size[this]=s__Stack_size[this] - 1
            // Add the index to the list of free indexes.
            set s__Stack_next[n]=s__Stack_free
            set s__Stack_free=n
            // Return the value.
            return s__Stack_value[n]
        endfunction
        function s__Stack_peek takes integer this returns integer
            // Read the value of the top index.
            return s__Stack_value[s__Stack_top[this]]
        endfunction


        function s__Stack_add takes integer this,integer value returns nothing
            call s__Stack_push(this,value)
        endfunction
        function s__Stack_contains takes integer this,integer value returns boolean
            // Get the first index of the list.
            local integer i=s__Stack_top[this]
            // Search through the list.
            loop
                // Stop the search when the end of the list is reached.
                exitwhen i == 0
                // Stop the search if the value is found.
                if s__Stack_value[i] == value then
                    return true
                endif
                // Get the next index of the list.
                set i=s__Stack_next[i]
            endloop
            return false
        endfunction
        function s__Stack_count takes integer this,integer value returns integer
            local integer count=0
            // Get the first index of the list.
            local integer i=s__Stack_top[this]
            // Search through the list.
            loop
                // Stop the search when the end of the list is reached.
                exitwhen i == 0
                // Increase the count if the value is found.
                if s__Stack_value[i] == value then
                    set count=count + 1
                endif
                // Get the next index of the list.
                set i=s__Stack_next[i]
            endloop
            return count
        endfunction
        function s__Stack__get_first takes integer this returns integer
            return (s__Stack_value[s__Stack_top[(this)]]) // INLINED!!
        endfunction
        function s__Stack__get_random takes integer this returns integer
            local integer r=GetRandomInt(1, s__Stack_size[this])
            // Get the first index of the list.
            local integer i=s__Stack_top[this]
            // Loop through the list.
            loop
                // Stop the loop after a random amount of repeats.
                set r=r - 1
                exitwhen r == 0 or i == 0
                // Get the next index of the list.
                set i=s__Stack_next[i]
            endloop
            return s__Stack_value[i]
        endfunction
        function s__Stack_remove takes integer this,integer value returns boolean
            // Get the first index of the list.
            local integer i1=s__Stack_top[this]
            local integer i2
            // Check if the first index holds the value.
            if s__Stack_value[i1] == value then
                call s__Stack_pop(this)
                return true
            endif
            // Search through the rest of the list.
            loop
                set i2=s__Stack_next[i1]
                // Stop the search when the end of the list is reached.
                exitwhen i2 == 0
                // Check if the next index holds the value.
                if s__Stack_value[i2] == value then
                    // Remove the index from the stack.
                    set s__Stack_next[i1]=s__Stack_next[i2]
                    // Add the removed index to the list of free indexes.
                    set s__Stack_next[i2]=s__Stack_free
                    set s__Stack_free=i2
                    set s__Stack_size[this]=s__Stack_size[this] - 1
                    return true
                endif
                set i1=i2
            endloop
            return false
        endfunction
        function s__Stack_purge takes integer this,integer value returns integer
            local integer count=0
            local integer i1
            local integer i2
            // If the first index holds the value, pop it.
            loop
                // If the list is empty, return.
                if s__Stack_top[this] == 0 then
                    return count
                endif
                // Repeat until the first index doesn't hold the value.
                exitwhen s__Stack_value[s__Stack_top[this]] != value
                call s__Stack_pop(this)
                set count=count + 1
            endloop
            // Get the first index of the list.
            set i1=s__Stack_top[this]
            // Search through the rest of the list.
            loop
                set i2=s__Stack_next[i1]
                // Stop the search when the end of the list is reached.
                exitwhen i2 == 0
                // Check if the next index holds the value.
                if s__Stack_value[i2] == value then
                    // Remove the index from the stack.
                    set s__Stack_next[i1]=s__Stack_next[i2]
                    // Add the removed index to the list of free indexes.
                    set s__Stack_next[i2]=s__Stack_free
                    set s__Stack_free=i2
                    set s__Stack_size[this]=s__Stack_size[this] - 1
                    set count=count + 1
                else
                    set i1=i2
                endif
            endloop
            return count
        endfunction
        function s__Stack_enum takes integer this,integer f,boolean top2bottom returns nothing
            local integer array value
            // Get the first index of the list.
            local integer i1=s__Stack_top[this]
            local integer i2=0
            // Populate the array.
            loop
                exitwhen i1 == 0
                set value[i2]=s__Stack_value[i1]
                set i2=i2 + 1
                set i1=s__Stack_next[i1]
            endloop
            // Call the Enum function for each value in the array.
            set i1=i2 - 1
            loop
                exitwhen i2 == 0
                set i2=i2 - 1
                // Enumerate in which direction?
                if top2bottom then
                    call sc___prototype19_evaluate(f,value[i1 - i2])
                else
                    call sc___prototype19_evaluate(f,value[i2])
                endif
            endloop
        endfunction
        function s__Stack_copy takes integer this returns integer
            local integer that=s__Stack__allocate()
            // Get the first index of the list.
            local integer i1=s__Stack_top[this]
            local integer i2
            // Add a dummy index to the top of the new list.
            call s__Stack_push(that,0)
            set i2=s__Stack_top[that]
            loop
                exitwhen i1 == 0
                // Get an index from the list of free indexes and add it at the end of the list.
                set s__Stack_next[i2]=s__Stack_free
                set i2=s__Stack_next[i2]
                set s__Stack_free=s__Stack_next[i2]
                // Extend the list of free indexes if needed.
                if s__Stack_free == 0 then
                    set s__Stack_free=i2 + 1
                endif
                // Copy the value to the new index.
                set s__Stack_value[i2]=s__Stack_value[i1]
                set i1=s__Stack_next[i1]
            endloop
            // End the new list correctly.
            set s__Stack_next[i2]=0
            // Remove the dummy index.
            call s__Stack_pop(that)
            // Copy the size value to the new list.
            set s__Stack_size[that]=s__Stack_size[this]
            return that
        endfunction


        function s__Stack_onDestroy takes integer this returns nothing
            local integer n
            // Remove all remaining indexes from the stack.
            loop
                // Get the top index.
                set n=s__Stack_top[this]
                exitwhen n == 0
                // Remove it from the stack.
                set s__Stack_top[this]=s__Stack_next[n]
                // Add it to the list of free indexes.
                set s__Stack_next[n]=s__Stack_free
                set s__Stack_free=n
            endloop
        endfunction

//Generated destructor of Stack
function s__Stack_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__Stack_V[this]!=-1) then
        return
    endif
    call s__Stack_onDestroy(this)
    set si__Stack_V[this]=si__Stack_F
    set si__Stack_F=this
endfunction
        function s__Stack_onInit takes nothing returns nothing
            // Store the EMPTY value to index 0 to make .peek inline friendly.
            set s__Stack_value[0]=s__Stack_EMPTY
        endfunction

//library Stack ends
//library Table:
    
    
    function s__Table___dex__get_size takes nothing returns integer
        return Table___sizeK
    endfunction
    function s__Table___dex__get_list takes nothing returns integer
        return Table___listK
    endfunction
    
    function s__Table___handles_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___handles_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
    
    function s__Table___agents__setindex takes integer this,integer key,agent value returns nothing
        call SaveAgentHandle(Table___ht, this, key, value)
    endfunction
    
    
    
//Run these textmacros to include the entire hashtable API as wrappers.
//Don't be intimidated by the number of macros - Vexorian's map optimizer is
//supposed to kill functions which inline (all of these functions inline).
//textmacro instance: NEW_ARRAY_BASIC("Real", "Real", "real")
    function s__Table___reals__getindex takes integer this,integer key returns real
        return LoadReal(Table___ht, this, key)
    endfunction
    function s__Table___reals__setindex takes integer this,integer key,real value returns nothing
        call SaveReal(Table___ht, this, key, value)
    endfunction
    function s__Table___reals_has takes integer this,integer key returns boolean
        return HaveSavedReal(Table___ht, this, key)
    endfunction
    function s__Table___reals_remove takes integer this,integer key returns nothing
        call RemoveSavedReal(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY_BASIC("Real", "Real", "real")
//textmacro instance: NEW_ARRAY_BASIC("Boolean", "Boolean", "boolean")
    function s__Table___booleans__getindex takes integer this,integer key returns boolean
        return LoadBoolean(Table___ht, this, key)
    endfunction
    function s__Table___booleans__setindex takes integer this,integer key,boolean value returns nothing
        call SaveBoolean(Table___ht, this, key, value)
    endfunction
    function s__Table___booleans_has takes integer this,integer key returns boolean
        return HaveSavedBoolean(Table___ht, this, key)
    endfunction
    function s__Table___booleans_remove takes integer this,integer key returns nothing
        call RemoveSavedBoolean(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY_BASIC("Boolean", "Boolean", "boolean")
//textmacro instance: NEW_ARRAY_BASIC("String", "Str", "string")
    function s__Table___strings__getindex takes integer this,integer key returns string
        return LoadStr(Table___ht, this, key)
    endfunction
    function s__Table___strings__setindex takes integer this,integer key,string value returns nothing
        call SaveStr(Table___ht, this, key, value)
    endfunction
    function s__Table___strings_has takes integer this,integer key returns boolean
        return HaveSavedString(Table___ht, this, key)
    endfunction
    function s__Table___strings_remove takes integer this,integer key returns nothing
        call RemoveSavedString(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY_BASIC("String", "Str", "string")
//New textmacro to allow table.integer[] syntax for compatibility with textmacros that might desire it.
//textmacro instance: NEW_ARRAY_BASIC("Integer", "Integer", "integer")
    function s__Table___integers__getindex takes integer this,integer key returns integer
        return LoadInteger(Table___ht, this, key)
    endfunction
    function s__Table___integers__setindex takes integer this,integer key,integer value returns nothing
        call SaveInteger(Table___ht, this, key, value)
    endfunction
    function s__Table___integers_has takes integer this,integer key returns boolean
        return HaveSavedInteger(Table___ht, this, key)
    endfunction
    function s__Table___integers_remove takes integer this,integer key returns nothing
        call RemoveSavedInteger(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY_BASIC("Integer", "Integer", "integer")
    
//textmacro instance: NEW_ARRAY("Player", "player")
    function s__Table___players__getindex takes integer this,integer key returns player
        return LoadPlayerHandle(Table___ht, this, key)
    endfunction
    function s__Table___players__setindex takes integer this,integer key,player value returns nothing
        call SavePlayerHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___players_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___players_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("Player", "player")
//textmacro instance: NEW_ARRAY("Widget", "widget")
    function s__Table___widgets__getindex takes integer this,integer key returns widget
        return LoadWidgetHandle(Table___ht, this, key)
    endfunction
    function s__Table___widgets__setindex takes integer this,integer key,widget value returns nothing
        call SaveWidgetHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___widgets_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___widgets_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("Widget", "widget")
//textmacro instance: NEW_ARRAY("Destructable", "destructable")
    function s__Table___destructables__getindex takes integer this,integer key returns destructable
        return LoadDestructableHandle(Table___ht, this, key)
    endfunction
    function s__Table___destructables__setindex takes integer this,integer key,destructable value returns nothing
        call SaveDestructableHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___destructables_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___destructables_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("Destructable", "destructable")
//textmacro instance: NEW_ARRAY("Item", "item")
    function s__Table___items__getindex takes integer this,integer key returns item
        return LoadItemHandle(Table___ht, this, key)
    endfunction
    function s__Table___items__setindex takes integer this,integer key,item value returns nothing
        call SaveItemHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___items_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___items_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("Item", "item")
//textmacro instance: NEW_ARRAY("Unit", "unit")
    function s__Table___units__getindex takes integer this,integer key returns unit
        return LoadUnitHandle(Table___ht, this, key)
    endfunction
    function s__Table___units__setindex takes integer this,integer key,unit value returns nothing
        call SaveUnitHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___units_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___units_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("Unit", "unit")
//textmacro instance: NEW_ARRAY("Ability", "ability")
    function s__Table___abilitys__getindex takes integer this,integer key returns ability
        return LoadAbilityHandle(Table___ht, this, key)
    endfunction
    function s__Table___abilitys__setindex takes integer this,integer key,ability value returns nothing
        call SaveAbilityHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___abilitys_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___abilitys_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("Ability", "ability")
//textmacro instance: NEW_ARRAY("Timer", "timer")
    function s__Table___timers__getindex takes integer this,integer key returns timer
        return LoadTimerHandle(Table___ht, this, key)
    endfunction
    function s__Table___timers__setindex takes integer this,integer key,timer value returns nothing
        call SaveTimerHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___timers_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___timers_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("Timer", "timer")
//textmacro instance: NEW_ARRAY("Trigger", "trigger")
    function s__Table___triggers__getindex takes integer this,integer key returns trigger
        return LoadTriggerHandle(Table___ht, this, key)
    endfunction
    function s__Table___triggers__setindex takes integer this,integer key,trigger value returns nothing
        call SaveTriggerHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___triggers_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___triggers_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("Trigger", "trigger")
//textmacro instance: NEW_ARRAY("TriggerCondition", "triggercondition")
    function s__Table___triggerconditions__getindex takes integer this,integer key returns triggercondition
        return LoadTriggerConditionHandle(Table___ht, this, key)
    endfunction
    function s__Table___triggerconditions__setindex takes integer this,integer key,triggercondition value returns nothing
        call SaveTriggerConditionHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___triggerconditions_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___triggerconditions_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("TriggerCondition", "triggercondition")
//textmacro instance: NEW_ARRAY("TriggerAction", "triggeraction")
    function s__Table___triggeractions__getindex takes integer this,integer key returns triggeraction
        return LoadTriggerActionHandle(Table___ht, this, key)
    endfunction
    function s__Table___triggeractions__setindex takes integer this,integer key,triggeraction value returns nothing
        call SaveTriggerActionHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___triggeractions_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___triggeractions_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("TriggerAction", "triggeraction")
//textmacro instance: NEW_ARRAY("TriggerEvent", "event")
    function s__Table___events__getindex takes integer this,integer key returns event
        return LoadTriggerEventHandle(Table___ht, this, key)
    endfunction
    function s__Table___events__setindex takes integer this,integer key,event value returns nothing
        call SaveTriggerEventHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___events_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___events_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("TriggerEvent", "event")
//textmacro instance: NEW_ARRAY("Force", "force")
    function s__Table___forces__getindex takes integer this,integer key returns force
        return LoadForceHandle(Table___ht, this, key)
    endfunction
    function s__Table___forces__setindex takes integer this,integer key,force value returns nothing
        call SaveForceHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___forces_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___forces_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("Force", "force")
//textmacro instance: NEW_ARRAY("Group", "group")
    function s__Table___groups__getindex takes integer this,integer key returns group
        return LoadGroupHandle(Table___ht, this, key)
    endfunction
    function s__Table___groups__setindex takes integer this,integer key,group value returns nothing
        call SaveGroupHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___groups_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___groups_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("Group", "group")
//textmacro instance: NEW_ARRAY("Location", "location")
    function s__Table___locations__getindex takes integer this,integer key returns location
        return LoadLocationHandle(Table___ht, this, key)
    endfunction
    function s__Table___locations__setindex takes integer this,integer key,location value returns nothing
        call SaveLocationHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___locations_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___locations_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("Location", "location")
//textmacro instance: NEW_ARRAY("Rect", "rect")
    function s__Table___rects__getindex takes integer this,integer key returns rect
        return LoadRectHandle(Table___ht, this, key)
    endfunction
    function s__Table___rects__setindex takes integer this,integer key,rect value returns nothing
        call SaveRectHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___rects_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___rects_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("Rect", "rect")
//textmacro instance: NEW_ARRAY("BooleanExpr", "boolexpr")
    function s__Table___boolexprs__getindex takes integer this,integer key returns boolexpr
        return LoadBooleanExprHandle(Table___ht, this, key)
    endfunction
    function s__Table___boolexprs__setindex takes integer this,integer key,boolexpr value returns nothing
        call SaveBooleanExprHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___boolexprs_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___boolexprs_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("BooleanExpr", "boolexpr")
//textmacro instance: NEW_ARRAY("Sound", "sound")
    function s__Table___sounds__getindex takes integer this,integer key returns sound
        return LoadSoundHandle(Table___ht, this, key)
    endfunction
    function s__Table___sounds__setindex takes integer this,integer key,sound value returns nothing
        call SaveSoundHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___sounds_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___sounds_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("Sound", "sound")
//textmacro instance: NEW_ARRAY("Effect", "effect")
    function s__Table___effects__getindex takes integer this,integer key returns effect
        return LoadEffectHandle(Table___ht, this, key)
    endfunction
    function s__Table___effects__setindex takes integer this,integer key,effect value returns nothing
        call SaveEffectHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___effects_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___effects_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("Effect", "effect")
//textmacro instance: NEW_ARRAY("UnitPool", "unitpool")
    function s__Table___unitpools__getindex takes integer this,integer key returns unitpool
        return LoadUnitPoolHandle(Table___ht, this, key)
    endfunction
    function s__Table___unitpools__setindex takes integer this,integer key,unitpool value returns nothing
        call SaveUnitPoolHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___unitpools_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___unitpools_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("UnitPool", "unitpool")
//textmacro instance: NEW_ARRAY("ItemPool", "itempool")
    function s__Table___itempools__getindex takes integer this,integer key returns itempool
        return LoadItemPoolHandle(Table___ht, this, key)
    endfunction
    function s__Table___itempools__setindex takes integer this,integer key,itempool value returns nothing
        call SaveItemPoolHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___itempools_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___itempools_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("ItemPool", "itempool")
//textmacro instance: NEW_ARRAY("Quest", "quest")
    function s__Table___quests__getindex takes integer this,integer key returns quest
        return LoadQuestHandle(Table___ht, this, key)
    endfunction
    function s__Table___quests__setindex takes integer this,integer key,quest value returns nothing
        call SaveQuestHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___quests_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___quests_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("Quest", "quest")
//textmacro instance: NEW_ARRAY("QuestItem", "questitem")
    function s__Table___questitems__getindex takes integer this,integer key returns questitem
        return LoadQuestItemHandle(Table___ht, this, key)
    endfunction
    function s__Table___questitems__setindex takes integer this,integer key,questitem value returns nothing
        call SaveQuestItemHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___questitems_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___questitems_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("QuestItem", "questitem")
//textmacro instance: NEW_ARRAY("DefeatCondition", "defeatcondition")
    function s__Table___defeatconditions__getindex takes integer this,integer key returns defeatcondition
        return LoadDefeatConditionHandle(Table___ht, this, key)
    endfunction
    function s__Table___defeatconditions__setindex takes integer this,integer key,defeatcondition value returns nothing
        call SaveDefeatConditionHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___defeatconditions_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___defeatconditions_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("DefeatCondition", "defeatcondition")
//textmacro instance: NEW_ARRAY("TimerDialog", "timerdialog")
    function s__Table___timerdialogs__getindex takes integer this,integer key returns timerdialog
        return LoadTimerDialogHandle(Table___ht, this, key)
    endfunction
    function s__Table___timerdialogs__setindex takes integer this,integer key,timerdialog value returns nothing
        call SaveTimerDialogHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___timerdialogs_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___timerdialogs_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("TimerDialog", "timerdialog")
//textmacro instance: NEW_ARRAY("Leaderboard", "leaderboard")
    function s__Table___leaderboards__getindex takes integer this,integer key returns leaderboard
        return LoadLeaderboardHandle(Table___ht, this, key)
    endfunction
    function s__Table___leaderboards__setindex takes integer this,integer key,leaderboard value returns nothing
        call SaveLeaderboardHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___leaderboards_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___leaderboards_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("Leaderboard", "leaderboard")
//textmacro instance: NEW_ARRAY("Multiboard", "multiboard")
    function s__Table___multiboards__getindex takes integer this,integer key returns multiboard
        return LoadMultiboardHandle(Table___ht, this, key)
    endfunction
    function s__Table___multiboards__setindex takes integer this,integer key,multiboard value returns nothing
        call SaveMultiboardHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___multiboards_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___multiboards_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("Multiboard", "multiboard")
//textmacro instance: NEW_ARRAY("MultiboardItem", "multiboarditem")
    function s__Table___multiboarditems__getindex takes integer this,integer key returns multiboarditem
        return LoadMultiboardItemHandle(Table___ht, this, key)
    endfunction
    function s__Table___multiboarditems__setindex takes integer this,integer key,multiboarditem value returns nothing
        call SaveMultiboardItemHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___multiboarditems_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___multiboarditems_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("MultiboardItem", "multiboarditem")
//textmacro instance: NEW_ARRAY("Trackable", "trackable")
    function s__Table___trackables__getindex takes integer this,integer key returns trackable
        return LoadTrackableHandle(Table___ht, this, key)
    endfunction
    function s__Table___trackables__setindex takes integer this,integer key,trackable value returns nothing
        call SaveTrackableHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___trackables_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___trackables_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("Trackable", "trackable")
//textmacro instance: NEW_ARRAY("Dialog", "dialog")
    function s__Table___dialogs__getindex takes integer this,integer key returns dialog
        return LoadDialogHandle(Table___ht, this, key)
    endfunction
    function s__Table___dialogs__setindex takes integer this,integer key,dialog value returns nothing
        call SaveDialogHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___dialogs_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___dialogs_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("Dialog", "dialog")
//textmacro instance: NEW_ARRAY("Button", "button")
    function s__Table___buttons__getindex takes integer this,integer key returns button
        return LoadButtonHandle(Table___ht, this, key)
    endfunction
    function s__Table___buttons__setindex takes integer this,integer key,button value returns nothing
        call SaveButtonHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___buttons_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___buttons_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("Button", "button")
//textmacro instance: NEW_ARRAY("TextTag", "texttag")
    function s__Table___texttags__getindex takes integer this,integer key returns texttag
        return LoadTextTagHandle(Table___ht, this, key)
    endfunction
    function s__Table___texttags__setindex takes integer this,integer key,texttag value returns nothing
        call SaveTextTagHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___texttags_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___texttags_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("TextTag", "texttag")
//textmacro instance: NEW_ARRAY("Lightning", "lightning")
    function s__Table___lightnings__getindex takes integer this,integer key returns lightning
        return LoadLightningHandle(Table___ht, this, key)
    endfunction
    function s__Table___lightnings__setindex takes integer this,integer key,lightning value returns nothing
        call SaveLightningHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___lightnings_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___lightnings_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("Lightning", "lightning")
//textmacro instance: NEW_ARRAY("Image", "image")
    function s__Table___images__getindex takes integer this,integer key returns image
        return LoadImageHandle(Table___ht, this, key)
    endfunction
    function s__Table___images__setindex takes integer this,integer key,image value returns nothing
        call SaveImageHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___images_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___images_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("Image", "image")
//textmacro instance: NEW_ARRAY("Ubersplat", "ubersplat")
    function s__Table___ubersplats__getindex takes integer this,integer key returns ubersplat
        return LoadUbersplatHandle(Table___ht, this, key)
    endfunction
    function s__Table___ubersplats__setindex takes integer this,integer key,ubersplat value returns nothing
        call SaveUbersplatHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___ubersplats_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___ubersplats_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("Ubersplat", "ubersplat")
//textmacro instance: NEW_ARRAY("Region", "region")
    function s__Table___regions__getindex takes integer this,integer key returns region
        return LoadRegionHandle(Table___ht, this, key)
    endfunction
    function s__Table___regions__setindex takes integer this,integer key,region value returns nothing
        call SaveRegionHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___regions_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___regions_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("Region", "region")
//textmacro instance: NEW_ARRAY("FogState", "fogstate")
    function s__Table___fogstates__getindex takes integer this,integer key returns fogstate
        return LoadFogStateHandle(Table___ht, this, key)
    endfunction
    function s__Table___fogstates__setindex takes integer this,integer key,fogstate value returns nothing
        call SaveFogStateHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___fogstates_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___fogstates_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("FogState", "fogstate")
//textmacro instance: NEW_ARRAY("FogModifier", "fogmodifier")
    function s__Table___fogmodifiers__getindex takes integer this,integer key returns fogmodifier
        return LoadFogModifierHandle(Table___ht, this, key)
    endfunction
    function s__Table___fogmodifiers__setindex takes integer this,integer key,fogmodifier value returns nothing
        call SaveFogModifierHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___fogmodifiers_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___fogmodifiers_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("FogModifier", "fogmodifier")
//textmacro instance: NEW_ARRAY("Hashtable", "hashtable")
    function s__Table___hashtables__getindex takes integer this,integer key returns hashtable
        return LoadHashtableHandle(Table___ht, this, key)
    endfunction
    function s__Table___hashtables__setindex takes integer this,integer key,hashtable value returns nothing
        call SaveHashtableHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___hashtables_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___hashtables_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY("Hashtable", "hashtable")
    
    
    // Implement modules for intuitive syntax (tb.handle; tb.unit; etc.)
//Implemented from module Table___realm:
    function s__Table__get_real takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___integerm:
    function s__Table__get_integer takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___booleanm:
    function s__Table__get_boolean takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___stringm:
    function s__Table__get_string takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___playerm:
    function s__Table__get_player takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___widgetm:
    function s__Table__get_widget takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___destructablem:
    function s__Table__get_destructable takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___itemm:
    function s__Table__get_item takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___unitm:
    function s__Table__get_unit takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___abilitym:
    function s__Table__get_ability takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___timerm:
    function s__Table__get_timer takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___triggerm:
    function s__Table__get_trigger takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___triggerconditionm:
    function s__Table__get_triggercondition takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___triggeractionm:
    function s__Table__get_triggeraction takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___eventm:
    function s__Table__get_event takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___forcem:
    function s__Table__get_force takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___groupm:
    function s__Table__get_group takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___locationm:
    function s__Table__get_location takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___rectm:
    function s__Table__get_rect takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___boolexprm:
    function s__Table__get_boolexpr takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___soundm:
    function s__Table__get_sound takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___effectm:
    function s__Table__get_effect takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___unitpoolm:
    function s__Table__get_unitpool takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___itempoolm:
    function s__Table__get_itempool takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___questm:
    function s__Table__get_quest takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___questitemm:
    function s__Table__get_questitem takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___defeatconditionm:
    function s__Table__get_defeatcondition takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___timerdialogm:
    function s__Table__get_timerdialog takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___leaderboardm:
    function s__Table__get_leaderboard takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___multiboardm:
    function s__Table__get_multiboard takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___multiboarditemm:
    function s__Table__get_multiboarditem takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___trackablem:
    function s__Table__get_trackable takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___dialogm:
    function s__Table__get_dialog takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___buttonm:
    function s__Table__get_button takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___texttagm:
    function s__Table__get_texttag takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___lightningm:
    function s__Table__get_lightning takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___imagem:
    function s__Table__get_image takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___ubersplatm:
    function s__Table__get_ubersplat takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___regionm:
    function s__Table__get_region takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___fogstatem:
    function s__Table__get_fogstate takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___fogmodifierm:
    function s__Table__get_fogmodifier takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___hashtablem:
    function s__Table__get_hashtable takes integer this returns integer
        return this
    endfunction
    
    function s__Table__get_handle takes integer this returns integer
        return this
    endfunction
    
    function s__Table__get_agent takes integer this returns integer
        return this
    endfunction
    
    //set this = tb[GetSpellAbilityId()]
    function s__Table__getindex takes integer this,integer key returns integer
        return LoadInteger(Table___ht, this, key) //return this.integer[key]
    endfunction
    
    //set tb[389034] = 8192
    function s__Table__setindex takes integer this,integer key,integer tb returns nothing
        call SaveInteger(Table___ht, this, key, tb) //set this.integer[key] = tb
    endfunction
    
    //set b = tb.has(2493223)
    function s__Table_has takes integer this,integer key returns boolean
        return HaveSavedInteger(Table___ht, this, key) //return this.integer.has(key)
    endfunction
    
    //call tb.remove(294080)
    function s__Table_remove takes integer this,integer key returns nothing
        call RemoveSavedInteger(Table___ht, this, key) //call this.integer.remove(key)
    endfunction
    
    //Remove all data from a Table instance
    function s__Table_flush takes integer this returns nothing
        call FlushChildHashtable(Table___ht, this)
    endfunction
    
    //local Table tb = Table.create()
    function s__Table_create takes nothing returns integer
        local integer this= (LoadInteger(Table___ht, ((Table___listK)), (0))) // INLINED!!
        
        if this == 0 then
            set this=Table___more + 1
            set Table___more=this
        else
            call SaveInteger(Table___ht, ((Table___listK)), (0), ( (LoadInteger(Table___ht, ((Table___listK)), (this))))) // INLINED!!
            call RemoveSavedInteger(Table___ht, ((Table___listK)), (this)) //Clear hashed memory // INLINED!!
        endif
        
        return this
    endfunction
    
    // Removes all data from a Table instance and recycles its index.
    //
    //     call tb.destroy()
    //
    function s__Table_destroy takes integer this returns nothing
        
        call FlushChildHashtable(Table___ht, (this)) // INLINED!!
        
        call SaveInteger(Table___ht, ((Table___listK)), (this), ( (LoadInteger(Table___ht, ((Table___listK)), (0))))) // INLINED!!
        call SaveInteger(Table___ht, ((Table___listK)), (0), ( this)) // INLINED!!
    endfunction
    
//ignored textmacro command: TABLE_BC_METHODS()
    
//ignored textmacro command: TABLE_BC_STRUCTS()
    
    
    //Returns a new TableArray to do your bidding. Simply use:
    //
    //    local TableArray ta = TableArray[array_size]
    //
    function s__TableArray__staticgetindex takes integer array_size returns integer
        local integer tb= (LoadInteger(Table___ht, ((Table___sizeK)), (array_size))) // INLINED!!
        local integer this= (LoadInteger(Table___ht, (tb), (0))) // INLINED!!
        
        
        if this == 0 then
            set this=Table___less - array_size
            set Table___less=this
        else
            call SaveInteger(Table___ht, (tb), (0), ( (LoadInteger(Table___ht, (tb), (this))))) //Set the last destroyed to the last-last destroyed // INLINED!!
            call RemoveSavedInteger(Table___ht, (tb), (this)) //Clear hashed memory // INLINED!!
        endif
        
        call SaveInteger(Table___ht, ((Table___sizeK)), (this), ( array_size)) //This remembers the array size // INLINED!!
        return this
    endfunction
    
    //Returns the size of the TableArray
    function s__TableArray__get_size takes integer this returns integer
        return (LoadInteger(Table___ht, ((Table___sizeK)), (this))) // INLINED!!
    endfunction
    
    //This magic method enables two-dimensional[array][syntax] for Tables,
    //similar to the two-dimensional utility provided by hashtables them-
    //selves.
    //
    //ta[integer a].unit[integer b] = unit u
    //ta[integer a][integer c] = integer d
    //
    //Inline-friendly when not running in debug mode
    //
    function s__TableArray__getindex takes integer this,integer key returns integer










        return this + key
    endfunction
    
    //Destroys a TableArray without flushing it; I assume you call .flush()
    //if you want it flushed too. This is a public method so that you don't
    //have to loop through all TableArray indices to flush them if you don't
    //need to (ie. if you were flushing all child-keys as you used them).
    //
    function s__TableArray_destroy takes integer this returns nothing
        local integer tb= (LoadInteger(Table___ht, ((Table___sizeK)), ((LoadInteger(Table___ht, ((Table___sizeK)), ((this))))))) // INLINED!!
        
        
        if tb == 0 then
            //Create a Table to index recycled instances with their array size
            set tb=s__Table_create()
            call SaveInteger(Table___ht, ((Table___sizeK)), ((LoadInteger(Table___ht, ((Table___sizeK)), ((this))))), ( tb)) // INLINED!!
        endif
        
        call RemoveSavedInteger(Table___ht, ((Table___sizeK)), (this)) //Clear the array size from hash memory // INLINED!!
        
        call SaveInteger(Table___ht, (tb), (this), ( (LoadInteger(Table___ht, (tb), (0))))) // INLINED!!
        call SaveInteger(Table___ht, (tb), (0), ( this)) // INLINED!!
    endfunction
    
    
    //Avoids hitting the op limit
    function s__TableArray_clean takes nothing returns nothing
        local integer tb= s__TableArray_tempTable
        local integer end= tb + 0x1000
        if end < s__TableArray_tempEnd then
            set s__TableArray_tempTable=end
            call ForForce(bj_FORCE_PLAYER[0], function s__TableArray_clean)
        else
            set end=s__TableArray_tempEnd
        endif
        loop
            call FlushChildHashtable(Table___ht, (tb)) // INLINED!!
            set tb=tb + 1
            exitwhen tb == end
        endloop
    endfunction
    
    //Flushes the TableArray and also destroys it. Doesn't get any more
    //similar to the FlushParentHashtable native than this.
    //
    function s__TableArray_flush takes integer this returns nothing
        set s__TableArray_tempTable=this
        set s__TableArray_tempEnd=this + (LoadInteger(Table___ht, ((Table___sizeK)), ((this)))) // INLINED!!
        call ForForce(bj_FORCE_PLAYER[0], function s__TableArray_clean)
        call s__TableArray_destroy(this)
    endfunction
    
    
//NEW: Added in Table 4.0. A fairly simple struct but allows you to do more
//than that which was previously possible.

    //Enables myHash[parentKey][childKey] syntax.
    //Basically, it creates a Table in the place of the parent key if
    //it didn't already get created earlier.
    function s__HashTable__getindex takes integer this,integer index returns integer
        local integer t= (LoadInteger(Table___ht, ((this)), (index))) // INLINED!!
        if t == 0 then
            set t=s__Table_create()
            call SaveInteger(Table___ht, ((this)), (index), ( t)) //whoops! Forgot that line. I'm out of practice! // INLINED!!
        endif
        return t
    endfunction

    //You need to call this on each parent key that you used if you
    //intend to destroy the HashTable or simply no longer need that key.
    function s__HashTable_remove takes integer this,integer index returns nothing
        local integer t= (LoadInteger(Table___ht, ((this)), (index))) // INLINED!!
        if t != 0 then
            call s__Table_destroy(t)
            call RemoveSavedInteger(Table___ht, ((this)), (index)) // INLINED!!
        endif
    endfunction
    
    //Added in version 4.1
    function s__HashTable_has takes integer this,integer index returns boolean
        return (HaveSavedInteger(Table___ht, ((this)), (index))) // INLINED!!
    endfunction
    
    //HashTables are just fancy Table indices.
    function s__HashTable_destroy takes integer this returns nothing
        call s__Table_destroy((this))
    endfunction
    
    //Like I said above...
    function s__HashTable_create takes nothing returns integer
        return s__Table_create()
    endfunction



//library Table ends
//library TimerUtils:
//*********************************************************************
//* TimerUtils (red+blue+orange flavors for 1.24b+) 2.0
//* ----------
//*
//*  To implement it , create a custom text trigger called TimerUtils
//* and paste the contents of this script there.
//*
//*  To copy from a map to another, copy the trigger holding this
//* library to your map.
//*
//* (requires vJass)   More scripts: htt://www.wc3c.net
//*
//* For your timer needs:
//*  * Attaching
//*  * Recycling (with double-free protection)
//*
//* set t=NewTimer()      : Get a timer (alternative to CreateTimer)
//* set t=NewTimerEx(x)   : Get a timer (alternative to CreateTimer), call
//*                            Initialize timer data as x, instead of 0.
//*
//* ReleaseTimer(t)       : Relese a timer (alt to DestroyTimer)
//* SetTimerData(t,2)     : Attach value 2 to timer
//* GetTimerData(t)       : Get the timer's value.
//*                         You can assume a timer's value is 0
//*                         after NewTimer.
//*
//* Multi-flavor:
//*    Set USE_HASH_TABLE to true if you don't want to complicate your life.
//*
//* If you like speed and giberish try learning about the other flavors.
//*
//********************************************************************

//================================================================

    //==================================================================================================
    
    

    //It is dependent on jasshelper's recent inlining optimization in order to perform correctly.
    function SetTimerData takes timer t,integer value returns nothing

            // new blue
            call SaveInteger(TimerUtils___ht, 0, GetHandleId(t), value)
            

















    endfunction

    function GetTimerData takes timer t returns integer

            // new blue
            return LoadInteger(TimerUtils___ht, 0, GetHandleId(t))
            

















    endfunction

    //==========================================================================================

    //==========================================================================================
    // I needed to decide between duplicating code ignoring the "Once and only once" rule
    // and using the ugly textmacros. I guess textmacros won.
    //

    function NewTimerEx takes integer value returns timer
        if ( TimerUtils___tN == 0 ) then
            if ( not TimerUtils___didinit ) then
                //This extra if shouldn't represent a major performance drawback
                //because QUANTITY rule is not supposed to be broken every day. 
                call TriggerEvaluate(st___prototype8[(1)]) // INLINED!!
                set TimerUtils___tN=TimerUtils___tN - 1
            else
                //If this happens then the QUANTITY rule has already been broken, try to fix the
                // issue, else fail.
                set s__TimerUtils___tT[0]= CreateTimer()















            endif
        else
            set TimerUtils___tN=TimerUtils___tN - 1
        endif
        call SaveInteger(TimerUtils___ht, 0, GetHandleId((s__TimerUtils___tT[TimerUtils___tN] )), ( value)) // INLINED!!
     return s__TimerUtils___tT[TimerUtils___tN]
    endfunction
    
    function NewTimer takes nothing returns timer
        return NewTimerEx(0)
    endfunction


    //==========================================================================================
    function ReleaseTimer takes timer t returns nothing
        if ( t == null ) then
            return
        endif
        if ( TimerUtils___tN == TimerUtils___ARRAY_SIZE ) then
            //stack is full, the map already has much more troubles than the chance of bug
            call DestroyTimer(t)
        else
            call PauseTimer(t)
            if ( (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) == TimerUtils___HELD ) then // INLINED!!
                return
            endif
            call SaveInteger(TimerUtils___ht, 0, GetHandleId((t )), ( TimerUtils___HELD)) // INLINED!!
            set s__TimerUtils___tT[TimerUtils___tN]= t
            set TimerUtils___tN=TimerUtils___tN + 1
        endif
    endfunction

    function TimerUtils___init takes nothing returns nothing
     local integer i=0
     local integer o=- 1
     local boolean oops= false
        if ( TimerUtils___didinit ) then
            return
        else
            set TimerUtils___didinit=true
        endif
     

            set TimerUtils___ht=InitHashtable()
            loop
                exitwhen ( i == TimerUtils___QUANTITY )
                set s__TimerUtils___tT[i]= CreateTimer()
                call SaveInteger(TimerUtils___ht, 0, GetHandleId((s__TimerUtils___tT[i] )), ( TimerUtils___HELD)) // INLINED!!
                set i=i + 1
            endloop
            set TimerUtils___tN=TimerUtils___QUANTITY










































    endfunction


//library TimerUtils ends
//library UnitDefaultRadius:
 function GetUnitDefaultRadius takes integer unitTypeID returns real
		if unitTypeID == MAZER then
			return 18.
		elseif unitTypeID == PLATFORMERWISP then
			return 14.
		elseif unitTypeID == TEAM_REVIVE_UNIT_ID then
			return 80.
		elseif unitTypeID == LGUARD or unitTypeID == GUARD then
			return 21.
		elseif unitTypeID == ICETROLL then
			return 40.
		elseif unitTypeID == SPIRITWALKER then
			return 42.
		elseif unitTypeID == CLAWMAN then
			return 50.
		elseif unitTypeID == REGRET then
			return 24.
		elseif unitTypeID == LMEMORY then
			return 39.
		elseif unitTypeID == GUILT then
			return 92.
		elseif unitTypeID == GREENFROG or unitTypeID == ORANGEFROG or unitTypeID == PURPLEFROG or unitTypeID == TURQOISEFROG or unitTypeID == REDFROG then
			return 32.
		elseif sc__InWorldPowerup_IsPowerupUnit(unitTypeID) then
			return 47.
		elseif unitTypeID == WWWISP then
			return 19.
		elseif unitTypeID == WWSKUL then
			return 20.
		elseif unitTypeID == KEYR then
			return 128.
		elseif unitTypeID == RKEY then
			return 65.
		elseif unitTypeID == RFIRE then
			//standard GameLoop defines max flex distance as 32 from edge, so use: theoretical glitchless kill radius = [terrain radius] + [terrain flex] = 64 + 32 = 96
			//theoretical because collision runs periodically, so add in a safety margin of 4 units to compensate somewhat
			//practical kill radius = 100, default mazer radius = 18 -> fire radius = 100 - 18 = 82
			return 82.
		elseif unitTypeID == BKEY then
			return 65.
		elseif unitTypeID == BFIRE then
			return 82.
		elseif unitTypeID == GKEY then
			return 65.
		elseif unitTypeID == GFIRE then
			return 82.
		elseif unitTypeID == BLACKHOLE then
			return 96.
		elseif unitTypeID == GRAVITY then
			return 45.
		elseif unitTypeID == BOUNCER then
			return 40.
		elseif unitTypeID == UBOUNCE or unitTypeID == DBOUNCE or unitTypeID == RBOUNCE or unitTypeID == LBOUNCE then
			return 35.
		elseif unitTypeID == SUPERSPEED then
			return 85.
		elseif unitTypeID == TELEPORT then
			return 78.
		else
			return 0.
		endif
	endfunction

//library UnitDefaultRadius ends
//library UnitGlobals:

//library UnitGlobals ends
//library Vector2:
//*****************************************************************
//*  VECTOR LIBRARY
//*
//*  written by: Anitarf
//*  re-written in 2d by: Serenity09
//*
//*  The library contains a struct named vector, which represents a
//*  point in 2D space. As such, it has three real members, one for
//*  each coordinate: x, y, z. It also has the following methods:
//*
//*        static method create takes real x, real y, real z returns vector
//*  Creates a new vector with the given coordinates.
//*
//*        method getLength takes nothing returns real
//*  Returns the length of the vector it is called on.
//*
//*        static method sum takes vector augend, vector addend returns vector
//*  Returns the sum of two vectors as a new vector.
//*
//*        method add takes vector addend returns nothing
//*  Similar to sum, except that it doesn't create a new vector for the result,
//*  but changes the vector it is called on by adding the "added" to it.
//*
//*        static method difference takes vector minuend, vector subtrahend returns vector
//*  Returns the difference between two vectors as a new vector.
//*
//*        method subtract takes vector subtrahend returns nothing
//*  Similar to difference, except that it doesn't create a new vector for the result,
//*  but changes the vector it is called on by subtracting the "subtrahend" from it.
//*
//*        method scale takes real factor returns nothing
//*  Scales the vector it is called on by the given factor.
//*
//*        method setLength takes real length returns nothing
//*  Sets the length of the vector it is called on to the given value, maintaining its orientation.
//*
//*        static method dotProduct takes vector a, vector b returns real
//*  Calculates the dot product (also called scalar product) of two vectors.
//*
//*        static method projectionVector takes vector projected, vector direction returns vector
//*  Calculates the projection of the vector "projected" onto the vector "direction"
//*  and returns it as a new vector.
//*  Returns null if the vector "direction" has a length of 0.
//*
//*        method projectVector takes vector direction returns nothing
//*  Projects the vector it is called on onto the vector "direction".
//*  Does nothing if the vector "direction" has a length of 0.
//*
//*        static method getAngle takes vector a, vector b returns real
//*  Returns the angle between two vectors, in radians, returns a value between 0 and pi.
//*  Returns 0.0 if any of the vectors are 0 units long.
//*
//*        method rotate takes vector axis, real angle returns nothing
//*  Rotates the vector it is called on around the axis defined by the vector "axis"
//*  by the given angle, which should be input in radians.
//*  Does nothing if axis is 0 units long.
//*
//*****************************************************************

        
//Implemented from module Alloc:
		
		

			

		
		
  function s__vector2_allocate takes nothing returns integer
   local integer this= s__vector2_Alloc___recycler[0]
			


			
			if ( s__vector2_Alloc___recycler[this] == 0 ) then
				set s__vector2_Alloc___recycler[0]=this + 1
			else
				set s__vector2_Alloc___recycler[0]=s__vector2_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__vector2_deallocate takes integer this returns nothing


			


			
			set s__vector2_Alloc___recycler[this]=s__vector2_Alloc___recycler[0]
			set s__vector2_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__vector2_Alloc___onInit takes nothing returns nothing
			set s__vector2_Alloc___recycler[0]=1
  endfunction
        
        function s__vector2_create takes real x,real y returns integer
            local integer v= s__vector2_allocate()
            
            set s__vector2_x[v]=x
            set s__vector2_y[v]=y
			//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Created vector2, current usage" + I2S(.calculateMemoryUsage()))
            return v
        endfunction
  function s__vector2_createFromRect takes rect r returns integer
			return s__vector2_create(GetRectCenterX(r) , GetRectCenterY(r))
  endfunction
        
        function s__vector2_destroy takes integer this returns nothing
            //add to recycle stack
            call s__vector2_deallocate(this)
			//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Destroyed vector2, current usage" + I2S(.calculateMemoryUsage()))
        endfunction
        
        function s__vector2_getLength takes integer this returns real
          return SquareRoot(s__vector2_x[this] * s__vector2_x[this] + s__vector2_y[this] * s__vector2_y[this])
        endfunction
        
        function s__vector2_add takes integer this,integer addend returns nothing
            set s__vector2_x[this]=s__vector2_x[this] + s__vector2_x[addend]
            set s__vector2_y[this]=s__vector2_y[this] + s__vector2_y[addend]
        endfunction
        
        function s__vector2_subtract takes integer this,integer subtrahend returns nothing
            set s__vector2_x[this]=s__vector2_x[this] - s__vector2_x[subtrahend]
            set s__vector2_y[this]=s__vector2_y[this] - s__vector2_y[subtrahend]
        endfunction
        
        function s__vector2_scale takes integer this,real factor returns nothing
            set s__vector2_x[this]=s__vector2_x[this] * factor
            set s__vector2_y[this]=s__vector2_y[this] * factor
        endfunction
        
        function s__vector2_setLength takes integer this,real length returns nothing
            local real l= SquareRoot(s__vector2_x[this] * s__vector2_x[this] + s__vector2_y[this] * s__vector2_y[this])





            set l=length / l
            set s__vector2_x[this]=s__vector2_x[this] * l
            set s__vector2_y[this]=s__vector2_y[this] * l
        endfunction
        
        function s__vector2_toString takes integer this returns string
            return R2S(s__vector2_x[this]) + "," + R2S(s__vector2_y[this])
        endfunction
  function s__vector2_fromString takes string s returns integer
   local integer v= s__vector2_allocate()
   local integer length= StringLength(s)
   local integer position= - 1
   local integer mid= length / 2
   local integer i= 0
			
			loop
			exitwhen mid + i > length or position != - 1
				if mid + i + 1 < length and SubString(s, mid + i, mid + i + 1) == "," then
					set position=mid + i
				elseif mid - i - 1 >= 0 and SubString(s, mid - i - 1, mid - i) == "," then
					set position=mid - i - 1
				endif
			set i=i + 1
			endloop
			
			// call BJDebugMsg("Position starting up: " + SubString(s, position, position + 1) + ", down" + SubString(s, position - 1, position))
			// call BJDebugMsg("First part: " + SubString(s, 0, position) + ", second part: " + SubString(s, position + 1, length))
			
			set s__vector2_x[v]=S2R(SubString(s, 0, position))
			set s__vector2_y[v]=S2R(SubString(s, position + 1, length))
			
			return v
  endfunction
        
        function s__vector2_dotProduct takes integer a,integer b returns real
            return ( s__vector2_x[a] * s__vector2_x[b] + s__vector2_y[a] * s__vector2_y[b] )
        endfunction
		
  function s__vector2_getAngleHorizontal takes integer this returns real
			return Atan2(s__vector2_y[this], s__vector2_x[this])
  endfunction
		
// ================================================================
        function s__vector2_projectVector takes integer this,integer direction returns nothing
            local real l= s__vector2_x[direction] * s__vector2_x[direction] + s__vector2_y[direction] * s__vector2_y[direction]





            set l=( s__vector2_x[this] * s__vector2_x[direction] + s__vector2_y[this] * s__vector2_y[direction] ) / l
            set s__vector2_x[this]=s__vector2_x[direction] * l
            set s__vector2_y[this]=s__vector2_y[direction] * l
        endfunction
        function s__vector2_projectUnitVector takes integer this,integer unitDirection returns nothing
            local real l
            
            set l=s__vector2_x[this] * s__vector2_x[unitDirection] + s__vector2_y[this] * s__vector2_y[unitDirection]
            set s__vector2_x[this]=s__vector2_x[unitDirection] * l
            set s__vector2_y[this]=s__vector2_y[unitDirection] * l
        endfunction
		
  function s__vector2_unitInDirection takes real direction returns integer
			return s__vector2_create(Cos(direction) , Sin(direction))
  endfunction
        function s__vector2_getAngle takes integer a,integer b returns real
            local real l= SquareRoot(s__vector2_x[a] * s__vector2_x[a] + s__vector2_y[a] * s__vector2_y[a]) * SquareRoot(s__vector2_x[b] * s__vector2_x[b] + s__vector2_y[b] * s__vector2_y[b])





            return Acos(( s__vector2_x[a] * s__vector2_x[b] + s__vector2_y[a] * s__vector2_y[b] ) / l) //angle is returned in radians
        endfunction

//library Vector2 ends
//library locust:

//adds flexible locust to unit u
function AddUnitLocust takes unit u returns nothing
    call UnitAddAbility(u, 'Aloc')
    call ShowUnit(u, false)
    call UnitRemoveAbility(u, 'Aloc')
    call ShowUnit(u, true)
endfunction

//adds flexible locust to last created unit
function AddLastUnitLocust takes nothing returns nothing
    call UnitAddAbility(bj_lastCreatedUnit, 'Aloc')
    call ShowUnit(bj_lastCreatedUnit, false)
    call UnitRemoveAbility(bj_lastCreatedUnit, 'Aloc')
    call ShowUnit(bj_lastCreatedUnit, true)
endfunction

//Will show dead hidden heroes
function AddEnumLocust takes nothing returns nothing
    local unit u= GetEnumUnit()
    
    call UnitAddAbility(u, 'Aloc')
    call ShowUnit(u, false)
    call UnitRemoveAbility(u, 'Aloc')
    call ShowUnit(u, true)
    
    set u=null
endfunction

function AddLocustAll takes nothing returns nothing
    //local group units = CreateGroup()
    
    call GroupEnumUnitsInRect(TempGroup, bj_mapInitialPlayableArea, NotMazer)
    call ForGroup(TempGroup, function AddEnumLocust)
      
    call GroupClear(TempGroup)
    //call DestroyGroup(units)
    //set units = null
endfunction


//library locust ends
//library ContinueGlobals:

//library ContinueGlobals ends
//library GameModesGlobals:

//library GameModesGlobals ends
//library GetUnitCollision:
    
    function GetUnitCollision__C takes unit u,real x,real y,integer i returns real
        local real l= 0
        local real h= 300
        local real m= 150
        
        loop
            if ( IsUnitInRangeXY(u, x + m, y, 0) ) then
                set l=m
            else
                set h=m
            endif
            set m=( l + h ) / 2
            exitwhen l + .01 > h
        endloop
        
        set m=R2I(( m + .005 ) * 100) / 100.
        
        call SaveReal(Table___ht, (((GetUnitCollision__uc))), (i), (( m)*1.0)) // INLINED!!
        
        return m
    endfunction
    function GetUnitCollision takes unit u returns real
        local integer i= GetUnitTypeId(u)
        
        if ( (HaveSavedReal(Table___ht, (((GetUnitCollision__uc))), (i))) ) then // INLINED!!
            return (LoadReal(Table___ht, (((GetUnitCollision__uc))), (i))) // INLINED!!
        endif
        
        return GetUnitCollision__C(u , GetUnitX(u) , GetUnitY(u) , i)
    endfunction
    
    
//Implemented from module GetUnitCollision__Initializer:
        function s__GetUnitCollision__init_GetUnitCollision__Initializer___onInit takes nothing returns nothing
            set GetUnitCollision__uc=s__Table_create()
        endfunction

//library GetUnitCollision ends
//library IndexedUnit:
		
		
						
//Implemented from module Alloc:
		
		

			

		
		
  function s__IndexedUnit_allocate takes nothing returns integer
   local integer this= s__IndexedUnit_Alloc___recycler[0]
			


			
			if ( s__IndexedUnit_Alloc___recycler[this] == 0 ) then
				set s__IndexedUnit_Alloc___recycler[0]=this + 1
			else
				set s__IndexedUnit_Alloc___recycler[0]=s__IndexedUnit_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__IndexedUnit_deallocate takes integer this returns nothing


			


			
			set s__IndexedUnit_Alloc___recycler[this]=s__IndexedUnit_Alloc___recycler[0]
			set s__IndexedUnit_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__IndexedUnit_Alloc___onInit takes nothing returns nothing
			set s__IndexedUnit_Alloc___recycler[0]=1
  endfunction
		
  function s__IndexedUnit__staticgetindex takes unit u returns integer
			return GetUnitUserData(u)
  endfunction
  function s__IndexedUnit_create takes unit u returns integer
   local integer unitTypeID= GetUnitTypeId(u)
   local integer rand
			











    local integer new= s__IndexedUnit_allocate()

			
			set s__IndexedUnit_Unit[new]=u
			call SetUnitUserData(u, new)
			
			//set properties that will be used for any indexed unit
			//set new.MoveSpeed = GetUnitMoveSpeed(u)
			set s__IndexedUnit_Collideable[new]=unitTypeID != MAZER and unitTypeID != PLATFORMERWISP and unitTypeID != GREENFROG and unitTypeID != ORANGEFROG and unitTypeID != PURPLEFROG and unitTypeID != TURQOISEFROG and unitTypeID != REDFROG and unitTypeID != SMLTARG and unitTypeID != BLACKHOLE
			set s__IndexedUnit_RectangularGeometry[new]=unitTypeID == TANK or unitTypeID == TRUCK or unitTypeID == FIRETRUCK or unitTypeID == AMBULANCE or unitTypeID == JEEP or unitTypeID == PASSENGERCAR or unitTypeID == CORVETTE or unitTypeID == POLICECAR
			if not s__IndexedUnit_RectangularGeometry[new] then
				set s__IndexedUnit_Radius[new]=GetUnitDefaultRadius(unitTypeID)
				set s__IndexedUnit_Scale[new]=1.
			endif
			
			if unitTypeID == PASSENGERCAR then
				//equal weights per color
				set rand=GetRandomInt(0, 4)
				
				if rand == 0 then
					call SetUnitColor(s__IndexedUnit_Unit[new], PLAYER_COLOR_CYAN)
				elseif rand == 1 then
					call SetUnitColor(s__IndexedUnit_Unit[new], PLAYER_COLOR_YELLOW)
				elseif rand == 2 then
					call SetUnitColor(s__IndexedUnit_Unit[new], PLAYER_COLOR_LIGHT_BLUE)
				elseif rand == 3 then
					call SetUnitColor(s__IndexedUnit_Unit[new], PLAYER_COLOR_MINT)
				else
					call SetUnitColor(s__IndexedUnit_Unit[new], PLAYER_COLOR_LAVENDER)
				endif
			elseif unitTypeID == CORVETTE then
				set rand=GetRandomInt(0, 30)
				
				if rand < 10 then
					call SetUnitColor(s__IndexedUnit_Unit[new], PLAYER_COLOR_RED)
				elseif rand < 15 then
					call SetUnitColor(s__IndexedUnit_Unit[new], PLAYER_COLOR_ORANGE)
				elseif rand < 25 then
					call SetUnitColor(s__IndexedUnit_Unit[new], PLAYER_COLOR_LIGHT_BLUE)
				else
					call SetUnitColor(s__IndexedUnit_Unit[new], PLAYER_COLOR_LAVENDER)
				endif
			elseif unitTypeID == TRUCK then
				set rand=GetRandomInt(0, 10)
				
				if rand == 0 then
					call SetUnitColor(s__IndexedUnit_Unit[new], PLAYER_COLOR_RED)
				else
					call SetUnitColor(s__IndexedUnit_Unit[new], PLAYER_COLOR_AQUA)
				endif
			endif
			
			//defaults
			set s__IndexedUnit_R[new]=- 1
			set s__IndexedUnit_MoveSpeed[new]=- 1
			
			return new
  endfunction
		
  function s__IndexedUnit_SetScale takes integer this,real scale returns nothing





			
			//update related properties. TODO consider supporting scale on rectangular geomtries in the future
			if not s__IndexedUnit_RectangularGeometry[this] then
				set s__IndexedUnit_Radius[this]=s__IndexedUnit_Radius[this] * scale / s__IndexedUnit_Scale[this]
			endif
			
			set s__IndexedUnit_Scale[this]=scale
			call SetUnitScale(s__IndexedUnit_Unit[this], scale, scale, scale)
  endfunction
		
  function s__IndexedUnit_GetMoveSpeed takes integer this returns real
			if s__IndexedUnit_MoveSpeed[this] != - 1 then
				return s__IndexedUnit_MoveSpeed[this]
			else
				return GetUnitDefaultMoveSpeed(s__IndexedUnit_Unit[this])
			endif
  endfunction
  function s__IndexedUnit_UpdateMoveSpeed takes integer this returns nothing
			set s__IndexedUnit_MoveSpeed[this]=GetUnitMoveSpeed(s__IndexedUnit_Unit[this])
  endfunction
  function s__IndexedUnit_SetMoveSpeed takes integer this,real movespeed returns nothing
			set s__IndexedUnit_MoveSpeed[this]=movespeed
			call SetUnitMoveSpeed(s__IndexedUnit_Unit[this], movespeed)
  endfunction
		
		//NOT safe to call for GetLocalPlayer
  function s__IndexedUnit_InitializeVertexColor takes integer this returns nothing
   local integer unitTypeID= GetUnitTypeId(s__IndexedUnit_Unit[this])
			
			if unitTypeID == REDFROG then
				set s__IndexedUnit_R[this]=255
				set s__IndexedUnit_G[this]=3
				set s__IndexedUnit_B[this]=3
			// elseif unitTypeID == GREENFROG then
				// set this.R = 255
				// set this.G = 255
				// set this.B = 255
			elseif unitTypeID == PURPLEFROG then
				set s__IndexedUnit_R[this]=190
				set s__IndexedUnit_G[this]=0
				set s__IndexedUnit_B[this]=254
			elseif unitTypeID == ORANGEFROG then
				set s__IndexedUnit_R[this]=254
				set s__IndexedUnit_G[this]=65
				set s__IndexedUnit_B[this]=14
			elseif unitTypeID == TURQOISEFROG then
				set s__IndexedUnit_R[this]=0
				set s__IndexedUnit_G[this]=184
				set s__IndexedUnit_B[this]=255
			else
				set s__IndexedUnit_R[this]=255
				set s__IndexedUnit_G[this]=255
				set s__IndexedUnit_B[this]=255
			endif
			
			set s__IndexedUnit_A[this]=255
  endfunction
  function s__IndexedUnit_SetVertexColor takes integer this,integer r,integer g,integer b,integer a returns nothing
			set s__IndexedUnit_R[this]=r
			set s__IndexedUnit_G[this]=g
			set s__IndexedUnit_B[this]=b
			set s__IndexedUnit_A[this]=a
			
			call SetUnitVertexColor(s__IndexedUnit_Unit[this], r, g, b, a)
  endfunction
  function s__IndexedUnit_SetColor takes integer this,integer r,integer g,integer b returns nothing
			set s__IndexedUnit_R[this]=r
			set s__IndexedUnit_G[this]=g
			set s__IndexedUnit_B[this]=b
			
			call SetUnitVertexColor(s__IndexedUnit_Unit[this], r, g, b, s__IndexedUnit_A[this])
  endfunction
  function s__IndexedUnit_SetAlpha takes integer this,integer a returns nothing
			set s__IndexedUnit_A[this]=a
			
			call SetUnitVertexColor(s__IndexedUnit_Unit[this], s__IndexedUnit_R[this], s__IndexedUnit_G[this], s__IndexedUnit_B[this], a)
  endfunction
		//the only colorization method that is safe to call in a local player block
  function s__IndexedUnit_SetAlphaLocal takes integer this,integer a returns nothing
			call SetUnitVertexColor(s__IndexedUnit_Unit[this], s__IndexedUnit_R[this], s__IndexedUnit_G[this], s__IndexedUnit_B[this], a)
  endfunction
		
  function s__IndexedUnit_destroy takes integer this returns nothing
			call SetUnitUserData(s__IndexedUnit_Unit[this], 0)
			set s__IndexedUnit_Unit[this]=null
			
			call s__IndexedUnit_deallocate(this)
  endfunction

//library IndexedUnit ends
//library MemoryAnalysis:
	




































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































	
	
	

//library MemoryAnalysis ends
//library PatternSpawn:
	
//processed: 	function interface IPatternSpawn takes PatternSpawn spawn, Levels_Level parentLevel returns group
	
		
		//assumes every variation has the same number of cycles
		
		
		
  function s__PatternSpawn_GetVariation takes integer this returns integer
			return s__PatternSpawn_CurrentCycle[this] / s__PatternSpawn_CycleCount[this]
  endfunction
  function s__PatternSpawn_GetCycle takes integer this,integer variation returns integer
			return s__PatternSpawn_CurrentCycle[this] - variation * s__PatternSpawn_CycleCount[this]
  endfunction
		
  function s__PatternSpawn_Spawn takes integer this,integer parentLevel returns group
			if ( s__PatternSpawn_CycleVariations[this] == 1 and s__PatternSpawn_CurrentCycle[this] + 1 == s__PatternSpawn_CycleCount[this] ) or ( s__PatternSpawn_CycleVariations[this] != 1 and ModuloInteger(s__PatternSpawn_CurrentCycle[this] + 1, s__PatternSpawn_CycleCount[this]) == 0 ) then
				if s__PatternSpawn_CycleVariations[this] == 1 then
					set s__PatternSpawn_CurrentCycle[this]=0
				else
					set s__PatternSpawn_CurrentCycle[this]=GetRandomInt(0, s__PatternSpawn_CycleVariations[this] - 1) * s__PatternSpawn_CycleCount[this]
				endif
			else
				set s__PatternSpawn_CurrentCycle[this]=s__PatternSpawn_CurrentCycle[this] + 1
			endif
			


			
			return sc___prototype29_evaluate(s__PatternSpawn_SpawnCB[this],this , parentLevel)
  endfunction
		
  function s__PatternSpawn_Reset takes integer this returns nothing
			set s__PatternSpawn_CurrentCycle[this]=s__PatternSpawn_CycleCount[this] - 1
  endfunction
		
  function s__PatternSpawn_create takes integer spawnCB,integer cycleCount returns integer
   local integer new= s__PatternSpawn_c
			set s__PatternSpawn_c=s__PatternSpawn_c + 1
			
			set s__PatternSpawn_SpawnCB[new]=spawnCB
			set s__PatternSpawn_CycleCount[new]=cycleCount
			
			set s__PatternSpawn_Data[new]=0
			set s__PatternSpawn_CurrentCycle[new]=s__PatternSpawn_CycleCount[new] - 1
			set s__PatternSpawn_CycleVariations[new]=1
			
			return new
  endfunction
	
	
	
				
		
  function s__LinePatternSpawn_GetSpawnPositionCount takes integer this returns integer
			return R2I(s__LinePatternSpawn_SpawnLineLength[this] / s__LinePatternSpawn_SpawnOffset[this])
  endfunction
  function s__LinePatternSpawn_GetSpawnPosition takes integer this,integer spawnIndex returns integer
			return s__vector2_create(s__vector2_x[s__LinePatternSpawn_SpawnOrigin[this]] + Cos(s__LinePatternSpawn_SpawnLineAngle[this] * bj_DEGTORAD) * ( .5 * s__LinePatternSpawn_SpawnOffset[this] + s__LinePatternSpawn_SpawnOffset[this] * spawnIndex ) , s__vector2_y[s__LinePatternSpawn_SpawnOrigin[this]] + Sin(s__LinePatternSpawn_SpawnLineAngle[this] * bj_DEGTORAD) * ( .5 * s__LinePatternSpawn_SpawnOffset[this] + s__LinePatternSpawn_SpawnOffset[this] * spawnIndex ))
  endfunction
		
  function s__LinePatternSpawn_DrawOrigin takes integer this returns nothing
			call Draw_DrawLine(s__vector2_x[s__LinePatternSpawn_SpawnOrigin[this]] , s__vector2_y[s__LinePatternSpawn_SpawnOrigin[this]] , s__vector2_x[s__LinePatternSpawn_SpawnOrigin[this]] + Cos(s__LinePatternSpawn_SpawnLineAngle[this] * bj_DEGTORAD) * s__LinePatternSpawn_SpawnLineLength[this] , s__vector2_y[s__LinePatternSpawn_SpawnOrigin[this]] + Sin(s__LinePatternSpawn_SpawnLineAngle[this] * bj_DEGTORAD) * s__LinePatternSpawn_SpawnLineLength[this] , 0)
  endfunction
		
  function s__LinePatternSpawn_create takes integer spawnCB,integer cycleCount,integer spawnOrigin,real spawnLineAngle,real spawnLineLength,real spawnLineOffset returns integer
   local integer new= s__PatternSpawn_create(spawnCB , cycleCount)
			
			set s__LinePatternSpawn_PatternSpawn[new]=new
			
			set s__LinePatternSpawn_SpawnOrigin[new]=spawnOrigin
			set s__LinePatternSpawn_SpawnLineAngle[new]=spawnLineAngle
			set s__LinePatternSpawn_SpawnLineLength[new]=spawnLineLength
			set s__LinePatternSpawn_SpawnOffset[new]=spawnLineOffset
			
			return new
  endfunction
		
		//hack helper for avoiding a vJASS abstract class / interface that defines GetSpawnPosition for override by its children
  function s__LinePatternSpawn_createFromPoint takes integer spawnCB,integer cycleCount,rect spawnRectPoint returns integer
			return s__LinePatternSpawn_create(spawnCB , cycleCount , s__vector2_create(GetRectCenterX(spawnRectPoint) , GetRectCenterY(spawnRectPoint)) , 0 , 0 , 0)
  endfunction
		//nice helper for creating a pattern spawn area from a WE rect
  function s__LinePatternSpawn_createFromRect takes integer spawnCB,integer cycleCount,rect spawnRect,real spawnLineOffset returns integer
   local integer spawnOrigin
   local real spawnLineAngle
   local real spawnLineLength
						
			if GetRectMaxX(spawnRect) - GetRectMinX(spawnRect) >= GetRectMaxY(spawnRect) - GetRectMinY(spawnRect) then
				set spawnLineLength=GetRectMaxX(spawnRect) - GetRectMinX(spawnRect)
				set spawnLineAngle=0 //auto create from rect always starts position index on left side and moves right
				set spawnOrigin=s__vector2_create(GetRectMinX(spawnRect) , ( GetRectMaxY(spawnRect) + GetRectMinY(spawnRect) ) / 2.)
			else
				set spawnLineLength=GetRectMaxY(spawnRect) - GetRectMinY(spawnRect)
				set spawnLineAngle=90 //auto create from rect always starts position index on bottom side and moves up
				set spawnOrigin=s__vector2_create(( GetRectMaxX(spawnRect) + GetRectMinX(spawnRect) ) / 2. , GetRectMinY(spawnRect))
			endif
			
			//bound spawnLineLength to include at least a single location
			//allows tiny rects that define position accurately to also define a single spawn location
			if spawnLineLength < spawnLineOffset then
				set spawnLineLength=spawnLineOffset
			endif
			
			return s__LinePatternSpawn_create(spawnCB , cycleCount , spawnOrigin , spawnLineAngle , spawnLineLength , spawnLineOffset)
  endfunction

//library PatternSpawn ends
//library PlatformerProfile:
        
        
        //all properties that support physics
        //public real          TerminalVelocityX    //this caps how fast a unit can go due to gravity, going faster in this will cause you to slow down to this over time
        //TODO replace X and Y falloff with references to easing functions
        
        function s__PlatformerProfile_create takes integer tvy,integer xf,integer yf,integer ms,real msoff,integer ga,integer vj,real v2h,integer hj returns integer
            local integer new
            
            //first check to see if there are any structs waiting to be recycled
            set s__PlatformerProfile_instanceCount=s__PlatformerProfile_instanceCount + 1
            set new=s__PlatformerProfile_instanceCount
            
            //calculate the base * TIMESTEP once, when created
            //set new.TerminalVelocityX = tvx * PlatformerGlobals_GAMELOOP_TIMESTEP
            set s__PlatformerProfile_TerminalVelocityY[new]=tvy * PlatformerGlobals_GAMELOOP_TIMESTEP
            set s__PlatformerProfile_XFalloff[new]=xf * PlatformerGlobals_GAMELOOP_TIMESTEP
            set s__PlatformerProfile_YFalloff[new]=yf * PlatformerGlobals_GAMELOOP_TIMESTEP
            set s__PlatformerProfile_MoveSpeed[new]=ms * PlatformerGlobals_GAMELOOP_TIMESTEP
            set s__PlatformerProfile_GravitationalAccel[new]=ga * PlatformerGlobals_GAMELOOP_TIMESTEP
            set s__PlatformerProfile_vJumpSpeed[new]=vj * PlatformerGlobals_GAMELOOP_TIMESTEP
            set s__PlatformerProfile_hJumpSpeed[new]=hj * PlatformerGlobals_GAMELOOP_TIMESTEP
            
            //ratios/percentages don't get effected by timestep length
            set s__PlatformerProfile_MoveSpeedVelOffset[new]=msoff
            set s__PlatformerProfile_v2hJumpRatio[new]=v2h
            
            return new
        endfunction        
    
    function PlatformerProfile__Init takes nothing returns nothing
        //create default profile
        local integer profile= s__PlatformerProfile_create(PlatformerProfile__YTERMINAL , PlatformerProfile__xFALLOFF , PlatformerProfile__yFALLOFF , PlatformerProfile__MOVESPEED , PlatformerProfile__MOVESPEEDOFFSET , PlatformerProfile__GRAVITYACCEL , PlatformerProfile__vJUMPSPEED , PlatformerProfile__v2hJUMPSPEED , PlatformerProfile__hJUMPSPEED)
        if profile != PlatformerProfile_DefaultProfileID then
            call DisplayTextToForce(bj_FORCE_PLAYER[0], "Warning, another profile was created before the default profile! Platforming is going to crash and burn horribly!")
        endif
        
        //old profile to make ice feel better -- this caused everything to feel a bit off from what you'd just gotten used to
        
		
		//moon profile
        set profile=s__PlatformerProfile_create(R2I(PlatformerProfile__YTERMINAL * .75) , R2I(PlatformerProfile__xFALLOFF * 0.1) , R2I(PlatformerProfile__yFALLOFF * 0.1) , R2I(PlatformerProfile__MOVESPEED * .9) , PlatformerProfile__MOVESPEEDOFFSET , - 10 , PlatformerProfile__vJUMPSPEED , PlatformerProfile__v2hJUMPSPEED , PlatformerProfile__hJUMPSPEED)
    endfunction

//library PlatformerProfile ends
//library PlatformerUnitGlobals:

//library PlatformerUnitGlobals ends
//library RSnowMovement:

	
 function s__RSnowMovement_RSnowMove takes nothing returns nothing
  local group swap= NewGroup()
  local unit u
		//local real dist
		
  local integer i
		
		loop
		set u=FirstOfGroup(s__RSnowMovement_g)
		exitwhen u == null
			set i=GetPlayerId(GetOwningPlayer(u))
						
			set s__VelocityX[i]= s__VelocityX[i] + Cos(s__RSFacing[i]) * RSnowMovement___ACCELERATION
			set s__VelocityY[i]= s__VelocityY[i] + Sin(s__RSFacing[i]) * RSnowMovement___ACCELERATION
			
			//set dist = SquareRoot(VelocityX[i]*VelocityX[i] + VelocityY[i]*VelocityY[i])
			
			call SetUnitX(u, GetUnitX(u) + s__VelocityX[i])
			call SetUnitY(u, GetUnitY(u) + s__VelocityY[i])
			call IssueImmediateOrder(u, "stop")
			
		call GroupAddUnit(swap, u)
		call GroupRemoveUnit(s__RSnowMovement_g, u)
		endloop
		
		call ReleaseGroup(s__RSnowMovement_g)
		set s__RSnowMovement_g=swap
		
		set u=null
		set swap=null
 endfunction

 function s__RSnowMovement_Add takes unit u returns nothing
		if s__RSnowMovement_g == null then
			set s__RSnowMovement_g=NewGroup()
			set s__RSnowMovement_t=(NewTimerEx(0)) // INLINED!!
			
			call TimerStart(s__RSnowMovement_t, RSnowMovement___TIMESTEP, true, function s__RSnowMovement_RSnowMove)
		endif
		
		set s__RSFacing[GetPlayerId(GetOwningPlayer(u))]= GetUnitFacing(u) * bj_DEGTORAD
		call GroupAddUnit(s__RSnowMovement_g, u)
 endfunction
	
 function s__RSnowMovement_Remove takes unit u returns nothing
		call GroupRemoveUnit(s__RSnowMovement_g, u)
		
		if (FirstOfGroup((s__RSnowMovement_g)) == null) then // INLINED!!
			call ReleaseTimer(s__RSnowMovement_t)
			call ReleaseGroup(s__RSnowMovement_g)
			
			set s__RSnowMovement_g=null
			set s__RSnowMovement_t=null
		endif
 endfunction


//library RSnowMovement ends
//library RelativeVector2:
		
  function s__relativeVector2_getAbsolutePosition takes integer this returns integer
   local integer position
			
			if s__relativeVector2_Parent[this] == 0 then
				return s__vector2_create(s__vector2_x[(this)] , s__vector2_y[(this)])
			else
				set position=s__relativeVector2_getAbsolutePosition(s__relativeVector2_Parent[this])
				
				set s__vector2_x[position]=s__vector2_x[position] + s__vector2_x[(this)]
				set s__vector2_y[position]=s__vector2_y[position] + s__vector2_y[(this)]
				
				return position
			endif
  endfunction
		
  function s__relativeVector2_createFromAbsolute takes real absX,real absY,integer parent returns integer
   local integer new
			
			if parent == 0 then
				set new=s__vector2_create(absX , absY)
			else
				set new=s__relativeVector2_getAbsolutePosition(parent)
				set s__vector2_x[new]=absX - s__vector2_x[new]
				set s__vector2_y[new]=absY - s__vector2_y[new]
			endif
						
			set s__relativeVector2_Parent[(new)]=parent
			
			return new
  endfunction
  function s__relativeVector2_create takes real x,real y,integer parent returns integer
   local integer new= s__vector2_create(x , y)
			
			set s__relativeVector2_Parent[new]=parent
			
			return new
  endfunction
  function s__relativeVector2_destroy takes integer this returns nothing
			set s__relativeVector2_Parent[this]=0
			
			call s__vector2_deallocate((this))
  endfunction

//library RelativeVector2 ends
//library SkatingGlobals:

//library SkatingGlobals ends
//library TerrainGlobals:
    
 function TerrainID2S takes integer ttype returns string
		if ttype == ABYSS then
			return "abyss"
		elseif ttype == LRGBRICKS then
			return "large bricks"
		elseif ttype == RTILE then
			return "round tile"
		elseif ttype == ROAD then
			return "road"
		elseif ttype == LAVA then
			return "lava"
		elseif ttype == NOEFFECT then
			return "no effect"
		elseif ttype == GRASS then
			return "grass"
		elseif ttype == SNOW then
			return "snow"
		elseif ttype == D_GRASS then
			return "dark grass"
		elseif ttype == SLOWICE then
			return "slow ice"
		elseif ttype == LEAVES then
			return "leaves"
		elseif ttype == MEDIUMICE then
			return "medium ice"
		elseif ttype == FASTICE then
			return "fast ice"
		elseif ttype == VINES then
			return "vines"
		elseif ttype == SAND then
			return "sand"
		elseif ttype == RSNOW then
			return "rocky snow"
		else



			
			return ""
		endif
	endfunction
	
    function TerrainGlobals_IsTerrainPathable takes integer ttype returns boolean
        return ttype == DEATH or ttype == PATHABLE or ttype == OCEAN or ttype == PLATFORMING or ttype == VINES or ttype == RTILE or ttype == LEAVES
    endfunction
    function TerrainGlobals_IsTerrainUnpathable takes integer ttype returns boolean
        return ttype == WALL or ttype == GRASS or ttype == DGRASS or ttype == FASTICE or ttype == SLOWICE or ttype == SAND or ttype == SNOW or ttype == RSNOW or ttype == ROAD
    endfunction
    
    function TerrainGlobals_IsTerrainJumpable takes integer ttype returns boolean
        return TerrainGlobals_IsTerrainUnpathable(ttype)
    endfunction
    
    function TerrainGlobals_IsTerrainWallJumpable takes integer ttype returns boolean
        return ttype == WALL or ttype == RSNOW or ttype == GRASS or ttype == DGRASS or ttype == SLOWICE or ttype == FASTICE or ttype == ROAD
    endfunction
	//relevant to a strict subset of IsTerrainWallJumpable
	//if the terrain is good footing then the platformer will immediately negate any Y velocity against their jump direction
 function TerrainGlobals_IsTerrainGoodFooting takes integer ttype returns boolean
		return ttype == WALL or ttype == RSNOW or ttype == GRASS or ttype == DGRASS or ttype == ROAD
	endfunction
    function TerrainGlobals_IsTerrainSoft takes integer ttype returns boolean
        return ttype == SAND or ttype == SNOW
    endfunction
	//Use not IsTerrainSoft in conjunction with IsTerrainUnpathable instead of IsTerrainHard
	
	
	//relevant to a strict subset of hard terrains
	
	
    function TerrainGlobals_IsTerrainDiagonal takes integer ttype returns boolean
        return ttype == SLOWICE or ttype == FASTICE or ttype == GRASS or ttype == DGRASS
    endfunction
    function TerrainGlobals_IsTerrainSquare takes integer ttype returns boolean
        return ttype == WALL or ttype == SNOW or ttype == SAND or ttype == RSNOW or ttype == ROAD
    endfunction
    
    function GetTerrainCenterpoint takes real x,real y returns integer
        local integer center= s__vector2_allocate()
        
        if x >= 0 then
            set s__vector2_x[center]=R2I(( x + 64.500000 ) / 128.) * 128.
        else
            set s__vector2_x[center]=R2I(( x - 63.499999 ) / 128.) * 128.
        endif
        if y >= 0 then
            set s__vector2_y[center]=R2I(( y + 64.500000 ) / 128.) * 128.
        else
            set s__vector2_y[center]=R2I(( y - 63.499999 ) / 128.) * 128.
        endif
        
        return center
    endfunction
    
    
    
    function GetTerrainLeft takes real centerX returns real
        return centerX - TERRAIN_QUADRANT_SIZE - TERRAIN_QUADRANT_ROUND
    endfunction
    
    function GetTerrainRight takes real centerX returns real
        return centerX + TERRAIN_QUADRANT_SIZE - TERRAIN_QUADRANT_ROUND
    endfunction
    
    function GetTerrainBottom takes real centerY returns real
        return centerY - TERRAIN_QUADRANT_SIZE - TERRAIN_QUADRANT_ROUND
    endfunction
    
    function GetTerrainTop takes real centerY returns real
        return centerY + TERRAIN_QUADRANT_SIZE - TERRAIN_QUADRANT_ROUND
    endfunction
    
    function TerrainGlobals___initTerrainGlobals takes nothing returns nothing
        local integer i= 0
    
        loop
        exitwhen i >= NumberPlayers
            //set PreviousTerrainType2[i] = NOEFFECT
            //set PreviousTerrainType[i] = NOEFFECT
            set s__PreviousTerrainTypedx[i]= NOEFFECT
            
            set i=i + 1
        endloop
    endfunction

//library TerrainGlobals ends
//library Alloc:

//library Alloc ends
//library ComplexTerrainPathing:

//returns a vector that represents the orthogonal to a pathing map
function ComplexTerrainPathing_GetUnitVectorForPathing takes integer terrainPathing returns integer
    if terrainPathing == ComplexTerrainPathing_Top then
        return ComplexTerrainPathing_Up_UnitVector
    elseif terrainPathing == ComplexTerrainPathing_Bottom then
        return ComplexTerrainPathing_Down_UnitVector
    elseif terrainPathing == ComplexTerrainPathing_Left then
        return ComplexTerrainPathing_Left_UnitVector
    elseif terrainPathing == ComplexTerrainPathing_Right then
        return ComplexTerrainPathing_Right_UnitVector
    elseif terrainPathing == ComplexTerrainPathing_NE then
        return ComplexTerrainPathing_NE_UnitVector
    elseif terrainPathing == ComplexTerrainPathing_SE then
        return ComplexTerrainPathing_SE_UnitVector
    elseif terrainPathing == ComplexTerrainPathing_SW then
        return ComplexTerrainPathing_SW_UnitVector
    elseif terrainPathing == ComplexTerrainPathing_NW then
        return ComplexTerrainPathing_NW_UnitVector
    endif
    
    return 0
endfunction

function ComplexTerrainPathing_GetParallelForPathing takes integer terrainPathing returns integer
    if terrainPathing == ComplexTerrainPathing_Top then
        return ComplexTerrainPathing_Right_UnitVector
    elseif terrainPathing == ComplexTerrainPathing_Bottom then
        return ComplexTerrainPathing_Left_UnitVector
    elseif terrainPathing == ComplexTerrainPathing_Left then
        return ComplexTerrainPathing_Down_UnitVector
    elseif terrainPathing == ComplexTerrainPathing_Right then
        return ComplexTerrainPathing_Up_UnitVector
    elseif terrainPathing == ComplexTerrainPathing_NE then
        return ComplexTerrainPathing_NW_UnitVector
    elseif terrainPathing == ComplexTerrainPathing_SE then
        return ComplexTerrainPathing_SW_UnitVector
    elseif terrainPathing == ComplexTerrainPathing_SW then
        return ComplexTerrainPathing_SE_UnitVector
    elseif terrainPathing == ComplexTerrainPathing_NW then
        return ComplexTerrainPathing_NE_UnitVector
    endif
	
	return 0
endfunction
	
//direction is x or y based for horizontal and vertical walls, but is purely x based for diagonals
function ComplexTerrainPathing_GetParallelForPathingDirection takes integer terrainPathing,boolean direction returns integer
	if direction and ( terrainPathing == ComplexTerrainPathing_Top or terrainPathing == ComplexTerrainPathing_Bottom ) then
        return ComplexTerrainPathing_Right_UnitVector
    elseif not direction and ( terrainPathing == ComplexTerrainPathing_Top or terrainPathing == ComplexTerrainPathing_Bottom ) then
        return ComplexTerrainPathing_Left_UnitVector
    elseif direction and ( terrainPathing == ComplexTerrainPathing_Left or terrainPathing == ComplexTerrainPathing_Right ) then
        return ComplexTerrainPathing_Up_UnitVector
    elseif not direction and ( terrainPathing == ComplexTerrainPathing_Left or terrainPathing == ComplexTerrainPathing_Right ) then
        return ComplexTerrainPathing_Down_UnitVector
    elseif direction and ( terrainPathing == ComplexTerrainPathing_NE or terrainPathing == ComplexTerrainPathing_SW ) then
        return ComplexTerrainPathing_SE_UnitVector
    elseif not direction and ( terrainPathing == ComplexTerrainPathing_NE or terrainPathing == ComplexTerrainPathing_SW ) then
        return ComplexTerrainPathing_NW_UnitVector
    elseif direction and ( terrainPathing == ComplexTerrainPathing_SE or terrainPathing == ComplexTerrainPathing_NW ) then
        return ComplexTerrainPathing_NE_UnitVector
    elseif not direction and ( terrainPathing == ComplexTerrainPathing_SE or terrainPathing == ComplexTerrainPathing_NW ) then
        return ComplexTerrainPathing_SW_UnitVector
    endif
    
    return 0
endfunction

function ComplexTerrainPathing_GetAngleForUnitVector takes integer unitVector returns real
    if unitVector == ComplexTerrainPathing_Up_UnitVector then
        //return 90.
        return bj_PI * .5
    elseif unitVector == ComplexTerrainPathing_Down_UnitVector then
        //return 270.
        return bj_PI * 1.5
    elseif unitVector == ComplexTerrainPathing_Left_UnitVector then
        //return 180.
        return bj_PI
    elseif unitVector == ComplexTerrainPathing_Right_UnitVector then
        return 0.
    elseif unitVector == ComplexTerrainPathing_NE_UnitVector then
        //return 45.
        return bj_PI * .75
    elseif unitVector == ComplexTerrainPathing_SE_UnitVector then
        //return 315.
        return bj_PI * 1.25
    elseif unitVector == ComplexTerrainPathing_SW_UnitVector then
        //return 225.
        return bj_PI * 1.75
    elseif unitVector == ComplexTerrainPathing_NW_UnitVector then
        //return 135.
        return bj_PI * .25
    endif
    
    return 0.
endfunction

    
    //should be one of the above 10 directional values
    
    //0 = not pushed against any unpathable terrain on that axis
    //not 0 = pushed against that terrain on that axis
    //may be different than the vanilla GetTerrainTypeID for diagonal terrains
    
    //should be NE, SE, SW, or NW

    //need to be able to reproduce the diagonal accurately
    //midpoint + Diagonal type should be enough to reproduce the line
    //do i need all this info to represent a linear line? eq will either be y = constant, x = constant, y = x, or y = -x
    //public real DiagonalPointAx
    //public real DiagonalPointAy
    //public real DiagonalPointBx
    //public real DiagonalPointBy
    
    //do we?
    //need the position of the unit entering the diagonal
    //public real OriginPointX
    //public real OriginPointY
    //public real DestinationPointX
    //public real DestinationPointY
	
 function s__ComplexTerrainPathingResult_Print takes integer this returns nothing
		call DisplayTextToForce(bj_FORCE_PLAYER[0], "Pathing: " + I2S(s__ComplexTerrainPathingResult_TerrainPathingForPoint[this]) + ", Quadrant " + I2S(s__ComplexTerrainPathingResult_QuadrantForPoint[this]))
 endfunction
    
 function s__ComplexTerrainPathingResult_GetXTerrainType takes integer this returns integer
		if s__ComplexTerrainPathingResult_TerrainPathingForPoint[this] == ComplexTerrainPathing_Square then
			return GetTerrainType(s__ComplexTerrainPathingResult_TerrainMidpointX[this], s__ComplexTerrainPathingResult_TerrainMidpointY[this])
		else
			return s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[this]
		endif
 endfunction
 function s__ComplexTerrainPathingResult_GetYTerrainType takes integer this returns integer
		if s__ComplexTerrainPathingResult_TerrainPathingForPoint[this] == ComplexTerrainPathing_Square then
			return GetTerrainType(s__ComplexTerrainPathingResult_TerrainMidpointX[this], s__ComplexTerrainPathingResult_TerrainMidpointY[this])
		else
			return s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[this]
		endif
 endfunction
	
    function s__ComplexTerrainPathingResult_CreateSimple takes integer pathingType,real terrainMidX,real terrainMidY returns integer
        local integer new

        //first check to see if there are any structs waiting to be recycled
        if ( s__ComplexTerrainPathingResult_recycle == 0 ) then
            //if recycle is 0, there are no structs, so increase instance count
            set s__ComplexTerrainPathingResult_instanceCount=s__ComplexTerrainPathingResult_instanceCount + 1
            set new=s__ComplexTerrainPathingResult_instanceCount
        else
            //a struct is waiting to be recycled, so use it
            set new=s__ComplexTerrainPathingResult_recycle
            set s__ComplexTerrainPathingResult_recycle=s__ComplexTerrainPathingResult_recycleNext[s__ComplexTerrainPathingResult_recycle]
            
            set s__ComplexTerrainPathingResult_QuadrantForPoint[new]=0
            set s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[new]=0
            set s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[new]=0
        endif
        
        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Create Simple, CTPR Count: " + I2S(RecycleCount))
        
        set s__ComplexTerrainPathingResult_TerrainPathingForPoint[new]=pathingType
        //set new.RelevantXTerrainTypeID = relevantTerrainType
        set s__ComplexTerrainPathingResult_TerrainMidpointX[new]=terrainMidX
        set s__ComplexTerrainPathingResult_TerrainMidpointY[new]=terrainMidY
                
        return new
    endfunction
    function s__ComplexTerrainPathingResult_CreateComplex takes integer pathingType,real terrainMidX,real terrainMidY,integer quadrant,integer terrainPushedX,integer terrainPushedY returns integer
        local integer new
        
        //first check to see if there are any structs waiting to be recycled
        if ( s__ComplexTerrainPathingResult_recycle == 0 ) then
            //if recycle is 0, there are no structs, so increase instance count
            set s__ComplexTerrainPathingResult_instanceCount=s__ComplexTerrainPathingResult_instanceCount + 1
            set new=s__ComplexTerrainPathingResult_instanceCount
        else
            //a struct is waiting to be recycled, so use it
            set new=s__ComplexTerrainPathingResult_recycle
            set s__ComplexTerrainPathingResult_recycle=s__ComplexTerrainPathingResult_recycleNext[s__ComplexTerrainPathingResult_recycle]
        endif
        
        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Create Complex, CTPR Count: " + I2S(RecycleCount))
        
        set s__ComplexTerrainPathingResult_TerrainPathingForPoint[new]=pathingType
        //set new.RelevantXTerrainTypeID = relevantTerrainType
        set s__ComplexTerrainPathingResult_TerrainMidpointX[new]=terrainMidX
        set s__ComplexTerrainPathingResult_TerrainMidpointY[new]=terrainMidY
        
        set s__ComplexTerrainPathingResult_QuadrantForPoint[new]=quadrant
        set s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[new]=terrainPushedX
        set s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[new]=terrainPushedY
        
        return new
    endfunction
    function s__ComplexTerrainPathingResult_create takes integer pathingType returns integer
        local integer new
        
        //first check to see if there are any structs waiting to be recycled
        if ( s__ComplexTerrainPathingResult_recycle == 0 ) then
            //if recycle is 0, there are no structs, so increase instance count
            set s__ComplexTerrainPathingResult_instanceCount=s__ComplexTerrainPathingResult_instanceCount + 1
            set new=s__ComplexTerrainPathingResult_instanceCount
        else
            //a struct is waiting to be recycled, so use it
            set new=s__ComplexTerrainPathingResult_recycle
            set s__ComplexTerrainPathingResult_recycle=s__ComplexTerrainPathingResult_recycleNext[s__ComplexTerrainPathingResult_recycle]
            
            set s__ComplexTerrainPathingResult_TerrainMidpointX[new]=0
            set s__ComplexTerrainPathingResult_TerrainMidpointY[new]=0
            set s__ComplexTerrainPathingResult_QuadrantForPoint[new]=0
            set s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[new]=0
            set s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[new]=0
        endif
        
        set s__ComplexTerrainPathingResult_TerrainPathingForPoint[new]=pathingType
        
        return new
    endfunction
    
    function s__ComplexTerrainPathingResult_destroy takes integer this returns nothing
        //add to recycle stack
        set s__ComplexTerrainPathingResult_recycleNext[this]=s__ComplexTerrainPathingResult_recycle
        set s__ComplexTerrainPathingResult_recycle=this
    endfunction

function ComplexTerrainPathing_GetPathingForPoint takes real x,real y returns integer
    local real terrainCenterX
    local real terrainCenterY
    
    local integer ttype
	
 local real relX
 local real relY

    //get the center coordinates for the tile containing (x,y)
    
    
    if x >= 0 then
        set terrainCenterX=R2I(( x + 64.500 ) / 128.) * 128.
    else
        set terrainCenterX=R2I(( x - 63.499 ) / 128.) * 128.
    endif
    if y >= 0 then
        set terrainCenterY=R2I(( y + 64.500 ) / 128.) * 128.
    else
        set terrainCenterY=R2I(( y - 63.499 ) / 128.) * 128.
    endif
    
    set relX=x - terrainCenterX
	set relY=y - terrainCenterY
	
    //the order terrain is checked in is to optimize for the following assumptions:
    //majority of the usable map will be open space
    //followed by square blocks
    //and finally diagonals
    
    //all terrain tiles must fall into 1 of those 3 categories or they'll be ignored entirely
    
    //this is a very expensive function and its called every physics loop per player, so evaluation order should be kept relevent to the map contents
    
    set ttype=GetTerrainType(terrainCenterX, terrainCenterY)
    
    if TerrainGlobals_IsTerrainPathable(ttype) then
        //step 1: figure out which diagonal we need to check
        //step 2: see if diagonal exists
        //step 3: see if point within diagonal and return ID (only 1 possible)
        
        if x >= terrainCenterX and y >= terrainCenterY then
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "3, y: " + R2S(y - terrainCenterY - 64) + " x: " + R2S(x - terrainCenterX)) 
            //checking for diagonal ID 3
            if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(terrainCenterX + TERRAIN_TILE_SIZE, terrainCenterY)) and TerrainGlobals_IsTerrainDiagonal(GetTerrainType(terrainCenterX, terrainCenterY + TERRAIN_TILE_SIZE)) and ( y - terrainCenterY - 64 >= - x + terrainCenterX ) then
                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_SW , terrainCenterX , terrainCenterY , ComplexTerrainPathing_NE , GetTerrainType(terrainCenterX + TERRAIN_TILE_SIZE, terrainCenterY) , GetTerrainType(terrainCenterX, terrainCenterY + TERRAIN_TILE_SIZE))
            endif
        elseif x < terrainCenterX and y < terrainCenterY then
            //checking for diagonal ID 1
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "1, y: " + R2S(y - terrainCenterY) + " x: " + R2S(x - terrainCenterX + 64)) 
            if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(terrainCenterX - TERRAIN_TILE_SIZE, terrainCenterY)) and TerrainGlobals_IsTerrainDiagonal(GetTerrainType(terrainCenterX, terrainCenterY - TERRAIN_TILE_SIZE)) and ( y - terrainCenterY <= - x + terrainCenterX - 64 ) then
                //call CreateUnit(Player(0), 'etst', x, y, 6)
                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_NE , terrainCenterX , terrainCenterY , ComplexTerrainPathing_SW , GetTerrainType(terrainCenterX - TERRAIN_TILE_SIZE, terrainCenterY) , GetTerrainType(terrainCenterX, terrainCenterY - TERRAIN_TILE_SIZE))
            endif
        elseif x >= terrainCenterX then //y < terrainCenterY
            //checking for diagonal ID 4
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "4, y: " + R2S(y - terrainCenterY + 64) + " x: " + R2S(x - terrainCenterX)) 
            if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(terrainCenterX + TERRAIN_TILE_SIZE, terrainCenterY)) and TerrainGlobals_IsTerrainDiagonal(GetTerrainType(terrainCenterX, terrainCenterY - TERRAIN_TILE_SIZE)) and ( ( y - terrainCenterY + 64 ) <= ( x - terrainCenterX ) ) then
                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_NW , terrainCenterX , terrainCenterY , ComplexTerrainPathing_SE , GetTerrainType(terrainCenterX + TERRAIN_TILE_SIZE, terrainCenterY) , GetTerrainType(terrainCenterX, terrainCenterY - TERRAIN_TILE_SIZE))
            endif
        else //x < terrainCenterX and y >= terrainCenterY
            //checking for diagonal ID 2
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "4, y: " + R2S(y - terrainCenterY) + " x: " + R2S(x - terrainCenterX + 64)) 
            if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(terrainCenterX - TERRAIN_TILE_SIZE, terrainCenterY)) and TerrainGlobals_IsTerrainDiagonal(GetTerrainType(terrainCenterX, terrainCenterY + TERRAIN_TILE_SIZE)) and ( ( y - terrainCenterY ) >= ( x - terrainCenterX + 64 ) ) then
                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_SE , terrainCenterX , terrainCenterY , ComplexTerrainPathing_NW , GetTerrainType(terrainCenterX - TERRAIN_TILE_SIZE, terrainCenterY) , GetTerrainType(terrainCenterX, terrainCenterY + TERRAIN_TILE_SIZE))
            endif
        endif
        
        //otherwise we're on an open tile that doesn't have any diagonal tiles nearby overlapping onto this x, y coordinate
        return 0
    elseif TerrainGlobals_IsTerrainSquare(ttype) then
        return s__ComplexTerrainPathingResult_CreateSimple(ComplexTerrainPathing_Square , terrainCenterX , terrainCenterY)
    //check if (x,y) is even pathable (we should be there at all) and then check to see if adjoining tiles are diagonal and we overlap
    else //there are only 3 types of terrain pathing -- square and diagonal are the two 'solid' types, with diagonal being only partially solid, and open
    //elseif IsTerrainDiagonal(GetTerrainType(x, y)) then
        //step 1: figure out which diagonals we might need to check
        //step 2: figure out which of those actually exist based on what terrain is adjacent
        //step 3: see if (x,y) is within any of those diagonals
        //step 4: return the diagonal ID (x,y) is within (0 for none)
        
		//**********
		//Quadrant 1
        if x >= terrainCenterX and y >= terrainCenterY then //quadrant 1
			if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(terrainCenterX + TERRAIN_TILE_SIZE, terrainCenterY + TERRAIN_TILE_SIZE)) then
				if relY >= relX then



					//nearest natural diagonal above
					return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_NW , terrainCenterX , terrainCenterY + TERRAIN_TILE_SIZE , ComplexTerrainPathing_SE , ttype , ttype)
				else



					//nearest natural diagonal in same tile
					return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_SE , terrainCenterX , terrainCenterY , ComplexTerrainPathing_SE , ttype , ttype)
				endif
			elseif not TerrainGlobals_IsTerrainPathable(GetTerrainType(terrainCenterX, terrainCenterY + TERRAIN_TILE_SIZE)) then
				return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Right , terrainCenterX , terrainCenterY , ComplexTerrainPathing_NE , ttype , 0)
			elseif not TerrainGlobals_IsTerrainPathable(GetTerrainType(terrainCenterX + TERRAIN_TILE_SIZE, terrainCenterY)) then
				return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Top , terrainCenterX , terrainCenterY , ComplexTerrainPathing_NE , 0 , ttype)
			else
				if relY <= TERRAIN_QUADRANT_SIZE - relX then



					return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_NE , terrainCenterX , terrainCenterY , ComplexTerrainPathing_NE , ttype , ttype)
				endif
			endif
			
		//**********
		//Quadrant 2
		elseif x < terrainCenterX and y >= terrainCenterY then //quadrant 2
			if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(terrainCenterX - TERRAIN_TILE_SIZE, terrainCenterY + TERRAIN_TILE_SIZE)) then
				if relY >= - relX then



					//nearest natural diagonal above
					return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_NE , terrainCenterX , terrainCenterY + TERRAIN_TILE_SIZE , ComplexTerrainPathing_SW , ttype , ttype)
				else



					//nearest natural diagonal in same tile
					return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_SW , terrainCenterX , terrainCenterY , ComplexTerrainPathing_SW , ttype , ttype)
				endif
			elseif not TerrainGlobals_IsTerrainPathable(GetTerrainType(terrainCenterX, terrainCenterY + TERRAIN_TILE_SIZE)) then
				return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Left , terrainCenterX , terrainCenterY , ComplexTerrainPathing_NW , ttype , 0)
			elseif not TerrainGlobals_IsTerrainPathable(GetTerrainType(terrainCenterX - TERRAIN_TILE_SIZE, terrainCenterY)) then
				return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Top , terrainCenterX , terrainCenterY , ComplexTerrainPathing_NW , 0 , ttype)
			else
				if relY <= TERRAIN_QUADRANT_SIZE + relX then



					return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_NW , terrainCenterX , terrainCenterY , ComplexTerrainPathing_NW , ttype , ttype)
				endif
			endif
			
		//**********
		//Quadrant 3
		elseif x < terrainCenterX then //and y < terrainCenterY    quadrant 3
			if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(terrainCenterX - TERRAIN_TILE_SIZE, terrainCenterY - TERRAIN_TILE_SIZE)) then
				if relY >= relX then



					//nearest natural diagonal in same tile
					return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_NW , terrainCenterX , terrainCenterY , ComplexTerrainPathing_NW , ttype , ttype)
				else



					//nearest natural diagonal below
					return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_SE , terrainCenterX , terrainCenterY - TERRAIN_TILE_SIZE , ComplexTerrainPathing_NW , ttype , ttype)
				endif
			elseif not TerrainGlobals_IsTerrainPathable(GetTerrainType(terrainCenterX, terrainCenterY - TERRAIN_TILE_SIZE)) then
				return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Left , terrainCenterX , terrainCenterY , ComplexTerrainPathing_SW , ttype , 0)
			elseif not TerrainGlobals_IsTerrainPathable(GetTerrainType(terrainCenterX - TERRAIN_TILE_SIZE, terrainCenterY)) then
				return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Bottom , terrainCenterX , terrainCenterY , ComplexTerrainPathing_SW , 0 , ttype)
			else
				if relY >= - relX - TERRAIN_QUADRANT_SIZE then



					return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_SW , terrainCenterX , terrainCenterY , ComplexTerrainPathing_SW , ttype , ttype)
				endif
			endif
			
		//**********
		//Quadrant 4
		else //x >= terrainCenterY and y < terrainCenterX    //quadrant 4
			if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(terrainCenterX + TERRAIN_TILE_SIZE, terrainCenterY - TERRAIN_TILE_SIZE)) then
				if relY >= - relX then



					//nearest natural diagonal in same tile
					return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_NE , terrainCenterX , terrainCenterY , ComplexTerrainPathing_NE , ttype , ttype)
				else



					//nearest natural diagonal below
					return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_SW , terrainCenterX , terrainCenterY - TERRAIN_TILE_SIZE , ComplexTerrainPathing_NE , ttype , ttype)
				endif
			elseif not TerrainGlobals_IsTerrainPathable(GetTerrainType(terrainCenterX, terrainCenterY - TERRAIN_TILE_SIZE)) then
				return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Right , terrainCenterX , terrainCenterY , ComplexTerrainPathing_SE , ttype , 0)
			elseif not TerrainGlobals_IsTerrainPathable(GetTerrainType(terrainCenterX + TERRAIN_TILE_SIZE, terrainCenterY)) then
				return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Bottom , terrainCenterX , terrainCenterY , ComplexTerrainPathing_SE , 0 , ttype)
			else
				if relY >= relX - TERRAIN_QUADRANT_SIZE then



					return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_SE , terrainCenterX , terrainCenterY , ComplexTerrainPathing_SE , ttype , ttype)
				endif
			endif
			
        endif
    endif
    
    //0 represents null -- ie, a pathable result for the x,y location
    return 0
endfunction
    
function ComplexTerrainPathing__init takes nothing returns nothing
    set ComplexTerrainPathing_Up_UnitVector=s__vector2_create(0 , 1)
    set ComplexTerrainPathing_Down_UnitVector=s__vector2_create(0 , - 1)
    set ComplexTerrainPathing_Left_UnitVector=s__vector2_create(- 1 , 0)
    set ComplexTerrainPathing_Right_UnitVector=s__vector2_create(1 , 0)
    
    set ComplexTerrainPathing_NE_UnitVector=s__vector2_create(SIN_45 , SIN_45)
    set ComplexTerrainPathing_SE_UnitVector=s__vector2_create(SIN_45 , - SIN_45)
    set ComplexTerrainPathing_SW_UnitVector=s__vector2_create(- SIN_45 , - SIN_45)
    set ComplexTerrainPathing_NW_UnitVector=s__vector2_create(- SIN_45 , SIN_45)
    
    
    
//    debug call DisplayTextToForce(bj_FORCE_PLAYER[0], I2S(Up_UnitVector))
//    debug call DisplayTextToForce(bj_FORCE_PLAYER[0], I2S(Down_UnitVector))
//    debug call DisplayTextToForce(bj_FORCE_PLAYER[0], I2S(Left_UnitVector))
//    debug call DisplayTextToForce(bj_FORCE_PLAYER[0], I2S(Right_UnitVector))
//    
//    debug call DisplayTextToForce(bj_FORCE_PLAYER[0], I2S(NE_UnitVector))
//    debug call DisplayTextToForce(bj_FORCE_PLAYER[0], I2S(SE_UnitVector))
//    debug call DisplayTextToForce(bj_FORCE_PLAYER[0], I2S(SW_UnitVector))
//    debug call DisplayTextToForce(bj_FORCE_PLAYER[0], I2S(NW_UnitVector))    
endfunction
    

//library ComplexTerrainPathing ends
//library DisposableUnit:
	
		
  function s__DisposableUnit_IsUnitDisposable takes unit u returns boolean
			if GetUnitUserData(u) != 0 then
				return s__DisposableUnit_TrackedStartable[(GetUnitUserData(u))] != 0
			else
				return false
			endif
  endfunction
		
  function s__DisposableUnit_dispose takes integer this returns nothing



			
			call sc__IStartable_destroy(s__DisposableUnit_TrackedStartable[this])
			set s__DisposableUnit_TrackedStartable[this]=0
			
			call s__IndexedUnit_destroy((this))
			



  endfunction
  function s__DisposableUnit_register takes unit u,integer disposable returns integer
   local integer new
			if GetUnitUserData(u) == 0 then
				set new=s__IndexedUnit_create(u)
			else
				set new=GetUnitUserData(u)
			endif
			
			set s__DisposableUnit_TrackedStartable[new]=disposable
			



			
			return new
  endfunction

//library DisposableUnit ends
//library IceSteering:

function IceSteering___ControlledSteering takes nothing returns boolean
    local integer i= GetPlayerId(GetTriggerPlayer())
    	
    if s__CanSteer[i] then
        call SetUnitFacingTimed(s__MazersArray[i], ( bj_RADTODEG * Atan2(GetOrderPointY() - GetUnitY(s__MazersArray[i]), GetOrderPointX() - GetUnitX(s__MazersArray[i])) ), 0)
    endif
	
	return false
endfunction

//===========================================================================
function IceSteering___Init takes nothing returns nothing
    local trigger t= CreateTrigger()
 local integer i= 0
	
    loop
    exitwhen i >= NumberPlayers
        call TriggerRegisterPlayerUnitEvent(t, Player(i), EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER, null)
        set i=i + 1
    endloop
    call TriggerAddCondition(t, Condition(function IceSteering___ControlledSteering))
	
	set t=null
endfunction


//library IceSteering ends
//library MnT:


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                          Mortar And Target Struct
//                              by Serenity09
//                            Clan TMMM US East
//
// Purpose: Creates a mortar and target pair that is easy to keep track of.
// Consolidates all code into creating the pair and then periodically calling
// MnTActions in order to randomly move the target within the confines and order
// the Mortar to attack it.
//
// To create: create a way to reference the mortar/target pair after creation (such as a global variable)
// Instantiate the struct using .create()
// Ex. local MortarNTarget lvl2Mortar = MortarNTarget.create(int <mortarID>, int <targetID>, player <playerID>, rect <mortarrect>, rect <targetrect>)
// mortarID is the integer data value for the unit to be used as the mortar
// targetID is the integer data value for the unit to be used as the target
// playerID is who will own the mortar and target
// mortarrect is the rect in which the mortar will be created
// targetrect is the boundaries within which the target will randomly move (teleport style)
//
// To issue the standard MnTActions to that mortar just call MnTActions on it
// Ex. call lvl2Mortar.MnTActions()
//
// Unlike wispwheels, you should destroy mortars when not in use (mortars dont use hashes)
// When you destroy a mortar/target with .destroy(), .onDestroy() will automatically be called
// .onDestroy() removes the mortar/target and nulls the unit member variables for that instance.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

//dear god why did i abbreviate "And" to "N"
    //member variables
    
    
//Implemented from module List:
    
    
    
    function s__MortarNTarget__get_first takes nothing returns integer
        return s__MortarNTarget_next[(0)]
    endfunction
    
    function s__MortarNTarget__get_last takes nothing returns integer
        return s__MortarNTarget_prev[(0)]
    endfunction
        
    function s__MortarNTarget_listRemove takes integer this returns nothing
        if not s__MortarNTarget_List__inlist[this] then
            return
        endif
        set s__MortarNTarget_List__inlist[this]=false
        set s__MortarNTarget_next[s__MortarNTarget_prev[this]]=s__MortarNTarget_next[this]
        set s__MortarNTarget_prev[s__MortarNTarget_next[this]]=s__MortarNTarget_prev[this]
        set s__MortarNTarget_count=s__MortarNTarget_count - 1
    endfunction

    function s__MortarNTarget_listAdd takes integer this returns nothing
        if s__MortarNTarget_List__inlist[this] or s__MortarNTarget_List__destroying or this == 0 then
            return
        endif
        set s__MortarNTarget_List__inlist[this]=true
        set s__MortarNTarget_next[(s__MortarNTarget_prev[(0)])]=this // INLINED!!
        set s__MortarNTarget_prev[this]=(s__MortarNTarget_prev[(0)]) // INLINED!!
        set s__MortarNTarget_prev[(0)]=this
        set s__MortarNTarget_next[this]=(0)
        set s__MortarNTarget_count=s__MortarNTarget_count + 1
    endfunction
    
    function s__MortarNTarget_listDestroy takes nothing returns nothing
        local integer this= (s__MortarNTarget_prev[(0)]) // INLINED!!
            set s__MortarNTarget_List__destroying=true
            loop
                exitwhen this == 0
                call sc__IStartable_deallocate(this)
                set this=s__MortarNTarget_prev[this]
            endloop
            set s__MortarNTarget_List__destroying=false
    endfunction
    
        
    function s__MortarNTarget_MnTActions takes integer this returns nothing
        local real newX
        local real newY
		
  local integer attempt= 0
        
        loop
			set attempt=attempt + 1
            set newX=GetRandomReal(s__MortarNTarget_minX[this], s__MortarNTarget_maxX[this])
            set newY=GetRandomReal(s__MortarNTarget_minY[this], s__MortarNTarget_maxY[this])
            
            exitwhen GetTerrainType(newX, newY) != MnT___IllegalTerrainType or attempt == MnT___MAX_VALID_TARGET_ATTEMPTS
        endloop
		



		
        //move the target randomly within its given boundaries
        call SetUnitX(s__MortarNTarget_Target[this], newX)
        call SetUnitY(s__MortarNTarget_Target[this], newY)
        
        //order the mortar to attack the target
        call IssuePointOrder(s__MortarNTarget_Mortar[this], "attackground", GetUnitX(s__MortarNTarget_Target[this]), GetUnitY(s__MortarNTarget_Target[this]))
    endfunction
    
    
    
    function s__MortarNTarget_MnTPeriodic takes nothing returns nothing
        //use of thistype because it might not be called by a simple wheel
        local integer e= (s__MortarNTarget_next[(0)]) // INLINED!!
        
        loop
        exitwhen e == 0
            call s__MortarNTarget_MnTActions(e)
            set e=s__MortarNTarget_next[e]
        endloop
    endfunction
    
    function s__MortarNTarget_Start takes integer this returns nothing
        call PauseUnit(s__MortarNTarget_Mortar[this], false)
		
		if s__MortarNTarget_count == 0 then
            call TimerStart(MnT___MnTTimer, MnT___MnTTimeStep, true, function s__MortarNTarget_MnTPeriodic)
        endif
        call s__MortarNTarget_listAdd(this)
    endfunction
    
    function s__MortarNTarget_Stop takes integer this returns nothing
        call IssueImmediateOrder(s__MortarNTarget_Mortar[this], "stop")
        call PauseUnit(s__MortarNTarget_Mortar[this], true)
		
		call s__MortarNTarget_listRemove(this)
        if s__MortarNTarget_count == 0 then
            call PauseTimer(MnT___MnTTimer)
        endif
    endfunction

        
    function s__MortarNTarget_onDestroy takes integer this returns nothing
        //runs when MortarNTarget.destroy() is called
        call RemoveUnit(s__MortarNTarget_Mortar[this])
        call RemoveUnit(s__MortarNTarget_Target[this])
        
        call s__MortarNTarget_listRemove(this)
        if s__MortarNTarget_count == 0 then
            call PauseTimer(MnT___MnTTimer)
        endif
        
        set s__MortarNTarget_Mortar[this]=null
        set s__MortarNTarget_Target[this]=null
    endfunction
    
    function s__MortarNTarget_create takes integer mortarID,integer targetID,player playerID,rect mortarloc,rect targetrect returns integer
        //allocate memory for the mortar and target
        local integer new= s__MortarNTarget__allocate()
        //create the mortar and target
        set s__MortarNTarget_Mortar[new]=CreateUnit(playerID, mortarID, GetRectCenterX(mortarloc), GetRectCenterY(mortarloc), 0)
        call PauseUnit(s__MortarNTarget_Mortar[new], true)
		
		set s__MortarNTarget_Target[new]=CreateUnit(playerID, targetID, GetRectCenterX(targetrect), GetRectCenterY(targetrect), 0)
		call SetUnitColor(s__MortarNTarget_Target[new], PLAYER_COLOR_AQUA)
        
        call AddUnitLocust(s__MortarNTarget_Mortar[new])
        call AddUnitLocust(s__MortarNTarget_Target[new])
        
        set s__MortarNTarget_minX[new]=GetRectMinX(targetrect)
        set s__MortarNTarget_maxX[new]=GetRectMaxX(targetrect)
        set s__MortarNTarget_minY[new]=GetRectMinY(targetrect)
        set s__MortarNTarget_maxY[new]=GetRectMaxY(targetrect)
        
        return new
    endfunction


//library MnT ends
//library PlatformerOcean:
    
    function PlatformerOcean__Loop takes integer p returns nothing
        
        //design concept:
        //movement left and right should be entirely velocity based, with the platformer gaining a boost going in the same direction of their velocity
        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Ocean loop plat " + I2S(p) + " axis state " + I2S(p.HorizontalAxisState))
        
        //going right
        if s__Platformer_HorizontalAxisState[p] == 1 then
            if s__Platformer_XVelocity[p] < 0 then //velocity left
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "(opp) before: " + R2S(p.XVelocity) + " after: " + R2S(p.XVelocity + p.MoveSpeed * .5))
                set s__Platformer_XVelocity[p]=s__Platformer_XVelocity[p] + s__Platformer_MoveSpeed[p] * PlatformerOcean_OCEAN_MOTION * PlatformerOcean__OPPOSITIONDIFFERENCE
                    
				call DestroyEffect(AddSpecialEffect("Doodads\\Icecrown\\Water\\BubbleGeyserSteam\\BubbleGeyserSteam.mdl", GetUnitX(s__Platformer_Unit[p]), GetUnitY(s__Platformer_Unit[p])))
            elseif s__Platformer_XVelocity[p] == PlatformerOcean__MAX_VELOCITY then
                //no change, still maxed
            elseif s__Platformer_XVelocity[p] + s__Platformer_MoveSpeed[p] * PlatformerOcean_OCEAN_MOTION >= PlatformerOcean__MAX_VELOCITY then
                set s__Platformer_XVelocity[p]=PlatformerOcean__MAX_VELOCITY
            else
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "(same) before: " + R2S(p.XVelocity) + " after: " + R2S(p.XVelocity + p.MoveSpeed * OCEAN_MOTION))
                set s__Platformer_XVelocity[p]=s__Platformer_XVelocity[p] + s__Platformer_MoveSpeed[p] * PlatformerOcean_OCEAN_MOTION
            endif
        elseif s__Platformer_HorizontalAxisState[p] == - 1 then
            if s__Platformer_XVelocity[p] > 0 then //velocity right
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "(opp) before: " + R2S(p.XVelocity) + " after: " + R2S(p.XVelocity - p.MoveSpeed * .5))
                set s__Platformer_XVelocity[p]=s__Platformer_XVelocity[p] - s__Platformer_MoveSpeed[p] * PlatformerOcean_OCEAN_MOTION * PlatformerOcean__OPPOSITIONDIFFERENCE
                
                call DestroyEffect(AddSpecialEffect("Doodads\\Icecrown\\Water\\BubbleGeyserSteam\\BubbleGeyserSteam.mdl", GetUnitX(s__Platformer_Unit[p]), GetUnitY(s__Platformer_Unit[p])))
            elseif s__Platformer_XVelocity[p] == - PlatformerOcean__MAX_VELOCITY then
                //no change, still maxed
            elseif s__Platformer_XVelocity[p] - s__Platformer_MoveSpeed[p] * PlatformerOcean_OCEAN_MOTION <= - PlatformerOcean__MAX_VELOCITY then
                set s__Platformer_XVelocity[p]=- PlatformerOcean__MAX_VELOCITY
            else
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "(same) before: " + R2S(p.XVelocity) + " after: " + R2S(p.XVelocity - p.MoveSpeed * OCEAN_MOTION))
                set s__Platformer_XVelocity[p]=s__Platformer_XVelocity[p] - s__Platformer_MoveSpeed[p] * PlatformerOcean_OCEAN_MOTION
            endif
        endif
    endfunction
    
    function PlatformerOcean__Loop_Init takes nothing returns nothing
        local integer cur= s__SimpleList_List_first[PlatformerOcean_Platformers]
        
        if cur != 0 then
            loop
            exitwhen cur == 0
                call PlatformerOcean__Loop(s__SimpleList_ListNode_value[cur])
            set cur=s__SimpleList_ListNode_next[cur]
            endloop
        endif
    endfunction
    
    function PlatformerOcean_Add takes integer p returns nothing
        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Ocean adding platformer " + I2S(p) + " count " + I2S(Platformers.count))
        
        if s__SimpleList_List_count[PlatformerOcean_Platformers] == 0 then
            call TimerStart(PlatformerOcean__Timer, PlatformerOcean_TIMESTEP, true, function PlatformerOcean__Loop_Init)
        endif
        call sc__SimpleList_List_add(PlatformerOcean_Platformers,p)
    endfunction
    
    function PlatformerOcean_Remove takes integer p returns nothing
        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Ocean removing platformer " + I2S(p) + " count " + I2S(Platformers.count))
        
        call sc__SimpleList_List_remove(PlatformerOcean_Platformers,p)
        if s__SimpleList_List_count[PlatformerOcean_Platformers] == 0 then
            call PauseTimer(PlatformerOcean__Timer)
        endif
    endfunction
    
    function PlatformerOcean__Init takes nothing returns nothing
        set PlatformerOcean_Platformers=sc__SimpleList_List_create()
        set PlatformerOcean__Timer=CreateTimer()
    endfunction

//library PlatformerOcean ends
//library PlatformerTerrainEffectGlobals:

//library PlatformerTerrainEffectGlobals ends
//library RelayPatternSpawn:
		//public RelayTurn SpawnTurn
		
  function s__RelayPatternSpawn_create takes integer spawnCB,integer cycleCount,integer parent returns integer
   local integer new= s__PatternSpawn_create(spawnCB , cycleCount)
			set s__RelayPatternSpawn_Pattern[new]=new
			set s__RelayPatternSpawn_Parent[new]=parent
			//set new.SpawnTurn = RelayTurn(parent.Turns.first.value)
			
			return new
  endfunction

//library RelayPatternSpawn ends
//library TerrainHelpers:
    
    function TerrainHelpers_IsValidTerrain takes integer ttype returns boolean
        return ttype != ABYSS and ttype != LAVA and ttype != PLATFORMING
    endfunction
    
    function TerrainHelpers_IsValidTerrain_Standard takes integer ttype returns boolean
        return ttype != ABYSS and ttype != PLATFORMING
    endfunction
    
    function TerrainHelpers_IsValidTerrain_Platforming takes integer ttype returns boolean
        return ttype != LAVA and ttype != PLATFORMING
    endfunction
        
    function TerrainHelpers_NoStaticUnits takes real x,real y returns boolean
        local integer uTypeId
        local boolean flag
        local unit u
        
        local real dx
        local real dy
        local real dist
        
        call GroupEnumUnitsInRange(TerrainHelpers___NearbyUnits, x, y, CollisLrgRadius, null)
        
        loop
        set u=FirstOfGroup(TerrainHelpers___NearbyUnits)
        exitwhen u == null
            set uTypeId=GetUnitTypeId(FirstOfGroup(TerrainHelpers___NearbyUnits))
            if ( uTypeId == REGRET or uTypeId == GUILT or uTypeId == LMEMORY or uTypeId == BFIRE or uTypeId == RFIRE or uTypeId == GFIRE ) then
                //check if within range
                set dx=x - GetUnitX(u)
                set dy=y - GetUnitY(u)
                set dist=SquareRoot(dx * dx + dy * dy)
                
                if ( uTypeId == REGRET and dist < 43 ) or ( uTypeId == LMEMORY and dist < 57 ) or ( uTypeId == GUILT and dist < 120 ) or ( uTypeId == BFIRE and dist < 80 ) or ( uTypeId == RFIRE and dist < 80 ) or ( uTypeId == GFIRE and dist < 80 ) then
                    call GroupClear(TerrainHelpers___NearbyUnits)
                    set u=null
                    
                    return false
                endif
            endif
        call GroupRemoveUnit(TerrainHelpers___NearbyUnits, u)
        endloop
        
        set u=null
        return true
    endfunction
	
 function GetDistanceFromTile takes real tileCenterX,real tileCenterY,real x,real y returns real
		//  var dx = Math.max(rect.min.x - p.x, 0, p.x - rect.max.x);
		//	var dy = Math.max(rect.min.y - p.y, 0, p.y - rect.max.y);
		//	return Math.sqrt(dx*dx + dy*dy);
  local real dx= tileCenterX - TERRAIN_QUADRANT_SIZE - x
  local real dy= tileCenterY - TERRAIN_QUADRANT_SIZE - y
		
		if dx < 0 then
			set dx=0
		endif
		if dx < x - tileCenterX - TERRAIN_QUADRANT_SIZE then
			set dx=x - tileCenterX - TERRAIN_QUADRANT_SIZE
		endif
		
		if dy < 0 then
			set dy=0
		endif
		if dy < y - tileCenterY - TERRAIN_QUADRANT_SIZE then
			set dy=y - tileCenterY - TERRAIN_QUADRANT_SIZE
		endif
		
		return SquareRoot(dx * dx + dy * dy)
	endfunction
	    
    function TerrainHelpers_TryGetFirstSafeLocation takes real x,real y,integer maxRadius,integer prevGameMode returns integer
        local integer iSide
        local integer iRadius
								
  local integer tileCenter
		
  local real checkDistance
  local real bestDistance= 10000
  local integer bestCenter= 0
                
        //handle radius 1 separately
        if TerrainHelpers_NoStaticUnits(x , y) and ( ( ( prevGameMode == Teams_GAMEMODE_STANDARD or prevGameMode == Teams_GAMEMODE_STANDARD_PAUSED ) and TerrainHelpers_IsValidTerrain_Standard(GetTerrainType(x, y)) ) or ( ( prevGameMode == Teams_GAMEMODE_PLATFORMING or prevGameMode == Teams_GAMEMODE_PLATFORMING_PAUSED ) and TerrainHelpers_IsValidTerrain_Platforming(GetTerrainType(x, y)) ) ) then
            return s__vector2_create(x , y)
        endif
		
		//get x,y tile center, to define other nearby tiles and check the distance between them and x,y
        set tileCenter=GetTerrainCenterpoint(x , y)
		
        set iRadius=2
        loop
        exitwhen iRadius > maxRadius
            //check the two long sides
            set iSide=1
            loop
            exitwhen iSide > iRadius * 2 - 1
                //debug call CreateUnit(Player(0), WWWISP, x - 128 * iRadius + 128 * iSide, y + 128 * (iRadius - 1), 0)
                //debug call CreateUnit(Player(1), WWWISP, x - 128 * iRadius + 128 * iSide, y - 128 * (iRadius - 1), 0)
                
                if TerrainHelpers_NoStaticUnits(x - 128 * iRadius + 128 * iSide , y + 128 * ( iRadius - 1 )) and ( ( ( prevGameMode == Teams_GAMEMODE_STANDARD or prevGameMode == Teams_GAMEMODE_STANDARD_PAUSED ) and TerrainHelpers_IsValidTerrain_Standard(GetTerrainType(x - 128 * iRadius + 128 * iSide, y + 128 * ( iRadius - 1 ))) ) or ( ( prevGameMode == Teams_GAMEMODE_PLATFORMING or prevGameMode == Teams_GAMEMODE_PLATFORMING_PAUSED ) and TerrainHelpers_IsValidTerrain_Platforming(GetTerrainType(x - 128 * iRadius + 128 * iSide, y + 128 * ( iRadius - 1 ))) ) ) then
                    //get the distance between the check center and previous best center
					set checkDistance=GetDistanceFromTile(s__vector2_x[tileCenter] - 128 * iRadius + 128 * iSide , s__vector2_y[tileCenter] + 128 * ( iRadius - 1 ) , x , y)
					if checkDistance < bestDistance then
						set bestDistance=checkDistance
						
						if bestCenter != 0 then
							call s__vector2_deallocate(bestCenter)
						endif
						set bestCenter=s__vector2_create(s__vector2_x[tileCenter] - 128 * iRadius + 128 * iSide , s__vector2_y[tileCenter] + 128 * ( iRadius - 1 ))
					endif
                endif
				
				if TerrainHelpers_NoStaticUnits(x - 128 * iRadius + 128 * iSide , y - 128 * ( iRadius - 1 )) and ( ( ( prevGameMode == Teams_GAMEMODE_STANDARD or prevGameMode == Teams_GAMEMODE_STANDARD_PAUSED ) and TerrainHelpers_IsValidTerrain_Standard(GetTerrainType(x - 128 * iRadius + 128 * iSide, y - 128 * ( iRadius - 1 ))) ) or ( ( prevGameMode == Teams_GAMEMODE_PLATFORMING or prevGameMode == Teams_GAMEMODE_PLATFORMING_PAUSED ) and TerrainHelpers_IsValidTerrain_Platforming(GetTerrainType(x - 128 * iRadius + 128 * iSide, y - 128 * ( iRadius - 1 ))) ) ) then
                    set checkDistance=GetDistanceFromTile(s__vector2_x[tileCenter] - 128 * iRadius + 128 * iSide , s__vector2_y[tileCenter] - 128 * ( iRadius - 1 ) , x , y)
					if checkDistance < bestDistance then
						set bestDistance=checkDistance
						
						if bestCenter != 0 then
							call s__vector2_deallocate(bestCenter)
						endif
						set bestCenter=s__vector2_create(s__vector2_x[tileCenter] - 128 * iRadius + 128 * iSide , s__vector2_y[tileCenter] - 128 * ( iRadius - 1 ))
					endif
                endif
            set iSide=iSide + 1
            endloop
                        
            //check the two short sides
            set iSide=1
            loop
            exitwhen iSide > iRadius * 2 - 3
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "placing y: " + R2S(y - 128 * (iRadius - 1) + 128 * iSide))
                //debug call CreateUnit(Player(2), WWWISP, x + 128 * (iRadius - 1), y - 128 * (iRadius - 1) + 128 * iSide, 0)
                //debug call CreateUnit(Player(3), WWWISP, x - 128 * (iRadius - 1), y - 128 * (iRadius - 1) + 128 * iSide, 0)                
                if TerrainHelpers_NoStaticUnits(x + 128 * ( iRadius - 1 ) , y - 128 * ( iRadius - 1 ) + 128 * iSide) and ( ( ( prevGameMode == Teams_GAMEMODE_STANDARD or prevGameMode == Teams_GAMEMODE_STANDARD_PAUSED ) and TerrainHelpers_IsValidTerrain_Standard(GetTerrainType(x + 128 * ( iRadius - 1 ), y - 128 * ( iRadius - 1 ) + 128 * iSide)) ) or ( ( prevGameMode == Teams_GAMEMODE_PLATFORMING or prevGameMode == Teams_GAMEMODE_PLATFORMING_PAUSED ) and TerrainHelpers_IsValidTerrain_Platforming(GetTerrainType(x + 128 * ( iRadius - 1 ), y - 128 * ( iRadius - 1 ) + 128 * iSide)) ) ) then
                    set checkDistance=GetDistanceFromTile(s__vector2_x[tileCenter] + 128 * ( iRadius - 1 ) , s__vector2_y[tileCenter] - 128 * ( iRadius - 1 ) + 128 * iSide , x , y)
					if checkDistance < bestDistance then
						set bestDistance=checkDistance
						
						if bestCenter != 0 then
							call s__vector2_deallocate(bestCenter)
						endif
						set bestCenter=s__vector2_create(s__vector2_x[tileCenter] + 128 * ( iRadius - 1 ) , s__vector2_y[tileCenter] - 128 * ( iRadius - 1 ) + 128 * iSide)
					endif
                elseif TerrainHelpers_NoStaticUnits(x - 128 * ( iRadius - 1 ) , y - 128 * ( iRadius - 1 ) + 128 * iSide) and ( ( ( prevGameMode == Teams_GAMEMODE_STANDARD or prevGameMode == Teams_GAMEMODE_STANDARD_PAUSED ) and TerrainHelpers_IsValidTerrain_Standard(GetTerrainType(x - 128 * ( iRadius - 1 ), y - 128 * ( iRadius - 1 ) + 128 * iSide)) ) or ( ( prevGameMode == Teams_GAMEMODE_PLATFORMING or prevGameMode == Teams_GAMEMODE_PLATFORMING_PAUSED ) and TerrainHelpers_IsValidTerrain_Platforming(GetTerrainType(x - 128 * ( iRadius - 1 ), y - 128 * ( iRadius - 1 ) + 128 * iSide)) ) ) then
                    set checkDistance=GetDistanceFromTile(s__vector2_x[tileCenter] - 128 * ( iRadius - 1 ) , s__vector2_y[tileCenter] - 128 * ( iRadius - 1 ) + 128 * iSide , x , y)
					if checkDistance < bestDistance then
						set bestDistance=checkDistance
						
						if bestCenter != 0 then
							call s__vector2_deallocate(bestCenter)
						endif
						set bestCenter=s__vector2_create(s__vector2_x[tileCenter] - 128 * ( iRadius - 1 ) , s__vector2_y[tileCenter] - 128 * ( iRadius - 1 ) + 128 * iSide)
					endif
                endif
            set iSide=iSide + 1
            endloop
			
			//the best center for any single ring will be better than any best center in the next ring
			if bestCenter != 0 then
				call s__vector2_deallocate(tileCenter)
				return bestCenter
			endif
        set iRadius=iRadius + 1
        endloop
        
        //failed to find a safe location, return 0 and pass the buck
		call s__vector2_deallocate(tileCenter)
        return 0
    endfunction
    
    function TerrainHelpers_TryGetLastValidLocation takes real x,real y,real facing,integer prevGameMode returns integer
        local integer validPoint
        //first check the current position, maybe death was due to collision or some other natural means
        if TerrainHelpers_NoStaticUnits(x , y) and TerrainHelpers_IsValidTerrain(GetTerrainType(x, y)) then
            set validPoint=s__vector2_create(x , y)
        else
            //terrain check is very flexible so need to put revive somewhere more reachable
            //convert facing to radians, now that its needed
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "facing " + R2S(facing))
            
            set facing=facing * DEGREE_TO_RADIANS
            
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "facing " + R2S(facing))
            //debug call CreateUnit(Player(0), WWWISP, x + 128*Cos(facing), y + 128*Sin(facing), 0)
            
            //check if terrain opposite mazer's facing is not abyss
            if ( ( ( prevGameMode == Teams_GAMEMODE_STANDARD or prevGameMode == Teams_GAMEMODE_STANDARD_PAUSED ) and TerrainHelpers_IsValidTerrain_Standard(GetTerrainType(x - 128 * Cos(facing), y - 128 * Sin(facing))) ) or ( ( prevGameMode == Teams_GAMEMODE_PLATFORMING or prevGameMode == Teams_GAMEMODE_PLATFORMING_PAUSED ) and TerrainHelpers_IsValidTerrain_Platforming(GetTerrainType(x - 128 * Cos(facing), y - 128 * Sin(facing))) ) ) and TerrainHelpers_NoStaticUnits(x - 128 * Cos(facing) , y - 128 * Sin(facing)) then
                //debug call CreateUnit(Player(0), WWWISP, x, y, 0)
                set validPoint=GetTerrainCenterpoint(x - 128 * Cos(facing) , y - 128 * Sin(facing))
            else
                //not safe, so need to iterate all terrain tiles in area
                set validPoint=TerrainHelpers_TryGetFirstSafeLocation(x , y , 3 , prevGameMode)

                //check that a point was found
                if validPoint == 0 then
                    set validPoint=s__vector2_create(x , y)
                endif
            endif
        endif
        
        return validPoint
    endfunction

//library TerrainHelpers ends
//library UnitLocalVisibility:
 function SetUnitLocalOpacity takes unit u,integer playerID,integer opacity returns nothing
  local integer uInfo= GetUnitUserData(u)
		
		if GetLocalPlayer() == Player(playerID) then
			if uInfo != 0 and s__IndexedUnit_R[uInfo] != - 1 then
				call s__IndexedUnit_SetAlphaLocal(uInfo,opacity)
			else
				call SetUnitVertexColor(u, 255, 255, 255, opacity)
			endif
		endif
	endfunction
 function SetUnitLocalVisibility takes unit u,integer playerID,boolean visible returns nothing
  local integer uInfo= GetUnitUserData(u)
		
		if GetLocalPlayer() == Player(playerID) then
			if uInfo != 0 and s__IndexedUnit_R[uInfo] != - 1 then
				if visible then
					call s__IndexedUnit_SetAlphaLocal(uInfo,255)
				else
					call s__IndexedUnit_SetAlphaLocal(uInfo,0)
				endif
			else
				if visible then
					call SetUnitVertexColor(u, 255, 255, 255, 255)
				else
					call SetUnitVertexColor(u, 255, 255, 255, 0)
				endif
			endif
		endif
	endfunction

//library UnitLocalVisibility ends
//library MovementSpeedHelpers:
	//only so many units so not worth making these dynamically read a unit for values. might not even be possible for animation index
 function IsUnitAnimated takes integer unitID returns boolean
		return unitID == LGUARD or unitID == GUARD or unitID == ICETROLL or unitID == SPIRITWALKER or unitID == CLAWMAN or unitID == MAZER or unitID == CORVETTE or unitID == POLICECAR or unitID == FIRETRUCK or unitID == JEEP or unitID == PASSENGERCAR or unitID == TRUCK
	endfunction
 function GetWalkAnimationIndex takes integer unitID returns integer
		if unitID == LGUARD or unitID == GUARD then
			return 2
		elseif unitID == ICETROLL then
			return 8
		elseif unitID == SPIRITWALKER then
			return 2
		elseif unitID == CLAWMAN then
			return 8
		elseif unitID == MAZER then
			return 4
		elseif unitID == CORVETTE then
			return 1
		elseif unitID == FIRETRUCK then
			return 2
		elseif unitID == JEEP then
			return 2
		elseif unitID == PASSENGERCAR then
			return 3
		elseif unitID == POLICECAR then
			return 1
		elseif unitID == TRUCK then
			return 3
		else



			
			return 0
		endif
	endfunction
	//the existing GetUnitDefaultMoveSpeed native seems a little weird
 function GetDefaultMoveSpeed takes integer unitID returns real
		if unitID == LGUARD then
			return 140.
		elseif unitID == GUARD then
			return 270.
		elseif unitID == ICETROLL then
			return 230.
		elseif unitID == SPIRITWALKER then
			return 270.
		elseif unitID == CLAWMAN then
			return 270.
		elseif unitID == MAZER then
			return 320.
		elseif unitID == BOUNCER then
			return 200.
		elseif unitID == GRAVITY then
			return 100.
		elseif unitID == LBOUNCE or unitID == RBOUNCE or unitID == UBOUNCE or unitID == DBOUNCE then
			return 160.
		elseif unitID == SUPERSPEED then
			return 200.
		else



			
			return 0.
		endif
	endfunction

//library MovementSpeedHelpers ends
//library Recycle:
    
    
	
	
	//API for Recycle struct
 function Recycle_MakeUnit takes integer uID,real x,real y returns unit
        return sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, (uID))),x , y) // INLINED!!
    endfunction
    function Recycle_MakeUnitWithFacing takes integer uID,real x,real y,real angle returns unit
        return sc__Recycle_UnitRecycler_MakeWithFacing((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, (uID))),x , y , angle) // INLINED!!
    endfunction
	//TODO remove, basically useless, leaks when as useful as it can be
    function Recycle_MakeUnitForPlayer takes integer uID,real x,real y,player p returns unit
        local integer r= (LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, (uID))) // INLINED!!
        local unit u
        
        if s__Recycle_UnitRecycler_defaultOwner[r] == p then
            return sc__Recycle_UnitRecycler_Make(r,x , y)
        else
            set u=sc__Recycle_UnitRecycler_Make(r,x , y)
            call SetUnitOwner(u, p, true)
            return u
        endif
    endfunction
	
    function Recycle_ReleaseUnit takes unit u returns nothing
        call sc__Recycle_UnitRecycler_Release((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, (GetUnitTypeId(u)))),u) // INLINED!!
    endfunction
    
    function Recycle_MakeUnitAndPatrol takes integer uID,real x1,real y1,real x2,real y2 returns nothing
        call IssuePointOrder((sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((uID )))),(( x1 )*1.0) , (( y1)*1.0))), "patrol", x2, y2) // INLINED!!
    endfunction
    function Recycle_MakeUnitAndPatrolRect takes integer uID,rect r1,rect r2 returns nothing
        call IssuePointOrder((sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((uID )))),(( GetRectCenterX(r1) )*1.0) , (( GetRectCenterY(r1))*1.0))), "patrol", GetRectCenterX(r2), GetRectCenterY(r2)) // INLINED!!
    endfunction
    function Recycle_MakeUnitAndProjectRandom takes integer uID,rect create,real angle,real dist returns nothing
        local real x= GetRandomReal(GetRectMinX(create), GetRectMaxX(create))
        local real y= GetRandomReal(GetRectMinY(create), GetRectMaxY(create))
        //unit faces away from the direction it will travel
        local real moveAngleRad= angle / 180 * bj_PI
        
        call IssuePointOrder((sc__Recycle_UnitRecycler_MakeWithFacing((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((uID )))),(( x )*1.0) , (( y )*1.0) , (( angle + 180)*1.0))), "move", x + dist * Cos(moveAngleRad), y + dist * Sin(moveAngleRad)) // INLINED!!
    endfunction
    
		
        
		
        function s__Recycle_UnitRecycler_Preload takes integer this,integer count returns nothing
            local unit u
            local integer i= 0
            
            loop
            exitwhen i >= count
				set u=CreateUnit(s__Recycle_UnitRecycler_defaultOwner[this], s__Recycle_UnitRecycler_uID[this], Recycle_SAFE_X + s__Recycle_UnitRecycler_count[this], Recycle_SAFE_Y + this * Recycle___SAFE_TYPE_OFFSET + s__Recycle_UnitRecycler_count[this], s__Recycle_UnitRecycler_facing[this])
                call s__IndexedUnit_create(u)
				
                call UnitAddAbility(u, 'Aloc')

					call ShowUnit(u, false)




				
				call GroupAddUnit(s__Recycle_UnitRecycler_uStack[this], u)
				set s__Recycle_UnitRecycler_count[this]=s__Recycle_UnitRecycler_count[this] + 1
            set i=i + 1
            endloop
			
			set u=null
        endfunction
        
        function s__Recycle_UnitRecycler_destroy takes integer this returns nothing



			
			//call this.deallocate()
        endfunction
        function s__Recycle_UnitRecycler_create takes integer UID,real DefaultFacing,player Owner returns integer
            local integer new= s__Recycle_UnitRecycler_c
			set s__Recycle_UnitRecycler_c=s__Recycle_UnitRecycler_c + 1
            
            set s__Recycle_UnitRecycler_count[new]=0
			set s__Recycle_UnitRecycler_uStack[new]=CreateGroup()
            set s__Recycle_UnitRecycler_uID[new]=UID
            set s__Recycle_UnitRecycler_facing[new]=DefaultFacing
            set s__Recycle_UnitRecycler_defaultOwner[new]=Owner
            call SaveInteger(s__Recycle_UnitRecycler_Recyclers, 0, UID, new)
                        
            return new
        endfunction
		
		//ONLY WORKS FOR STATIC UNITS, IE PLACED AND THEN NEVER ORDERED
  function s__Recycle_UnitRecycler_MakeWithFacing takes integer this,real x,real y,real angle returns unit
   local unit u
			
			if s__Recycle_UnitRecycler_count[this] == 0 then
				call s__Recycle_UnitRecycler_Preload(this,Recycle_BUFFER_UNIT_COUNT)
			endif
			
			//pop the top unit off stack
			set u=FirstOfGroup(s__Recycle_UnitRecycler_uStack[this])
			call GroupRemoveUnit(s__Recycle_UnitRecycler_uStack[this], u)
			set s__Recycle_UnitRecycler_count[this]=s__Recycle_UnitRecycler_count[this] - 1
			

				call ShowUnit(u, true)


				call SetUnitPosition(u, x, y)
				call SetUnitX(u, x)
				call SetUnitY(u, y)




			call SetUnitFacing(u, angle)
			
			//call DisplayTextToForce(bj_FORCE_PLAYER[0], "recycling with n left:" + I2S(r.count))
			return u
        endfunction
        function s__Recycle_UnitRecycler_Make takes integer this,real x,real y returns unit
            local unit u
			
			if s__Recycle_UnitRecycler_count[this] == 0 then //either no recycler for unit type or no units in stack
                call s__Recycle_UnitRecycler_Preload(this,Recycle_BUFFER_UNIT_COUNT)
			endif
			
			//pop the top unit off stack
			set u=FirstOfGroup(s__Recycle_UnitRecycler_uStack[this])
			call GroupRemoveUnit(s__Recycle_UnitRecycler_uStack[this], u)
			set s__Recycle_UnitRecycler_count[this]=s__Recycle_UnitRecycler_count[this] - 1
			

				call ShowUnit(u, true)


				call SetUnitPosition(u, x, y)
				call SetUnitX(u, x)
				call SetUnitY(u, y)




			
			return u
        endfunction
		
        function s__Recycle_UnitRecycler_Release takes integer this,unit u returns nothing
			if GetUnitUserData(u) != 0 and s__DisposableUnit_IsUnitDisposable(u) then
				call s__DisposableUnit_dispose((GetUnitUserData(u)))
			endif
			
			if this == 0 or s__Recycle_UnitRecycler_count[this] == Recycle_MAX_SINGLE_INSTANCE_COUNT then
                //call DisplayTextToForce(bj_FORCE_PLAYER[0], "no recycler exists for uid: " + I2S(GetUnitTypeId(u)) + " " + I2S(Levels_ticker))
                call s__IndexedUnit_destroy((GetUnitUserData(u)))
				call RemoveUnit(u)
            else
                //call DisplayTextToForce(bj_FORCE_PLAYER[0], "releasing total stack size: " + I2S(r.count + 1) + " key: " + I2S(Levels_ticker))
				call GroupAddUnit(s__Recycle_UnitRecycler_uStack[this], u)
				set s__Recycle_UnitRecycler_count[this]=s__Recycle_UnitRecycler_count[this] + 1
                
				//to trust that blizzard setters check for a different value before setting...
				if GetOwningPlayer(u) != s__Recycle_UnitRecycler_defaultOwner[this] then
					call SetUnitOwner(u, s__Recycle_UnitRecycler_defaultOwner[this], true)
				endif
				// if GetUnitMoveSpeed(u) != GetDefaultMoveSpeed(GetUnitTypeId(u)) then
					// call SetUnitMoveSpeed(u, GetDefaultMoveSpeed(GetUnitTypeId(u)))
				// endif
				call SetUnitMoveSpeed(u, GetUnitDefaultMoveSpeed(u))
				call IssueImmediateOrder(u, "stop")
				//moving/hiding units via these functions results in buggy recycles
                //call SetUnitX(u, SAFE_X + r.count)
                //call SetUnitY(u, SAFE_Y + r.count)

					call ShowUnit(u, false)

				

					call SetUnitPosition(u, Recycle_SAFE_X + s__Recycle_UnitRecycler_count[this], Recycle_SAFE_Y + this * Recycle___SAFE_TYPE_OFFSET + s__Recycle_UnitRecycler_count[this])
					call SetUnitX(u, Recycle_SAFE_X + s__Recycle_UnitRecycler_count[this])
					call SetUnitY(u, Recycle_SAFE_Y + this * Recycle___SAFE_TYPE_OFFSET + s__Recycle_UnitRecycler_count[this])




            endif
        endfunction
		
  function s__Recycle_UnitRecycler_GetRecycler takes integer unitTypeID returns integer
			return LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, unitTypeID)
  endfunction
		
  function s__Recycle_UnitRecycler_onInit takes nothing returns nothing
            call s__Recycle_UnitRecycler_Preload(s__Recycle_UnitRecycler_create(LGUARD , 0 , Player(10)),25)
            call s__Recycle_UnitRecycler_Preload(s__Recycle_UnitRecycler_create(GUARD , 0 , Player(10)),25)
            
            call s__Recycle_UnitRecycler_Preload(s__Recycle_UnitRecycler_create(ICETROLL , 0 , Player(10)),25)
			
			call s__Recycle_UnitRecycler_Preload(s__Recycle_UnitRecycler_create(SPIRITWALKER , 0 , Player(10)),10)
			call s__Recycle_UnitRecycler_Preload(s__Recycle_UnitRecycler_create(CLAWMAN , 0 , Player(10)),10)
			
			call s__Recycle_UnitRecycler_Preload(s__Recycle_UnitRecycler_create(TANK , 0 , Player(10)),5)
			call s__Recycle_UnitRecycler_Preload(s__Recycle_UnitRecycler_create(TRUCK , 0 , Player(10)),10)
			call s__Recycle_UnitRecycler_Preload(s__Recycle_UnitRecycler_create(FIRETRUCK , 0 , Player(10)),10)
			call s__Recycle_UnitRecycler_Preload(s__Recycle_UnitRecycler_create(AMBULANCE , 0 , Player(10)),10)
			call s__Recycle_UnitRecycler_Preload(s__Recycle_UnitRecycler_create(CORVETTE , 0 , Player(10)),10)
			call s__Recycle_UnitRecycler_Preload(s__Recycle_UnitRecycler_create(PASSENGERCAR , 0 , Player(10)),10)
			call s__Recycle_UnitRecycler_Preload(s__Recycle_UnitRecycler_create(JEEP , 0 , Player(10)),10)
			call s__Recycle_UnitRecycler_Preload(s__Recycle_UnitRecycler_create(POLICECAR , 0 , Player(10)),10)
			
            call s__Recycle_UnitRecycler_Preload(s__Recycle_UnitRecycler_create(GRAVITY , 0 , Player(10)),3)
			
			call s__Recycle_UnitRecycler_Preload(s__Recycle_UnitRecycler_create(BOUNCER , 0 , Player(10)),10)
            call s__Recycle_UnitRecycler_Preload(s__Recycle_UnitRecycler_create(UBOUNCE , 90 , Player(11)),5)
            call s__Recycle_UnitRecycler_Preload(s__Recycle_UnitRecycler_create(LBOUNCE , 180 , Player(11)),5)
            call s__Recycle_UnitRecycler_Preload(s__Recycle_UnitRecycler_create(DBOUNCE , 270 , Player(11)),5)
            call s__Recycle_UnitRecycler_Preload(s__Recycle_UnitRecycler_create(RBOUNCE , 0 , Player(11)),5)
			
			call s__Recycle_UnitRecycler_Preload(s__Recycle_UnitRecycler_create(BLACKHOLE , 0 , Player(10)),3)
			
			call s__Recycle_UnitRecycler_Preload(s__Recycle_UnitRecycler_create(RFIRE , 0 , Player(11)),3)
			call s__Recycle_UnitRecycler_Preload(s__Recycle_UnitRecycler_create(BFIRE , 0 , Player(11)),3)
            
			call s__Recycle_UnitRecycler_create(BRICK , 0 , Player(10))
			call s__Recycle_UnitRecycler_create(GOLD_BRICK , 0 , Player(10))
			call s__Recycle_UnitRecycler_create(PADDLE , 0 , Player(10))
			
            call s__Recycle_UnitRecycler_create(WWWISP , 0 , Player(11)) //.Preload(10)
            
        endfunction

//library Recycle ends
//library SimpleList:
        
        
//Implemented from module Alloc:
		
		

			

		
		
  function s__SimpleList_ListNode_allocate takes nothing returns integer
   local integer this= s__SimpleList_ListNode_Alloc___recycler[0]
			


			
			if ( s__SimpleList_ListNode_Alloc___recycler[this] == 0 ) then
				set s__SimpleList_ListNode_Alloc___recycler[0]=this + 1
			else
				set s__SimpleList_ListNode_Alloc___recycler[0]=s__SimpleList_ListNode_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__SimpleList_ListNode_deallocate takes integer this returns nothing


			


			
			set s__SimpleList_ListNode_Alloc___recycler[this]=s__SimpleList_ListNode_Alloc___recycler[0]
			set s__SimpleList_ListNode_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__SimpleList_ListNode_Alloc___onInit takes nothing returns nothing
			set s__SimpleList_ListNode_Alloc___recycler[0]=1
  endfunction
    
                
//Implemented from module Alloc:
		
		

			

		
		
  function s__SimpleList_List_allocate takes nothing returns integer
   local integer this= s__SimpleList_List_Alloc___recycler[0]
			


			
			if ( s__SimpleList_List_Alloc___recycler[this] == 0 ) then
				set s__SimpleList_List_Alloc___recycler[0]=this + 1
			else
				set s__SimpleList_List_Alloc___recycler[0]=s__SimpleList_List_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__SimpleList_List_deallocate takes integer this returns nothing


			


			
			set s__SimpleList_List_Alloc___recycler[this]=s__SimpleList_List_Alloc___recycler[0]
			set s__SimpleList_List_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__SimpleList_List_Alloc___onInit takes nothing returns nothing
			set s__SimpleList_List_Alloc___recycler[0]=1
  endfunction
        
        function s__SimpleList_List_add takes integer this,integer value returns nothing
            local integer curHead= s__SimpleList_List_first[this]
            
            set s__SimpleList_List_first[this]=s__SimpleList_ListNode_allocate()
            set s__SimpleList_ListNode_value[s__SimpleList_List_first[this]]=value
            
            set s__SimpleList_ListNode_prev[s__SimpleList_List_first[this]]=0
            set s__SimpleList_ListNode_next[s__SimpleList_List_first[this]]=curHead
            
            if curHead != 0 then
                set s__SimpleList_ListNode_prev[curHead]=s__SimpleList_List_first[this]
            else
                set s__SimpleList_List_last[this]=s__SimpleList_List_first[this]
            endif
            
            set s__SimpleList_List_count[this]=s__SimpleList_List_count[this] + 1
        endfunction
        function s__SimpleList_List_addEnd takes integer this,integer value returns nothing
            local integer curEnd= s__SimpleList_List_last[this]
            
            set s__SimpleList_List_last[this]=s__SimpleList_ListNode_allocate()
            set s__SimpleList_ListNode_value[s__SimpleList_List_last[this]]=value
            
            set s__SimpleList_ListNode_next[s__SimpleList_List_last[this]]=0
            set s__SimpleList_ListNode_prev[s__SimpleList_List_last[this]]=curEnd
            
            if curEnd != 0 then
                set s__SimpleList_ListNode_next[curEnd]=s__SimpleList_List_last[this]
            else
                set s__SimpleList_List_first[this]=s__SimpleList_List_last[this]
            endif
            
            set s__SimpleList_List_count[this]=s__SimpleList_List_count[this] + 1
        endfunction
  function s__SimpleList_List_insert takes integer this,integer value,integer position returns nothing
   local integer curPosition= 0
   local integer curNode
   local integer newNode
			
			if position <= 0 or s__SimpleList_List_count[this] == 0 then
				call s__SimpleList_List_add(this,value)
			elseif position >= s__SimpleList_List_count[this] then
				call s__SimpleList_List_addEnd(this,value)
			else
				set curNode=s__SimpleList_List_first[this]
				loop
				exitwhen curPosition == position
					
				set curNode=s__SimpleList_ListNode_next[curNode]
				set curPosition=curPosition + 1
				endloop
				
				set newNode=s__SimpleList_ListNode_allocate()
				set s__SimpleList_ListNode_value[newNode]=value
				set s__SimpleList_ListNode_prev[newNode]=s__SimpleList_ListNode_prev[curNode]
				set s__SimpleList_ListNode_next[newNode]=curNode
				
				set s__SimpleList_ListNode_prev[curNode]=newNode
				if s__SimpleList_ListNode_prev[newNode] != 0 then
					set s__SimpleList_ListNode_next[s__SimpleList_ListNode_prev[newNode]]=newNode
				endif
			endif
  endfunction
        
        //remove the first node and return it
		//remember to store or destroy the node when finished with it
        function s__SimpleList_List_pop takes integer this returns integer
            //store the node that's being popped
            local integer pop= s__SimpleList_List_first[this]
            
            //check if popping an empty list
			if pop != 0 then
				//update the first node to the second node
				set s__SimpleList_List_first[this]=s__SimpleList_ListNode_next[pop]
				set s__SimpleList_List_count[this]=s__SimpleList_List_count[this] - 1
				
				if s__SimpleList_List_count[this] == 0 then
					set s__SimpleList_List_last[this]=0
				else
					set s__SimpleList_ListNode_prev[s__SimpleList_List_first[this]]=0
				endif
			endif
                        
            return pop
        endfunction
  function s__SimpleList_List_get takes integer this,integer index returns integer
   local integer cur
            local integer i= 0
			
			if i >= s__SimpleList_List_count[this] then
				return 0
			else
				set cur=s__SimpleList_List_first[this]
				
				loop
				exitwhen i == index
				set i=i + 1
				set cur=s__SimpleList_ListNode_next[cur]
				endloop
				
				return cur
			endif
  endfunction
		
        function s__SimpleList_List_remove takes integer this,integer value returns nothing
            local integer cur= s__SimpleList_List_first[this]
            
            loop
            exitwhen cur == 0
                if s__SimpleList_ListNode_value[cur] == value then
                    if s__SimpleList_ListNode_next[cur] != 0 then
                        set s__SimpleList_ListNode_prev[s__SimpleList_ListNode_next[cur]]=s__SimpleList_ListNode_prev[cur]
                    else
                        set s__SimpleList_List_last[this]=s__SimpleList_ListNode_prev[cur]
                    endif
                    
                    if s__SimpleList_ListNode_prev[cur] != 0 then
                        set s__SimpleList_ListNode_next[s__SimpleList_ListNode_prev[cur]]=s__SimpleList_ListNode_next[cur]
                    else
                        set s__SimpleList_List_first[this]=s__SimpleList_ListNode_next[cur]
                    endif
                    
                    call s__SimpleList_ListNode_deallocate(cur)
                    
                    set s__SimpleList_List_count[this]=s__SimpleList_List_count[this] - 1
                    
                    return
                endif
            set cur=s__SimpleList_ListNode_next[cur]
            endloop
        endfunction
        function s__SimpleList_List_removeNode takes integer this,integer node returns nothing
            if s__SimpleList_ListNode_next[node] != 0 then
                set s__SimpleList_ListNode_prev[s__SimpleList_ListNode_next[node]]=s__SimpleList_ListNode_prev[node]
            else
                set s__SimpleList_List_last[this]=s__SimpleList_ListNode_prev[node]
            endif
            
            if s__SimpleList_ListNode_prev[node] != 0 then
                set s__SimpleList_ListNode_next[s__SimpleList_ListNode_prev[node]]=s__SimpleList_ListNode_next[node]
            else
                set s__SimpleList_List_first[this]=s__SimpleList_ListNode_next[node]
            endif
            
            call s__SimpleList_ListNode_deallocate(node)
            
            set s__SimpleList_List_count[this]=s__SimpleList_List_count[this] - 1
        endfunction
        function s__SimpleList_List_clear takes integer this returns nothing
            local integer cur
            
            //de-allocate all nodes in the list
            if s__SimpleList_List_count[this] > 0 then
                set cur=s__SimpleList_List_first[this]
                
                loop
                exitwhen s__SimpleList_ListNode_next[cur] == 0
                    set cur=s__SimpleList_ListNode_next[cur]
                    call s__SimpleList_ListNode_deallocate(s__SimpleList_ListNode_prev[cur])
                endloop
                
                call s__SimpleList_ListNode_deallocate(cur)
            endif
            
            //reset list properties
            set s__SimpleList_List_first[this]=0
            set s__SimpleList_List_last[this]=0
            set s__SimpleList_List_count[this]=0
        endfunction
        
//        public method insertAt takes integer value, integer position returns nothing
//            //TODO add an optional static table to make insert at efficient
//            
//            
//        endmethod
//        
        function s__SimpleList_List_contains takes integer this,integer value returns boolean
            local integer cur= s__SimpleList_List_first[this]
            
            loop
            exitwhen cur == 0
                if s__SimpleList_ListNode_value[cur] == value then
                    return true
                endif
            set cur=s__SimpleList_ListNode_next[cur]
            endloop
            
            return false
        endfunction
        function s__SimpleList_List_index takes integer this,integer value returns integer
            local integer cur= s__SimpleList_List_first[this]
            local integer i= 0
            
            loop
            exitwhen cur == 0
                if s__SimpleList_ListNode_value[cur] == value then
                    return i
                endif
            set i=i + 1
            set cur=s__SimpleList_ListNode_next[cur]
            endloop
            
            return - 1
        endfunction
        
        function s__SimpleList_List_checkCircular takes integer this returns boolean
            local integer cur
            
            if s__SimpleList_List_first[this] != 0 and s__SimpleList_ListNode_next[s__SimpleList_List_first[this]] != 0 then
                set cur=s__SimpleList_ListNode_next[s__SimpleList_List_first[this]]
                
                loop
                exitwhen cur == 0
                    if cur == s__SimpleList_List_first[this] then
                        return true
                    endif
                set cur=s__SimpleList_ListNode_next[cur]
                endloop
            endif
            
            return false
        endfunction
        function s__SimpleList_List_print takes integer this,integer pID returns nothing
            local integer cur
            if s__SimpleList_List_count[this] == 0 then
                call DisplayTextToPlayer(Player(0), 0, 0, "Empty List with ID " + I2S(this))
            else
                if s__SimpleList_List_checkCircular(this) then
                    call DisplayTextToPlayer(Player(0), 0, 0, "Circular List with ID " + I2S(this))
                else
                    call DisplayTextToPlayer(Player(0), 0, 0, "List with ID " + I2S(this))
                    
                    set cur=s__SimpleList_List_first[this]
                    loop
                    exitwhen cur == 0
                        call DisplayTextToPlayer(Player(0), 0, 0, I2S(cur) + ": " + I2S(s__SimpleList_ListNode_value[cur]))
                    set cur=s__SimpleList_ListNode_next[cur]
                    endloop
                endif
            endif
        endfunction
        
        function s__SimpleList_List_destroy takes integer this returns nothing
            call s__SimpleList_List_clear(this)
            call s__SimpleList_List_deallocate(this)
        endfunction
        
        function s__SimpleList_List_create takes nothing returns integer
            local integer new= s__SimpleList_List_allocate()
            
            set s__SimpleList_List_count[new]=0
            set s__SimpleList_List_first[new]=0
            set s__SimpleList_List_last[new]=0
            
            return new
        endfunction
	
	
	//Used to cache a stable-state list into something that can be accessed by index in constant time
	//this is a fragile design
	//indexes a list's state on create. does NOT update index as the list changes, since i can't imagine needing a dynamic indexed list for my scope -- its pretty much only useful for optimizing stable-state lists into something cacheable
	//because this extends the base lists ID, you can only have one index per list. creating more will just leak the originals

  function s__IndexedListNode_create takes integer node,integer dex returns integer
			set s__IndexedListNode_index[(node)]=dex
			set s__IndexedListNode_base[(node)]=node
			
			return node
  endfunction
 function SimpleList_IndexList takes integer list returns integer
  local integer curNode= s__SimpleList_List_first[list]
  local integer curNodeIndex= 0
  local integer indexedList= s__Table_create()
		
		loop
		exitwhen curNode == 0
			call SaveInteger(Table___ht, (indexedList), (curNodeIndex), ( s__IndexedListNode_create(curNode , curNodeIndex))) // INLINED!!
		set curNodeIndex=curNodeIndex + 1
		set curNode=s__SimpleList_ListNode_next[curNode]
		endloop
		
		return indexedList
	endfunction
		
  function s__IndexedList__getindex takes integer this,integer index returns integer
			return (LoadInteger(Table___ht, (s__IndexedList_indexedNodes[this]), (index))) // INLINED!!
  endfunction
		






		
  function s__IndexedList_create takes integer list returns integer
   local integer new= list
			set s__IndexedList_indexedNodes[new]=SimpleList_IndexList(list)
			set s__IndexedList_base[new]=list
			
			return new
  endfunction
  function s__IndexedList_destroy takes integer this returns nothing
			call s__Table_destroy(s__IndexedList_indexedNodes[this])
			
			call s__SimpleList_List_destroy((this))
  endfunction

//library SimpleList ends
//library SpecialEffect:
	
		
//Implemented from module Alloc:
		
		

			

		
		
  function s__TimedEffect_allocate takes nothing returns integer
   local integer this= s__TimedEffect_Alloc___recycler[0]
			


			
			if ( s__TimedEffect_Alloc___recycler[this] == 0 ) then
				set s__TimedEffect_Alloc___recycler[0]=this + 1
			else
				set s__TimedEffect_Alloc___recycler[0]=s__TimedEffect_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__TimedEffect_deallocate takes integer this returns nothing


			


			
			set s__TimedEffect_Alloc___recycler[this]=s__TimedEffect_Alloc___recycler[0]
			set s__TimedEffect_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__TimedEffect_Alloc___onInit takes nothing returns nothing
			set s__TimedEffect_Alloc___recycler[0]=1
  endfunction
		
  function s__TimedEffect_OnExpire takes nothing returns nothing
   local timer t= GetExpiredTimer()
   local integer te= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
			
			call DestroyEffect(s__TimedEffect_Effect[te])
			set s__TimedEffect_Effect[te]=null
			
			call s__TimedEffect_deallocate(te)
			call ReleaseTimer(t)
			set t=null
  endfunction
		
  function s__TimedEffect_createForTarget takes string fxFileLocation,widget targetWidget,string attachPointName,player viewer,real duration returns integer
   local integer new= s__TimedEffect_allocate()
			









				set s__TimedEffect_Effect[new]=AddSpecialEffectTarget(fxFileLocation, targetWidget, attachPointName)

			
			call TimerStart(NewTimerEx(new), duration, false, function s__TimedEffect_OnExpire)
			
			return new
  endfunction
  function s__TimedEffect_create takes string fxFileLocation,real x,real y,player viewer,real duration returns integer
   local integer new= s__TimedEffect_allocate()
			









				set s__TimedEffect_Effect[new]=AddSpecialEffect(fxFileLocation, x, y)

			
			call TimerStart(NewTimerEx(new), duration, false, function s__TimedEffect_OnExpire)
			
			return new
  endfunction
	
		
  function s__UserActiveTimedEffect_OnExpire takes nothing returns nothing
   local timer t= GetExpiredTimer()
   local integer te= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
			
			if s__User_ActiveEffect[s__UserActiveTimedEffect_Viewer[te]] != null then
				call DestroyEffect(s__User_ActiveEffect[s__UserActiveTimedEffect_Viewer[te]])
				set s__TimedEffect_Effect[(te)]=null
				set s__User_ActiveEffect[s__UserActiveTimedEffect_Viewer[te]]=null
			endif
			
			call s__TimedEffect_deallocate((te))
			call ReleaseTimer(t)
			set t=null
  endfunction
		
  function s__UserActiveTimedEffect_create takes string fxFileLocation,string attachPointName,integer viewer,real duration returns integer
   local integer new= s__TimedEffect_allocate()
			
			set s__UserActiveTimedEffect_Viewer[(new)]=viewer
			
			if s__User_ActiveEffect[viewer] != null then
				call DestroyEffect(s__User_ActiveEffect[viewer])
			endif
			









				set s__TimedEffect_Effect[new]=AddSpecialEffectTarget(fxFileLocation, s__User_ActiveUnit[viewer], attachPointName)

			
			//call UserActiveTimedEffect(new).Viewer.SetActiveEffectEx(new.Effect)
			set s__User_ActiveEffect[viewer]=s__TimedEffect_Effect[new]
			
			call TimerStart(NewTimerEx(new), duration, false, function s__UserActiveTimedEffect_OnExpire)
			
			return new
  endfunction
	
 function CreateSpecialEffect takes string fxFileLocation,real x,real y,player viewer returns effect









			return AddSpecialEffect(fxFileLocation, x, y)

	endfunction
 function CreateSpecialEffectTarget takes string fxFileLocation,widget targetWidget,string attachPointName,player viewer returns effect









			return AddSpecialEffectTarget(fxFileLocation, targetWidget, attachPointName)

	endfunction
	
 function CreateTimedSpecialEffect takes string fxFileLocation,real x,real y,player viewer,real duration returns effect
		return s__TimedEffect_Effect[s__TimedEffect_create(fxFileLocation , x , y , viewer , duration)]
	endfunction
 function CreateTimedSpecialEffectTarget takes string fxFileLocation,widget targetWidget,string attachPointName,player viewer,real duration returns effect
		return s__TimedEffect_Effect[s__TimedEffect_createForTarget(fxFileLocation , targetWidget , attachPointName , viewer , duration)]
	endfunction
		
 function CreateInstantSpecialEffect takes string fxFileLocation,real x,real y,player viewer returns nothing









			call DestroyEffect(AddSpecialEffect(fxFileLocation, x, y))

	endfunction
 function CreateInstantSpecialEffectTarget takes string fxFileLocation,widget targetWidget,string attachPointName,player viewer returns nothing









			call DestroyEffect(AddSpecialEffectTarget(fxFileLocation, targetWidget, attachPointName))

	endfunction

//library SpecialEffect ends
//library BoundedSpoke:
        
        
        
        
        
        
  function s__BoundedSpoke_Print takes integer this returns nothing
			call DisplayTextToForce(bj_FORCE_PLAYER[0], "Min angle: " + R2S(s__BoundedSpoke_MinAngle[this]) + ", Max angle: " + R2S(s__BoundedSpoke_MaxAngle[this]))
  endfunction
		
        function s__BoundedSpoke_Rotate takes integer this returns nothing
            local integer wUnitNode= s__SimpleList_List_first[s__BoundedSpoke_Units[this]]
            
            //R2I translates to Math.floor
            local integer iLayer= 0
            local real x
            local real y
            
            local real theta= s__BoundedSpoke_CurrentAngle[this] + s__BoundedSpoke_CurrentRotationSpeed[this]
            
			if s__BoundedSpoke_MaxAngle[this] != 0 then
				if theta >= s__BoundedSpoke_MaxAngle[this] then
					set s__BoundedSpoke_CurrentAngle[this]=s__BoundedSpoke_MaxAngle[this]
					
					set s__BoundedSpoke_CurrentRotationSpeed[this]=- s__BoundedSpoke_CurrentRotationSpeed[this]
					set theta=s__BoundedSpoke_CurrentAngle[this] + s__BoundedSpoke_CurrentRotationSpeed[this]
				elseif theta <= s__BoundedSpoke_MinAngle[this] then
					set s__BoundedSpoke_CurrentAngle[this]=s__BoundedSpoke_MinAngle[this]
					
					set s__BoundedSpoke_CurrentRotationSpeed[this]=- s__BoundedSpoke_CurrentRotationSpeed[this]
					set theta=s__BoundedSpoke_CurrentAngle[this] + s__BoundedSpoke_CurrentRotationSpeed[this]
				endif
			endif
            
            loop
            exitwhen wUnitNode == 0
                if s__SimpleList_ListNode_value[wUnitNode] != 0 then
                    set x=s__vector2_x[s__BoundedSpoke_Center[this]] + s__BoundedSpoke_InitialOffset[this] * Cos(theta) + iLayer * s__BoundedSpoke_LayerOffset[this] * Cos(theta)
                    set y=s__vector2_y[s__BoundedSpoke_Center[this]] + s__BoundedSpoke_InitialOffset[this] * Sin(theta) + iLayer * s__BoundedSpoke_LayerOffset[this] * Sin(theta)
                    
                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "x: " + R2S(x))
                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "y: " + R2S(y))
                    
                    call SetUnitPosition(s__IndexedUnit_Unit[(s__SimpleList_ListNode_value[wUnitNode])], x, y)
                endif
                
            set iLayer=iLayer + 1
            set wUnitNode=s__SimpleList_ListNode_next[wUnitNode]
            endloop
            
            set s__BoundedSpoke_CurrentAngle[this]=s__BoundedSpoke_CurrentAngle[this] + s__BoundedSpoke_CurrentRotationSpeed[this]
            if s__BoundedSpoke_CurrentAngle[this] >= 2 * bj_PI then
                set s__BoundedSpoke_CurrentAngle[this]=s__BoundedSpoke_CurrentAngle[this] - 2 * bj_PI
            endif
        endfunction
        
        function s__BoundedSpoke_Periodic takes nothing returns nothing
            local integer curSpoke= s__SimpleList_List_first[s__BoundedSpoke_ActiveSpokes]
            
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Wheel periodic!")
            
            loop
            exitwhen curSpoke == 0
                call s__BoundedSpoke_Rotate((s__SimpleList_ListNode_value[curSpoke]))
            set curSpoke=s__SimpleList_ListNode_next[curSpoke]
            endloop
        endfunction
        
        function s__BoundedSpoke_Stop takes integer this returns nothing
            call s__SimpleList_List_remove(s__BoundedSpoke_ActiveSpokes,this)
            
            if s__SimpleList_List_count[s__BoundedSpoke_ActiveSpokes] == 0 then
                call PauseTimer(s__BoundedSpoke_Timer)
            endif
            
            //TODO hide all wheel units
        endfunction
        
        function s__BoundedSpoke_Start takes integer this returns nothing
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Starting wheel")
            
            if s__SimpleList_List_count[s__BoundedSpoke_ActiveSpokes] == 0 then
                call TimerStart(s__BoundedSpoke_Timer, BoundedSpoke_TIMESTEP, true, function s__BoundedSpoke_Periodic)
            endif
            
            call s__SimpleList_List_addEnd(s__BoundedSpoke_ActiveSpokes,this)
            
            //TODO show all wheel units
        endfunction
        
        //adds units to spokes
        function s__BoundedSpoke_AddUnits takes integer this,integer unitID,integer count returns nothing
            local integer iUnit= 0
   local unit u
            
            //R2I translates to Math.floor
            local integer iLayer
            local real x
            local real y
            
            local real theta
            
            loop
            exitwhen iUnit >= count
                set iLayer=s__SimpleList_List_count[s__BoundedSpoke_Units[this]]
                                
                set x=s__vector2_x[s__BoundedSpoke_Center[this]] + s__BoundedSpoke_InitialOffset[this] * Cos(s__BoundedSpoke_CurrentAngle[this]) + iLayer * s__BoundedSpoke_LayerOffset[this] * Cos(s__BoundedSpoke_CurrentAngle[this])
                set y=s__vector2_y[s__BoundedSpoke_Center[this]] + s__BoundedSpoke_InitialOffset[this] * Sin(s__BoundedSpoke_CurrentAngle[this]) + iLayer * s__BoundedSpoke_LayerOffset[this] * Sin(s__BoundedSpoke_CurrentAngle[this])
                
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "x: " + R2S(x))
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "y: " + R2S(y))
                
                set u=CreateUnit(BoundedSpoke_SPOKE_PLAYER, unitID, x, y, 0)
				call s__IndexedUnit_create(u)
                call AddUnitLocust(u)
                
                call s__SimpleList_List_addEnd(s__BoundedSpoke_Units[this],GetUnitUserData(u))
            set iUnit=iUnit + 1
            endloop
        endfunction
        
        function s__BoundedSpoke_AddEmptySpace takes integer this,integer count returns nothing
            local integer iUnit= 0
            loop
            exitwhen iUnit >= count
                call s__SimpleList_List_addEnd(s__BoundedSpoke_Units[this],0)
            set iUnit=iUnit + 1
            endloop
        endfunction
        
        function s__BoundedSpoke_SetAngleBounds takes integer this,real min,real max returns nothing
            set s__BoundedSpoke_MinAngle[this]=min
            set s__BoundedSpoke_MaxAngle[this]=max
            
            set s__BoundedSpoke_CurrentAngle[this]=min
        endfunction
        
        function s__BoundedSpoke_onInit takes nothing returns nothing
            set s__BoundedSpoke_ActiveSpokes=s__SimpleList_List_create()
            set s__BoundedSpoke_Timer=CreateTimer()
        endfunction
        
        function s__BoundedSpoke_create takes real x,real y returns integer
            local integer new= s__BoundedSpoke__allocate()
            
            set s__BoundedSpoke_Center[new]=s__vector2_create(x , y)
            
            set s__BoundedSpoke_InitialOffset[new]=0
            
            set s__BoundedSpoke_CurrentAngle[new]=0
            set s__BoundedSpoke_CurrentRotationSpeed[new]=BoundedSpoke___DEFAULT_ROTATION_SPEED
            set s__BoundedSpoke_MinAngle[new]=0
            set s__BoundedSpoke_MaxAngle[new]=0
            
            set s__BoundedSpoke_Units[new]=s__SimpleList_List_create()
            
            return new
        endfunction

//library BoundedSpoke ends
//library BoundedWheel:
        
        
        function s__BoundedWheel_Rotate takes integer this returns nothing
            local integer wUnitNode= s__SimpleList_List_first[s__Wheel_Units[this]]
            
            //R2I translates to Math.floor
            local integer iLayer= 0
            local integer iSpoke= 0
            local real x
            local real y
            
            local real theta= s__Wheel_CurrentAngle[this] + s__Wheel_RotationSpeed[this]
            
            if theta >= s__BoundedWheel_MaxAngle[this] then
                set s__Wheel_CurrentAngle[this]=s__BoundedWheel_MaxAngle[this]
                
                set s__Wheel_RotationSpeed[this]=- s__Wheel_RotationSpeed[this]
            elseif theta <= s__BoundedWheel_MinAngle[this] then
                set s__Wheel_CurrentAngle[this]=s__BoundedWheel_MinAngle[this]
                
                set s__Wheel_RotationSpeed[this]=- s__Wheel_RotationSpeed[this]
            endif
            
            loop
            exitwhen wUnitNode == 0
                if iSpoke == s__Wheel_SpokeCount[this] then
                    set iSpoke=0
                    set iLayer=iLayer + 1
                endif
                
                if s__SimpleList_ListNode_value[wUnitNode] != 0 then
                    set theta=s__Wheel_CurrentAngle[this] + iSpoke * s__Wheel_AngleBetween[this]
                    set x=s__vector2_x[s__Wheel_Center[this]] + s__Wheel_InitialOffset[this] * Cos(theta) + iLayer * s__Wheel_DistanceBetween[this] * Cos(theta)
                    set y=s__vector2_y[s__Wheel_Center[this]] + s__Wheel_InitialOffset[this] * Sin(theta) + iLayer * s__Wheel_DistanceBetween[this] * Sin(theta)
                    
                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "x: " + R2S(x))
                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "y: " + R2S(y))
                    
                    call SetUnitPosition(s__IndexedUnit_Unit[(s__SimpleList_ListNode_value[wUnitNode])], x, y)
                //else
                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Empty unit")
                endif
                
                
            set iSpoke=iSpoke + 1
            set wUnitNode=s__SimpleList_ListNode_next[wUnitNode]
            endloop
            
            set s__Wheel_CurrentAngle[this]=s__Wheel_CurrentAngle[this] + s__Wheel_RotationSpeed[this]
            if s__Wheel_CurrentAngle[this] >= 2 * bj_PI then
                set s__Wheel_CurrentAngle[this]=s__Wheel_CurrentAngle[this] - 2 * bj_PI
            endif
        endfunction
        
        function s__BoundedWheel_SetAngleBounds takes integer this,real min,real max returns nothing
            set s__BoundedWheel_MinAngle[this]=min
            set s__BoundedWheel_MaxAngle[this]=max
            
            set s__Wheel_CurrentAngle[this]=min
        endfunction
        
        function s__BoundedWheel_create takes real x,real y returns integer
            //calls super.create i think...
            local integer new= s__BoundedWheel__allocate(x , y)
            
            return new
        endfunction

//library BoundedWheel ends
//library BrickBreaker:
	
	
	
 function MakeBricks takes real x,real y,integer rowCount,integer columnCount,integer expectedGoldCount returns nothing
  local integer iRow= 0
  local boolean iRowEven
  local integer iColumn
		
  local integer rowGoldCount= 0
		
  local integer brickID
				
		loop
		exitwhen iRow == rowCount
			if rowCount > 2 then
				if iRow == 0 or iRow == rowCount - 1 then
					set rowGoldCount=expectedGoldCount
				else
					set rowGoldCount=0
				endif
			else
				if iRow == 0 then
					set rowGoldCount=0
				else
					set rowGoldCount=expectedGoldCount
				endif
			endif
			
			if ( iRow / 2 ) - ( iRow / 2. ) == 0 then
				set iRowEven=true
			else
				set iRowEven=false
			endif
			
			set iColumn=0
			loop
			if iRowEven then
			exitwhen iColumn == columnCount
			else
			exitwhen iColumn == columnCount - 1
			endif
			
				if rowGoldCount < expectedGoldCount then
					if iColumn != 0 and iColumn != columnCount - 1 and GetRandomInt(0, 2) == 0 then
						set brickID=GOLD_BRICK
						
						set rowGoldCount=rowGoldCount + 1
					else
						set brickID=BRICK
					endif
				else
					set brickID=BRICK
				endif
				
				if iRowEven then
call sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((brickID )))),(( x + iColumn * ( BRICK_WIDTH + BRICK_BUFFER ) )*1.0) , (( y - iRow * ( BRICK_HEIGHT + BRICK_BUFFER ))*1.0)) // INLINED!!
				else
call sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((brickID )))),(( x + BRICK_HALF_WIDTH + BRICK_HALF_BUFFER + iColumn * ( BRICK_WIDTH + BRICK_BUFFER ) )*1.0) , (( y - iRow * ( BRICK_HEIGHT + BRICK_BUFFER ))*1.0)) // INLINED!!
				endif
				
			set iColumn=iColumn + 1
			endloop
			
		set iRow=iRow + 1
		endloop
	endfunction
	
 function BrickBreakStart takes nothing returns nothing
		call MakeBricks(GetRectCenterX(gg_rct_BB_Bricks1) , GetRectCenterY(gg_rct_BB_Bricks1) , 5 , 7 , 2)
	endfunction
 function BrickBreakStop takes nothing returns nothing
	
	endfunction

//library BrickBreaker ends
//library Cinema:


//processed: function interface CinemaUserConditional takes User user returns boolean

//allows a single integer ID to lookup fields for the cinema's callback function (which only gives you a single int to work with)
    
//Implemented from module Alloc:
		
		

			

		
		
  function s__CinemaCallbackModel_allocate takes nothing returns integer
   local integer this= s__CinemaCallbackModel_Alloc___recycler[0]
			


			
			if ( s__CinemaCallbackModel_Alloc___recycler[this] == 0 ) then
				set s__CinemaCallbackModel_Alloc___recycler[0]=this + 1
			else
				set s__CinemaCallbackModel_Alloc___recycler[0]=s__CinemaCallbackModel_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__CinemaCallbackModel_deallocate takes integer this returns nothing


			


			
			set s__CinemaCallbackModel_Alloc___recycler[this]=s__CinemaCallbackModel_Alloc___recycler[0]
			set s__CinemaCallbackModel_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__CinemaCallbackModel_Alloc___onInit takes nothing returns nothing
			set s__CinemaCallbackModel_Alloc___recycler[0]=1
  endfunction
    
 function s__CinemaCallbackModel_EndCallbackStack takes integer this returns nothing
		//call DisplayTextToForce(bj_FORCE_PLAYER[0], "No more messages for CB Model " + I2S(cinemaCBModel))
		call s__SimpleList_List_add(s__Cinematic_PreviousViewers[s__CinemaCallbackModel_Cinematic[this]],s__CinemaCallbackModel_User[this])
		
		if s__Cinematic_PauseViewers[s__CinemaCallbackModel_Cinematic[this]] then
			call sc__User_Pause(s__CinemaCallbackModel_User[this],false)
		endif
		
		set EventCinematic=s__CinemaCallbackModel_Cinematic[this]
		set EventUser=s__CinemaCallbackModel_User[this]
		call s__Event_fire(s__Cinematic_OnCinemaEnd)
		
		call sc__CinemaCallbackModel_destroy(this)
 endfunction
 function s__CinemaCallbackModel_destroy takes integer this returns nothing
		//recycle cb model and its handle properties
		call ReleaseTimer(s__CinemaCallbackModel_Timer[this])
		set s__CinemaCallbackModel_Timer[this]=null
		call s__CinemaCallbackModel_deallocate(this)
 endfunction
	
    function s__CinemaCallbackModel_create takes integer cinematic,integer currentMessage,integer user,timer time returns integer
        local integer new= s__CinemaCallbackModel_allocate()
        
        set s__CinemaCallbackModel_Cinematic[new]=cinematic
        set s__CinemaCallbackModel_CurrentMessage[new]=currentMessage
        set s__CinemaCallbackModel_User[new]=user
		set s__CinemaCallbackModel_Timer[new]=time
        
        return new
    endfunction

        
//Implemented from module Alloc:
		
		

			

		
		
  function s__CinemaMessage_allocate takes nothing returns integer
   local integer this= s__CinemaMessage_Alloc___recycler[0]
			


			
			if ( s__CinemaMessage_Alloc___recycler[this] == 0 ) then
				set s__CinemaMessage_Alloc___recycler[0]=this + 1
			else
				set s__CinemaMessage_Alloc___recycler[0]=s__CinemaMessage_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__CinemaMessage_deallocate takes integer this returns nothing


			


			
			set s__CinemaMessage_Alloc___recycler[this]=s__CinemaMessage_Alloc___recycler[0]
			set s__CinemaMessage_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__CinemaMessage_Alloc___onInit takes nothing returns nothing
			set s__CinemaMessage_Alloc___recycler[0]=1
  endfunction
    
    function s__CinemaMessage_destroy takes integer this returns nothing
        set s__CinemaMessage_Source[this]=null
        set s__CinemaMessage_Text[this]=null
        
        call s__CinemaMessage_deallocate(this)
    endfunction
    
    function s__CinemaMessage_create takes unit source,string text,real time returns integer
        local integer new= s__CinemaMessage_allocate()
        
        set s__CinemaMessage_Source[new]=source
        set s__CinemaMessage_Text[new]=text
        set s__CinemaMessage_MessageTime[new]=time
		
		set s__CinemaMessage_NextMessageBuffer[new]=0
        
        return new
    endfunction

    
    //TODO move into CinemaMessage for at least equal, but ideally greater control
    //public CinemaCallback OnCinemaStart
    //public CinemaCallback OnCinemaEnd
    //public SimpleList_List OnCinemaEndCBs //list of integers representing a function interface -- can only recycle the list
    // public Event OnDestroy
    
//Implemented from module Alloc:
		
		

			

		
		
  function s__Cinematic_allocate takes nothing returns integer
   local integer this= s__Cinematic_Alloc___recycler[0]
			


			
			if ( s__Cinematic_Alloc___recycler[this] == 0 ) then
				set s__Cinematic_Alloc___recycler[0]=this + 1
			else
				set s__Cinematic_Alloc___recycler[0]=s__Cinematic_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__Cinematic_deallocate takes integer this returns nothing


			


			
			set s__Cinematic_Alloc___recycler[this]=s__Cinematic_Alloc___recycler[0]
			set s__Cinematic_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__Cinematic_Alloc___onInit takes nothing returns nothing
			set s__Cinematic_Alloc___recycler[0]=1
  endfunction
    
    function s__Cinematic_HasUserViewed takes integer this,integer user returns boolean
        local integer cur= s__SimpleList_List_first[s__Cinematic_PreviousViewers[this]]
        
        //check the cinematic's previous viewers
        loop
        exitwhen cur == 0
            if s__SimpleList_ListNode_value[cur] == user then
                return true
            endif
        set cur=s__SimpleList_ListNode_next[cur]
        endloop
        
        //check the user's currently playing cinematic
        if s__CinemaCallbackModel_Cinematic[s__User_CinematicPlaying[user]] == this then
            return true
        endif
        
        //check the user's cinematic queue
        set cur=s__SimpleList_List_first[s__User_CinematicQueue[user]]
        loop
        exitwhen cur == 0
            if s__SimpleList_ListNode_value[cur] == this then
                return true
            endif
        set cur=s__SimpleList_ListNode_next[cur]
        endloop
        
        return false
    endfunction
    
 function s__Cinematic_SetLastMessageBuffer takes integer this,real buffer returns nothing
		set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[this]]])]=buffer
 endfunction
 function s__Cinematic_SetLastMessageDefaults takes integer this returns nothing
		set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[(this)]]])]=((DEFAULT_CONVERSATION_BUFFER)*1.0) // INLINED!!
 endfunction
	
    function s__Cinematic_AddMessage takes integer this,unit u,string text,real timeout returns nothing
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[this],s__CinemaMessage_create(u , text , timeout))
    endfunction
 function s__Cinematic_AddMessageCustom takes integer this,integer message returns nothing
		call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[this],message)
 endfunction
    
    function s__Cinematic_PlayMessageCallback takes nothing returns nothing
        local timer t= GetExpiredTimer()
        local integer cinemaCBModel= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
        local real time
        local integer curEndCB
        
		//it would be safer to just store the timer and release it as part of EndCallbackStack
		if s__CinemaCallbackModel_CurrentMessage[cinemaCBModel] == 0 then
			//call DisplayTextToForce(bj_FORCE_PLAYER[0], "No more messages for CB Model " + I2S(cinemaCBModel))
			call s__CinemaCallbackModel_EndCallbackStack(cinemaCBModel)
		else
			set time=s__CinemaMessage_MessageTime[(s__SimpleList_ListNode_value[s__CinemaCallbackModel_CurrentMessage[cinemaCBModel]])]
			//add MESSAGE_ALIVE_BUFFER here instead of in the message's buffer because it's specifically for dealing with the DisplayMessage API adding in a default buffer
			call sc__User_DisplayMessage(s__CinemaCallbackModel_User[cinemaCBModel],s__CinemaMessage_Text[(s__SimpleList_ListNode_value[s__CinemaCallbackModel_CurrentMessage[cinemaCBModel]])] , time + MESSAGE_ALIVE_BUFFER)
			
			//add the message's display time to the buffer time between this message and the next
			//allows cinematics to show more than one message at once, while still controlling their display time
			set time=time + s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__CinemaCallbackModel_CurrentMessage[cinemaCBModel]])]
			if time < 0 then
				set time=0
			endif
			
			//finished current message in cinematic but there's still more
			set s__CinemaCallbackModel_CurrentMessage[cinemaCBModel]=s__SimpleList_ListNode_next[s__CinemaCallbackModel_CurrentMessage[cinemaCBModel]]
			//call SetTimerData(t, cinemaCBModel) //re-using same model, so original ID attached to timer is still applicable
			
			call TimerStart(t, time, false, function s__Cinematic_PlayMessageCallback)
		endif
        
        set t=null
    endfunction
    
    function s__Cinematic_CanUserActivate takes integer this,integer user returns boolean
        return not s__Cinematic_HasUserViewed(this,user) and sc__User_IsActiveUnitInRect(user,s__Cinematic_ActivationArea[this]) and ( s__Cinematic_ActivationCondition[this] == 0 or sc___prototype3_evaluate(s__Cinematic_ActivationCondition[this],user) )
    endfunction
    
    function s__Cinematic_Activate takes integer this,integer user returns integer
        local timer t= (NewTimerEx(0)) // INLINED!!
  local integer cbModel= s__CinemaCallbackModel_create(this , s__SimpleList_List_first[s__Cinematic_CinemaMessages[this]] , user , t)
        call SaveInteger(TimerUtils___ht, 0, GetHandleId((t )), ( cbModel)) // INLINED!!
        
        if s__Cinematic_PauseViewers[this] then
            call sc__User_Pause(user,true)
        endif
                
        call TimerStart(t, .0, false, function s__Cinematic_PlayMessageCallback)
        set t=null
		
		return cbModel
    endfunction
    
    function s__Cinematic_destroy takes integer this returns nothing
        local integer curCinemaMessage
        
        //alert any dependent functionality of the cinematic being destroyed
        // set EventCinematic = this
        // call .OnDestroy.fire()
        //right now, this is just the level, so hard-coding that dependency may be enough



		
		if s__Cinematic_ParentLevel[this] != 0 then
            call s__SimpleList_List_remove(s__Levels_Level_Cinematics[s__Cinematic_ParentLevel[this]],this)
        endif
        
        loop
        set curCinemaMessage=s__SimpleList_List_pop(s__Cinematic_CinemaMessages[this])
        exitwhen curCinemaMessage == 0
            call s__CinemaMessage_destroy((s__SimpleList_ListNode_value[curCinemaMessage]))
        endloop
        
        call s__SimpleList_List_destroy(s__Cinematic_PreviousViewers[this])
        call s__SimpleList_List_destroy(s__Cinematic_CinemaMessages[this])
        
        set s__Cinematic_ActivationArea[this]=null
        
        call s__Cinematic_deallocate(this)
    endfunction
    
    function s__Cinematic_CheckAllWatched takes nothing returns boolean
        local integer cinema= EventCinematic
        //call DisplayTextToForce(bj_FORCE_PLAYER[0], "Cinema count " + I2S(cinema.PreviousViewers.count) + ", active player count " + I2S(User.ActivePlayers))
        
        //if all players start watching the same cinematic, the first player to finish it will destroy the cine for everyone (since previous viewers includes current viewers)
        //could either move logic to check user cine queue + make prev viewers refer to those that have finished
        //OR just assume no cinematic will take longer than X seconds, and have a callback to destroy this cinematic then
        if s__SimpleList_List_count[s__Cinematic_PreviousViewers[cinema]] == s__User_ActivePlayers then



			
			call s__Cinematic_destroy(cinema)
        endif
        
        return false
    endfunction
    
    function s__Cinematic_create takes rect activationArea,boolean individual,boolean pause,integer firstMessage returns integer
        local integer new= s__Cinematic_allocate()
        
        set s__Cinematic_ActivationArea[new]=activationArea
        set s__Cinematic_Individual[new]=individual
        set s__Cinematic_PauseViewers[new]=pause
        		
        set s__Cinematic_ActivationCondition[new]=0
		set s__Cinematic_Priority[new]=1
        //set new.OnCinemaStart = 0
        //set new.OnCinemaEnd = 0
        //set new.OnCinemaEnd = Event.create()
        //call new.OnCinemaEnd.register(Condition(function thistype.CheckAllWatched))
        
        set s__Cinematic_ParentLevel[new]=0
        
        //set new.OnDestroy = Event.create()
        //set new.OnCinemaEndCBs = SimpleList_List.create()
        //call new.OnCinemaEndCBs.add(CheckAllWatched)
        
        set s__Cinematic_PreviousViewers[new]=s__SimpleList_List_create()
        set s__Cinematic_CinemaMessages[new]=s__SimpleList_List_create()
        
        call s__SimpleList_List_add(s__Cinematic_CinemaMessages[new],firstMessage)
        
        return new
    endfunction
    
    function s__Cinematic_onInit takes nothing returns nothing
        set s__Cinematic_OnCinemaEnd=s__Event_create()
        call TriggerAddCondition(s__Event_e[(s__Cinematic_OnCinemaEnd)], (Condition(function sc__User_OnCinemaEndCB))) // INLINED!!
        call TriggerAddCondition(s__Event_e[(s__Cinematic_OnCinemaEnd)], (Condition(function s__Cinematic_CheckAllWatched))) // INLINED!!
    endfunction

//library Cinema ends
//library Deferred:
//processed: 	function interface DeferredCallback takes integer result, integer callbackData returns integer
	
		
		//JASS does not implement error handling, no good way to offer failure
		//public DeferredCallback Failure
		
		
		
//Implemented from module Alloc:
		
		

			

		
		
  function s__DeferredAwaiter_allocate takes nothing returns integer
   local integer this= s__DeferredAwaiter_Alloc___recycler[0]
			


			
			if ( s__DeferredAwaiter_Alloc___recycler[this] == 0 ) then
				set s__DeferredAwaiter_Alloc___recycler[0]=this + 1
			else
				set s__DeferredAwaiter_Alloc___recycler[0]=s__DeferredAwaiter_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__DeferredAwaiter_deallocate takes integer this returns nothing


			


			
			set s__DeferredAwaiter_Alloc___recycler[this]=s__DeferredAwaiter_Alloc___recycler[0]
			set s__DeferredAwaiter_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__DeferredAwaiter_Alloc___onInit takes nothing returns nothing
			set s__DeferredAwaiter_Alloc___recycler[0]=1
  endfunction
		
  function s__DeferredAwaiter_Remove takes integer this returns nothing
			call sc__Deferred_Remove(s__DeferredAwaiter_Parent[this],this)
  endfunction
		
  function s__DeferredAwaiter_create takes integer parent,integer callbackData returns integer
   local integer new= s__DeferredAwaiter_allocate()
			
			set s__DeferredAwaiter_Parent[new]=parent
			set s__DeferredAwaiter_CallbackData[new]=callbackData
			
			set s__DeferredAwaiter_Promise[new]=sc__Deferred_create()
			
			return new
  endfunction
  function s__DeferredAwaiter_destroy takes integer this returns nothing
			set s__DeferredAwaiter_Success[this]=0
			set s__DeferredAwaiter_Progress[this]=0
			
			//call this.Remove()
			call sc__Deferred_destroy(s__DeferredAwaiter_Promise[this])
			call s__DeferredAwaiter_deallocate(this)
			
			//call DisplayTextToPlayer(Player(0), 0, 0, "Deallocated deferred awaiter - " + I2S(this))
  endfunction
	
		
		
//Implemented from module Alloc:
		
		

			

		
		
  function s__Deferred_allocate takes nothing returns integer
   local integer this= s__Deferred_Alloc___recycler[0]
			


			
			if ( s__Deferred_Alloc___recycler[this] == 0 ) then
				set s__Deferred_Alloc___recycler[0]=this + 1
			else
				set s__Deferred_Alloc___recycler[0]=s__Deferred_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__Deferred_deallocate takes integer this returns nothing


			


			
			set s__Deferred_Alloc___recycler[this]=s__Deferred_Alloc___recycler[0]
			set s__Deferred_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__Deferred_Alloc___onInit takes nothing returns nothing
			set s__Deferred_Alloc___recycler[0]=1
  endfunction
		
  function s__Deferred_Progress takes integer this,integer progress returns nothing
   local integer curAwaiter
   local integer awaiterResult
			
			if not s__Deferred_Resolved[this] then
				set curAwaiter=s__SimpleList_List_first[s__Deferred_Waiting[this]]
				loop
				exitwhen curAwaiter == 0
					if s__DeferredAwaiter_Progress[(s__SimpleList_ListNode_value[curAwaiter])] != 0 then
						set awaiterResult=sc___prototype54_evaluate(s__DeferredAwaiter_Progress[(s__SimpleList_ListNode_value[curAwaiter])],progress , s__DeferredAwaiter_CallbackData[(s__SimpleList_ListNode_value[curAwaiter])])
						
						call s__Deferred_Progress(s__DeferredAwaiter_Promise[(s__SimpleList_ListNode_value[curAwaiter])],awaiterResult)
					endif
				set curAwaiter=s__SimpleList_ListNode_next[curAwaiter]
				endloop
			endif
  endfunction
  function s__Deferred_Resolve takes integer this,integer result returns nothing
   local integer curAwaiter= s__SimpleList_List_first[s__Deferred_Waiting[this]]
   local integer awaiterResult
			
			if not s__Deferred_Resolved[this] then
				set s__Deferred_Resolved[this]=true
				set s__Deferred_Result[this]=result
				
				loop
				//leave JASS deferreds in waiting queue, to allow them to be properly recycled after use
				//set curAwaiter = this.Waiting.pop()
				exitwhen curAwaiter == 0
					if s__DeferredAwaiter_Success[(s__SimpleList_ListNode_value[curAwaiter])] != 0 then
						set awaiterResult=sc___prototype54_evaluate(s__DeferredAwaiter_Success[(s__SimpleList_ListNode_value[curAwaiter])],result , s__DeferredAwaiter_CallbackData[(s__SimpleList_ListNode_value[curAwaiter])])
						
						//TODO check if awaiterResult is a Deferred and chain it if it is. this would need a way to inherently type an arbitrary int ref at runtime
						
						call s__Deferred_Resolve(s__DeferredAwaiter_Promise[(s__SimpleList_ListNode_value[curAwaiter])],awaiterResult)
					endif
					
					// call DeferredAwaiter(curAwaiter.value).destroy()
					// call curAwaiter.deallocate()
				set curAwaiter=s__SimpleList_ListNode_next[curAwaiter]
				endloop
			endif
  endfunction
		
  function s__Deferred_Then takes integer this,integer success,integer progress,integer callbackData returns integer
   local integer awaiter
			
			if s__Deferred_Resolved[this] then
				call sc___prototype54_evaluate(success,s__Deferred_Result[this] , callbackData)
				
				//this should still return an awaiter so that it can be depended on properly
				return s__DeferredAwaiter_create(this , callbackData)
			else
				set awaiter=s__DeferredAwaiter_create(this , callbackData)
				set s__DeferredAwaiter_Success[awaiter]=success
				//set awaiter.Failure = failure
				set s__DeferredAwaiter_Progress[awaiter]=progress
				
				call s__SimpleList_List_addEnd(s__Deferred_Waiting[this],awaiter)
				
				return awaiter
			endif
  endfunction
  function s__Deferred_Remove takes integer this,integer awaiter returns nothing
			call s__SimpleList_List_remove(s__Deferred_Waiting[this],awaiter)
			call s__DeferredAwaiter_destroy(awaiter)
  endfunction
		
  function s__Deferred_create takes nothing returns integer
   local integer new= s__Deferred_allocate()
			
			set s__Deferred_Resolved[new]=false
			set s__Deferred_Cancel[new]=0
			set s__Deferred_Result[new]=0
			set s__Deferred_Waiting[new]=s__SimpleList_List_create()
			
			return new
  endfunction
		
		//Calling destroy will recycle the entire tree of deferreds and their awaiters depending on this one. This often makes sense to do because if a Deferred parent is destroyed before resolving then it's children will also never resolve. But a deferred which has resolved may have children which have not; in thise case, killing off the parent may make sense, but its children should still have a chance at life
		//Still, recycling trees of deferreds will be annoying to do in chunks, and it should almost always be okay to keep a full tree of Deferreds in memory until ready to be recycled, and for use cases where it isn't, the tree can be broken up by defining multiple root deferreds and resolving/destroying them appropriately
		//SO the current intended use is to construct a deferred tree in whatever way makes sense, and then to keep it entirely around until no node in the tree needs it anymore
		//Otherwise, with no auto garbage collection, the implementing code will be responsible for recycling every parent deferred and its children awaiters (repeat recursively)
		//TODO a Canceled/Destroyed callback would be useful for handling this situation as a child of the deferred tree, otherwise all destroy logic for all child deferreds needs to be handled at the same level as the destroy call, which may not always make sense or be possible
		
		//Deferreds that can be destroyed and then later accessed as if they were not destroyed need code protecting them from that exact use case
		//Ex. Deferred "A" will resolve when async functionality "X" is finished. When this happens, neither the async function "X" nor the resolve call guarantees conditions required by listening Then calls
		//This is problematic when Deferred "A" will execute Then code that can crash if certain conditions aren't met
		//Solution to recycling Deferreds. Only destroy deferreds that are not depended on anymore. Coordinating logic flow for a set of deferred's can be achieved using the All/Any wrappers, or combinations thereof
  function s__Deferred_destroy takes integer this returns nothing
   local integer curAwaiterNode
   local integer awaiterResult
			
			//call DisplayTextToPlayer(Player(0), 0, 0, "Deferred destroying - " + I2S(this) + ", awaiter count - " + I2S(this.Waiting.count))
			
			loop
			set curAwaiterNode=s__SimpleList_List_pop(s__Deferred_Waiting[this])
			exitwhen curAwaiterNode == 0
				if not s__Deferred_Resolved[this] and s__Deferred_Cancel[this] != 0 then
					call sc___prototype54_evaluate(s__Deferred_Cancel[this],s__Deferred_Result[this] , s__DeferredAwaiter_CallbackData[(s__SimpleList_ListNode_value[curAwaiterNode])])
				endif
				
				call s__DeferredAwaiter_destroy((s__SimpleList_ListNode_value[curAwaiterNode]))
				call s__SimpleList_ListNode_deallocate(curAwaiterNode)
			endloop
			
			call s__SimpleList_List_destroy(s__Deferred_Waiting[this])
			call s__Deferred_deallocate(this)
			
			//call DisplayTextToPlayer(Player(0), 0, 0, "Deallocated deferred - " + I2S(this))
  endfunction

//library Deferred ends
//library DrunkWalker:
    
	
	//create takes rect spawn, real timeBetweenSpawns, real timeBetweenMoves, integer spawnedUnit, real spawnedUnitApproxLifespan returns thistype
		
                
        
        
//Implemented from module Alloc:
		
		

			

		
		
  function s__DrunkWalker_DrunkWalker_allocate takes nothing returns integer
   local integer this= s__DrunkWalker_DrunkWalker_Alloc___recycler[0]
			


			
			if ( s__DrunkWalker_DrunkWalker_Alloc___recycler[this] == 0 ) then
				set s__DrunkWalker_DrunkWalker_Alloc___recycler[0]=this + 1
			else
				set s__DrunkWalker_DrunkWalker_Alloc___recycler[0]=s__DrunkWalker_DrunkWalker_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__DrunkWalker_DrunkWalker_deallocate takes integer this returns nothing


			


			
			set s__DrunkWalker_DrunkWalker_Alloc___recycler[this]=s__DrunkWalker_DrunkWalker_Alloc___recycler[0]
			set s__DrunkWalker_DrunkWalker_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__DrunkWalker_DrunkWalker_Alloc___onInit takes nothing returns nothing
			set s__DrunkWalker_DrunkWalker_Alloc___recycler[0]=1
  endfunction
		
        function s__DrunkWalker_DrunkWalker_move takes nothing returns nothing
            local timer t= GetExpiredTimer()
            local integer dw= ((LoadInteger(TimerUtils___ht, 0, GetHandleId((t))))) // INLINED!!
            
            local real curX= GetUnitX(s__DrunkWalker_DrunkWalker_Walker[dw])
            local real curY= GetUnitY(s__DrunkWalker_DrunkWalker_Walker[dw])
            
            local real newX
            local real newY
			
   local real dx
   local real dy
			
            local real dist
			
   local integer destinationAttempt= 0
                        
            call DestroyEffect(s__DrunkWalker_DrunkWalker_beer[dw])
            set s__DrunkWalker_DrunkWalker_beer[dw]=null
            
            //TODO get random point in ring around unit -- generate a random for radius, and a random for angle and then check that the point is legal afterwards
            loop
			set destinationAttempt=destinationAttempt + 1
                set newX=GetRandomReal(GetRectMinX(s__DrunkWalker_DrunkWalkerSpawn_SpawnArea[s__DrunkWalker_DrunkWalker_Parent[dw]]), GetRectMaxX(s__DrunkWalker_DrunkWalkerSpawn_SpawnArea[s__DrunkWalker_DrunkWalker_Parent[dw]]))
                set newY=GetRandomReal(GetRectMinY(s__DrunkWalker_DrunkWalkerSpawn_SpawnArea[s__DrunkWalker_DrunkWalker_Parent[dw]]), GetRectMaxY(s__DrunkWalker_DrunkWalkerSpawn_SpawnArea[s__DrunkWalker_DrunkWalker_Parent[dw]]))
				
                // set dist = (newX - curX) * (newY - curY) / 2 //good nuff
				set dx=newX - curX
				set dy=newY - curY
				set dist=SquareRoot(dx * dx + dy * dy)
			exitwhen destinationAttempt > DrunkWalker_MAXIMUM_VALID_LOCATION_ATTEMPTS or ( dist > s__DrunkWalker_DrunkWalkerSpawn_MinDistance[s__DrunkWalker_DrunkWalker_Parent[dw]] and GetTerrainType(newX, newY) != ABYSS and GetTerrainType(newX, newY) != LAVA )
			endloop
            





			
            call IssuePointOrder(s__DrunkWalker_DrunkWalker_Walker[dw], "move", newX, newY)
            
			set dx=( dist / s__IndexedUnit_GetMoveSpeed((GetUnitUserData(s__DrunkWalker_DrunkWalker_Walker[dw]))) ) + GetRandomReal(DrunkWalker_STOP_TIMEOUT_BUFFER_MINIMUM, DrunkWalker_STOP_TIMEOUT_BUFFER_MAXIMUM)
            set s__DrunkWalker_DrunkWalker_TimeAlive[dw]=s__DrunkWalker_DrunkWalker_TimeAlive[dw] + dx
            call TimerStart(t, dx, false, function sc__DrunkWalker_DrunkWalker_drinkEffect)
            
            set t=null
        endfunction
        
        function s__DrunkWalker_DrunkWalker_drinkEffect takes nothing returns nothing
            local timer t= GetExpiredTimer()
            local integer dw= ((LoadInteger(TimerUtils___ht, 0, GetHandleId((t))))) // INLINED!!
			
   local real timeoutRand
            
            if s__DrunkWalker_DrunkWalker_TimeAlive[dw] < s__DrunkWalker_DrunkWalkerSpawn_WalkerLife[s__DrunkWalker_DrunkWalker_Parent[dw]] then
                //set dw.beer = AddSpecialEffectTarget("Abilities\\Spells\\Other\\StrongDrink\\BrewmasterMissile.mdl", dw.Walker, "overhead")
                set s__DrunkWalker_DrunkWalker_beer[dw]=AddSpecialEffect("Abilities\\Spells\\Other\\StrongDrink\\BrewmasterMissile.mdl", GetUnitX(s__DrunkWalker_DrunkWalker_Walker[dw]), GetUnitY(s__DrunkWalker_DrunkWalker_Walker[dw]))
				call BlzSetSpecialEffectScale(s__DrunkWalker_DrunkWalker_beer[dw], DrunkWalker___STATIC_BEER_VFX_SCALE)
				call BlzSetSpecialEffectHeight(s__DrunkWalker_DrunkWalker_beer[dw], DrunkWalker___STATIC_BEER_VFX_HEIGHT)
				//call BlzSetSpecialEffectScale(dw.beer, IDEAL_BEER_MODEL_RADIUS / GetUnitDefaultRadius(dw.Parent.uID))
				
                set timeoutRand=GetRandomReal(1, 3)
				set s__DrunkWalker_DrunkWalker_TimeAlive[dw]=s__DrunkWalker_DrunkWalker_TimeAlive[dw] + timeoutRand
				
                if s__DrunkWalker_DrunkWalker_TimeAlive[dw] / s__DrunkWalker_DrunkWalkerSpawn_WalkerLife[s__DrunkWalker_DrunkWalker_Parent[dw]] >= DrunkWalker___PCT_BEFORE_ANGRY and GetRandomInt(0, 1) == 1 then
                    // call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Items\\TomeOfRetraining\\TomeOfRetrainingCaster.mdl", dw.Walker, "chest"))
					//call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Orc\\AncestralSpirit\\AncestralSpiritCaster.mdl", dw.Walker, "chest"))
					call CreateTimedSpecialEffectTarget("Abilities\\Spells\\Orc\\AncestralSpirit\\AncestralSpiritCaster.mdl" , s__DrunkWalker_DrunkWalker_Walker[dw] , SpecialEffect_ORIGIN , null , timeoutRand - .05)
					call SetUnitVertexColor(s__DrunkWalker_DrunkWalker_Walker[dw], 255, 0, 0, 255)
                    call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(s__DrunkWalker_DrunkWalker_Walker[dw])),GetDefaultMoveSpeed(s__DrunkWalker_DrunkWalkerSpawn_uID[s__DrunkWalker_DrunkWalker_Parent[dw]]) * 1.5)
					//call SetUnitMoveSpeed(dw.Walker, GetUnitDefaultMoveSpeed(dw.Walker) * 1.5)
                endif
                call TimerStart(t, timeoutRand, false, function s__DrunkWalker_DrunkWalker_move)
                set t=null
            else
                call sc__DrunkWalker_DrunkWalker_destroy(dw)
            endif
        endfunction
		
  function s__DrunkWalker_DrunkWalker_destroy takes integer this returns nothing
			if s__DrunkWalker_DrunkWalker_beer[this] != null then
				call DestroyEffect(s__DrunkWalker_DrunkWalker_beer[this])
				set s__DrunkWalker_DrunkWalker_beer[this]=null
			endif
			
			call SetUnitVertexColor(s__DrunkWalker_DrunkWalker_Walker[this], 255, 255, 255, 255)
			call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(s__DrunkWalker_DrunkWalker_Walker[this])),GetDefaultMoveSpeed(s__DrunkWalker_DrunkWalkerSpawn_uID[s__DrunkWalker_DrunkWalker_Parent[this]]))
			//call SetUnitMoveSpeed(.Walker, GetUnitDefaultMoveSpeed(.Walker))
			
			call Recycle_ReleaseUnit(s__DrunkWalker_DrunkWalker_Walker[this])
			set s__DrunkWalker_DrunkWalker_Walker[this]=null
			
			//call PauseTimer(.t) //happens during release timer
			call ReleaseTimer(s__DrunkWalker_DrunkWalker_t[this])
			set s__DrunkWalker_DrunkWalker_t[this]=null
			
			call s__SimpleList_List_remove(s__DrunkWalker_DrunkWalkerSpawn_Drunks[s__DrunkWalker_DrunkWalker_Parent[this]],this)
			
			call s__DrunkWalker_DrunkWalker_deallocate(this)
  endfunction
        
        function s__DrunkWalker_DrunkWalker_create takes integer parent returns integer
            local integer new= s__DrunkWalker_DrunkWalker_allocate()
            local real tempX
            local real tempY
            local integer ttype
			
   local integer destinationAttempt= 0
			
			call s__SimpleList_List_addEnd(s__DrunkWalker_DrunkWalkerSpawn_Drunks[parent],new)
			set s__DrunkWalker_DrunkWalker_Parent[new]=parent
			            
            loop
                set tempX=GetRandomReal(GetRectMinX(s__DrunkWalker_DrunkWalkerSpawn_SpawnArea[parent]), GetRectMaxX(s__DrunkWalker_DrunkWalkerSpawn_SpawnArea[parent]))
                set tempY=GetRandomReal(GetRectMinY(s__DrunkWalker_DrunkWalkerSpawn_SpawnArea[parent]), GetRectMaxY(s__DrunkWalker_DrunkWalkerSpawn_SpawnArea[parent]))
                
                set ttype=GetTerrainType(tempX, tempY)
				set destinationAttempt=destinationAttempt + 1
                exitwhen destinationAttempt > DrunkWalker_MAXIMUM_VALID_LOCATION_ATTEMPTS or ttype == ABYSS or ttype == LAVA
            endloop
            
            set s__DrunkWalker_DrunkWalker_Walker[new]=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((s__DrunkWalker_DrunkWalkerSpawn_uID[parent] )))),(( tempX )*1.0) , (( tempY)*1.0))) // INLINED!!
            set s__DrunkWalker_DrunkWalker_TimeAlive[new]=GetRandomReal(.75, 2.25)
            
            set s__DrunkWalker_DrunkWalker_t[new]=NewTimerEx(new)
            call TimerStart(s__DrunkWalker_DrunkWalker_t[new], s__DrunkWalker_DrunkWalker_TimeAlive[new], false, function s__DrunkWalker_DrunkWalker_drinkEffect)
            
            return new
        endfunction
	
		
		
		
        function s__DrunkWalker_DrunkWalkerSpawn_periodic takes nothing returns nothing
            local integer dws= ((LoadInteger(TimerUtils___ht, 0, GetHandleId((GetExpiredTimer()))))) // INLINED!!
            if dws != 0 then
                call s__DrunkWalker_DrunkWalker_create(dws)
            endif
        endfunction
        
        function s__DrunkWalker_DrunkWalkerSpawn_Stop takes integer this returns nothing
			loop
			exitwhen s__SimpleList_List_first[s__DrunkWalker_DrunkWalkerSpawn_Drunks[this]] == 0
				call s__DrunkWalker_DrunkWalker_destroy((s__SimpleList_ListNode_value[s__SimpleList_List_first[s__DrunkWalker_DrunkWalkerSpawn_Drunks[this]]]))
			endloop
		
			//call PauseTimer(.t)
			call ReleaseTimer(s__DrunkWalker_DrunkWalkerSpawn_t[this])
			set s__DrunkWalker_DrunkWalkerSpawn_t[this]=null
        endfunction
        
        function s__DrunkWalker_DrunkWalkerSpawn_Start takes integer this returns nothing
			set s__DrunkWalker_DrunkWalkerSpawn_t[this]=NewTimerEx(this)
			call TimerStart(s__DrunkWalker_DrunkWalkerSpawn_t[this], s__DrunkWalker_DrunkWalkerSpawn_SpawnTimeout[this], true, function s__DrunkWalker_DrunkWalkerSpawn_periodic)
        endfunction
        
        function s__DrunkWalker_DrunkWalkerSpawn_create takes rect spawn,real spawntimeout,integer uid,real lifespan returns integer
            local integer new= s__DrunkWalker_DrunkWalkerSpawn__allocate()
            
			set s__DrunkWalker_DrunkWalkerSpawn_Drunks[new]=s__SimpleList_List_create()
			
            set s__DrunkWalker_DrunkWalkerSpawn_SpawnArea[new]=spawn
            set s__DrunkWalker_DrunkWalkerSpawn_SpawnTimeout[new]=spawntimeout
            set s__DrunkWalker_DrunkWalkerSpawn_uID[new]=uid
            set s__DrunkWalker_DrunkWalkerSpawn_WalkerLife[new]=lifespan
            
			set s__DrunkWalker_DrunkWalkerSpawn_MinDistance[new]=RAbsBJ(( GetRectMaxX(spawn) - GetRectMinX(spawn) ))
			if RAbsBJ(( GetRectMaxY(spawn) - GetRectMinY(spawn) )) >= s__DrunkWalker_DrunkWalkerSpawn_MinDistance[new] then
				set s__DrunkWalker_DrunkWalkerSpawn_MinDistance[new]=RAbsBJ(( GetRectMaxY(spawn) - GetRectMinY(spawn) ))
			endif
			set s__DrunkWalker_DrunkWalkerSpawn_MinDistance[new]=s__DrunkWalker_DrunkWalkerSpawn_MinDistance[new] / 10.
            
            return new
        endfunction

//library DrunkWalker ends
//library EDWEffects:
    function CPEffect takes integer i returns nothing
        call DestroyLightning(AddLightning("AFOD", false, GetUnitX(s__MazersArray[i]), GetUnitY(s__MazersArray[i]), 0, 0))
    endfunction
    
    function CollisionDeathEffect takes unit target,unit source returns nothing
  local integer sourceTypeID= GetUnitTypeId(source)
		call CreateInstantSpecialEffect("Abilities\\Spells\\Human\\Flare\\FlareTarget.mdl" , GetUnitX(target) , GetUnitY(target) , GetOwningPlayer(target))
		
		if sourceTypeID == LGUARD or sourceTypeID == GUARD or sourceTypeID == WWWISP or sourceTypeID == WWSKUL then
			call CreateTimedSpecialEffectTarget("Abilities\\Weapons\\Bolt\\BoltImpact.mdl" , target , SpecialEffect_CHEST , GetOwningPlayer(target) , 2.)
		elseif sourceTypeID == REGRET or sourceTypeID == LMEMORY or sourceTypeID == GUILT then
			call CreateTimedSpecialEffect("Abilities\\Spells\\Other\\HowlOfTerror\\HowlTarget.mdl" , GetUnitX(target) , GetUnitY(target) , GetOwningPlayer(target) , 2.)
		elseif sourceTypeID == ICETROLL or sourceTypeID == SPIRITWALKER or sourceTypeID == CLAWMAN or s__IndexedUnit_RectangularGeometry[(GetUnitUserData(source))] then
			//TODO reduce scale
			call CreateInstantSpecialEffect("Abilities\\Spells\\Human\\Thunderclap\\ThunderClapCaster.mdl" , GetUnitX(target) , GetUnitY(target) , GetOwningPlayer(target))
		endif
    endfunction
    
    function TerrainDeathEffect takes unit u returns nothing
		call CreateInstantSpecialEffect("Abilities\\Spells\\Other\\Doom\\DoomTarget.mdl" , GetUnitX(u) , GetUnitY(u) , GetOwningPlayer(u))
		call CreateInstantSpecialEffect("Abilities\\Spells\\Demon\\DarkPortal\\DarkPortalTarget.mdl" , GetUnitX(u) , GetUnitY(u) , GetOwningPlayer(u))
    endfunction
        
    function RShieldEffect takes unit u returns nothing
		call CreateInstantSpecialEffect("Abilities\\Spells\\Human\\Feedback\\SpellBreakerAttack.mdl" , GetUnitX(u) , GetUnitY(u) , GetOwningPlayer(u))
    endfunction
 function RFireEffect takes unit target,unit source returns nothing
  local effect fx= (s__TimedEffect_Effect[s__TimedEffect_create(("Abilities\\Spells\\Other\\BreathOfFire\\BreathOfFireMissile.mdl" ) , (( GetUnitX(target) )*1.0) , (( GetUnitY(target) )*1.0) , ( GetOwningPlayer(target) ) , (( 1.5)*1.0))]) // INLINED!!
		call BlzSetSpecialEffectYaw(fx, Atan2(GetUnitY(source) - GetUnitY(target), GetUnitX(source) - GetUnitX(target)) + bj_PI)
		set fx=null
    endfunction
    
    function BShieldEffect takes unit u returns nothing
		call CreateInstantSpecialEffect("Abilities\\Spells\\Undead\\FrostArmor\\FrostArmorTarget.mdl" , GetUnitX(u) , GetUnitY(u) , GetOwningPlayer(u))
    endfunction
 function BFireEffect takes unit u returns nothing
		call CreateInstantSpecialEffect("Abilities\\Weapons\\FrostWyrmMissile\\FrostWyrmMissile.mdl" , GetUnitX(u) , GetUnitY(u) , GetOwningPlayer(u))
    endfunction
    
    function GShieldEffect takes unit u returns nothing
		call CreateInstantSpecialEffect("Abilities\\Spells\\Undead\\AnimateDead\\AnimateDeadTarget.mdl" , GetUnitX(u) , GetUnitY(u) , GetOwningPlayer(u))
    endfunction
 function GFireEffect takes unit target,unit source returns nothing
		// local effect fx = CreateTimedSpecialEffect("Abilities\\Spells\\Undead\\CarrionSwarm\\CarrionSwarmMissile.mdl", GetUnitX(target), GetUnitY(target), GetOwningPlayer(target), 1.5)
		// call BlzSetSpecialEffectYaw(fx, Atan2(GetUnitY(source) - GetUnitY(target), GetUnitX(source) - GetUnitX(target)) + bj_PI)
		// set fx = null
		
		call CreateInstantSpecialEffect("Abilities\\Spells\\Undead\\DeathCoil\\DeathCoilSpecialArt.mdl" , GetUnitX(target) , GetUnitY(target) , GetOwningPlayer(target))
    endfunction
    
    function ShieldRemoveEffect takes unit u returns nothing
		call CreateInstantSpecialEffect("Abilities\\Spells\\Human\\DispelMagic\\DispelMagicTarget.mdl" , GetUnitX(u) , GetUnitY(u) , GetOwningPlayer(u))
    endfunction
	
 function GravityEffect takes unit target,unit source returns nothing
		//call CreateInstantSpecialEffectTarget("Abilities\\Spells\\Undead\\ReplenishHealth\\ReplenishHealthCasterOverhead.mdl", source, SpecialEffect_ORIGIN, GetOwningPlayer(target))
  local effect fx= CreateSpecialEffect("Abilities\\Spells\\Undead\\ReplenishHealth\\ReplenishHealthCasterOverhead.mdl" , GetUnitX(source) , GetUnitY(source) , GetOwningPlayer(target))
		call BlzSetSpecialEffectScale(fx, .5)
		call BlzSetSpecialEffectAlpha(fx, 55)
		call DestroyEffect(fx)
		//call BlzSetSpecialEffectPitch(fx, bj_PI / 2)
		set fx=null
		
		call CreateInstantSpecialEffect("Abilities\\Spells\\Human\\ControlMagic\\ControlMagicTarget.mdl" , GetUnitX(target) , GetUnitY(target) , GetOwningPlayer(target))
	endfunction
 function BounceEffect takes unit target,unit source returns nothing
		// local effect fx = CreateSpecialEffect("Abilities\\Spells\\Undead\\ReplenishHealth\\ReplenishHealthCasterOverhead.mdl", GetUnitX(source), GetUnitY(source), GetOwningPlayer(target))
		// call BlzSetSpecialEffectScale(fx, .5)
		// call BlzSetSpecialEffectAlpha(fx, 55)
		// call DestroyEffect(fx)
		// set fx = null
		
		//call CreateInstantSpecialEffect("Abilities\\Spells\\Human\\SpellSteal\\SpellStealTarget.mdl", GetUnitX(source), GetUnitY(source), GetOwningPlayer(target))
		// local effect fx = CreateSpecialEffectTarget("Abilities\\Spells\\Items\\SpellShieldAmulet\\SpellShieldCaster.mdl", source, "origin", GetOwningPlayer(target))
		// call BlzSetSpecialEffectAlpha(fx, 0)
		// call DestroyEffect(fx)
		// set fx = null
		
  local effect fx= (s__TimedEffect_Effect[s__TimedEffect_create(("Abilities\\Spells\\Human\\SunderingBlades\\SunderingBlades.mdl" ) , (( GetUnitX(source) )*1.0) , (( GetUnitY(source) )*1.0) , ( GetOwningPlayer(target) ) , (( 1.)*1.0))]) // INLINED!!
		call BlzSetSpecialEffectScale(fx, 2.)
		set fx=null
		
		set fx=CreateSpecialEffect("Abilities\\Spells\\Items\\SpellShieldAmulet\\SpellShieldCaster.mdl" , GetUnitX(source) , GetUnitY(source) , GetOwningPlayer(target))
		// call BlzSetSpecialEffectAlpha(fx, 0)
		// call BlzSetSpecialEffectYaw(fx, Atan2(GetUnitY(source) - GetUnitY(target), GetUnitX(source) - GetUnitX(target)) + bj_PI)
		if s__Platformer_GravitationalAccel[s__User_Platformer[(GetPlayerId(GetOwningPlayer(target)))]] > 0 then
			call BlzSetSpecialEffectYaw(fx, bj_PI * 1.5)
		else
			call BlzSetSpecialEffectYaw(fx, bj_PI * .5)
		endif
		
		call DestroyEffect(fx)
		set fx=null
		
		//play spell steal target sound
		
		// call CreateInstantSpecialEffectTarget("Abilities\\Spells\\Orc\\Bloodlust\\BloodlustTarget.mdl", source, SpecialEffect_CHEST, GetOwningPlayer(target))
		// call CreateInstantSpecialEffect("Abilities\\Spells\\Orc\\Bloodlust\\BloodlustTarget.mdl", GetUnitX(source), GetUnitY(source), GetOwningPlayer(target))
				
		//local effect fx = CreateTimedSpecialEffectTarget("Abilities\\Spells\\Undead\\AntiMagicShell\\AntiMagicShell.mdl", source, SpecialEffect_ORIGIN, GetOwningPlayer(target), .5)
		
		//call BlzSetSpecialEffectScale(fx, 3)
		//call BlzSetSpecialEffectAlpha(fx, 200)
		
		// set fx = null
		
		//call CreateInstantSpecialEffectTarget("Abilities\\Spells\\Items\\SpellShieldAmulet\\SpellShieldCaster.mdl", source, "origin", GetOwningPlayer(target))
	endfunction
 function DirectionalBounceEffect takes unit target,unit source returns nothing
		call CreateInstantSpecialEffectTarget("Abilities\\Spells\\Other\\BlackArrow\\BlackArrowMissile.mdl" , target , SpecialEffect_CHEST , GetOwningPlayer(target))
	endfunction
 function SuperSpeedEffect takes unit target,unit source returns nothing
  local effect fx= (s__TimedEffect_Effect[s__TimedEffect_create(("Abilities\\Spells\\Other\\BreathOfFire\\BreathOfFireMissile.mdl" ) , (( GetUnitX(source) )*1.0) , (( GetUnitY(source) )*1.0) , ( GetOwningPlayer(target) ) , (( 1.)*1.0))]) // INLINED!!
		call BlzSetSpecialEffectYaw(fx, GetUnitFacing(source) * bj_DEGTORAD)
		set fx=null
		
		call sc__User_CreateUserTimedEffect((GetPlayerId(GetOwningPlayer(target))),"Abilities\\Weapons\\DemolisherFireMissile\\DemolisherFireMissile.mdl" , SpecialEffect_CHEST , 2.)
    endfunction
	
 function HardStopEffect takes integer p,real velocity returns nothing
		// local effect fx = CreateTimedSpecialEffect("Abilities\\Spells\\Human\\Thunderclap\\ThunderClapCaster.mdl", GetUnitX(p.Unit), GetUnitY(p.Unit), Player(p.PID), .5)
		// //local effect fx = CreateTimedSpecialEffect("Abilities\\Spells\\Orc\\WarStomp\\WarStompCaster.mdl", GetUnitX(p.Unit), GetUnitY(p.Unit), Player(p.PID), .5)
		// local real scale
		
		// if velocity < 0 then
			// set velocity = -velocity
		// endif
		// set scale = velocity / VELOCITY_HARDSTOP_THRESHOLD / 20.
		// if scale > 3. then
			// set scale = 3.
		// endif
		
		// call DisplayTextToForce(bj_FORCE_PLAYER[0], "Hard stop scale: " + R2S(scale))
		
		// call BlzSetSpecialEffectScale(fx, scale)
		// call BlzSetSpecialEffectAlpha(fx, 100)
		// //call DestroyEffect(fx)
		// set fx = null
		
		if s__User_ActiveEffect[(s__Platformer_PID[p])] != null then
			call DestroyEffect(s__User_ActiveEffect[(s__Platformer_PID[p])])
			set s__User_ActiveEffect[(s__Platformer_PID[p])]=null
		endif
	endfunction
	
 function TeleportEffect takes widget source,integer target returns nothing
		call CreateInstantSpecialEffectTarget("Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTarget.mdl" , s__User_ActiveUnit[target] , SpecialEffect_ORIGIN , Player(target))
	endfunction
 function CollectibleAcquireEffect takes integer source,integer target returns nothing
		//call CreateInstantSpecialEffectTarget("Abilities\\Spells\\Other\\Charm\\CharmTarget.mdl", source.UncollectedUnit, SpecialEffect_ORIGIN, Player(target))
		//call CreateInstantSpecialEffect("Abilities\\Spells\\Other\\Charm\\CharmTarget.mdl", GetUnitX(source.UncollectedUnit), GetUnitY(source.UncollectedUnit), Player(target))
  local effect fx= CreateSpecialEffect("Abilities\\Spells\\Other\\Charm\\CharmTarget.mdl" , GetUnitX(s__Collectible_UncollectedUnit[source]) , GetUnitY(s__Collectible_UncollectedUnit[source]) , Player(target))
		call BlzSetSpecialEffectScale(fx, .5)
		
		call DestroyEffect(fx)
		set fx=null
	endfunction
	
 function AddContinueEffect takes integer source,integer target returns nothing
		call CreateTimedSpecialEffect("Abilities\\Spells\\NightElf\\Tranquility\\Tranquility.mdl" , GetUnitX(s__InWorldPowerup_Unit[source]) , GetUnitY(s__InWorldPowerup_Unit[source]) , Player(target) , 3.)
	endfunction
 function StealContinueEffect takes integer source,integer target returns nothing
		//TODO show parasite overhead team stolen from
		
  local effect fx= CreateSpecialEffect("Abilities\\Spells\\Human\\Resurrect\\ResurrectCaster.mdl" , GetUnitX(s__InWorldPowerup_Unit[source]) , GetUnitY(s__InWorldPowerup_Unit[source]) , Player(target))
		call BlzSetSpecialEffectYaw(fx, Atan2(GetUnitY(s__InWorldPowerup_Unit[source]) - GetUnitY(s__User_ActiveUnit[target]), GetUnitX(s__InWorldPowerup_Unit[source]) - GetUnitX(s__User_ActiveUnit[target])) + bj_PI)
		call DestroyEffect(fx)
		set fx=null
		
		call CreateInstantSpecialEffectTarget("Abilities\\Spells\\Human\\Resurrect\\ResurrectTarget.mdl" , s__User_ActiveUnit[target] , SpecialEffect_ORIGIN , Player(target))
	endfunction
	
 function AddScoreEffect takes integer source,integer target returns nothing
		call CreateInstantSpecialEffectTarget("Abilities\\Spells\\Items\\ResourceItems\\ResourceEffectTarget.mdl" , s__User_ActiveUnit[target] , SpecialEffect_ORIGIN , Player(target))
		call CreateInstantSpecialEffect("UI\\Feedback\\GoldCredit\\GoldCredit.mdl" , GetUnitX(s__InWorldPowerup_Unit[source]) , GetUnitY(s__InWorldPowerup_Unit[source]) , Player(target))
		
		call AttachSoundToUnit(gg_snd_ReceiveGold, s__User_ActiveUnit[target])
		call StartSound(gg_snd_ReceiveGold)
	endfunction
 function StealScoreEffect takes integer source,integer target returns nothing
		//TODO show parasite overhead team stolen from
		
  local effect fx= CreateSpecialEffect("Abilities\\Spells\\Other\\Transmute\\PileofGold.mdl" , GetUnitX(s__InWorldPowerup_Unit[source]) , GetUnitY(s__InWorldPowerup_Unit[source]) , Player(target))
		call BlzSetSpecialEffectScale(fx, 1.5)
		call DestroyEffect(fx)
		set fx=null
	endfunction

//library EDWEffects ends
//library EDWPatternSpawnDefinitions:
	
	
	//basic wrapper for above pattern
 function DiagonalCrossSpawn takes integer spawn,integer parentLevel returns group
  local group g= NewGroup()
  local integer cycle= s__PatternSpawn_GetCycle(spawn,s__PatternSpawn_GetVariation(spawn))
  local integer spawnPositionLastIndex= s__LinePatternSpawn_GetSpawnPositionCount((spawn)) - 1
  local integer spawnPosition
		
//textmacro instance: DiagonalCrossSpawn("spawn", "g", "cycle", "spawnPositionLastIndex", "spawnPosition", "spawn.Data")
		if cycle < spawnPositionLastIndex then
			set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),cycle)
		else
			set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),spawnPositionLastIndex - ( cycle - spawnPositionLastIndex ))
		endif
				
		call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((s__PatternSpawn_Data[spawn] )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
		call s__vector2_deallocate(spawnPosition)
//end of: DiagonalCrossSpawn("spawn", "g", "cycle", "spawnPositionLastIndex", "spawnPosition", "spawn.Data")
		
		return g
	endfunction
	
	//basic spawns for basic bitches
 function OriginSpawn takes integer spawn,integer parentLevel returns group
  local group g= NewGroup()
		call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((s__PatternSpawn_Data[spawn] )))),(( s__vector2_x[s__LinePatternSpawn_SpawnOrigin[(spawn)]] )*1.0) , (( s__vector2_y[s__LinePatternSpawn_SpawnOrigin[(spawn)]])*1.0)))) // INLINED!!
		return g
	endfunction
 function RandomLineSpawn takes integer spawn,integer parentLevel returns group
  local group g= NewGroup()
		
		call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((s__PatternSpawn_Data[spawn] )))),(( s__vector2_x[s__LinePatternSpawn_SpawnOrigin[(spawn)]] + Cos(s__LinePatternSpawn_SpawnLineAngle[(spawn)]) * GetRandomReal(0, s__LinePatternSpawn_SpawnLineLength[(spawn)]) )*1.0) , (( s__vector2_y[s__LinePatternSpawn_SpawnOrigin[(spawn)]] + Sin(s__LinePatternSpawn_SpawnLineAngle[(spawn)]) * GetRandomReal(0, s__LinePatternSpawn_SpawnLineLength[(spawn)]))*1.0)))) // INLINED!!
		
		return g
	endfunction
 function RandomLineSlotSpawn takes integer spawn,integer parentLevel returns group
  local group g= NewGroup()
  local integer spawnPosition= s__LinePatternSpawn_GetSpawnPosition((spawn),GetRandomInt(0, s__LinePatternSpawn_GetSpawnPositionCount((spawn)) - 1))
		
		call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((s__PatternSpawn_Data[spawn] )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
		
		call s__vector2_deallocate(spawnPosition)
		return g
	endfunction
	
 function BlackholeSpawn takes integer spawn,integer parentLevel returns group
  local group g= NewGroup()
  local integer spawnPosition= s__LinePatternSpawn_GetSpawnPosition((spawn),0)
  local integer bhole= sc__Blackhole_create(s__vector2_x[spawnPosition] , s__vector2_y[spawnPosition] , false)
		set s__IStartable_ParentLevel[bhole]=parentLevel
		
		call s__DisposableUnit_register(s__Blackhole_BlackholeUnit[bhole] , bhole)
		call sc__Blackhole_Start(bhole)
		
		call GroupAddUnit(g, s__Blackhole_BlackholeUnit[bhole])
		
		call s__vector2_deallocate(spawnPosition)
		
		return g
	endfunction
	
 function IntroPatternSpawn takes integer spawn,integer parentLevel returns group
  local group g= NewGroup()
		//local unit u = Recycle_MakeUnit(LGUARD, LinePatternSpawn(spawn).SpawnOrigin.x + GetRandomReal(0, LinePatternSpawn(spawn).SpawnLineLength), LinePatternSpawn(spawn).SpawnOrigin.y)
		//call SetUnitMoveSpeed(u, 200.)
		
		call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((LGUARD )))),(( s__vector2_x[s__LinePatternSpawn_SpawnOrigin[(spawn)]] + GetRandomReal(0, s__LinePatternSpawn_SpawnLineLength[(spawn)]) )*1.0) , (( s__vector2_y[s__LinePatternSpawn_SpawnOrigin[(spawn)]])*1.0)))) // INLINED!!
		
		return g
	endfunction
	
 function IW2PatternSpawn takes integer spawn,integer parentLevel returns group
  local group g= NewGroup()
		
  local unit u= (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((LGUARD )))),(( s__vector2_x[s__LinePatternSpawn_SpawnOrigin[(spawn)]] )*1.0) , (( s__vector2_y[s__LinePatternSpawn_SpawnOrigin[(spawn)]] + GetRandomReal(0, s__LinePatternSpawn_SpawnLineLength[(spawn)]))*1.0))) // INLINED!!
		call SetUnitMoveSpeed(u, 200.)
		call GroupAddUnit(g, u)
		
		if RewardMode == GameModesGlobals_HARD then
			if GetRandomInt(0, 1) == 0 then
				set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[s__LinePatternSpawn_SpawnOrigin[(spawn)]] )*1.0) , (( s__vector2_y[s__LinePatternSpawn_SpawnOrigin[(spawn)]] + GetRandomReal(0, s__LinePatternSpawn_SpawnLineLength[(spawn)]))*1.0))) // INLINED!!
				call SetUnitMoveSpeed(u, 300.)
				call GroupAddUnit(g, u)
			endif
		endif
		
		return g
	endfunction
	
 function LW1PatternSpawn1 takes integer spawn,integer parentLevel returns group
  local group g= NewGroup()
  local integer spawnPosition
		
//textmacro instance: DiagonalCrossSpawn("spawn", "g", "spawn.CurrentCycle", "2", "spawnPosition", "spawn.Data")
		if s__PatternSpawn_CurrentCycle[s__LinePatternSpawn_PatternSpawn[spawn]] < 2 then
			set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),s__PatternSpawn_CurrentCycle[s__LinePatternSpawn_PatternSpawn[spawn]])
		else
			set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),2 - ( s__PatternSpawn_CurrentCycle[s__LinePatternSpawn_PatternSpawn[spawn]] - 2 ))
		endif
				
		call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((s__PatternSpawn_Data[s__LinePatternSpawn_PatternSpawn[spawn]] )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
		call s__vector2_deallocate(spawnPosition)
//end of: DiagonalCrossSpawn("spawn", "g", "spawn.CurrentCycle", "2", "spawnPosition", "spawn.Data")
		
		//call SetUnitMoveSpeed(bj_lastCreatedUnit, 150.)
		
		return g
	endfunction
 function W3APatternSpawn takes integer spawn,integer parentLevel returns group
  local group g= NewGroup()
  local integer variation= s__PatternSpawn_GetVariation(spawn)
  local integer cycle= s__PatternSpawn_GetCycle(spawn,variation)
  local integer spawnPositionLastIndex= s__LinePatternSpawn_GetSpawnPositionCount((spawn)) - 1
  local integer spawnPosition
  local integer rand
  local integer i
  local integer bhole
		
		if variation == 0 then
			if cycle == 0 then
//textmacro instance: AllSpawn("spawn", "g", "i", "2", "spawnPositionLastIndex", "spawnPosition", "ICETROLL")
		set i=0
		loop
		exitwhen i > spawnPositionLastIndex
			if i != 2 then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),i)
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
			endif
		set i=i + 1
		endloop
//end of: AllSpawn("spawn", "g", "i", "2", "spawnPositionLastIndex", "spawnPosition", "ICETROLL")
			elseif cycle == 1 then
//textmacro instance: AllSpawn("spawn", "g", "i", "1", "spawnPositionLastIndex", "spawnPosition", "ICETROLL")
		set i=0
		loop
		exitwhen i > spawnPositionLastIndex
			if i != 1 then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),i)
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
			endif
		set i=i + 1
		endloop
//end of: AllSpawn("spawn", "g", "i", "1", "spawnPositionLastIndex", "spawnPosition", "ICETROLL")
			elseif cycle == 2 then
//textmacro instance: AllSpawn("spawn", "g", "i", "0", "spawnPositionLastIndex", "spawnPosition", "ICETROLL")
		set i=0
		loop
		exitwhen i > spawnPositionLastIndex
			if i != 0 then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),i)
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
			endif
		set i=i + 1
		endloop
//end of: AllSpawn("spawn", "g", "i", "0", "spawnPositionLastIndex", "spawnPosition", "ICETROLL")
			endif
		elseif variation == 1 then
			if cycle == 0 or cycle == 2 then
//textmacro instance: AllSpawn("spawn", "g", "i", "1", "spawnPositionLastIndex", "spawnPosition", "ICETROLL")
		set i=0
		loop
		exitwhen i > spawnPositionLastIndex
			if i != 1 then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),i)
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
			endif
		set i=i + 1
		endloop
//end of: AllSpawn("spawn", "g", "i", "1", "spawnPositionLastIndex", "spawnPosition", "ICETROLL")
			elseif cycle == 1 then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),1)
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
			endif
		elseif variation == 2 then
			if cycle == 0 or cycle == 2 then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),1)
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
			elseif cycle == 1 then
//textmacro instance: AllSpawn("spawn", "g", "i", "1", "spawnPositionLastIndex", "spawnPosition", "ICETROLL")
		set i=0
		loop
		exitwhen i > spawnPositionLastIndex
			if i != 1 then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),i)
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
			endif
		set i=i + 1
		endloop
//end of: AllSpawn("spawn", "g", "i", "1", "spawnPositionLastIndex", "spawnPosition", "ICETROLL")
			endif
		elseif variation == 3 then
			if cycle == 0 then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),GetRandomInt(0, 2))
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
			elseif cycle == 1 then
				//TODO make some sort of IDisposable interface / Using-like wrapper that can interact with Recycle_ReleaseUnit
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),GetRandomInt(0, 2))
				
				set bhole=sc__Blackhole_create(s__vector2_x[spawnPosition] , s__vector2_y[spawnPosition] , false)
				set s__IStartable_ParentLevel[bhole]=parentLevel
				call s__DisposableUnit_register(s__Blackhole_BlackholeUnit[bhole] , bhole)
				call sc__Blackhole_Start(bhole)
				
				call GroupAddUnit(g, s__Blackhole_BlackholeUnit[bhole])
				
				call s__vector2_deallocate(spawnPosition)
			elseif cycle == 2 then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),GetRandomInt(0, 2))
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
			endif
		endif
				
		return g
	endfunction
 function W4APatternSpawn takes integer spawn,integer parentLevel returns group
  local group g= NewGroup()
  local integer variation= s__PatternSpawn_GetVariation(spawn)
  local integer cycle= s__PatternSpawn_GetCycle(spawn,variation)
  local integer spawnPositionLastIndex= s__LinePatternSpawn_GetSpawnPositionCount((spawn)) - 1
  local integer spawnPosition
  local integer rand
  local integer i
		
		if variation == 0 then
			if cycle == 0 then
				set rand=GetRandomInt(0, 3)
//textmacro instance: AllSpawn("spawn", "g", "i", "rand", "spawnPositionLastIndex", "spawnPosition", "ICETROLL")
		set i=0
		loop
		exitwhen i > spawnPositionLastIndex
			if i != rand then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),i)
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
			endif
		set i=i + 1
		endloop
//end of: AllSpawn("spawn", "g", "i", "rand", "spawnPositionLastIndex", "spawnPosition", "ICETROLL")
			elseif cycle == 1 or cycle == 4 then
//textmacro instance: EvenSpawn("spawn", "g", "i", "spawnPositionLastIndex", "spawnPosition", "ICETROLL")
		set i=0
		loop
		exitwhen i > spawnPositionLastIndex
			set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),i)
			call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
			call s__vector2_deallocate(spawnPosition)
		set i=i + 2
		endloop
//end of: EvenSpawn("spawn", "g", "i", "spawnPositionLastIndex", "spawnPosition", "ICETROLL")
			elseif cycle == 2 then
//textmacro instance: OddSpawn("spawn", "g", "i", "spawnPositionLastIndex", "spawnPosition", "ICETROLL")
		set i=1
		loop
		exitwhen i > spawnPositionLastIndex
			set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),i)
			call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
			call s__vector2_deallocate(spawnPosition)
		set i=i + 2
		endloop
//end of: OddSpawn("spawn", "g", "i", "spawnPositionLastIndex", "spawnPosition", "ICETROLL")
			elseif cycle == 3 then
				set rand=GetRandomInt(0, 3)
//textmacro instance: AllSpawn("spawn", "g", "i", "rand", "spawnPositionLastIndex", "spawnPosition", "ICETROLL")
		set i=0
		loop
		exitwhen i > spawnPositionLastIndex
			if i != rand then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),i)
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
			endif
		set i=i + 1
		endloop
//end of: AllSpawn("spawn", "g", "i", "rand", "spawnPositionLastIndex", "spawnPosition", "ICETROLL")
			endif
		elseif variation == 1 then
			if cycle == 0 or cycle == 3 then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),0)
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
				
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),3)
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
			elseif cycle == 1 or cycle == 2 or cycle == 4 then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),1)
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
				
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),2)
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
			endif
		elseif variation == 2 then
			if cycle == 0 or cycle == 2 then
				set rand=GetRandomInt(0, 3)
//textmacro instance: AllSpawn("spawn", "g", "i", "rand", "spawnPositionLastIndex", "spawnPosition", "ICETROLL")
		set i=0
		loop
		exitwhen i > spawnPositionLastIndex
			if i != rand then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),i)
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
			endif
		set i=i + 1
		endloop
//end of: AllSpawn("spawn", "g", "i", "rand", "spawnPositionLastIndex", "spawnPosition", "ICETROLL")
			elseif cycle == 1 or cycle == 4 then
				set rand=GetRandomInt(0, 1)
				
				if rand == 0 then
//textmacro instance: EvenSpawn("spawn", "g", "i", "spawnPositionLastIndex", "spawnPosition", "ICETROLL")
		set i=0
		loop
		exitwhen i > spawnPositionLastIndex
			set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),i)
			call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
			call s__vector2_deallocate(spawnPosition)
		set i=i + 2
		endloop
//end of: EvenSpawn("spawn", "g", "i", "spawnPositionLastIndex", "spawnPosition", "ICETROLL")
				else
//textmacro instance: OddSpawn("spawn", "g", "i", "spawnPositionLastIndex", "spawnPosition", "ICETROLL")
		set i=1
		loop
		exitwhen i > spawnPositionLastIndex
			set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),i)
			call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
			call s__vector2_deallocate(spawnPosition)
		set i=i + 2
		endloop
//end of: OddSpawn("spawn", "g", "i", "spawnPositionLastIndex", "spawnPosition", "ICETROLL")
				endif
			elseif cycle == 3 then
				set rand=GetRandomInt(0, 1)
				
				if rand == 0 then
					set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),0)
					call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
					call s__vector2_deallocate(spawnPosition)
					
					set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),3)
					call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
					call s__vector2_deallocate(spawnPosition)
				else
					set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),1)
					call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
					call s__vector2_deallocate(spawnPosition)
					
					set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),2)
					call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
					call s__vector2_deallocate(spawnPosition)
				endif
			endif
		endif
		
		return g
	endfunction

//library EDWPatternSpawnDefinitions ends
//library EDWRelayPatternSpawnDefinitions:
	
	
 function RelayGeneratorFirstSpawn takes integer spawn,integer parentLevel returns group
  local group g= NewGroup()
  local integer spawnTurn= s__SimpleList_ListNode_value[s__SimpleList_List_first[s__RelayGenerator_Turns[s__RelayPatternSpawn_Parent[spawn]]]]
  local unit u
				
		set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((s__PatternSpawn_Data[s__RelayPatternSpawn_Pattern[spawn]] )))),(( s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] )*1.0) , (( s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]])*1.0))) // INLINED!!
		call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(u)),GetUnitMoveSpeed(u) * s__RelayGenerator_OverclockFactor[s__RelayPatternSpawn_Parent[spawn]])
		call GroupAddUnit(g, u)
		
		return g
	endfunction
	
 function RelayGeneratorAllSpawn takes integer spawn,integer parentLevel returns group
  local group g= NewGroup()
  local integer currentLane= 0
  local integer numberLanes= sc__RelayGenerator_GetNumberLanes(s__RelayPatternSpawn_Parent[spawn])
  local integer spawnTurn= s__SimpleList_ListNode_value[s__SimpleList_List_first[s__RelayGenerator_Turns[s__RelayPatternSpawn_Parent[spawn]]]]
  local real x
  local real y
  local unit u
		
		loop
		exitwhen currentLane >= numberLanes
			if s__RelayTurn_Direction[spawnTurn] == 90 or s__RelayTurn_Direction[spawnTurn] == 270 then
				set x=s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] + s__RelayTurn_FirstLaneX[spawnTurn] * currentLane * s__RelayGenerator_UnitLaneSize[s__RelayPatternSpawn_Parent[spawn]]
				set y=s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]]
			else
				set x=s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]]
				set y=s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]] + s__RelayTurn_FirstLaneY[spawnTurn] * currentLane * s__RelayGenerator_UnitLaneSize[s__RelayPatternSpawn_Parent[spawn]]
			endif
			
			set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((s__PatternSpawn_Data[s__RelayPatternSpawn_Pattern[spawn]] )))),(( x )*1.0) , (( y)*1.0))) // INLINED!!
			call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(u)),GetUnitMoveSpeed(u) * s__RelayGenerator_OverclockFactor[s__RelayPatternSpawn_Parent[spawn]])
			call GroupAddUnit(g, u)
		
		set currentLane=currentLane + 1
		endloop
		
		return g
	endfunction
	
 function RelayGeneratorRandomSpawn takes integer spawn,integer parentLevel returns group
  local group g= NewGroup()
  local integer lane= GetRandomInt(0, sc__RelayGenerator_GetNumberLanes(s__RelayPatternSpawn_Parent[spawn]) - 1)
  local integer spawnTurn= s__SimpleList_ListNode_value[s__SimpleList_List_first[s__RelayGenerator_Turns[s__RelayPatternSpawn_Parent[spawn]]]]
  local real x= s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]]
  local real y= s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]]
  local unit u
		
		if s__RelayTurn_Direction[spawnTurn] == 90 or s__RelayTurn_Direction[spawnTurn] == 270 then
			set x=x + s__RelayTurn_FirstLaneX[spawnTurn] * lane * s__RelayGenerator_UnitLaneSize[s__RelayPatternSpawn_Parent[spawn]]
		else
			set y=y + s__RelayTurn_FirstLaneY[spawnTurn] * lane * s__RelayGenerator_UnitLaneSize[s__RelayPatternSpawn_Parent[spawn]]
		endif
		
		set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((s__PatternSpawn_Data[s__RelayPatternSpawn_Pattern[spawn]] )))),(( x )*1.0) , (( y)*1.0))) // INLINED!!
		call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(u)),GetUnitMoveSpeed(u) * s__RelayGenerator_OverclockFactor[s__RelayPatternSpawn_Parent[spawn]])
		call GroupAddUnit(g, u)
		
		return g
	endfunction
	
 function LW2PatternSpawn1 takes integer spawn,integer parentLevel returns group
  local group g= NewGroup()
  local integer spawnTurn= s__SimpleList_ListNode_value[s__SimpleList_List_first[s__RelayGenerator_Turns[s__RelayPatternSpawn_Parent[spawn]]]]
  local unit u
		//local integer rand = spawn.CurrentCycle / 2
		//local boolean evenCycle = (spawn.CurrentCycle / 2.) - rand == 0.
		
		if s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 1 or ( s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 2 and sc__Levels_Level_GetWeightedRandomInt(parentLevel,0 , 1) == 1 ) then
			set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((AMBULANCE )))),(( s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] )*1.0) , (( s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]])*1.0))) // INLINED!!
			
			call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(u)),3. * EDWRelayPatternSpawnDefinitions___LW2_RG1_BASEMS * s__RelayGenerator_OverclockFactor[s__RelayPatternSpawn_Parent[spawn]])
			call GroupAddUnit(g, u)
		elseif s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 3 then
			// set rand = GetRandomInt(0, 1)
			// if rand == 0 then
				// set u = Recycle_MakeUnit(TRUCK, spawnTurn.FirstLane.x + 2*spawnTurn.FirstLaneX*spawn.Parent.UnitLaneSize, spawnTurn.FirstLane.y)
			// elseif rand == 1 then
				// set u = Recycle_MakeUnit(FIRETRUCK, spawnTurn.FirstLane.x + 2*spawnTurn.FirstLaneX*spawn.Parent.UnitLaneSize, spawnTurn.FirstLane.y)
			// endif
			set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((TRUCK )))),(( s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] + 2 * s__RelayTurn_FirstLaneX[spawnTurn] * s__RelayGenerator_UnitLaneSize[s__RelayPatternSpawn_Parent[spawn]] )*1.0) , (( s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]])*1.0))) // INLINED!!
			
			call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(u)),EDWRelayPatternSpawnDefinitions___LW2_RG1_BASEMS * s__RelayGenerator_OverclockFactor[s__RelayPatternSpawn_Parent[spawn]])
			call GroupAddUnit(g, u)
		endif
		
		if ( s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] / 2. ) - ( s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] / 2 ) == 0. then
			// set rand = GetRandomInt(0, 3)
			// if rand == 0 then
				// set u = Recycle_MakeUnit(PASSENGERCAR, spawnTurn.FirstLane.x + spawnTurn.FirstLaneX*spawn.Parent.UnitLaneSize, spawnTurn.FirstLane.y)
			// elseif rand == 1 then
				// set u = Recycle_MakeUnit(JEEP, spawnTurn.FirstLane.x + spawnTurn.FirstLaneX*spawn.Parent.UnitLaneSize, spawnTurn.FirstLane.y)
			// elseif rand == 2 then
				// set u = Recycle_MakeUnit(POLICECAR, spawnTurn.FirstLane.x + spawnTurn.FirstLaneX*spawn.Parent.UnitLaneSize, spawnTurn.FirstLane.y)
			// elseif rand == 3 then
				// set u = Recycle_MakeUnit(CORVETTE, spawnTurn.FirstLane.x + spawnTurn.FirstLaneX*spawn.Parent.UnitLaneSize, spawnTurn.FirstLane.y)
			// endif
			set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((JEEP )))),(( s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] + s__RelayTurn_FirstLaneX[spawnTurn] * s__RelayGenerator_UnitLaneSize[s__RelayPatternSpawn_Parent[spawn]] )*1.0) , (( s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]])*1.0))) // INLINED!!
			
			call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(u)),2.25 * EDWRelayPatternSpawnDefinitions___LW2_RG1_BASEMS * s__RelayGenerator_OverclockFactor[s__RelayPatternSpawn_Parent[spawn]])
			call GroupAddUnit(g, u)
		endif
		
		return g
	endfunction
 function LW2PatternSpawn2 takes integer spawn,integer parentLevel returns group
  local group g= NewGroup()
  local integer spawnTurn= s__SimpleList_ListNode_value[s__SimpleList_List_first[s__RelayGenerator_Turns[s__RelayPatternSpawn_Parent[spawn]]]]
  local unit u
		//local integer rand
		
		if s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 0 then
			set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((CORVETTE )))),(( s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] + s__RelayTurn_FirstLaneX[spawnTurn] * s__RelayGenerator_UnitLaneSize[s__RelayPatternSpawn_Parent[spawn]] )*1.0) , (( s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]])*1.0))) // INLINED!!
			
			call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(u)),2.5 * EDWRelayPatternSpawnDefinitions___LW2_RG2_BASEMS * s__RelayGenerator_OverclockFactor[s__RelayPatternSpawn_Parent[spawn]])
			call GroupAddUnit(g, u)
		elseif s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 1 and sc__Levels_Level_GetWeightedRandomInt(parentLevel,0 , 1) == 1 then
			set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((POLICECAR )))),(( s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] + s__RelayTurn_FirstLaneX[spawnTurn] * s__RelayGenerator_UnitLaneSize[s__RelayPatternSpawn_Parent[spawn]] )*1.0) , (( s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]])*1.0))) // INLINED!!
			
			call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(u)),2.5 * EDWRelayPatternSpawnDefinitions___LW2_RG2_BASEMS * s__RelayGenerator_OverclockFactor[s__RelayPatternSpawn_Parent[spawn]])
			call GroupAddUnit(g, u)
		endif
		
		if s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 1 or s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 3 or s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 5 then
			set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((PASSENGERCAR )))),(( s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] )*1.0) , (( s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]])*1.0))) // INLINED!!
			
			call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(u)),EDWRelayPatternSpawnDefinitions___LW2_RG2_BASEMS * s__RelayGenerator_OverclockFactor[s__RelayPatternSpawn_Parent[spawn]])
			call GroupAddUnit(g, u)
		endif
		
		return g
	endfunction
 function LW2PatternSpawn3 takes integer spawn,integer parentLevel returns group
  local group g= NewGroup()
  local integer spawnTurn= s__SimpleList_ListNode_value[s__SimpleList_List_first[s__RelayGenerator_Turns[s__RelayPatternSpawn_Parent[spawn]]]]
  local unit u
		//local integer rand
		
		if s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 0 or s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 2 then
			set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((FIRETRUCK )))),(( s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] + s__RelayTurn_FirstLaneX[spawnTurn] * s__RelayGenerator_UnitLaneSize[s__RelayPatternSpawn_Parent[spawn]] )*1.0) , (( s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]])*1.0))) // INLINED!!
			
			call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(u)),EDWRelayPatternSpawnDefinitions___LW2_RG3_BASEMS * s__RelayGenerator_OverclockFactor[s__RelayPatternSpawn_Parent[spawn]])
			call GroupAddUnit(g, u)
		elseif s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 1 then
			set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((JEEP )))),(( s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] )*1.0) , (( s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]])*1.0))) // INLINED!!
			
			call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(u)),1.5 * EDWRelayPatternSpawnDefinitions___LW2_RG3_BASEMS * s__RelayGenerator_OverclockFactor[s__RelayPatternSpawn_Parent[spawn]])
			call GroupAddUnit(g, u)
		endif
			
		return g
	endfunction
 function LW2PatternSpawn4 takes integer spawn,integer parentLevel returns group
  local group g= NewGroup()
  local integer spawnTurn= s__SimpleList_ListNode_value[s__SimpleList_List_first[s__RelayGenerator_Turns[s__RelayPatternSpawn_Parent[spawn]]]]
  local unit u
		
		if s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 0 or s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 2 then
			if s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 0 then
				set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((PASSENGERCAR )))),(( s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] )*1.0) , (( s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]])*1.0))) // INLINED!!
			elseif s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 2 then
				set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((PASSENGERCAR )))),(( s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] )*1.0) , (( s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]] + s__RelayTurn_FirstLaneY[spawnTurn] * s__RelayGenerator_UnitLaneSize[s__RelayPatternSpawn_Parent[spawn]])*1.0))) // INLINED!!
			endif
			
			call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(u)),EDWRelayPatternSpawnDefinitions___LW2_RG4_BASEMS * s__RelayGenerator_OverclockFactor[s__RelayPatternSpawn_Parent[spawn]])
			call GroupAddUnit(g, u)
		endif
		
		return g
	endfunction
	
 function PW2PatternSpawn takes integer spawn,integer parentLevel returns group
  local group g= NewGroup()
  local unit u
		//local integer lane = GetRandomInt(0, spawn.Parent.GetNumberLanes() - 1)
  local integer spawnTurn= s__SimpleList_ListNode_value[s__SimpleList_List_first[s__RelayGenerator_Turns[s__RelayPatternSpawn_Parent[spawn]]]]
				
		if s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 1 or s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 3 then
			//lane 0
			set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] )*1.0) , (( s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]])*1.0))) // INLINED!!
			call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(u)),200. * s__RelayGenerator_OverclockFactor[s__RelayPatternSpawn_Parent[spawn]])
			//call SetUnitMoveSpeed(u, 200)
			call GroupAddUnit(g, u)
			
			//lane 2
			set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] )*1.0) , (( s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]] + 2 * s__RelayTurn_FirstLaneY[spawnTurn] * s__RelayGenerator_UnitLaneSize[s__RelayPatternSpawn_Parent[spawn]])*1.0))) // INLINED!!
			call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(u)),200. * s__RelayGenerator_OverclockFactor[s__RelayPatternSpawn_Parent[spawn]])
			//call SetUnitMoveSpeed(u, 200)
			call GroupAddUnit(g, u)
		elseif s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 2 then
			//lane 1
			set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] )*1.0) , (( s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]] + s__RelayTurn_FirstLaneY[spawnTurn] * s__RelayGenerator_UnitLaneSize[s__RelayPatternSpawn_Parent[spawn]])*1.0))) // INLINED!!
			call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(u)),400. * s__RelayGenerator_OverclockFactor[s__RelayPatternSpawn_Parent[spawn]])
			//call SetUnitMoveSpeed(u, 400)
			call GroupAddUnit(g, u)
		endif
		
		return g
	endfunction

//library EDWRelayPatternSpawnDefinitions ends
//library LavaDamage:

		
		//this doesn't work when run on timer start
		//for some reason timers start with a different elapsed / remaining time than they tick with
		//OR i could pass Elapsed time in as a parameter, hard coding it to the ideal value for its start state
  function s__LavaDamage_ApplyDamage takes integer pID,real pctTimeElapsed returns nothing
			//delta remaining from previous call * % of timestep represented during call
   local real pctTimeDamaged= pctTimeElapsed - s__LavaDamage_pctTimeApplied[pID]
   local real damagedHP= RMaxBJ(0., ( GetUnitState(s__MazersArray[pID], UNIT_STATE_LIFE) - LavaDamage___LAVARATE * pctTimeDamaged ))
			




			
			if pctTimeElapsed >= 1. then
				//reset deltas
				set s__LavaDamage_pctTimeApplied[pID]=0.
			else
				//equivalent to thistype.pctTimeApplied[pID] + pctTimeDamaged
				set s__LavaDamage_pctTimeApplied[pID]=pctTimeElapsed
			endif
						



			
			//update mazer life
			call SetUnitState(s__MazersArray[pID], UNIT_STATE_LIFE, damagedHP)
			
			if damagedHP == 0 then
				call CreateInstantSpecialEffect(LavaDamage___DEATH_FX , GetUnitX(s__MazersArray[pID]) , GetUnitY(s__MazersArray[pID]) , Player(pID))
			endif
  endfunction		
  function s__LavaDamage_ApplyDamageLoop takes nothing returns nothing
   local integer curPlayerNode= s__SimpleList_List_first[s__LavaDamage_players]
   local real pctTimeElapsed= TimerGetElapsed(s__LavaDamage_t) / LavaDamage___TIMESTEP
			
			loop
			exitwhen curPlayerNode == 0
				call s__LavaDamage_ApplyDamage(s__SimpleList_ListNode_value[curPlayerNode] , pctTimeElapsed)
			set curPlayerNode=s__SimpleList_ListNode_next[curPlayerNode]
			endloop
  endfunction

  function s__LavaDamage_Add takes integer pID returns nothing
			set s__LavaDamage_pctTimeApplied[pID]=0.
			
			if s__SimpleList_List_count[s__LavaDamage_players] == 0 then
				set s__LavaDamage_t=(NewTimerEx(0)) // INLINED!!
				call TimerStart(s__LavaDamage_t, LavaDamage___TIMESTEP, true, function s__LavaDamage_ApplyDamageLoop)
				
				//immediately apply full portion of damage
				call s__LavaDamage_ApplyDamage(pID , 1.)
			else
				//immediately apply the portion of damage that the timer has currently elapsed for, it will then apply the remaining damage at the next natural tick
				call s__LavaDamage_ApplyDamage(pID , TimerGetElapsed(s__LavaDamage_t) / LavaDamage___TIMESTEP)
			endif
			
			call s__SimpleList_List_add(s__LavaDamage_players,pID)
  endfunction
		
  function s__LavaDamage_Remove takes integer pID returns nothing
			call s__SimpleList_List_remove(s__LavaDamage_players,pID)
			
			if s__SimpleList_List_count[s__LavaDamage_players] == 0 then
				call ReleaseTimer(s__LavaDamage_t)
				set s__LavaDamage_t=null
			endif
  endfunction
		
  function s__LavaDamage_onInit takes nothing returns nothing
			set s__LavaDamage_players=s__SimpleList_List_create()
  endfunction

//library LavaDamage ends
//library PlatformerBounce:


	
	
 function s__PlatformerBounce_Bounce takes integer plat returns nothing
		// local vector2 terrainCenter = GetTerrainCenterpoint(plat.XPosition, plat.YPosition)
			
		// //this is too inconsistent inside this loop, will need to move it out to its own timer after all...
		// if .GravitationalAccel > 0 then
			// set .YVelocity = -BOOST_SPEED
		// elseif .GravitationalAccel < 0 then
			// set .YVelocity = BOOST_SPEED
		// endif
		
		if s__Platformer_TerrainDX[plat] == BOOST or GetTerrainType(s__Platformer_XPosition[plat], s__Platformer_YPosition[plat]) == BOOST then
			call DestroyEffect(AddSpecialEffect(PlatformerBounce_TERRAIN_SUPERBOUNCE_FX, s__Platformer_XPosition[plat], s__Platformer_YPosition[plat]))
		endif
 endfunction
 function s__PlatformerBounce_BounceCallback takes nothing returns nothing
  local integer curPlatformerNode= s__SimpleList_List_first[s__PlatformerBounce_ActivePlatformers]
		
		loop
		exitwhen curPlatformerNode == 0
			call s__PlatformerBounce_Bounce(s__SimpleList_ListNode_value[curPlatformerNode])
		set curPlatformerNode=s__SimpleList_ListNode_next[curPlatformerNode]
		endloop
 endfunction

 function s__PlatformerBounce_Add takes integer plat returns nothing
		//register self
		if s__SimpleList_List_count[s__PlatformerBounce_ActivePlatformers] == 0 then
			call TimerStart(s__PlatformerBounce_BounceTimer, PlatformerBounce__TIMESTEP, true, function s__PlatformerBounce_BounceCallback)
		endif
		
		call s__SimpleList_List_addEnd(s__PlatformerBounce_ActivePlatformers,plat)
		
		//immediately bounce that shit
		call s__PlatformerBounce_Bounce(plat)
 endfunction
	
 function s__PlatformerBounce_Remove takes integer plat returns nothing
		//deregister self
		call s__SimpleList_List_remove(s__PlatformerBounce_ActivePlatformers,plat)
		
		if s__SimpleList_List_count[s__PlatformerBounce_ActivePlatformers] == 0 then
			call PauseTimer(s__PlatformerBounce_BounceTimer)
		endif
 endfunction
	
 function s__PlatformerBounce_onInit takes nothing returns nothing
		set s__PlatformerBounce_ActivePlatformers=s__SimpleList_List_create()
 endfunction


//library PlatformerBounce ends
//library PlatformerIce:
    
    function PlatformerIce__Loop takes integer p returns nothing
        local integer projVelocity
        local real distance
        local real maxDistance
        



        //design concept:
        //movement left and right should be like sledding -- lots of velocity with a bit of control
        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "before: " + R2S(p.XVelocity))
		
		//need to check that platformer is still on a diagonal because the terrain loop (which controls this callbacks parameters) runs at a different, much slower rate than the physics loop
		//the terrain loop can claim that the platformer is still on ice (and still in this callback group) while the physics loop has since established that they've left a diagonal
        if s__Platformer_OnDiagonal[p] then
			if s__Platformer_HorizontalAxisState[p] == 1 then
				//project velocity vector against current diagonal to match actual direction
				set projVelocity=s__vector2_create(s__Platformer_XVelocity[p] , s__Platformer_YVelocity[p])
				
				//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Raw velocity: " + projVelocity.toString())
				call s__vector2_projectUnitVector(projVelocity,ComplexTerrainPathing_GetParallelForPathing(s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[p]]))
				//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Projected velocity: " + projVelocity.toString())
				//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Projected velocity: " + projVelocity.toString())
				
				if s__vector2_x[projVelocity] >= 0 then //velocity right
					//TODO check i
					if s__Platformer_DiagonalPathing[p] != 0 then
						//only effects x velocity when on top or bottom
						if s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[p]] == ComplexTerrainPathing_Top or s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[p]] == ComplexTerrainPathing_Bottom then
							if s__Platformer_YTerrainPushedAgainst[p] == SLOWICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] + PlatformerIce_SLOW_VELOCITY
							elseif s__Platformer_YTerrainPushedAgainst[p] == FASTICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] + PlatformerIce_FAST_VELOCITY
							endif
						//also effects y velocity when on diagonal pieces
						elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[p]] == ComplexTerrainPathing_NE then
							if ( s__Platformer_XTerrainPushedAgainst[p] == SLOWICE and s__Platformer_YTerrainPushedAgainst[p] == FASTICE ) or ( s__Platformer_XTerrainPushedAgainst[p] == FASTICE and s__Platformer_YTerrainPushedAgainst[p] == SLOWICE ) then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] + PlatformerIce_HYBRID_VELOCITY
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] - PlatformerIce_HYBRID_VELOCITY
							elseif s__Platformer_XTerrainPushedAgainst[p] == SLOWICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] + PlatformerIce_SLOW_VELOCITY * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] - PlatformerIce_SLOW_VELOCITY * SIN_45
							elseif s__Platformer_XTerrainPushedAgainst[p] == FASTICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] + PlatformerIce_FAST_VELOCITY * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] - PlatformerIce_FAST_VELOCITY * SIN_45
							endif
						elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[p]] == ComplexTerrainPathing_SE then
							if ( s__Platformer_XTerrainPushedAgainst[p] == SLOWICE and s__Platformer_YTerrainPushedAgainst[p] == FASTICE ) or ( s__Platformer_XTerrainPushedAgainst[p] == FASTICE and s__Platformer_YTerrainPushedAgainst[p] == SLOWICE ) then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] + PlatformerIce_HYBRID_VELOCITY
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] + PlatformerIce_HYBRID_VELOCITY
							elseif s__Platformer_XTerrainPushedAgainst[p] == SLOWICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] + PlatformerIce_SLOW_VELOCITY * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] + PlatformerIce_SLOW_VELOCITY * SIN_45
							elseif s__Platformer_XTerrainPushedAgainst[p] == FASTICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] + PlatformerIce_FAST_VELOCITY * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] + PlatformerIce_FAST_VELOCITY * SIN_45
							endif
						elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[p]] == ComplexTerrainPathing_SW then
							if ( s__Platformer_XTerrainPushedAgainst[p] == SLOWICE and s__Platformer_YTerrainPushedAgainst[p] == FASTICE ) or ( s__Platformer_XTerrainPushedAgainst[p] == FASTICE and s__Platformer_YTerrainPushedAgainst[p] == SLOWICE ) then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] + PlatformerIce_HYBRID_VELOCITY
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] - PlatformerIce_HYBRID_VELOCITY
							elseif s__Platformer_XTerrainPushedAgainst[p] == SLOWICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] + PlatformerIce_SLOW_VELOCITY * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] - PlatformerIce_SLOW_VELOCITY * SIN_45
							elseif s__Platformer_XTerrainPushedAgainst[p] == FASTICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] + PlatformerIce_FAST_VELOCITY * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] - PlatformerIce_FAST_VELOCITY * SIN_45
							endif
						elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[p]] == ComplexTerrainPathing_NW then
							if ( s__Platformer_XTerrainPushedAgainst[p] == SLOWICE and s__Platformer_YTerrainPushedAgainst[p] == FASTICE ) or ( s__Platformer_XTerrainPushedAgainst[p] == FASTICE and s__Platformer_YTerrainPushedAgainst[p] == SLOWICE ) then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] + PlatformerIce_HYBRID_VELOCITY
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] + PlatformerIce_HYBRID_VELOCITY
							elseif s__Platformer_XTerrainPushedAgainst[p] == SLOWICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] + PlatformerIce_SLOW_VELOCITY * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] + PlatformerIce_SLOW_VELOCITY * SIN_45
							elseif s__Platformer_XTerrainPushedAgainst[p] == FASTICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] + PlatformerIce_FAST_VELOCITY * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] + PlatformerIce_FAST_VELOCITY * SIN_45
							endif
						endif
						
						//play effect when moving in same direction
						call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Undead\\FrostArmor\\FrostArmorDamage.mdl", s__Platformer_XPosition[p] - s__vector2_x[s__Platformer_PushedAgainstVector[p]] * PlatformerGlobals_RADIUS, s__Platformer_YPosition[p] - s__vector2_y[s__Platformer_PushedAgainstVector[p]] * PlatformerGlobals_RADIUS))
					endif
				else
					if s__Platformer_DiagonalPathing[p] != 0 then
						//only effects x velocity when on top or bottom
						if s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[p]] == ComplexTerrainPathing_Top or s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[p]] == ComplexTerrainPathing_Bottom then
							if s__Platformer_YTerrainPushedAgainst[p] == SLOWICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] + PlatformerIce_SLOW_VELOCITY * PlatformerIce_SLOW_OPPOSITIONDIFFERENCE
							elseif s__Platformer_YTerrainPushedAgainst[p] == FASTICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] + PlatformerIce_FAST_VELOCITY * PlatformerIce_FAST_OPPOSITIONDIFFERENCE
							endif
						
						//no effect when on left or right wall
						
						//also effects y velocity when on diagonal pieces
						elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[p]] == ComplexTerrainPathing_NE then
							if ( s__Platformer_XTerrainPushedAgainst[p] == SLOWICE and s__Platformer_YTerrainPushedAgainst[p] == FASTICE ) or ( s__Platformer_XTerrainPushedAgainst[p] == FASTICE and s__Platformer_YTerrainPushedAgainst[p] == SLOWICE ) then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] + PlatformerIce_HYBRID_OPP_VELOCITY
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] - PlatformerIce_HYBRID_OPP_VELOCITY
							elseif s__Platformer_XTerrainPushedAgainst[p] == SLOWICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] + PlatformerIce_SLOW_VELOCITY * PlatformerIce_SLOW_OPPOSITIONDIFFERENCE * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] - PlatformerIce_SLOW_VELOCITY * PlatformerIce_SLOW_OPPOSITIONDIFFERENCE * SIN_45
							elseif s__Platformer_XTerrainPushedAgainst[p] == FASTICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] + PlatformerIce_FAST_VELOCITY * PlatformerIce_FAST_OPPOSITIONDIFFERENCE * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] - PlatformerIce_FAST_VELOCITY * PlatformerIce_FAST_OPPOSITIONDIFFERENCE * SIN_45
							endif
						elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[p]] == ComplexTerrainPathing_SE then
							if ( s__Platformer_XTerrainPushedAgainst[p] == SLOWICE and s__Platformer_YTerrainPushedAgainst[p] == FASTICE ) or ( s__Platformer_XTerrainPushedAgainst[p] == FASTICE and s__Platformer_YTerrainPushedAgainst[p] == SLOWICE ) then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] + PlatformerIce_HYBRID_OPP_VELOCITY
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] + PlatformerIce_HYBRID_OPP_VELOCITY
							elseif s__Platformer_XTerrainPushedAgainst[p] == SLOWICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] + PlatformerIce_SLOW_VELOCITY * PlatformerIce_SLOW_OPPOSITIONDIFFERENCE * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] + PlatformerIce_SLOW_VELOCITY * PlatformerIce_SLOW_OPPOSITIONDIFFERENCE * SIN_45
							elseif s__Platformer_XTerrainPushedAgainst[p] == FASTICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] + PlatformerIce_FAST_VELOCITY * PlatformerIce_FAST_OPPOSITIONDIFFERENCE * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] + PlatformerIce_FAST_VELOCITY * PlatformerIce_FAST_OPPOSITIONDIFFERENCE * SIN_45
							endif
						elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[p]] == ComplexTerrainPathing_SW then
							if ( s__Platformer_XTerrainPushedAgainst[p] == SLOWICE and s__Platformer_YTerrainPushedAgainst[p] == FASTICE ) or ( s__Platformer_XTerrainPushedAgainst[p] == FASTICE and s__Platformer_YTerrainPushedAgainst[p] == SLOWICE ) then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] + PlatformerIce_HYBRID_OPP_VELOCITY
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] - PlatformerIce_HYBRID_OPP_VELOCITY
							elseif s__Platformer_XTerrainPushedAgainst[p] == SLOWICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] + PlatformerIce_SLOW_VELOCITY * PlatformerIce_SLOW_OPPOSITIONDIFFERENCE * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] - PlatformerIce_SLOW_VELOCITY * PlatformerIce_SLOW_OPPOSITIONDIFFERENCE * SIN_45
							elseif s__Platformer_XTerrainPushedAgainst[p] == FASTICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] + PlatformerIce_FAST_VELOCITY * PlatformerIce_FAST_OPPOSITIONDIFFERENCE * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] - PlatformerIce_FAST_VELOCITY * PlatformerIce_FAST_OPPOSITIONDIFFERENCE * SIN_45
							endif
						elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[p]] == ComplexTerrainPathing_NW then
							if ( s__Platformer_XTerrainPushedAgainst[p] == SLOWICE and s__Platformer_YTerrainPushedAgainst[p] == FASTICE ) or ( s__Platformer_XTerrainPushedAgainst[p] == FASTICE and s__Platformer_YTerrainPushedAgainst[p] == SLOWICE ) then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] + PlatformerIce_HYBRID_OPP_VELOCITY
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] + PlatformerIce_HYBRID_OPP_VELOCITY
							elseif s__Platformer_XTerrainPushedAgainst[p] == SLOWICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] + PlatformerIce_SLOW_VELOCITY * PlatformerIce_SLOW_OPPOSITIONDIFFERENCE * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] + PlatformerIce_SLOW_VELOCITY * PlatformerIce_SLOW_OPPOSITIONDIFFERENCE * SIN_45
							elseif s__Platformer_XTerrainPushedAgainst[p] == FASTICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] + PlatformerIce_FAST_VELOCITY * PlatformerIce_FAST_OPPOSITIONDIFFERENCE * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] + PlatformerIce_FAST_VELOCITY * PlatformerIce_FAST_OPPOSITIONDIFFERENCE * SIN_45
							endif
						endif
					endif
				endif
				
				//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Projected velocity: " + projVelocity.toString())
				
				//compute projVelocity distance
				set distance=SquareRoot(s__vector2_x[projVelocity] * s__vector2_x[projVelocity] + s__vector2_y[projVelocity] * s__vector2_y[projVelocity])

				//check if projVelocity distance is greater than or equal to max speed for ice type
				if ( s__Platformer_XTerrainPushedAgainst[p] == SLOWICE and s__Platformer_YTerrainPushedAgainst[p] == FASTICE ) or ( s__Platformer_XTerrainPushedAgainst[p] == FASTICE and s__Platformer_YTerrainPushedAgainst[p] == SLOWICE ) then
					set maxDistance=( PlatformerIce_SLOW_MAX_VELOCITY + PlatformerIce_FAST_MAX_VELOCITY ) / 2
				elseif s__Platformer_XTerrainPushedAgainst[p] == SLOWICE or s__Platformer_YTerrainPushedAgainst[p] == SLOWICE then
					set maxDistance=PlatformerIce_SLOW_MAX_VELOCITY
				elseif s__Platformer_XTerrainPushedAgainst[p] == FASTICE or s__Platformer_YTerrainPushedAgainst[p] == FASTICE then
					set maxDistance=PlatformerIce_FAST_MAX_VELOCITY
				endif
				
				//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Max distance: " + R2S(maxDistance))
				
				//update velocity
				if distance > maxDistance then
					//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Projected velocity: " + projVelocity.toString())
					
					//only update velocities if they were below the max velocity before
					if SquareRoot(s__Platformer_XVelocity[p] * s__Platformer_XVelocity[p] + s__Platformer_YVelocity[p] * s__Platformer_YVelocity[p]) < maxDistance then
						set s__Platformer_XVelocity[p]=s__vector2_x[projVelocity] * maxDistance / distance
						set s__Platformer_YVelocity[p]=s__vector2_y[projVelocity] * maxDistance / distance
					endif
					
					//TODO show superspeed animation
				else
					set s__Platformer_XVelocity[p]=s__vector2_x[projVelocity]
					set s__Platformer_YVelocity[p]=s__vector2_y[projVelocity]
				endif
				
				//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Updated velocity: " + R2S(p.XVelocity))
				
				call s__vector2_deallocate((projVelocity)) // INLINED!!
			elseif s__Platformer_HorizontalAxisState[p] == - 1 then
				set projVelocity=s__vector2_create(s__Platformer_XVelocity[p] , s__Platformer_YVelocity[p])
				//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Raw velocity: " + projVelocity.toString())
				call s__vector2_projectUnitVector(projVelocity,ComplexTerrainPathing_GetParallelForPathing(s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[p]]))
				//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Projected velocity: " + projVelocity.toString())
				
				//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Projected velocity: " + projVelocity.toString())
				
				//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Axis left, X Velocity: " + R2S(projVelocity.x))
				
				if s__vector2_x[projVelocity] <= 0 then //velocity left
					if s__Platformer_DiagonalPathing[p] != 0 then
						//only effects x velocity when on top or bottom
						if s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[p]] == ComplexTerrainPathing_Top or s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[p]] == ComplexTerrainPathing_Bottom then
							if s__Platformer_YTerrainPushedAgainst[p] == SLOWICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] - PlatformerIce_SLOW_VELOCITY
							elseif s__Platformer_YTerrainPushedAgainst[p] == FASTICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] - PlatformerIce_FAST_VELOCITY
							endif
						
						//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "X Velocity after: " + R2S(p.XVelocity))
						//also effects y velocity when on diagonal pieces
						elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[p]] == ComplexTerrainPathing_NE then
							if ( s__Platformer_XTerrainPushedAgainst[p] == SLOWICE and s__Platformer_YTerrainPushedAgainst[p] == FASTICE ) or ( s__Platformer_XTerrainPushedAgainst[p] == FASTICE and s__Platformer_YTerrainPushedAgainst[p] == SLOWICE ) then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] - PlatformerIce_HYBRID_VELOCITY
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] + PlatformerIce_HYBRID_VELOCITY
							elseif s__Platformer_XTerrainPushedAgainst[p] == SLOWICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] - PlatformerIce_SLOW_VELOCITY * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] + PlatformerIce_SLOW_VELOCITY * SIN_45
							elseif s__Platformer_XTerrainPushedAgainst[p] == FASTICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] - PlatformerIce_FAST_VELOCITY * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] + PlatformerIce_FAST_VELOCITY * SIN_45
							endif
						elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[p]] == ComplexTerrainPathing_SE then
							if ( s__Platformer_XTerrainPushedAgainst[p] == SLOWICE and s__Platformer_YTerrainPushedAgainst[p] == FASTICE ) or ( s__Platformer_XTerrainPushedAgainst[p] == FASTICE and s__Platformer_YTerrainPushedAgainst[p] == SLOWICE ) then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] - PlatformerIce_HYBRID_VELOCITY
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] - PlatformerIce_HYBRID_VELOCITY
							elseif s__Platformer_XTerrainPushedAgainst[p] == SLOWICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] - PlatformerIce_SLOW_VELOCITY * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] - PlatformerIce_SLOW_VELOCITY * SIN_45
							elseif s__Platformer_XTerrainPushedAgainst[p] == FASTICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] - PlatformerIce_FAST_VELOCITY * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] - PlatformerIce_FAST_VELOCITY * SIN_45
							endif
						elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[p]] == ComplexTerrainPathing_SW then
							if ( s__Platformer_XTerrainPushedAgainst[p] == SLOWICE and s__Platformer_YTerrainPushedAgainst[p] == FASTICE ) or ( s__Platformer_XTerrainPushedAgainst[p] == FASTICE and s__Platformer_YTerrainPushedAgainst[p] == SLOWICE ) then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] - PlatformerIce_HYBRID_VELOCITY
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] + PlatformerIce_HYBRID_VELOCITY
							elseif s__Platformer_XTerrainPushedAgainst[p] == SLOWICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] - PlatformerIce_SLOW_VELOCITY * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] + PlatformerIce_SLOW_VELOCITY * SIN_45
							elseif s__Platformer_XTerrainPushedAgainst[p] == FASTICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] - PlatformerIce_FAST_VELOCITY * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] + PlatformerIce_FAST_VELOCITY * SIN_45
							endif
						elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[p]] == ComplexTerrainPathing_NW then
							if ( s__Platformer_XTerrainPushedAgainst[p] == SLOWICE and s__Platformer_YTerrainPushedAgainst[p] == FASTICE ) or ( s__Platformer_XTerrainPushedAgainst[p] == FASTICE and s__Platformer_YTerrainPushedAgainst[p] == SLOWICE ) then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] - PlatformerIce_HYBRID_VELOCITY
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] - PlatformerIce_HYBRID_VELOCITY
							elseif s__Platformer_XTerrainPushedAgainst[p] == SLOWICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] - PlatformerIce_SLOW_VELOCITY * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] - PlatformerIce_SLOW_VELOCITY * SIN_45
							elseif s__Platformer_XTerrainPushedAgainst[p] == FASTICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] - PlatformerIce_FAST_VELOCITY * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] - PlatformerIce_FAST_VELOCITY * SIN_45
							endif
						endif
						
						//play effect when moving in same direction
						call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Undead\\FrostArmor\\FrostArmorDamage.mdl", s__Platformer_XPosition[p] - s__vector2_x[s__Platformer_PushedAgainstVector[p]] * PlatformerGlobals_RADIUS, s__Platformer_YPosition[p] - s__vector2_y[s__Platformer_PushedAgainstVector[p]] * PlatformerGlobals_RADIUS))
					endif
				else
					//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "(same) before: " + R2S(p.XVelocity) + " after: " + R2S(p.XVelocity - p.MoveSpeed * OCEAN_MOTION))
					if s__Platformer_DiagonalPathing[p] != 0 then
						//only effects x velocity when on top or bottom
						if s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[p]] == ComplexTerrainPathing_Top or s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[p]] == ComplexTerrainPathing_Bottom then
							if s__Platformer_YTerrainPushedAgainst[p] == SLOWICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] - PlatformerIce_SLOW_VELOCITY * PlatformerIce_SLOW_OPPOSITIONDIFFERENCE
							elseif s__Platformer_YTerrainPushedAgainst[p] == FASTICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] - PlatformerIce_FAST_VELOCITY * PlatformerIce_FAST_OPPOSITIONDIFFERENCE
							endif
							
							//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "X Velocity after: " + R2S(p.XVelocity))
						//no effect when on left or right wall
						
						//also effects y velocity when on diagonal pieces
						elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[p]] == ComplexTerrainPathing_NE then
							if ( s__Platformer_XTerrainPushedAgainst[p] == SLOWICE and s__Platformer_YTerrainPushedAgainst[p] == FASTICE ) or ( s__Platformer_XTerrainPushedAgainst[p] == FASTICE and s__Platformer_YTerrainPushedAgainst[p] == SLOWICE ) then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] - PlatformerIce_HYBRID_OPP_VELOCITY
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] + PlatformerIce_HYBRID_OPP_VELOCITY
							elseif s__Platformer_XTerrainPushedAgainst[p] == SLOWICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] - PlatformerIce_SLOW_VELOCITY * PlatformerIce_SLOW_OPPOSITIONDIFFERENCE * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] + PlatformerIce_SLOW_VELOCITY * PlatformerIce_SLOW_OPPOSITIONDIFFERENCE * SIN_45
							elseif s__Platformer_XTerrainPushedAgainst[p] == FASTICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] - PlatformerIce_FAST_VELOCITY * PlatformerIce_FAST_OPPOSITIONDIFFERENCE * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] + PlatformerIce_FAST_VELOCITY * PlatformerIce_FAST_OPPOSITIONDIFFERENCE * SIN_45
							endif
						elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[p]] == ComplexTerrainPathing_SE then
							if ( s__Platformer_XTerrainPushedAgainst[p] == SLOWICE and s__Platformer_YTerrainPushedAgainst[p] == FASTICE ) or ( s__Platformer_XTerrainPushedAgainst[p] == FASTICE and s__Platformer_YTerrainPushedAgainst[p] == SLOWICE ) then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] - PlatformerIce_HYBRID_OPP_VELOCITY
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] - PlatformerIce_HYBRID_OPP_VELOCITY
							elseif s__Platformer_XTerrainPushedAgainst[p] == SLOWICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] - PlatformerIce_SLOW_VELOCITY * PlatformerIce_SLOW_OPPOSITIONDIFFERENCE * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] - PlatformerIce_SLOW_VELOCITY * PlatformerIce_SLOW_OPPOSITIONDIFFERENCE * SIN_45
							elseif s__Platformer_XTerrainPushedAgainst[p] == FASTICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] - PlatformerIce_FAST_VELOCITY * PlatformerIce_FAST_OPPOSITIONDIFFERENCE * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] - PlatformerIce_FAST_VELOCITY * PlatformerIce_FAST_OPPOSITIONDIFFERENCE * SIN_45
							endif
						elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[p]] == ComplexTerrainPathing_SW then
							if ( s__Platformer_XTerrainPushedAgainst[p] == SLOWICE and s__Platformer_YTerrainPushedAgainst[p] == FASTICE ) or ( s__Platformer_XTerrainPushedAgainst[p] == FASTICE and s__Platformer_YTerrainPushedAgainst[p] == SLOWICE ) then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] - PlatformerIce_HYBRID_OPP_VELOCITY
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] + PlatformerIce_HYBRID_OPP_VELOCITY
							elseif s__Platformer_XTerrainPushedAgainst[p] == SLOWICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] - PlatformerIce_SLOW_VELOCITY * PlatformerIce_SLOW_OPPOSITIONDIFFERENCE * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] + PlatformerIce_SLOW_VELOCITY * PlatformerIce_SLOW_OPPOSITIONDIFFERENCE * SIN_45
							elseif s__Platformer_XTerrainPushedAgainst[p] == FASTICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] - PlatformerIce_FAST_VELOCITY * PlatformerIce_FAST_OPPOSITIONDIFFERENCE * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] + PlatformerIce_FAST_VELOCITY * PlatformerIce_FAST_OPPOSITIONDIFFERENCE * SIN_45
							endif
						elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[p]] == ComplexTerrainPathing_NW then
							if ( s__Platformer_XTerrainPushedAgainst[p] == SLOWICE and s__Platformer_YTerrainPushedAgainst[p] == FASTICE ) or ( s__Platformer_XTerrainPushedAgainst[p] == FASTICE and s__Platformer_YTerrainPushedAgainst[p] == SLOWICE ) then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] - PlatformerIce_HYBRID_OPP_VELOCITY
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] - PlatformerIce_HYBRID_OPP_VELOCITY
							elseif s__Platformer_XTerrainPushedAgainst[p] == SLOWICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] - PlatformerIce_SLOW_VELOCITY * PlatformerIce_SLOW_OPPOSITIONDIFFERENCE * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] - PlatformerIce_SLOW_VELOCITY * PlatformerIce_SLOW_OPPOSITIONDIFFERENCE * SIN_45
							elseif s__Platformer_XTerrainPushedAgainst[p] == FASTICE then
								set s__vector2_x[projVelocity]=s__vector2_x[projVelocity] - PlatformerIce_FAST_VELOCITY * PlatformerIce_FAST_OPPOSITIONDIFFERENCE * SIN_45
								set s__vector2_y[projVelocity]=s__vector2_y[projVelocity] - PlatformerIce_FAST_VELOCITY * PlatformerIce_FAST_OPPOSITIONDIFFERENCE * SIN_45
							endif
						endif
					endif
				endif
				
				//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Projected velocity: " + projVelocity.toString())
				
				//compute projVelocity distance
				set distance=SquareRoot(s__vector2_x[projVelocity] * s__vector2_x[projVelocity] + s__vector2_y[projVelocity] * s__vector2_y[projVelocity])

				//check if projVelocity distance is greater than or equal to max speed for ice type
				if ( s__Platformer_XTerrainPushedAgainst[p] == SLOWICE and s__Platformer_YTerrainPushedAgainst[p] == FASTICE ) or ( s__Platformer_XTerrainPushedAgainst[p] == FASTICE and s__Platformer_YTerrainPushedAgainst[p] == SLOWICE ) then
					set maxDistance=( PlatformerIce_SLOW_MAX_VELOCITY + PlatformerIce_FAST_MAX_VELOCITY ) / 2
				elseif s__Platformer_XTerrainPushedAgainst[p] == SLOWICE or s__Platformer_YTerrainPushedAgainst[p] == SLOWICE then
					set maxDistance=PlatformerIce_SLOW_MAX_VELOCITY
				elseif s__Platformer_XTerrainPushedAgainst[p] == FASTICE or s__Platformer_YTerrainPushedAgainst[p] == FASTICE then
					set maxDistance=PlatformerIce_FAST_MAX_VELOCITY
				endif
				
				//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Max distance: " + R2S(maxDistance))
				
				//update velocity
				if distance > maxDistance then
					//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Projected velocity: " + projVelocity.toString())
					
					//only update velocities if they were below the max velocity before
					if SquareRoot(s__Platformer_XVelocity[p] * s__Platformer_XVelocity[p] + s__Platformer_YVelocity[p] * s__Platformer_YVelocity[p]) < maxDistance then
						set s__Platformer_XVelocity[p]=s__vector2_x[projVelocity] * maxDistance / distance
						set s__Platformer_YVelocity[p]=s__vector2_y[projVelocity] * maxDistance / distance
					endif
					
					//TODO show superspeed animation
				else
					set s__Platformer_XVelocity[p]=s__vector2_x[projVelocity]
					set s__Platformer_YVelocity[p]=s__vector2_y[projVelocity]
				endif
				
				//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Updated velocity: " + R2S(p.XVelocity))
				
				call s__vector2_deallocate((projVelocity)) // INLINED!!
			endif
		endif
		



        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "after: " + R2S(p.XVelocity))
    endfunction
    
    function PlatformerIce__Loop_Init takes nothing returns nothing
        local integer head= s__SimpleList_List_first[PlatformerIce_Platformers]
        
        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "init: " + I2S(head))
        
        if head != 0 then
            loop
            exitwhen head == 0
                call PlatformerIce__Loop(s__SimpleList_ListNode_value[head])
            set head=s__SimpleList_ListNode_next[head]
            endloop
        endif
    endfunction
    
    function PlatformerIce_Add takes integer p returns nothing
        if not PlatformerIce_IsOnIce[s__Platformer_PID[p]] then
            set PlatformerIce_IsOnIce[s__Platformer_PID[p]]=true
            
            call s__SimpleList_List_add(PlatformerIce_Platformers,p)
            
            if s__SimpleList_List_count[PlatformerIce_Platformers] == 1 then
                //set Timer = NewTimer()
                call TimerStart(PlatformerIce__Timer, PlatformerIce_TIMESTEP, true, function PlatformerIce__Loop_Init)
            endif
        endif
    endfunction
    
    function PlatformerIce_Remove takes integer p returns nothing
        if PlatformerIce_IsOnIce[s__Platformer_PID[p]] then
            set PlatformerIce_IsOnIce[s__Platformer_PID[p]]=false
            
            call s__SimpleList_List_remove(PlatformerIce_Platformers,p)
            
            if s__SimpleList_List_count[PlatformerIce_Platformers] == 0 then
                call PauseTimer(PlatformerIce__Timer)
                //call ReleaseTimer(Timer)
                //set Timer = null
            endif
        endif
    endfunction
    
    function PlatformerIce__Init takes nothing returns nothing
        local integer i= 0
        
        set PlatformerIce_Platformers=s__SimpleList_List_create()
        set PlatformerIce__Timer=CreateTimer()
        
        loop
        exitwhen i >= 8
            set PlatformerIce_IsOnIce[i]=false
        set i=i + 1
        endloop
    endfunction

//library PlatformerIce ends
//library PlatformerPropertyEquation:
    
    
        
//Implemented from module Alloc:
		
		

			

		
		
  function s__PlatformerPropertyAdjustment_allocate takes nothing returns integer
   local integer this= s__PlatformerPropertyAdjustment_Alloc___recycler[0]
			


			
			if ( s__PlatformerPropertyAdjustment_Alloc___recycler[this] == 0 ) then
				set s__PlatformerPropertyAdjustment_Alloc___recycler[0]=this + 1
			else
				set s__PlatformerPropertyAdjustment_Alloc___recycler[0]=s__PlatformerPropertyAdjustment_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__PlatformerPropertyAdjustment_deallocate takes integer this returns nothing


			


			
			set s__PlatformerPropertyAdjustment_Alloc___recycler[this]=s__PlatformerPropertyAdjustment_Alloc___recycler[0]
			set s__PlatformerPropertyAdjustment_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__PlatformerPropertyAdjustment_Alloc___onInit takes nothing returns nothing
			set s__PlatformerPropertyAdjustment_Alloc___recycler[0]=1
  endfunction
        
        function s__PlatformerPropertyAdjustment_create takes integer ttype,real value returns integer
            local integer new= s__PlatformerPropertyAdjustment_allocate()
            
            set s__PlatformerPropertyAdjustment_TerrainID[new]=ttype
            set s__PlatformerPropertyAdjustment_Value[new]=value
            
            return new
        endfunction
    
        
//Implemented from module Alloc:
		
		

			

		
		
  function s__PlatformerPropertyEquation_allocate takes nothing returns integer
   local integer this= s__PlatformerPropertyEquation_Alloc___recycler[0]
			


			
			if ( s__PlatformerPropertyEquation_Alloc___recycler[this] == 0 ) then
				set s__PlatformerPropertyEquation_Alloc___recycler[0]=this + 1
			else
				set s__PlatformerPropertyEquation_Alloc___recycler[0]=s__PlatformerPropertyEquation_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__PlatformerPropertyEquation_deallocate takes integer this returns nothing


			


			
			set s__PlatformerPropertyEquation_Alloc___recycler[this]=s__PlatformerPropertyEquation_Alloc___recycler[0]
			set s__PlatformerPropertyEquation_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__PlatformerPropertyEquation_Alloc___onInit takes nothing returns nothing
			set s__PlatformerPropertyEquation_Alloc___recycler[0]=1
  endfunction
        
        function s__PlatformerPropertyEquation_calculateAdjustedValue takes integer this,real baseValue returns real
            local integer adjustment= s__SimpleList_List_first[s__PlatformerPropertyEquation_MultiplicativeAdjustments[this]]
            
            loop
            exitwhen adjustment == 0
                set baseValue=baseValue * s__PlatformerPropertyAdjustment_Value[(s__SimpleList_ListNode_value[adjustment])]
            set adjustment=s__SimpleList_ListNode_next[adjustment]
            endloop
            
            set adjustment=s__SimpleList_List_first[s__PlatformerPropertyEquation_AdditiveAdjustments[this]]
            loop
            exitwhen adjustment == 0
                set baseValue=baseValue + s__PlatformerPropertyAdjustment_Value[(s__SimpleList_ListNode_value[adjustment])]
            set adjustment=s__SimpleList_ListNode_next[adjustment]
            endloop
            
            return baseValue
        endfunction
        
        function s__PlatformerPropertyEquation_getAdjustment takes integer this,boolean addOrMultiply,integer ttype returns integer
            local integer adjustmentNode
            local integer adjustment
            
            if addOrMultiply == PlatformerPropertyEquation_ADD_ADJUSTMENT then
                set adjustmentNode=s__SimpleList_List_first[s__PlatformerPropertyEquation_AdditiveAdjustments[this]]
                
                loop
                exitwhen adjustmentNode == 0
                    set adjustment=(s__SimpleList_ListNode_value[adjustmentNode])
                    
                    if s__PlatformerPropertyAdjustment_TerrainID[adjustment] == ttype then
                        return adjustment
                    endif
                set adjustmentNode=s__SimpleList_ListNode_next[adjustmentNode]
                endloop
            elseif addOrMultiply == PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT then
                set adjustmentNode=s__SimpleList_List_first[s__PlatformerPropertyEquation_MultiplicativeAdjustments[this]]
                
                loop
                exitwhen adjustmentNode == 0
                    set adjustment=(s__SimpleList_ListNode_value[adjustmentNode])
                    
                    if s__PlatformerPropertyAdjustment_TerrainID[adjustment] == ttype then
                        return adjustment
                    endif
                set adjustmentNode=s__SimpleList_ListNode_next[adjustmentNode]
                endloop
            endif
            
            return 0
        endfunction

        function s__PlatformerPropertyEquation_clearAdjustments takes integer this returns nothing
            local integer adjustment= s__SimpleList_List_first[s__PlatformerPropertyEquation_AdditiveAdjustments[this]]
            
            loop
            exitwhen adjustment == 0
                call s__PlatformerPropertyAdjustment_deallocate((s__SimpleList_ListNode_value[adjustment]))
            set adjustment=s__SimpleList_ListNode_next[adjustment]
            endloop
            
            set adjustment=s__SimpleList_List_first[s__PlatformerPropertyEquation_MultiplicativeAdjustments[this]]
            loop
            exitwhen adjustment == 0
                call s__PlatformerPropertyAdjustment_deallocate((s__SimpleList_ListNode_value[adjustment]))
            set adjustment=s__SimpleList_ListNode_next[adjustment]
            endloop
            
            call s__SimpleList_List_clear(s__PlatformerPropertyEquation_AdditiveAdjustments[this])
            call s__SimpleList_List_clear(s__PlatformerPropertyEquation_MultiplicativeAdjustments[this])
        endfunction
        
        function s__PlatformerPropertyEquation_removeAdjustment takes integer this,boolean addOrMultiply,integer ttype returns nothing
            local integer adjustmentNode
            local integer adjustment
            
            if addOrMultiply == PlatformerPropertyEquation_ADD_ADJUSTMENT then
                set adjustmentNode=s__SimpleList_List_first[s__PlatformerPropertyEquation_AdditiveAdjustments[this]]
                
                loop
                exitwhen adjustmentNode == 0
                    set adjustment=(s__SimpleList_ListNode_value[adjustmentNode])
                    
                    if s__PlatformerPropertyAdjustment_TerrainID[adjustment] == ttype then
                        call s__PlatformerPropertyAdjustment_deallocate(adjustment)
                        call s__SimpleList_List_removeNode(s__PlatformerPropertyEquation_AdditiveAdjustments[this],adjustmentNode)
                        //call .AdditiveAdjustments.remove(adjustment.value)
                    endif
                set adjustmentNode=s__SimpleList_ListNode_next[adjustmentNode]
                endloop
            elseif addOrMultiply == PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT then
                set adjustmentNode=s__SimpleList_List_first[s__PlatformerPropertyEquation_MultiplicativeAdjustments[this]]
                
                loop
                exitwhen adjustmentNode == 0
                    set adjustment=(s__SimpleList_ListNode_value[adjustmentNode])
                    
                    if s__PlatformerPropertyAdjustment_TerrainID[adjustment] == ttype then
                        call s__PlatformerPropertyAdjustment_deallocate(adjustment)
                        call s__SimpleList_List_removeNode(s__PlatformerPropertyEquation_MultiplicativeAdjustments[this],adjustmentNode)
                    endif
                set adjustmentNode=s__SimpleList_ListNode_next[adjustmentNode]
                endloop
            endif
        endfunction
        
        function s__PlatformerPropertyEquation_addAdjustment takes integer this,boolean addOrMultiply,integer ttype,real value returns nothing
            call s__PlatformerPropertyEquation_removeAdjustment(this,addOrMultiply , ttype)
            
            //debug call .AdditiveAdjustments.print(0)
            //debug call .MultiplicativeAdjustments.print(0)
            
            if addOrMultiply == PlatformerPropertyEquation_ADD_ADJUSTMENT then
                call s__SimpleList_List_addEnd(s__PlatformerPropertyEquation_AdditiveAdjustments[this],s__PlatformerPropertyAdjustment_create(ttype , value))
                //debug call .AdditiveAdjustments.print(0)
            elseif addOrMultiply == PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT then
                call s__SimpleList_List_addEnd(s__PlatformerPropertyEquation_MultiplicativeAdjustments[this],s__PlatformerPropertyAdjustment_create(ttype , value))
                //debug call .MultiplicativeAdjustments.print(0)
            endif
        endfunction
                
        function s__PlatformerPropertyEquation_destroy takes integer this returns nothing
            call s__PlatformerPropertyEquation_clearAdjustments(this)
            
            call s__SimpleList_List_destroy(s__PlatformerPropertyEquation_AdditiveAdjustments[this])
            call s__SimpleList_List_destroy(s__PlatformerPropertyEquation_MultiplicativeAdjustments[this])
            
            call s__PlatformerPropertyEquation_deallocate(this)
        endfunction
        
        function s__PlatformerPropertyEquation_create takes nothing returns integer
            local integer new= s__PlatformerPropertyEquation_allocate()
            
            set s__PlatformerPropertyEquation_AdditiveAdjustments[new]=s__SimpleList_List_create()
            set s__PlatformerPropertyEquation_MultiplicativeAdjustments[new]=s__SimpleList_List_create()
            
            return new
        endfunction

//library PlatformerPropertyEquation ends
//library PlatformerSlipStream:

    function PlatformerSlipStream__SlipStream takes nothing returns nothing
        local integer cur= s__SimpleList_List_first[PlatformerSlipStream__l]
        local integer p
        local integer platformerTerrainCenter
        local real yMin
        local real yMax
        local real halfLength
        local real distFromMiddle
        local real percentFromCenter
        local real multiplier
        local real offset
        
        loop
        exitwhen cur == 0
            set p=s__SimpleList_ListNode_value[cur]
            
            set platformerTerrainCenter=GetTerrainCenterpoint(s__Platformer_XPosition[p] , s__Platformer_YPosition[p])
            
            set yMin=s__vector2_y[platformerTerrainCenter]
            set yMax=s__vector2_y[platformerTerrainCenter]
            
            loop
            exitwhen GetTerrainType(s__Platformer_XPosition[p], yMin - TERRAIN_TILE_SIZE) != SLIPSTREAM
                set yMin=yMin - TERRAIN_TILE_SIZE
            endloop
            loop
            exitwhen GetTerrainType(s__Platformer_XPosition[p], yMax + TERRAIN_TILE_SIZE) != SLIPSTREAM
                set yMax=yMax + TERRAIN_TILE_SIZE
            endloop
            //recycling yMin to avoid declaring another local... a more accurate name would be yMiddle
            set yMin=( yMin + yMax ) / 2
            
            //halfLength = yMax - yMin(yMiddle)
            //percentFromCenter <-1,1> = (p.YPosition - yMin(yMiddle)) / halfLength 
            set halfLength=yMax - yMin
            set distFromMiddle=s__Platformer_YPosition[p] - yMin
            set percentFromCenter=distFromMiddle / halfLength
            set multiplier=- Sin(percentFromCenter * bj_PI / 2)
            //set multiplier = Sin(((p.YPosition - yMin) / (yMax - yMin)) * -bj_PI / 2)
            set offset=PlatformerSlipStream_OFFSET * multiplier
            
            
            
            set s__Platformer_YVelocity[p]=s__Platformer_YVelocity[p] + offset
            
            //this only works perfectly if the unit starts at the bottom or the top. it would be better to compute their expected velocity and set towards that
            
            
        set cur=s__SimpleList_ListNode_next[cur]
        endloop
    endfunction
    
    function PlatformerSlipStream_Add takes integer p returns nothing
        call s__SimpleList_List_addEnd(PlatformerSlipStream__l,p)
        
        if s__SimpleList_List_count[PlatformerSlipStream__l] == 1 then
            call TimerStart(PlatformerSlipStream__t, PlatformerSlipStream_TIMEOUT, true, function PlatformerSlipStream__SlipStream)
        endif
    endfunction
    
    function PlatformerSlipStream_Remove takes integer p returns nothing
        call s__SimpleList_List_remove(PlatformerSlipStream__l,p)
        
        if s__SimpleList_List_count[PlatformerSlipStream__l] == 0 then
            call PauseTimer(PlatformerSlipStream__t)
        endif
    endfunction
    
    function PlatformerSlipStream__Init takes nothing returns nothing
        set PlatformerSlipStream__l=s__SimpleList_List_create()
    endfunction

//library PlatformerSlipStream ends
//library PlayerUtils:
//===========================================================================
// "PlayerUtils" by Alain.Mark
//
// -Info-
//  -The main purpose of this lib is to get rid of using the Player(...) function
//  and replace it with a faster array search instead. (also w/ added utilities)
//
// -API-
//  -function GetPlayerById takes integer id returns nothing
//  -function GetPlayersCount takes nothing returns integer
//  -function GetHumanPlayersCount takes nothing returns integer
//  -function GetComputerPlayersCount takes nothing returns integer
//
//===========================================================================

    //=======================================================================
        
    //=======================================================================
        
    //=======================================================================
        function GetPlayerById takes integer id returns player
            return PlayerUtils___IndexedPlayers[id]
        endfunction
        
    //=======================================================================
        function GetPlayersCount takes nothing returns integer
            return PlayerUtils___ACTIVE_PLAYERS_COUNT
        endfunction
        
    //=======================================================================
        function GetHumanPlayersCount takes nothing returns integer
            return PlayerUtils___ACTIVE_HUMAN_PLAYERS_COUNT
        endfunction
        
    //=======================================================================
        function GetComputerPlayersCount takes nothing returns integer
            return PlayerUtils___ACTIVE_COMPUTER_PLAYERS_COUNT
        endfunction
        
    //=======================================================================
        function PlayerUtils___DetectLeavers takes nothing returns nothing
            local integer pID= GetPlayerId(GetTriggerPlayer())
            
            set PlayerUtils___ACTIVE_PLAYERS_COUNT=PlayerUtils___ACTIVE_PLAYERS_COUNT - 1
            set PlayerUtils___ACTIVE_HUMAN_PLAYERS_COUNT=PlayerUtils___ACTIVE_HUMAN_PLAYERS_COUNT - 1
            
            call s__SimpleList_List_remove(PlayerUtils_PlayerList,pID)
			set PlayerUtils_FirstPlayer=s__SimpleList_List_first[PlayerUtils_PlayerList]
        endfunction
        
    //=======================================================================
        function PlayerUtils_Init takes nothing returns nothing
            local player pl
            local integer n= 0
            
            set PlayerUtils_PlayerList=s__SimpleList_List_create()
            
            loop
                exitwhen n > NumberPlayers
                set pl=Player(n)
                if GetPlayerSlotState(pl) == PLAYER_SLOT_STATE_PLAYING then
                    if GetPlayerController(pl) == MAP_CONTROL_USER then
                        set PlayerUtils___ACTIVE_HUMAN_PLAYERS_COUNT=PlayerUtils___ACTIVE_HUMAN_PLAYERS_COUNT + 1
                        call TriggerRegisterPlayerEvent(PlayerUtils___LEAVER_SENTINEL, pl, EVENT_PLAYER_LEAVE)
                        call s__SimpleList_List_addEnd(PlayerUtils_PlayerList,n)
                    endif
                    set PlayerUtils___IndexedPlayers[n]=pl
                    set PlayerUtils___ACTIVE_PLAYERS_COUNT=PlayerUtils___ACTIVE_PLAYERS_COUNT + 1
                endif
                set n=n + 1
            endloop
            
            set PlayerUtils_FirstPlayer=s__SimpleList_List_first[PlayerUtils_PlayerList]
            set PlayerUtils___ACTIVE_COMPUTER_PLAYERS_COUNT=PlayerUtils___ACTIVE_PLAYERS_COUNT - PlayerUtils___ACTIVE_HUMAN_PLAYERS_COUNT
            
            call TriggerAddCondition(PlayerUtils___LEAVER_SENTINEL, Filter(function PlayerUtils___DetectLeavers))
        endfunction
        
//===========================================================================

//library PlayerUtils ends
//library RelayGenerator:
    
        //public unit Unit
        //public RelayGenerator Parent
        
//Implemented from module Alloc:
		
		

			

		
		
  function s__RelayUnit_allocate takes nothing returns integer
   local integer this= s__RelayUnit_Alloc___recycler[0]
			


			
			if ( s__RelayUnit_Alloc___recycler[this] == 0 ) then
				set s__RelayUnit_Alloc___recycler[0]=this + 1
			else
				set s__RelayUnit_Alloc___recycler[0]=s__RelayUnit_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__RelayUnit_deallocate takes integer this returns nothing


			


			
			set s__RelayUnit_Alloc___recycler[this]=s__RelayUnit_Alloc___recycler[0]
			set s__RelayUnit_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__RelayUnit_Alloc___onInit takes nothing returns nothing
			set s__RelayUnit_Alloc___recycler[0]=1
  endfunction
        
        function s__RelayUnit_create takes integer lane,integer firstTurn returns integer
            local integer new= s__RelayUnit_allocate()
            
            set s__RelayUnit_LaneNumber[new]=lane
            set s__RelayUnit_CurrentTurn[new]=firstTurn
            
            return new
        endfunction
    
        //public vector2 FirstLaneRelative
        
        
//Implemented from module Alloc:
		
		

			

		
		
  function s__RelayTurn_allocate takes nothing returns integer
   local integer this= s__RelayTurn_Alloc___recycler[0]
			


			
			if ( s__RelayTurn_Alloc___recycler[this] == 0 ) then
				set s__RelayTurn_Alloc___recycler[0]=this + 1
			else
				set s__RelayTurn_Alloc___recycler[0]=s__RelayTurn_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__RelayTurn_deallocate takes integer this returns nothing


			


			
			set s__RelayTurn_Alloc___recycler[this]=s__RelayTurn_Alloc___recycler[0]
			set s__RelayTurn_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__RelayTurn_Alloc___onInit takes nothing returns nothing
			set s__RelayTurn_Alloc___recycler[0]=1
  endfunction
        
        function s__RelayTurn_DrawCorner takes integer this returns nothing
            
        endfunction
        
        function s__RelayTurn_create takes rect area,integer center,integer generator,integer direction,real distance,integer firstX,integer firstY returns integer
            local integer new= s__RelayTurn_allocate()
            local integer firstLane
            
            set s__RelayTurn_Direction[new]=direction
            set s__RelayTurn_Distance[new]=distance
            set s__RelayTurn_Area[new]=area
            set s__RelayTurn_Center[new]=center
            
            set s__RelayTurn_FirstLaneX[new]=firstX
            set s__RelayTurn_FirstLaneY[new]=firstY
            
            //set new.FirstLaneRelative = vector2.create(firstX, firstY)
            set firstLane=s__vector2_create(s__vector2_x[center] , s__vector2_y[center])
            if firstX == RelayGenerator___LEFT then
				if ModuloInteger(s__RelayGenerator_Diameter[generator], 2) == 0 then
					set s__vector2_x[firstLane]=s__vector2_x[firstLane] - (R2I(s__RelayGenerator_Diameter[(generator)] / 2.)) * TERRAIN_TILE_SIZE + TERRAIN_QUADRANT_SIZE + RelayGenerator___UNIT_SIDE_BUFFER * s__RelayGenerator_UnitLaneSize[generator] // INLINED!!
				else
					set s__vector2_x[firstLane]=s__vector2_x[firstLane] - (R2I(s__RelayGenerator_Diameter[(generator)] / 2.)) * TERRAIN_TILE_SIZE + RelayGenerator___UNIT_SIDE_BUFFER * s__RelayGenerator_UnitLaneSize[generator] // INLINED!!
				endif
            else
				if ModuloInteger(s__RelayGenerator_Diameter[generator], 2) == 0 then
					set s__vector2_x[firstLane]=s__vector2_x[firstLane] + (R2I(s__RelayGenerator_Diameter[(generator)] / 2.)) * TERRAIN_TILE_SIZE - TERRAIN_QUADRANT_SIZE - RelayGenerator___UNIT_SIDE_BUFFER * s__RelayGenerator_UnitLaneSize[generator] // INLINED!!
				else
					set s__vector2_x[firstLane]=s__vector2_x[firstLane] + (R2I(s__RelayGenerator_Diameter[(generator)] / 2.)) * TERRAIN_TILE_SIZE - RelayGenerator___UNIT_SIDE_BUFFER * s__RelayGenerator_UnitLaneSize[generator] // INLINED!!
				endif
                
            endif
            
            if firstY == RelayGenerator___DOWN then
                if ModuloInteger(s__RelayGenerator_Diameter[generator], 2) == 0 then
					set s__vector2_y[firstLane]=s__vector2_y[firstLane] - (R2I(s__RelayGenerator_Diameter[(generator)] / 2.)) * TERRAIN_TILE_SIZE + TERRAIN_QUADRANT_SIZE + RelayGenerator___UNIT_SIDE_BUFFER * s__RelayGenerator_UnitLaneSize[generator] // INLINED!!
				else
					set s__vector2_y[firstLane]=s__vector2_y[firstLane] - (R2I(s__RelayGenerator_Diameter[(generator)] / 2.)) * TERRAIN_TILE_SIZE + RelayGenerator___UNIT_SIDE_BUFFER * s__RelayGenerator_UnitLaneSize[generator] // INLINED!!
				endif
            else
                if ModuloInteger(s__RelayGenerator_Diameter[generator], 2) == 0 then
					set s__vector2_y[firstLane]=s__vector2_y[firstLane] + (R2I(s__RelayGenerator_Diameter[(generator)] / 2.)) * TERRAIN_TILE_SIZE - TERRAIN_QUADRANT_SIZE - RelayGenerator___UNIT_SIDE_BUFFER * s__RelayGenerator_UnitLaneSize[generator] // INLINED!!
				else
					set s__vector2_y[firstLane]=s__vector2_y[firstLane] + (R2I(s__RelayGenerator_Diameter[(generator)] / 2.)) * TERRAIN_TILE_SIZE - RelayGenerator___UNIT_SIDE_BUFFER * s__RelayGenerator_UnitLaneSize[generator] // INLINED!!
				endif
            endif
            set s__RelayTurn_FirstLane[new]=firstLane
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "First lane: " + new.FirstLane.toString())
            
            //debug call Draw_DrawRegion(area, 0)
            //debug call CreateUnit(Player(RELAY_PLAYER), DEBUG_UNIT, new.Center.x, new.Center.y, 0)
            //debug call CreateUnit(Player(0), DEBUG_UNIT, new.FirstLane.x, new.FirstLane.y, 0)
            
            return new
        endfunction
    
        //public real Radius //in whole tile units
        
		
        
        
        
        
        //implement Alloc
        













        
        function s__RelayGenerator_ToString takes integer this returns string
            return "Unit Lane Size: " + R2S(s__RelayGenerator_UnitLaneSize[this]) + ", radius: " + R2S((R2I(s__RelayGenerator_Diameter[(this)] / 2.))) + ", number lanes: " + I2S(sc__RelayGenerator_GetNumberLanes(this)) // INLINED!!
        endfunction
        
  function s__RelayGenerator_GetNumberLanes takes integer this returns integer
            //number lanes in a single tile = tile-size / lane-offset
            //number lanes total = lanes-single * spawn-diameter
            return R2I(s__RelayGenerator_Diameter[this] * TERRAIN_TILE_SIZE / s__RelayGenerator_UnitLaneSize[this]) - RelayGenerator___UNIT_SIDE_BUFFER * 2
        endfunction
  function s__RelayGenerator_GetRadius takes integer this returns integer
			return R2I(s__RelayGenerator_Diameter[this] / 2.)
  endfunction
		
        
        
        //rect area needs to be in a legal position relative to the last turn's center, and combination of newDirection and newDistance needs to get a unit from their last rect to this one
        function s__RelayGenerator_AddTurn takes integer this,rect area,integer center,integer newDirection,real newDistance returns nothing
            //nextTurn.flipped = 
            local integer turn
            local integer lastTurn= (s__SimpleList_ListNode_value[s__SimpleList_List_last[s__RelayGenerator_Turns[this]]])
            
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Last turn ID " + I2S(Turns.last.value))
                        
            //check if turning 90 degrees
            if ( ( s__RelayTurn_Direction[lastTurn] == 0 or s__RelayTurn_Direction[lastTurn] == 180 ) and ( newDirection == 90 or newDirection == 270 ) ) or ( ( s__RelayTurn_Direction[lastTurn] == 90 or s__RelayTurn_Direction[lastTurn] == 270 ) and ( newDirection == 0 or newDirection == 180 ) ) then
                if newDirection == 90 then
                    if s__RelayTurn_Direction[lastTurn] == 0 then
                        //right -> up
                        if s__RelayTurn_FirstLaneY[lastTurn] == RelayGenerator___UP then
                            set turn=s__RelayTurn_create(area , center , this , newDirection , newDistance , RelayGenerator___LEFT , RelayGenerator___UP)
                        else //lastTurn.FirstLaneY == BOTTOM
                            set turn=s__RelayTurn_create(area , center , this , newDirection , newDistance , RelayGenerator___RIGHT , RelayGenerator___DOWN)
                        endif
                    else //lastTurn.Direction == 180
                        //left -> up
                        if s__RelayTurn_FirstLaneY[lastTurn] == RelayGenerator___UP then
                            set turn=s__RelayTurn_create(area , center , this , newDirection , newDistance , RelayGenerator___RIGHT , RelayGenerator___UP)
                        else //lastTurn.FirstLaneY == BOTTOM
                            set turn=s__RelayTurn_create(area , center , this , newDirection , newDistance , RelayGenerator___LEFT , RelayGenerator___DOWN)
                        endif
                    endif
                elseif newDirection == 270 then
                    if s__RelayTurn_Direction[lastTurn] == 0 then
                        //right -> down
                        if s__RelayTurn_FirstLaneY[lastTurn] == RelayGenerator___UP then
                            set turn=s__RelayTurn_create(area , center , this , newDirection , newDistance , RelayGenerator___RIGHT , RelayGenerator___UP)
                        else //lastTurn.FirstLaneY == BOTTOM
                            set turn=s__RelayTurn_create(area , center , this , newDirection , newDistance , RelayGenerator___LEFT , RelayGenerator___DOWN)
                        endif
                    else //lastTurn.Direction == 180
                        //left -> down
                        if s__RelayTurn_FirstLaneY[lastTurn] == RelayGenerator___UP then
                            set turn=s__RelayTurn_create(area , center , this , newDirection , newDistance , RelayGenerator___LEFT , RelayGenerator___UP)
                        else //lastTurn.FirstLaneY == BOTTOM
                            set turn=s__RelayTurn_create(area , center , this , newDirection , newDistance , RelayGenerator___RIGHT , RelayGenerator___DOWN)
                        endif
                    endif
                elseif newDirection == 0 then
                    if s__RelayTurn_Direction[lastTurn] == 90 then
                        //up -> right
                        if s__RelayTurn_FirstLaneX[lastTurn] == RelayGenerator___LEFT then
                            set turn=s__RelayTurn_create(area , center , this , newDirection , newDistance , RelayGenerator___LEFT , RelayGenerator___UP)
                        else //lastTurn.FirstLaneX == RIGHT
                            set turn=s__RelayTurn_create(area , center , this , newDirection , newDistance , RelayGenerator___RIGHT , RelayGenerator___DOWN)
                        endif
                    else //lastTurn.Direction == 270
                        //down -> right
                        if s__RelayTurn_FirstLaneX[lastTurn] == RelayGenerator___LEFT then
                            set turn=s__RelayTurn_create(area , center , this , newDirection , newDistance , RelayGenerator___LEFT , RelayGenerator___DOWN)
                        else //lastTurn.FirstLaneX == RIGHT
                            set turn=s__RelayTurn_create(area , center , this , newDirection , newDistance , RelayGenerator___RIGHT , RelayGenerator___UP)
                        endif
                    endif
                else //newDirection == 180
                    if s__RelayTurn_Direction[lastTurn] == 90 then
                        //up -> left
                        if s__RelayTurn_FirstLaneX[lastTurn] == RelayGenerator___LEFT then
                            set turn=s__RelayTurn_create(area , center , this , newDirection , newDistance , RelayGenerator___LEFT , RelayGenerator___DOWN)
                        else //lastTurn.FirstLaneX == RIGHT
                            set turn=s__RelayTurn_create(area , center , this , newDirection , newDistance , RelayGenerator___RIGHT , RelayGenerator___UP)
                        endif
                    else //lastTurn.Direction == 270
                        //down -> left
                        if s__RelayTurn_FirstLaneX[lastTurn] == RelayGenerator___LEFT then
                            set turn=s__RelayTurn_create(area , center , this , newDirection , newDistance , RelayGenerator___LEFT , RelayGenerator___UP)
                        else //lastTurn.FirstLaneX == RIGHT
                            set turn=s__RelayTurn_create(area , center , this , newDirection , newDistance , RelayGenerator___RIGHT , RelayGenerator___DOWN)
                        endif
                    endif
                endif
                
            else
                //either continuing straight or doubling back -- either way, persist the unchanged part of the first lane position
                if newDirection == 0 then
                    set turn=s__RelayTurn_create(area , center , this , newDirection , newDistance , RelayGenerator___RIGHT , s__RelayTurn_FirstLaneY[lastTurn])
                elseif newDirection == 180 then
                    set turn=s__RelayTurn_create(area , center , this , newDirection , newDistance , RelayGenerator___LEFT , s__RelayTurn_FirstLaneY[lastTurn])
                elseif newDirection == 90 then
                    set turn=s__RelayTurn_create(area , center , this , newDirection , newDistance , s__RelayTurn_FirstLaneX[lastTurn] , RelayGenerator___UP)
                else
                    set turn=s__RelayTurn_create(area , center , this , newDirection , newDistance , s__RelayTurn_FirstLaneX[lastTurn] , RelayGenerator___DOWN)
                endif
            endif
            
            if turn != 0 then
                call s__SimpleList_List_addEnd(s__RelayGenerator_Turns[this],turn)
                
                //debug call this.Turns.print(0)
            endif
        endfunction
        
        //uses easier to provide parameters to create a guaranteed legal destination rect
        function s__RelayGenerator_AddTurnSimple takes integer this,integer newDirection,integer tilesToTravel returns nothing
            local integer lastTurn= (s__SimpleList_ListNode_value[s__SimpleList_List_last[s__RelayGenerator_Turns[this]]])
            
            //relay diameter = (LaneCount + 2) / 2
            local real radius= (R2I(s__RelayGenerator_Diameter[(this)] / 2.)) * TERRAIN_TILE_SIZE // INLINED!!
            local real totalDistance= s__RelayGenerator_Diameter[this] * TERRAIN_TILE_SIZE + tilesToTravel * TERRAIN_TILE_SIZE
            
            local real turnCenterX
            local real turnCenterY
            
            if s__RelayTurn_Direction[lastTurn] == 0 then
                set turnCenterX=s__vector2_x[s__RelayTurn_Center[lastTurn]] + s__RelayTurn_Distance[lastTurn]
                set turnCenterY=s__vector2_y[s__RelayTurn_Center[lastTurn]]
            elseif s__RelayTurn_Direction[lastTurn] == 180 then
                set turnCenterX=s__vector2_x[s__RelayTurn_Center[lastTurn]] - s__RelayTurn_Distance[lastTurn]
                set turnCenterY=s__vector2_y[s__RelayTurn_Center[lastTurn]]
            elseif s__RelayTurn_Direction[lastTurn] == 90 then
                set turnCenterX=s__vector2_x[s__RelayTurn_Center[lastTurn]]
                set turnCenterY=s__vector2_y[s__RelayTurn_Center[lastTurn]] + s__RelayTurn_Distance[lastTurn]
            else //lastTurn.Direction == 270
                set turnCenterX=s__vector2_x[s__RelayTurn_Center[lastTurn]]
                set turnCenterY=s__vector2_y[s__RelayTurn_Center[lastTurn]] - s__RelayTurn_Distance[lastTurn]
            endif
            
            if ( ( s__RelayTurn_Direction[lastTurn] == 0 or s__RelayTurn_Direction[lastTurn] == 180 ) and ( newDirection == 90 or newDirection == 270 ) ) or ( ( s__RelayTurn_Direction[lastTurn] == 90 or s__RelayTurn_Direction[lastTurn] == 270 ) and ( newDirection == 0 or newDirection == 180 ) ) then
                call s__RelayGenerator_AddTurn(this,Rect(turnCenterX - radius - RelayGenerator___TURN_RECT_BUFFER, turnCenterY - radius - RelayGenerator___TURN_RECT_BUFFER, turnCenterX + radius + RelayGenerator___TURN_RECT_BUFFER, turnCenterY + radius + RelayGenerator___TURN_RECT_BUFFER) , s__vector2_create(turnCenterX , turnCenterY) , newDirection , totalDistance)
            else
                //get 1 cell wide rect on far side of square
                if newDirection == 0 then
                    call s__RelayGenerator_AddTurn(this,Rect(turnCenterX + radius - TERRAIN_TILE_SIZE - RelayGenerator___TURN_RECT_BUFFER, turnCenterY - radius - RelayGenerator___TURN_RECT_BUFFER, turnCenterX + radius + RelayGenerator___TURN_RECT_BUFFER, turnCenterY + radius + RelayGenerator___TURN_RECT_BUFFER) , s__vector2_create(turnCenterX , turnCenterY) , newDirection , totalDistance)
                elseif newDirection == 180 then
                    call s__RelayGenerator_AddTurn(this,Rect(turnCenterX - radius - RelayGenerator___TURN_RECT_BUFFER, turnCenterY - radius - RelayGenerator___TURN_RECT_BUFFER, turnCenterX - radius + TERRAIN_TILE_SIZE + RelayGenerator___TURN_RECT_BUFFER, turnCenterY + radius + RelayGenerator___TURN_RECT_BUFFER) , s__vector2_create(turnCenterX , turnCenterY) , newDirection , totalDistance)
                elseif newDirection == 90 then
                    call s__RelayGenerator_AddTurn(this,Rect(turnCenterX - radius - RelayGenerator___TURN_RECT_BUFFER, turnCenterY + radius - TERRAIN_TILE_SIZE - RelayGenerator___TURN_RECT_BUFFER, turnCenterX + radius + RelayGenerator___TURN_RECT_BUFFER, turnCenterY + radius + RelayGenerator___TURN_RECT_BUFFER) , s__vector2_create(turnCenterX , turnCenterY) , newDirection , totalDistance)
                else
                    call s__RelayGenerator_AddTurn(this,Rect(turnCenterX - radius - RelayGenerator___TURN_RECT_BUFFER, turnCenterY - radius - RelayGenerator___TURN_RECT_BUFFER, turnCenterX + radius + RelayGenerator___TURN_RECT_BUFFER, turnCenterY - radius + TERRAIN_TILE_SIZE + RelayGenerator___TURN_RECT_BUFFER) , s__vector2_create(turnCenterX , turnCenterY) , newDirection , totalDistance)
                endif
            endif
        endfunction
        
        function s__RelayGenerator_GetTurnDestination takes integer this,integer currentTurn,integer lane returns integer
            local integer nextTurn= (s__SimpleList_ListNode_value[s__SimpleList_ListNode_next[currentTurn]])
            
            //get the location of the first lane
            //check if corner
            if ( ( s__RelayTurn_Direction[(s__SimpleList_ListNode_value[currentTurn])] == 0 or s__RelayTurn_Direction[(s__SimpleList_ListNode_value[currentTurn])] == 180 ) and ( s__RelayTurn_Direction[nextTurn] == 90 or s__RelayTurn_Direction[nextTurn] == 270 ) ) or ( ( s__RelayTurn_Direction[(s__SimpleList_ListNode_value[currentTurn])] == 90 or s__RelayTurn_Direction[(s__SimpleList_ListNode_value[currentTurn])] == 270 ) and ( s__RelayTurn_Direction[nextTurn] == 0 or s__RelayTurn_Direction[nextTurn] == 180 ) ) then
				//get this units lane using firstLane
                return s__vector2_create(s__vector2_x[s__RelayTurn_FirstLane[nextTurn]] + s__RelayTurn_FirstLaneX[nextTurn] * s__RelayGenerator_UnitLaneSize[this] * lane , s__vector2_y[s__RelayTurn_FirstLane[nextTurn]] + s__RelayTurn_FirstLaneY[nextTurn] * s__RelayGenerator_UnitLaneSize[this] * lane)
            else //straight of some sorts
                if s__RelayTurn_Direction[nextTurn] == 90 or s__RelayTurn_Direction[nextTurn] == 270 then
                    return s__vector2_create(s__vector2_x[s__RelayTurn_FirstLane[nextTurn]] + s__RelayTurn_FirstLaneX[nextTurn] * s__RelayGenerator_UnitLaneSize[this] * lane , s__vector2_y[s__RelayTurn_FirstLane[nextTurn]])
                else //LEFT or RIGHT
                    return s__vector2_create(s__vector2_x[s__RelayTurn_FirstLane[nextTurn]] , s__vector2_y[s__RelayTurn_FirstLane[nextTurn]] + s__RelayTurn_FirstLaneY[nextTurn] * s__RelayGenerator_UnitLaneSize[this] * lane)
                endif
            endif
        endfunction
		
  function s__RelayGenerator_GetCachedTurnDestination takes integer this,integer currentTurn,integer lane returns integer
			// debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Current turn: " + I2S(currentTurn) + ", current turn index: " + I2S(IndexedListNode(currentTurn).index) + ", lane: " + I2S(lane))
			// debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Cached index: " + I2S(IndexedListNode(currentTurn).index*this.GetNumberLanes() + lane))
			return s__SimpleList_ListNode_value[s__IndexedListNode_base[(LoadInteger(Table___ht, (s__IndexedList_indexedNodes[(s__RelayGenerator_CachedTurnDestinations[this])]), ((s__IndexedListNode_index[(currentTurn)] * s__RelayGenerator_GetNumberLanes(this) + lane))))]] // INLINED!!
  endfunction
  function s__RelayGenerator_GetCachedNextTurnDestination takes integer this,integer turnUnit returns integer
			// debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Turn Unit: " + I2S(turnUnit) + ", cached destination: " + this.GetCachedTurnDestination(turnUnit.CurrentTurn, turnUnit.LaneNumber).toString())
			return s__RelayGenerator_GetCachedTurnDestination(this,s__RelayUnit_CurrentTurn[turnUnit] , s__RelayUnit_LaneNumber[turnUnit])
  endfunction
  function s__RelayGenerator_InitTurnDestinationCache takes integer this returns nothing
   local integer curTurnNode= s__SimpleList_List_first[s__RelayGenerator_Turns[this]]
   local integer curTurnIndex= 0
   local integer curLane
   local integer numberLanes= s__RelayGenerator_GetNumberLanes(this)
   local integer turnDestinationCache= s__SimpleList_List_create()
			
			//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Initializing destination cache for relay: " + I2S(this))
			
			loop
			exitwhen curTurnNode == 0
				set curLane=0
				loop
				exitwhen curLane >= numberLanes
					 call s__SimpleList_List_addEnd(turnDestinationCache,s__RelayGenerator_GetTurnDestination(this,curTurnNode , curLane))
				set curLane=curLane + 1
				endloop
				
			set curTurnNode=s__SimpleList_ListNode_next[curTurnNode]
			set curTurnIndex=curTurnIndex + 1
			endloop
			
			set s__RelayGenerator_CachedTurnDestinations[this]=s__IndexedList_create(turnDestinationCache)
  endfunction
        		
		//register the rect that matches the final turn's destination under a remove unit timer event
        function s__RelayGenerator_EndTurns takes integer this,integer endDirection returns nothing
            call s__RelayGenerator_AddTurnSimple(this,endDirection , 0)
			
			call s__IndexedList_create(s__RelayGenerator_Turns[this])
			call s__RelayGenerator_InitTurnDestinationCache(this)
        endfunction
		        
        function s__RelayGenerator_CreateUnitCB takes nothing returns nothing
            local integer this= (LoadInteger(TimerUtils___ht, 0, GetHandleId((GetExpiredTimer())))) // INLINED!!
   local integer spawnTurn= s__SimpleList_ListNode_value[s__SimpleList_List_first[s__RelayGenerator_Turns[this]]]
   local integer spawnUnit
			
   local group g
            local unit u
   local integer lane
            local integer destination
            
            set g=s__PatternSpawn_Spawn(s__RelayPatternSpawn_Pattern[s__RelayGenerator_SpawnPattern[this]],s__IStartable_ParentLevel[this])
			loop
			set u=FirstOfGroup(g)
			exitwhen u == null
				if s__RelayTurn_Direction[spawnTurn] == 90 or s__RelayTurn_Direction[spawnTurn] == 270 then
					//GetUnitX(u) = spawnTurn.FirstLane.x + spawnTurn.FirstLaneX*lane*this.UnitLaneSize
					//GetUnitX(u) - spawnTurn.FirstLane.x = spawnTurn.FirstLaneX*lane*this.UnitLaneSize
					//(GetUnitX(u) - spawnTurn.FirstLane.x) / (spawnTurn.FirstLaneX * this.UnitLaneSize) = lane
					set lane=R2I(( GetUnitX(u) - s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] ) / ( s__RelayTurn_FirstLaneX[spawnTurn] * s__RelayGenerator_UnitLaneSize[this] ))
				else
					set lane=R2I(( GetUnitY(u) - s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]] ) / ( s__RelayTurn_FirstLaneY[spawnTurn] * s__RelayGenerator_UnitLaneSize[this] ))
				endif
				
				//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Creating unit in lane " + I2S(lane))				
				call GroupAddUnit(s__RelayGenerator_Units[this], u)
				set spawnUnit=s__RelayUnit_create(lane , s__SimpleList_List_first[s__RelayGenerator_Turns[this]])
				set s__RelayGenerator_UnitIDToRelayUnitID[GetUnitUserData(u)]=spawnUnit
				
				//send unit to first destination
				set destination=s__RelayGenerator_GetCachedNextTurnDestination(this,spawnUnit)
				//call IssuePointOrder(u, "move", destination.x, destination.y)
				call SetUnitFacingTimed(u, s__RelayTurn_Direction[(s__SimpleList_ListNode_value[s__SimpleList_List_first[s__RelayGenerator_Turns[this]]])], 0)
				
				if IsUnitAnimated(GetUnitTypeId(u)) then
					call SetUnitAnimationByIndex(u, GetWalkAnimationIndex(GetUnitTypeId(u)))
					call SetUnitTimeScale(u, s__IndexedUnit_GetMoveSpeed((GetUnitUserData(u))) / GetUnitDefaultMoveSpeed(u))
				endif
				
				set s__RelayUnit_CurrentTurn[spawnUnit]=s__SimpleList_ListNode_next[s__SimpleList_List_first[s__RelayGenerator_Turns[this]]]
				set s__RelayUnit_CurrentDestination[spawnUnit]=destination
			call GroupRemoveUnit(g, u)
			endloop
            
			call ReleaseGroup(g)
			set g=null
        endfunction
		
  function s__RelayGenerator_ReleaseUnit takes integer this,unit u returns nothing
			call s__RelayUnit_deallocate((s__RelayGenerator_UnitIDToRelayUnitID[GetUnitUserData(u)]))
			call GroupRemoveUnit(s__RelayGenerator_Units[this], u)
			
			call Recycle_ReleaseUnit(u)
  endfunction
		
  function s__RelayGenerator_UpdateRelays takes nothing returns nothing
   local integer activeRelayNode= s__SimpleList_List_first[s__RelayGenerator_ActiveRelays]
   local integer activeRelay
   local group tempGroup
			
   local unit turnUnit
   local integer turnUnitInfo
   local integer turnUnitDirection
   local real updateCoordinate
			
   local real updateSpillover
			
			loop
            exitwhen activeRelayNode == 0
                set activeRelay=(s__SimpleList_ListNode_value[activeRelayNode])
				//call DisplayTextToForce(bj_FORCE_PLAYER[0], "Checking turns for generator " + I2S(activeRelay))
				
				set tempGroup=NewGroup()
				
                loop
				set turnUnit=FirstOfGroup(s__RelayGenerator_Units[activeRelay])
				exitwhen turnUnit == null
					set turnUnitInfo=s__RelayGenerator_UnitIDToRelayUnitID[GetUnitUserData(turnUnit)]
					
					set turnUnitDirection=s__RelayTurn_Direction[(s__SimpleList_ListNode_value[s__SimpleList_ListNode_prev[s__RelayUnit_CurrentTurn[turnUnitInfo]]])]
				
					if turnUnitDirection == 0 then
						set updateCoordinate=GetUnitX(turnUnit) + s__IndexedUnit_MoveSpeed[(GetUnitUserData(turnUnit))] * RelayGenerator___RELAY_MOVEMENT_TIMESTEP
						
						if updateCoordinate >= s__vector2_x[s__RelayUnit_CurrentDestination[turnUnitInfo]] then
							if s__SimpleList_ListNode_next[s__RelayUnit_CurrentTurn[turnUnitInfo]] != 0 then
								set turnUnitDirection=s__RelayTurn_Direction[(s__SimpleList_ListNode_value[s__RelayUnit_CurrentTurn[turnUnitInfo]])]
								set updateSpillover=updateCoordinate - s__vector2_x[s__RelayUnit_CurrentDestination[turnUnitInfo]]
								
								if turnUnitDirection == 0 then
									call SetUnitX(turnUnit, updateCoordinate)
								elseif turnUnitDirection == 180 then
									call SetUnitX(turnUnit, s__vector2_x[s__RelayUnit_CurrentDestination[turnUnitInfo]] - updateSpillover)
								else
									call SetUnitX(turnUnit, s__vector2_x[s__RelayUnit_CurrentDestination[turnUnitInfo]])
									
									if turnUnitDirection == 90 then
										call SetUnitY(turnUnit, s__vector2_y[s__RelayUnit_CurrentDestination[turnUnitInfo]] + updateSpillover)
									else
										call SetUnitY(turnUnit, s__vector2_y[s__RelayUnit_CurrentDestination[turnUnitInfo]] - updateSpillover)
									endif
								endif
								
								set s__RelayUnit_CurrentDestination[turnUnitInfo]=s__RelayGenerator_GetCachedNextTurnDestination(activeRelay,turnUnitInfo)
								set s__RelayUnit_CurrentTurn[turnUnitInfo]=s__SimpleList_ListNode_next[s__RelayUnit_CurrentTurn[turnUnitInfo]]
								
								//call IssuePointOrder(turnUnit, "move", turnUnitInfo.CurrentDestination.x, turnUnitInfo.CurrentDestination.y)
								call SetUnitFacingTimed(turnUnit, s__RelayTurn_Direction[(s__SimpleList_ListNode_value[s__SimpleList_ListNode_prev[s__RelayUnit_CurrentTurn[turnUnitInfo]]])], 0)
								
								call GroupAddUnit(tempGroup, turnUnit)
								call GroupRemoveUnit(s__RelayGenerator_Units[activeRelay], turnUnit)
							else
								call s__RelayGenerator_ReleaseUnit(activeRelay,turnUnit)
							endif
						else
							call SetUnitX(turnUnit, updateCoordinate)
					
							call GroupRemoveUnit(s__RelayGenerator_Units[activeRelay], turnUnit)
							call GroupAddUnit(tempGroup, turnUnit)
						endif
					elseif turnUnitDirection == 180 then
						set updateCoordinate=GetUnitX(turnUnit) - s__IndexedUnit_MoveSpeed[(GetUnitUserData(turnUnit))] * RelayGenerator___RELAY_MOVEMENT_TIMESTEP
						
						if updateCoordinate <= s__vector2_x[s__RelayUnit_CurrentDestination[turnUnitInfo]] then
							if s__SimpleList_ListNode_next[s__RelayUnit_CurrentTurn[turnUnitInfo]] != 0 then
								set turnUnitDirection=s__RelayTurn_Direction[(s__SimpleList_ListNode_value[s__RelayUnit_CurrentTurn[turnUnitInfo]])]
								set updateSpillover=s__vector2_x[s__RelayUnit_CurrentDestination[turnUnitInfo]] - updateCoordinate
								
								if turnUnitDirection == 0 then
									call SetUnitX(turnUnit, s__vector2_x[s__RelayUnit_CurrentDestination[turnUnitInfo]] + updateSpillover)
								elseif turnUnitDirection == 180 then
									call SetUnitX(turnUnit, updateCoordinate)
								else
									call SetUnitX(turnUnit, s__vector2_x[s__RelayUnit_CurrentDestination[turnUnitInfo]])
									
									if turnUnitDirection == 90 then
										call SetUnitY(turnUnit, s__vector2_y[s__RelayUnit_CurrentDestination[turnUnitInfo]] + updateSpillover)
									else
										call SetUnitY(turnUnit, s__vector2_y[s__RelayUnit_CurrentDestination[turnUnitInfo]] - updateSpillover)
									endif
								endif
								
								set s__RelayUnit_CurrentDestination[turnUnitInfo]=s__RelayGenerator_GetCachedNextTurnDestination(activeRelay,turnUnitInfo)
								set s__RelayUnit_CurrentTurn[turnUnitInfo]=s__SimpleList_ListNode_next[s__RelayUnit_CurrentTurn[turnUnitInfo]]
								
								//call IssuePointOrder(turnUnit, "move", turnUnitInfo.CurrentDestination.x, turnUnitInfo.CurrentDestination.y)
								call SetUnitFacingTimed(turnUnit, s__RelayTurn_Direction[(s__SimpleList_ListNode_value[s__SimpleList_ListNode_prev[s__RelayUnit_CurrentTurn[turnUnitInfo]]])], 0)
								
								call GroupAddUnit(tempGroup, turnUnit)
								call GroupRemoveUnit(s__RelayGenerator_Units[activeRelay], turnUnit)
							else
								call s__RelayGenerator_ReleaseUnit(activeRelay,turnUnit)
							endif
						else
							call SetUnitX(turnUnit, updateCoordinate)
					
							call GroupRemoveUnit(s__RelayGenerator_Units[activeRelay], turnUnit)
							call GroupAddUnit(tempGroup, turnUnit)
						endif
					elseif turnUnitDirection == 90 then
						set updateCoordinate=GetUnitY(turnUnit) + s__IndexedUnit_MoveSpeed[(GetUnitUserData(turnUnit))] * RelayGenerator___RELAY_MOVEMENT_TIMESTEP
						
						if updateCoordinate >= s__vector2_y[s__RelayUnit_CurrentDestination[turnUnitInfo]] then
							if s__SimpleList_ListNode_next[s__RelayUnit_CurrentTurn[turnUnitInfo]] != 0 then
								set turnUnitDirection=s__RelayTurn_Direction[(s__SimpleList_ListNode_value[s__RelayUnit_CurrentTurn[turnUnitInfo]])]
								set updateSpillover=updateCoordinate - s__vector2_y[s__RelayUnit_CurrentDestination[turnUnitInfo]]
								
								if turnUnitDirection == 90 then
									call SetUnitY(turnUnit, updateCoordinate)
								elseif turnUnitDirection == 270 then
									call SetUnitY(turnUnit, s__vector2_y[s__RelayUnit_CurrentDestination[turnUnitInfo]] - updateSpillover)
								else
									if turnUnitDirection == 0 then
										call SetUnitX(turnUnit, s__vector2_x[s__RelayUnit_CurrentDestination[turnUnitInfo]] + updateSpillover)
									else
										call SetUnitX(turnUnit, s__vector2_x[s__RelayUnit_CurrentDestination[turnUnitInfo]] - updateSpillover)
									endif
									
									call SetUnitY(turnUnit, s__vector2_y[s__RelayUnit_CurrentDestination[turnUnitInfo]])
								endif
								
								set s__RelayUnit_CurrentDestination[turnUnitInfo]=s__RelayGenerator_GetCachedNextTurnDestination(activeRelay,turnUnitInfo)
								set s__RelayUnit_CurrentTurn[turnUnitInfo]=s__SimpleList_ListNode_next[s__RelayUnit_CurrentTurn[turnUnitInfo]]
								
								//call IssuePointOrder(turnUnit, "move", turnUnitInfo.CurrentDestination.x, turnUnitInfo.CurrentDestination.y)
								call SetUnitFacingTimed(turnUnit, s__RelayTurn_Direction[(s__SimpleList_ListNode_value[s__SimpleList_ListNode_prev[s__RelayUnit_CurrentTurn[turnUnitInfo]]])], 0)
								
								call GroupAddUnit(tempGroup, turnUnit)
								call GroupRemoveUnit(s__RelayGenerator_Units[activeRelay], turnUnit)
							else
								call s__RelayGenerator_ReleaseUnit(activeRelay,turnUnit)
							endif
						else
							call SetUnitY(turnUnit, updateCoordinate)
						
							call GroupRemoveUnit(s__RelayGenerator_Units[activeRelay], turnUnit)
							call GroupAddUnit(tempGroup, turnUnit)
						endif
					else
						set updateCoordinate=GetUnitY(turnUnit) - s__IndexedUnit_MoveSpeed[(GetUnitUserData(turnUnit))] * RelayGenerator___RELAY_MOVEMENT_TIMESTEP
						
						if updateCoordinate <= s__vector2_y[s__RelayUnit_CurrentDestination[turnUnitInfo]] then
							if s__SimpleList_ListNode_next[s__RelayUnit_CurrentTurn[turnUnitInfo]] != 0 then
								set turnUnitDirection=s__RelayTurn_Direction[(s__SimpleList_ListNode_value[s__RelayUnit_CurrentTurn[turnUnitInfo]])]
								set updateSpillover=s__vector2_y[s__RelayUnit_CurrentDestination[turnUnitInfo]] - updateCoordinate
								
								if turnUnitDirection == 90 then
									call SetUnitY(turnUnit, updateCoordinate)
								elseif turnUnitDirection == 270 then
									call SetUnitY(turnUnit, s__vector2_y[s__RelayUnit_CurrentDestination[turnUnitInfo]] - updateSpillover)
								else
									if turnUnitDirection == 0 then
										call SetUnitX(turnUnit, s__vector2_x[s__RelayUnit_CurrentDestination[turnUnitInfo]] + updateSpillover)
									else
										call SetUnitX(turnUnit, s__vector2_x[s__RelayUnit_CurrentDestination[turnUnitInfo]] - updateSpillover)
									endif
									
									call SetUnitY(turnUnit, s__vector2_y[s__RelayUnit_CurrentDestination[turnUnitInfo]])
								endif
								
								set s__RelayUnit_CurrentDestination[turnUnitInfo]=s__RelayGenerator_GetCachedNextTurnDestination(activeRelay,turnUnitInfo)
								set s__RelayUnit_CurrentTurn[turnUnitInfo]=s__SimpleList_ListNode_next[s__RelayUnit_CurrentTurn[turnUnitInfo]]
								
								//call IssuePointOrder(turnUnit, "move", turnUnitInfo.CurrentDestination.x, turnUnitInfo.CurrentDestination.y)
								call SetUnitFacingTimed(turnUnit, s__RelayTurn_Direction[(s__SimpleList_ListNode_value[s__SimpleList_ListNode_prev[s__RelayUnit_CurrentTurn[turnUnitInfo]]])], 0)
								
								call GroupAddUnit(tempGroup, turnUnit)
								call GroupRemoveUnit(s__RelayGenerator_Units[activeRelay], turnUnit)
							else
								call s__RelayGenerator_ReleaseUnit(activeRelay,turnUnit)
							endif
						else
							call SetUnitY(turnUnit, updateCoordinate)
						
							call GroupRemoveUnit(s__RelayGenerator_Units[activeRelay], turnUnit)
							call GroupAddUnit(tempGroup, turnUnit)
						endif
					endif
				endloop
				
				call ReleaseGroup(s__RelayGenerator_Units[activeRelay])
				set s__RelayGenerator_Units[activeRelay]=tempGroup
            set activeRelayNode=s__SimpleList_ListNode_next[activeRelayNode]
            endloop
  endfunction
		
  function s__RelayGenerator_SetOverclockFactor takes integer this,real factor returns nothing
   local real oldFactor
   local group tempGroup
   local unit turnUnit
			// local real timeout
			
			if factor != s__RelayGenerator_OverclockFactor[this] then





				
				set oldFactor=s__RelayGenerator_OverclockFactor[this]
				set s__RelayGenerator_OverclockFactor[this]=factor
				
				if s__SimpleList_List_contains(s__RelayGenerator_ActiveRelays,this) then
					set tempGroup=NewGroup()
					
					loop
					set turnUnit=FirstOfGroup(s__RelayGenerator_Units[this])
					exitwhen turnUnit == null
						call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(turnUnit)),s__IndexedUnit_MoveSpeed[(GetUnitUserData(turnUnit))] / oldFactor * factor)
					
						if IsUnitAnimated(GetUnitTypeId(turnUnit)) then
							call SetUnitTimeScale(turnUnit, s__IndexedUnit_GetMoveSpeed((GetUnitUserData(turnUnit))) / GetUnitDefaultMoveSpeed(turnUnit))
						endif
					call GroupRemoveUnit(s__RelayGenerator_Units[this], turnUnit)
					call GroupAddUnit(tempGroup, turnUnit)
					endloop
					
					call ReleaseGroup(s__RelayGenerator_Units[this])
					set s__RelayGenerator_Units[this]=tempGroup
					
					// if TimerGetRemaining(this.UnitTimer) + OVERCLOCK_RESTART_BUFFER < .035 then
						// set timeout = .035
					// else
						// set timeout = TimerGetRemaining(this.UnitTimer) + OVERCLOCK_RESTART_BUFFER
					// endif
					
					call PauseTimer(s__RelayGenerator_UnitTimer[this])
					call TimerStart(s__RelayGenerator_UnitTimer[this], s__RelayGenerator_UnitTimeout[this] / s__RelayGenerator_OverclockFactor[this], true, function s__RelayGenerator_CreateUnitCB)
				endif
			endif
  endfunction
        
        function s__RelayGenerator_Start takes integer this returns nothing
            if not s__SimpleList_List_contains(s__RelayGenerator_ActiveRelays,this) then
                call s__SimpleList_List_add(s__RelayGenerator_ActiveRelays,this)
                
				set s__RelayGenerator_Units[this]=NewGroup()
				call s__PatternSpawn_Reset(s__RelayPatternSpawn_Pattern[s__RelayGenerator_SpawnPattern[this]])
				
                set s__RelayGenerator_UnitTimer[this]=NewTimerEx(this)
                call TimerStart(s__RelayGenerator_UnitTimer[this], s__RelayGenerator_UnitTimeout[this] / s__RelayGenerator_OverclockFactor[this], true, function s__RelayGenerator_CreateUnitCB)
                
                //call DisplayTextToForce(bj_FORCE_PLAYER[0], "Count relays on " + I2S(ActiveRelays.count))
                
                if s__SimpleList_List_count[s__RelayGenerator_ActiveRelays] == 1 then
                    call TimerStart(s__RelayGenerator_MovementTimer, RelayGenerator___RELAY_MOVEMENT_TIMESTEP, true, function s__RelayGenerator_UpdateRelays)
                    //call DisplayTextToForce(bj_FORCE_PLAYER[0], "Started turn check timer")
                endif
            endif
        endfunction
        
        function s__RelayGenerator_Stop takes integer this returns nothing
            local unit u
			
			if s__SimpleList_List_contains(s__RelayGenerator_ActiveRelays,this) then
                call s__SimpleList_List_remove(s__RelayGenerator_ActiveRelays,this)
                
				//recycle all units in a way that's proper for this struct
				loop
				set u=FirstOfGroup(s__RelayGenerator_Units[this])
				exitwhen u == null
					call s__RelayGenerator_ReleaseUnit(this,u)
					//call GroupRemoveUnit(.Units, u)
				endloop
				
				call ReleaseGroup(s__RelayGenerator_Units[this])
				
                //pauses and recycles timer while relay is off
                call ReleaseTimer(s__RelayGenerator_UnitTimer[this])
                
                if s__SimpleList_List_count[s__RelayGenerator_ActiveRelays] == 0 then
                    call PauseTimer(s__RelayGenerator_MovementTimer)
                endif
            endif
        endfunction
                        
        //takes:
        //real centerX -- center coord for relay generator's first turn (and spawn)
        //real centerY
        //integer spawnDiameter -- # of full tiles this spawn is in both length and width directions. all spawns are squares
        //integer laneCount -- # of lanes in relay
        function s__RelayGenerator_create takes real centerX,real centerY,integer spawnDiameter,integer laneCount,integer direction,integer tilesToTravel,real unitSpawnTimeout,integer spawnCB,integer cycleCount returns integer
            local integer new
            local real spawnRadius= spawnDiameter / 2. * TERRAIN_TILE_SIZE
   local integer testCenter
            local integer spawnCenter
            
            //local real travelDistance = spawnRadius*2 + tilesToTravel*TERRAIN_TILE_SIZE
            
            if ModuloInteger(direction, 90) == 0 then
                set new=s__RelayGenerator__allocate()
                
                set s__RelayGenerator_UnitTimeout[new]=unitSpawnTimeout
                
				if ModuloInteger(spawnDiameter, 2) == 0 then
					set spawnCenter=s__vector2_allocate()
					
					//get point halfway between two tiles on vertical
					set testCenter=GetTerrainCenterpoint(centerX , centerY - TERRAIN_QUADRANT_SIZE)
					set s__vector2_y[spawnCenter]=s__vector2_y[testCenter]
					call s__vector2_deallocate(testCenter)
					
					set testCenter=GetTerrainCenterpoint(centerX , centerY + TERRAIN_QUADRANT_SIZE)
					set s__vector2_y[spawnCenter]=( s__vector2_y[spawnCenter] + s__vector2_y[testCenter] ) / 2
					call s__vector2_deallocate(testCenter)

					//get point halfway between two tiles on horizontal
					set testCenter=GetTerrainCenterpoint(centerX - TERRAIN_QUADRANT_SIZE , centerY)
					set s__vector2_x[spawnCenter]=s__vector2_x[testCenter]
					call s__vector2_deallocate(testCenter)
					
					set testCenter=GetTerrainCenterpoint(centerX + TERRAIN_QUADRANT_SIZE , centerY)
					set s__vector2_x[spawnCenter]=( s__vector2_x[spawnCenter] + s__vector2_x[testCenter] ) / 2
					call s__vector2_deallocate(testCenter)
				else
					set spawnCenter=GetTerrainCenterpoint(centerX , centerY)
				endif
				
				set s__RelayGenerator_Diameter[new]=spawnDiameter
                // set new.Radius = R2I(spawnDiameter / 2. - .5000)
                set s__RelayGenerator_UnitLaneSize[new]=spawnDiameter * TERRAIN_TILE_SIZE / ( 1. * laneCount )
                
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Spawn radius: " + R2S(spawnRadius) + ", Lane count: " + R2S(new.LaneCount))
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Spawn initial total distance: " + R2S(spawnDiameter*TERRAIN_TILE_SIZE + tilesToTravel*TERRAIN_TILE_SIZE))
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], new.SpawnCenter.toString())
                
                set s__RelayGenerator_Turns[new]=s__SimpleList_List_create()
				
                if direction == 0 then
                    //sending right
                    call s__SimpleList_List_add(s__RelayGenerator_Turns[new],s__RelayTurn_create(Rect(s__vector2_x[spawnCenter] - spawnRadius - s__RelayGenerator_UnitLaneSize[new], s__vector2_y[spawnCenter] - spawnRadius - s__RelayGenerator_UnitLaneSize[new], s__vector2_x[spawnCenter] - spawnRadius + TERRAIN_TILE_SIZE + s__RelayGenerator_UnitLaneSize[new], s__vector2_y[spawnCenter] + spawnRadius + s__RelayGenerator_UnitLaneSize[new]) , spawnCenter , new , direction , spawnDiameter * TERRAIN_TILE_SIZE + tilesToTravel * TERRAIN_TILE_SIZE , RelayGenerator___LEFT , RelayGenerator___DOWN))
                elseif direction == 180 then
                    //sending left
                    call s__SimpleList_List_add(s__RelayGenerator_Turns[new],s__RelayTurn_create(Rect(s__vector2_x[spawnCenter] + spawnRadius - TERRAIN_TILE_SIZE - s__RelayGenerator_UnitLaneSize[new], s__vector2_y[spawnCenter] - spawnRadius - s__RelayGenerator_UnitLaneSize[new], s__vector2_x[spawnCenter] + spawnRadius + s__RelayGenerator_UnitLaneSize[new], s__vector2_y[spawnCenter] + spawnRadius + s__RelayGenerator_UnitLaneSize[new]) , spawnCenter , new , direction , spawnDiameter * TERRAIN_TILE_SIZE + tilesToTravel * TERRAIN_TILE_SIZE , RelayGenerator___RIGHT , RelayGenerator___DOWN))
                elseif direction == 90 then
                    //sending up
                    call s__SimpleList_List_add(s__RelayGenerator_Turns[new],s__RelayTurn_create(Rect(s__vector2_x[spawnCenter] - spawnRadius - s__RelayGenerator_UnitLaneSize[new], s__vector2_y[spawnCenter] - spawnRadius - s__RelayGenerator_UnitLaneSize[new], s__vector2_x[spawnCenter] + spawnRadius + s__RelayGenerator_UnitLaneSize[new], s__vector2_y[spawnCenter] - spawnRadius + TERRAIN_TILE_SIZE + s__RelayGenerator_UnitLaneSize[new]) , spawnCenter , new , direction , spawnDiameter * TERRAIN_TILE_SIZE + tilesToTravel * TERRAIN_TILE_SIZE , RelayGenerator___LEFT , RelayGenerator___DOWN))
                else //direction == 270
                    //sending down
                    call s__SimpleList_List_add(s__RelayGenerator_Turns[new],s__RelayTurn_create(Rect(s__vector2_x[spawnCenter] - spawnRadius - s__RelayGenerator_UnitLaneSize[new], s__vector2_y[spawnCenter] + spawnRadius - TERRAIN_TILE_SIZE - s__RelayGenerator_UnitLaneSize[new], s__vector2_x[spawnCenter] + spawnRadius + s__RelayGenerator_UnitLaneSize[new], s__vector2_y[spawnCenter] + spawnRadius + s__RelayGenerator_UnitLaneSize[new]) , spawnCenter , new , direction , spawnDiameter * TERRAIN_TILE_SIZE + tilesToTravel * TERRAIN_TILE_SIZE , RelayGenerator___LEFT , RelayGenerator___UP))
                endif
				
				set s__RelayGenerator_SpawnPattern[new]=s__RelayPatternSpawn_create(spawnCB , cycleCount , new)
				
				//defaults
				set s__RelayGenerator_OverclockFactor[new]=1.
                                
            else
            endif
            
            return new
        endfunction
  function s__RelayGenerator_createFromPoint takes rect centerPoint,integer spawnDiameter,integer laneCount,integer direction,integer tilesToTravel,real unitSpawnTimeout,integer spawnCB,integer cycleCount returns integer
			return s__RelayGenerator_create(GetRectCenterX(centerPoint) , GetRectCenterY(centerPoint) , spawnDiameter , laneCount , direction , tilesToTravel , unitSpawnTimeout , spawnCB , cycleCount)
  endfunction
        
        function s__RelayGenerator_onInit takes nothing returns nothing
            set s__RelayGenerator_ActiveRelays=s__SimpleList_List_create()
            set s__RelayGenerator_MovementTimer=CreateTimer()
            set s__RelayGenerator_UnitIDToRelayUnitID[0]=0
            //set UnitTable = Table.create()
        endfunction

//library RelayGenerator ends
//library RespawningUnit:

	
    //in degrees
    //special values: {-1: random direction out of up,right,down,left, -2: random direction out of diagonals, }
    
//Implemented from module Alloc:
		
		

			

		
		
  function s__RespawningUnit_allocate takes nothing returns integer
   local integer this= s__RespawningUnit_Alloc___recycler[0]
			


			
			if ( s__RespawningUnit_Alloc___recycler[this] == 0 ) then
				set s__RespawningUnit_Alloc___recycler[0]=this + 1
			else
				set s__RespawningUnit_Alloc___recycler[0]=s__RespawningUnit_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__RespawningUnit_deallocate takes integer this returns nothing


			


			
			set s__RespawningUnit_Alloc___recycler[this]=s__RespawningUnit_Alloc___recycler[0]
			set s__RespawningUnit_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__RespawningUnit_Alloc___onInit takes nothing returns nothing
			set s__RespawningUnit_Alloc___recycler[0]=1
  endfunction
    
 function s__RespawningUnit_respawn takes integer this returns unit
  local real direction
        
        if s__RespawningUnit_facing[this] >= 0 then
            set direction=s__RespawningUnit_facing[this]
        else
            if s__RespawningUnit_facing[this] == - 1 then
                set direction=GetRandomInt(0, 3) * 90
            elseif s__RespawningUnit_facing[this] == - 2 then
                set direction=GetRandomInt(0, 3) * 90 + 45
            else
                set direction=0
            endif
        endif
		
		return (sc__Recycle_UnitRecycler_MakeWithFacing((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((s__RespawningUnit_uID[this] )))),(( s__vector2_x[s__RespawningUnit_position[this]] )*1.0) , (( s__vector2_y[s__RespawningUnit_position[this]] )*1.0) , (( direction)*1.0))) // INLINED!!
 endfunction
	
 function s__RespawningUnit_destroy takes integer this returns nothing
		call s__vector2_deallocate(s__RespawningUnit_position[this])
		call s__RespawningUnit_deallocate(this)
 endfunction
    function s__RespawningUnit_create takes real X,real Y,integer UID,real Facing returns integer
        local integer new= s__RespawningUnit_allocate()
		
		set s__RespawningUnit_position[new]=s__vector2_create(X , Y)
        set s__RespawningUnit_uID[new]=UID
        set s__RespawningUnit_facing[new]=Facing
        
        return new
    endfunction

 function s__AutoRespawningUnit_callback takes nothing returns nothing
        local timer t= GetExpiredTimer()
        local integer wtr= ((LoadInteger(TimerUtils___ht, 0, GetHandleId((t))))) // INLINED!!
        
		call s__RespawningUnit_respawn(wtr)
		
        call ReleaseTimer(t)
        set t=null
		call s__RespawningUnit_destroy(wtr)
    endfunction
	
 function s__AutoRespawningUnit_create takes real X,real Y,integer UID,real Facing,real respawnTime returns integer
  local integer new= s__RespawningUnit_create(X , Y , UID , Facing)
		
		call TimerStart(NewTimerEx(new), respawnTime, false, function s__AutoRespawningUnit_callback)
		
		return new
 endfunction


//library RespawningUnit ends
//library SimpleGenerator:


		
    
    
    
 function s__SimpleGenerator_SetMoveSpeed takes integer this,real movespeed returns nothing
		set s__SimpleGenerator_SpawnMoveSpeed[this]=movespeed * SimpleGenerator___MOVEMENT_UPDATE_TIMESTEP * s__SimpleGenerator_OverclockFactor[this]
		
		if s__SimpleGenerator_SpawnDirection[this] == 180 or s__SimpleGenerator_SpawnDirection[this] == 270 then
			set s__SimpleGenerator_SpawnMoveSpeed[this]=- s__SimpleGenerator_SpawnMoveSpeed[this]
		endif
 endfunction
	
 function s__SimpleGenerator_SetOverclockFactor takes integer this,real factor returns nothing
  local real oldFactor
  local group tempGroup
  local unit turnUnit
		// local real timeout
		
		if factor != s__SimpleGenerator_OverclockFactor[this] then





			
			set oldFactor=s__SimpleGenerator_OverclockFactor[this]
			set s__SimpleGenerator_OverclockFactor[this]=factor
			
			if s__SimpleGenerator_SpawnMoveSpeed[this] != 0 then
				set s__SimpleGenerator_SpawnMoveSpeed[this]=s__SimpleGenerator_SpawnMoveSpeed[this] / oldFactor * factor
			endif
			
			if s__SimpleList_List_contains(s__SimpleGenerator_ActiveWidgets,this) then
				set tempGroup=NewGroup()
				
				loop
				set turnUnit=FirstOfGroup(s__SimpleGenerator_SpawnedUnits[this])
				exitwhen turnUnit == null
					call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(turnUnit)),s__IndexedUnit_GetMoveSpeed((GetUnitUserData(turnUnit))) / oldFactor * factor)
				
					if IsUnitAnimated(GetUnitTypeId(turnUnit)) then
						if s__SimpleGenerator_SpawnMoveSpeed[this] == 0 then
							call SetUnitTimeScale(turnUnit, s__IndexedUnit_GetMoveSpeed((GetUnitUserData(turnUnit))) / GetUnitDefaultMoveSpeed(turnUnit))
						else
							call SetUnitTimeScale(turnUnit, s__SimpleGenerator_SpawnMoveSpeed[this] / SimpleGenerator___MOVEMENT_UPDATE_TIMESTEP / GetUnitDefaultMoveSpeed(turnUnit))
						endif
					endif
				call GroupRemoveUnit(s__SimpleGenerator_SpawnedUnits[this], turnUnit)
				call GroupAddUnit(tempGroup, turnUnit)
				endloop
				
				call ReleaseGroup(s__SimpleGenerator_SpawnedUnits[this])
				set s__SimpleGenerator_SpawnedUnits[this]=tempGroup
				//set tempGroup = null
							
				call PauseTimer(s__SimpleGenerator_SpawnTimer[this])
				call TimerStart(s__SimpleGenerator_SpawnTimer[this], s__SimpleGenerator_SpawnTimeStep[this] / s__SimpleGenerator_OverclockFactor[this], true, function sc__SimpleGenerator_PeriodicSpawn)
			endif
		endif
 endfunction
	
    function s__SimpleGenerator_PeriodicSpawn takes nothing returns nothing
        local integer generator= (LoadInteger(TimerUtils___ht, 0, GetHandleId((GetExpiredTimer())))) // INLINED!!
  local group spawnGroup= s__PatternSpawn_Spawn(s__LinePatternSpawn_PatternSpawn[s__SimpleGenerator_SpawnPattern[generator]],s__IStartable_ParentLevel[generator])
  local unit u
		



				
		loop
		set u=FirstOfGroup(spawnGroup)
		exitwhen u == null
			if IsUnitAnimated(GetUnitTypeId(u)) then
				call SetUnitFacingTimed(u, s__SimpleGenerator_SpawnDirection[generator], 0)
				
				call SetUnitAnimationByIndex(u, GetWalkAnimationIndex(GetUnitTypeId(u)))
				
				if s__SimpleGenerator_SpawnMoveSpeed[generator] == 0 then
					call SetUnitTimeScale(u, s__IndexedUnit_GetMoveSpeed((GetUnitUserData(u))) / GetUnitDefaultMoveSpeed(u))
				else
					call SetUnitTimeScale(u, s__SimpleGenerator_SpawnMoveSpeed[generator] / SimpleGenerator___MOVEMENT_UPDATE_TIMESTEP / GetUnitDefaultMoveSpeed(u))
				endif
			endif
		call GroupAddUnit(s__SimpleGenerator_SpawnedUnits[generator], u)
		call GroupRemoveUnit(spawnGroup, u)
		endloop
					



				
		call ReleaseGroup(spawnGroup)
		//set spawnGroup = null
				



    endfunction
    function s__SimpleGenerator_PeriodicMove takes nothing returns nothing
        local integer curActiveWidgetNode= s__SimpleList_List_first[s__SimpleGenerator_ActiveWidgets]
        local group swapGroup
        local integer curActiveWidget
        local unit curUnit
                
        local real destinationCoordinate
        
        loop
        exitwhen curActiveWidgetNode == 0
			set curActiveWidget=(s__SimpleList_ListNode_value[curActiveWidgetNode])
			



                        
			set swapGroup=NewGroup()
            loop
            set curUnit=FirstOfGroup(s__SimpleGenerator_SpawnedUnits[curActiveWidget])
			exitwhen curUnit == null
                //evaluate cos/sin functions for 90 degree angles
				//would otherwise be x = x + Cos(.SpawnDirection)*.MoveSpeed
				
				if s__SimpleGenerator_SpawnMoveSpeed[curActiveWidget] == 0 then
					if s__SimpleGenerator_SpawnDirection[curActiveWidget] == 0 then
						set destinationCoordinate=GetUnitX(curUnit) + GetUnitMoveSpeed(curUnit) * SimpleGenerator___MOVEMENT_UPDATE_TIMESTEP
						
						if destinationCoordinate >= s__SimpleGenerator_EndCoordinate[curActiveWidget] then
							call GroupRemoveUnit(s__SimpleGenerator_SpawnedUnits[curActiveWidget], curUnit)
							call Recycle_ReleaseUnit(curUnit)
							



						else
							call SetUnitX(curUnit, destinationCoordinate)
					
							call GroupRemoveUnit(s__SimpleGenerator_SpawnedUnits[curActiveWidget], curUnit)
							call GroupAddUnit(swapGroup, curUnit)
						endif
					elseif s__SimpleGenerator_SpawnDirection[curActiveWidget] == 180 then
						set destinationCoordinate=GetUnitX(curUnit) - GetUnitMoveSpeed(curUnit) * SimpleGenerator___MOVEMENT_UPDATE_TIMESTEP
						
						if destinationCoordinate <= s__SimpleGenerator_EndCoordinate[curActiveWidget] then
							call GroupRemoveUnit(s__SimpleGenerator_SpawnedUnits[curActiveWidget], curUnit)
							call Recycle_ReleaseUnit(curUnit)
							



						else
							call SetUnitX(curUnit, destinationCoordinate)
					
							call GroupRemoveUnit(s__SimpleGenerator_SpawnedUnits[curActiveWidget], curUnit)
							call GroupAddUnit(swapGroup, curUnit)
						endif
					elseif s__SimpleGenerator_SpawnDirection[curActiveWidget] == 90 then
						set destinationCoordinate=GetUnitY(curUnit) + GetUnitMoveSpeed(curUnit) * SimpleGenerator___MOVEMENT_UPDATE_TIMESTEP
						
						if destinationCoordinate >= s__SimpleGenerator_EndCoordinate[curActiveWidget] then
							call GroupRemoveUnit(s__SimpleGenerator_SpawnedUnits[curActiveWidget], curUnit)
							call Recycle_ReleaseUnit(curUnit)
							



						else
							call SetUnitY(curUnit, destinationCoordinate)
						
							call GroupRemoveUnit(s__SimpleGenerator_SpawnedUnits[curActiveWidget], curUnit)
							call GroupAddUnit(swapGroup, curUnit)
						endif
					else
						set destinationCoordinate=GetUnitY(curUnit) - GetUnitMoveSpeed(curUnit) * SimpleGenerator___MOVEMENT_UPDATE_TIMESTEP
						
						if destinationCoordinate <= s__SimpleGenerator_EndCoordinate[curActiveWidget] then
							call GroupRemoveUnit(s__SimpleGenerator_SpawnedUnits[curActiveWidget], curUnit)
							call Recycle_ReleaseUnit(curUnit)
							



						else
							call SetUnitY(curUnit, destinationCoordinate)
						
							call GroupRemoveUnit(s__SimpleGenerator_SpawnedUnits[curActiveWidget], curUnit)
							call GroupAddUnit(swapGroup, curUnit)
						endif
					endif
				else
					if s__SimpleGenerator_SpawnDirection[curActiveWidget] == 0 or s__SimpleGenerator_SpawnDirection[curActiveWidget] == 180 then
						set destinationCoordinate=GetUnitX(curUnit) + s__SimpleGenerator_SpawnMoveSpeed[curActiveWidget]
						
						if ( s__SimpleGenerator_SpawnDirection[curActiveWidget] == 0 and destinationCoordinate >= s__SimpleGenerator_EndCoordinate[curActiveWidget] ) or ( s__SimpleGenerator_SpawnDirection[curActiveWidget] == 180 and destinationCoordinate <= s__SimpleGenerator_EndCoordinate[curActiveWidget] ) then
							call GroupRemoveUnit(s__SimpleGenerator_SpawnedUnits[curActiveWidget], curUnit)
							call Recycle_ReleaseUnit(curUnit)
							



						else
							call SetUnitX(curUnit, destinationCoordinate)
						
							call GroupRemoveUnit(s__SimpleGenerator_SpawnedUnits[curActiveWidget], curUnit)
							call GroupAddUnit(swapGroup, curUnit)
						endif
					else
						set destinationCoordinate=GetUnitY(curUnit) + s__SimpleGenerator_SpawnMoveSpeed[curActiveWidget]
						
						if ( s__SimpleGenerator_SpawnDirection[curActiveWidget] == 90 and destinationCoordinate >= s__SimpleGenerator_EndCoordinate[curActiveWidget] ) or ( s__SimpleGenerator_SpawnDirection[curActiveWidget] == 270 and destinationCoordinate <= s__SimpleGenerator_EndCoordinate[curActiveWidget] ) then
							call GroupRemoveUnit(s__SimpleGenerator_SpawnedUnits[curActiveWidget], curUnit)
							call Recycle_ReleaseUnit(curUnit)
							



						else
							call SetUnitY(curUnit, destinationCoordinate)
						
							call GroupRemoveUnit(s__SimpleGenerator_SpawnedUnits[curActiveWidget], curUnit)
							call GroupAddUnit(swapGroup, curUnit)
						endif
					endif
				endif
            endloop
			



			
            call ReleaseGroup(s__SimpleGenerator_SpawnedUnits[curActiveWidget])
            set s__SimpleGenerator_SpawnedUnits[curActiveWidget]=swapGroup
			set swapGroup=null
                        
        set curActiveWidgetNode=s__SimpleList_ListNode_next[curActiveWidgetNode]
        endloop
		



    endfunction
	
 function s__SimpleGenerator_Start takes integer this returns nothing
        if s__SimpleList_List_count[s__SimpleGenerator_ActiveWidgets] == 0 then
            call TimerStart(s__SimpleGenerator_MoveTimer, SimpleGenerator___MOVEMENT_UPDATE_TIMESTEP, true, function s__SimpleGenerator_PeriodicMove)
        endif
        
        call s__SimpleList_List_addEnd(s__SimpleGenerator_ActiveWidgets,this)
        set s__SimpleGenerator_SpawnTimer[this]=NewTimerEx(this)
        set s__SimpleGenerator_SpawnedUnits[this]=NewGroup()
		if s__SimpleGenerator_SpawnPattern[this] != 0 then
			call s__PatternSpawn_Reset(s__LinePatternSpawn_PatternSpawn[s__SimpleGenerator_SpawnPattern[this]])
		endif
		



		
        call TimerStart(s__SimpleGenerator_SpawnTimer[this], s__SimpleGenerator_SpawnTimeStep[this] / s__SimpleGenerator_OverclockFactor[this], true, function s__SimpleGenerator_PeriodicSpawn)
    endfunction
    function s__SimpleGenerator_Stop takes integer this returns nothing
        call s__SimpleList_List_remove(s__SimpleGenerator_ActiveWidgets,this)
		
        call ReleaseTimer(s__SimpleGenerator_SpawnTimer[this])
        set s__SimpleGenerator_SpawnTimer[this]=null
		
		call ReleaseGroup(s__SimpleGenerator_SpawnedUnits[this])
		set s__SimpleGenerator_SpawnedUnits[this]=null
        
		set s__SimpleGenerator_OverclockFactor[this]=1.
				
        if s__SimpleList_List_count[s__SimpleGenerator_ActiveWidgets] == 0 then
            call PauseTimer(s__SimpleGenerator_MoveTimer)
        endif
    endfunction
	
 function s__SimpleGenerator_destroy takes integer this returns nothing
        if s__SimpleList_List_contains(s__SimpleGenerator_ActiveWidgets,this) then
			call s__SimpleGenerator_Stop(this)
		endif
		
		if s__SimpleGenerator_SpawnPattern[this] != 0 then
			//TODO
			//call .SpawnPattern.destroy()
		endif
 endfunction
    function s__SimpleGenerator_create takes integer spawnPattern,real spawnTimestep,real spawnDirection,integer spawnLength returns integer
        local integer new= s__SimpleGenerator__allocate()
        
        local real xOffset
        local real yOffset
		





        
		set s__SimpleGenerator_SpawnPattern[new]=spawnPattern
		
        set s__SimpleGenerator_SpawnTimeStep[new]=spawnTimestep
        set s__SimpleGenerator_SpawnDirection[new]=spawnDirection
		
        if spawnDirection == 0 then
            set xOffset=spawnLength * TERRAIN_TILE_SIZE
            
            set s__SimpleGenerator_EndCoordinate[new]=s__vector2_x[s__LinePatternSpawn_SpawnOrigin[spawnPattern]] + xOffset
        elseif spawnDirection == 180 then
            set xOffset=- spawnLength * TERRAIN_TILE_SIZE
            
            set s__SimpleGenerator_EndCoordinate[new]=s__vector2_x[s__LinePatternSpawn_SpawnOrigin[spawnPattern]] + xOffset
        elseif spawnDirection == 90 then
            set yOffset=spawnLength * TERRAIN_TILE_SIZE
            
            set s__SimpleGenerator_EndCoordinate[new]=s__vector2_y[s__LinePatternSpawn_SpawnOrigin[spawnPattern]] + yOffset
        elseif spawnDirection == 270 then
            set yOffset=- spawnLength * TERRAIN_TILE_SIZE
            
            set s__SimpleGenerator_EndCoordinate[new]=s__vector2_y[s__LinePatternSpawn_SpawnOrigin[spawnPattern]] + yOffset
        else
            //error
            return 0 / 0
        endif
		
		//defaults
		set s__SimpleGenerator_SpawnMoveSpeed[new]=0.
		set s__SimpleGenerator_OverclockFactor[new]=1.
		
        return new
    endfunction
    
    function s__SimpleGenerator_onInit takes nothing returns nothing
        //set thistype.DespawnTimer = CreateTimer()
        set s__SimpleGenerator_MoveTimer=CreateTimer()
        set s__SimpleGenerator_ActiveWidgets=s__SimpleList_List_create()
    endfunction

//library SimpleGenerator ends
//library SimplePatrol:
	
		
		
		
  function s__SimplePatrol_CheckDestinations takes nothing returns nothing
   local integer curActivePatrol= s__SimpleList_List_first[s__SimplePatrol_ActivePatrols]
			// local vector2 nextDestination
			
			loop
			exitwhen curActivePatrol == 0
				//check if arrived at current destination
				if RAbsBJ(GetUnitX(s__SimplePatrol_Unit[(s__SimpleList_ListNode_value[curActivePatrol])]) - s__vector2_x[s__SimplePatrol_OnDestination[(s__SimpleList_ListNode_value[curActivePatrol])]]) <= SimplePatrol___DESTINATION_FLEX and RAbsBJ(GetUnitY(s__SimplePatrol_Unit[(s__SimpleList_ListNode_value[curActivePatrol])]) - s__vector2_y[s__SimplePatrol_OnDestination[(s__SimpleList_ListNode_value[curActivePatrol])]]) <= SimplePatrol___DESTINATION_FLEX then
					//update current destination to other destination
					if s__SimplePatrol_OnDestination[(s__SimpleList_ListNode_value[curActivePatrol])] == s__SimplePatrol_DestinationA[(s__SimpleList_ListNode_value[curActivePatrol])] then
						set s__SimplePatrol_OnDestination[(s__SimpleList_ListNode_value[curActivePatrol])]=s__SimplePatrol_DestinationB[(s__SimpleList_ListNode_value[curActivePatrol])]
						// set nextDestination = thistype(curActivePatrol.value).DestinationB
					else
						set s__SimplePatrol_OnDestination[(s__SimpleList_ListNode_value[curActivePatrol])]=s__SimplePatrol_DestinationA[(s__SimpleList_ListNode_value[curActivePatrol])]
						// set nextDestination = thistype(curActivePatrol.value).DestinationA
					endif
					
					//update internal and display move angle
					set s__SimplePatrol_MoveAngle[(s__SimpleList_ListNode_value[curActivePatrol])]=Atan2(s__vector2_y[s__SimplePatrol_OnDestination[(s__SimpleList_ListNode_value[curActivePatrol])]] - GetUnitY(s__SimplePatrol_Unit[(s__SimpleList_ListNode_value[curActivePatrol])]), s__vector2_x[s__SimplePatrol_OnDestination[(s__SimpleList_ListNode_value[curActivePatrol])]] - GetUnitX(s__SimplePatrol_Unit[(s__SimpleList_ListNode_value[curActivePatrol])]))
					// call SetUnitFacing(thistype(curActivePatrol.value).Unit, thistype(curActivePatrol.value).MoveAngle * bj_RADTODEG)
					
					// set thistype(curActivePatrol.value).OnDestination = nextDestination
				endif
				
				//move towards current destination
				call SetUnitX(s__SimplePatrol_Unit[(s__SimpleList_ListNode_value[curActivePatrol])], GetUnitX(s__SimplePatrol_Unit[(s__SimpleList_ListNode_value[curActivePatrol])]) + Cos(s__SimplePatrol_MoveAngle[(s__SimpleList_ListNode_value[curActivePatrol])]) * s__IndexedUnit_MoveSpeed[(GetUnitUserData((s__SimplePatrol_Unit[(s__SimpleList_ListNode_value[curActivePatrol])])))]) // INLINED!!
				call SetUnitY(s__SimplePatrol_Unit[(s__SimpleList_ListNode_value[curActivePatrol])], GetUnitY(s__SimplePatrol_Unit[(s__SimpleList_ListNode_value[curActivePatrol])]) + Sin(s__SimplePatrol_MoveAngle[(s__SimpleList_ListNode_value[curActivePatrol])]) * s__IndexedUnit_MoveSpeed[(GetUnitUserData((s__SimplePatrol_Unit[(s__SimpleList_ListNode_value[curActivePatrol])])))]) // INLINED!!
			set curActivePatrol=s__SimpleList_ListNode_next[curActivePatrol]
			endloop
  endfunction
		
  function s__SimplePatrol_Start takes integer this returns nothing
			if s__SimpleList_List_count[s__SimplePatrol_ActivePatrols] == 0 then
				call TimerStart(s__SimplePatrol_DestinationTimer, SimplePatrol___DESTINATION_TIME_DELTA, true, function s__SimplePatrol_CheckDestinations)
			endif
			
			set s__SimplePatrol_Unit[this]=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((s__SimplePatrol_UnitID[this] )))),(( s__vector2_x[s__SimplePatrol_DestinationA[this]] )*1.0) , (( s__vector2_y[s__SimplePatrol_DestinationA[this]])*1.0))) // INLINED!!
			if s__SimplePatrol_MoveSpeed[this] != - 1 then
				call s__IndexedUnit_SetMoveSpeed((GetUnitUserData((s__SimplePatrol_Unit[this]))),s__SimplePatrol_MoveSpeed[this]) // INLINED!!
			endif
			
			set s__SimplePatrol_OnDestination[this]=s__SimplePatrol_DestinationB[this]
			set s__SimplePatrol_MoveAngle[this]=Atan2(s__vector2_y[s__SimplePatrol_OnDestination[this]] - GetUnitY(s__SimplePatrol_Unit[this]), s__vector2_x[s__SimplePatrol_OnDestination[this]] - GetUnitX(s__SimplePatrol_Unit[this]))
			// call SetUnitFacing(this.Unit, this.MoveAngle * bj_RADTODEG)
			
			call s__SimpleList_List_add(s__SimplePatrol_ActivePatrols,this)
  endfunction
  function s__SimplePatrol_Stop takes integer this returns nothing
			call Recycle_ReleaseUnit(s__SimplePatrol_Unit[this])
			set s__SimplePatrol_Unit[this]=null
			
			call s__SimpleList_List_remove(s__SimplePatrol_ActivePatrols,this)
			
			if s__SimpleList_List_count[s__SimplePatrol_ActivePatrols] == 0 then
				call PauseTimer(s__SimplePatrol_DestinationTimer)
			endif
  endfunction
		
  function s__SimplePatrol_SetMoveSpeed takes integer this,real moveSpeed returns nothing
			set s__SimplePatrol_MoveSpeed[this]=moveSpeed * SimplePatrol___DESTINATION_TIME_DELTA
			
			if s__SimplePatrol_Unit[this] != null then
				call s__IndexedUnit_SetMoveSpeed((GetUnitUserData((s__SimplePatrol_Unit[this]))),moveSpeed) // INLINED!!
			endif
  endfunction
  function s__SimplePatrol_create takes integer unitID,real x1,real y1,real x2,real y2 returns integer
   local integer new= s__SimplePatrol__allocate()
			
			set s__SimplePatrol_UnitID[new]=unitID
			set s__SimplePatrol_DestinationA[new]=s__vector2_create(x1 , y1)
			set s__SimplePatrol_DestinationB[new]=s__vector2_create(x2 , y2)
			set s__SimplePatrol_MoveSpeed[new]=GetDefaultMoveSpeed(unitID) * SimplePatrol___DESTINATION_TIME_DELTA
			
			return new
  endfunction
  function s__SimplePatrol_onInit takes nothing returns nothing
			set s__SimplePatrol_DestinationTimer=CreateTimer()
			set s__SimplePatrol_ActivePatrols=s__SimpleList_List_create()
  endfunction

//library SimplePatrol ends
//library SynchronizedGroup:
	
				
		
//Implemented from module Alloc:
		
		

			

		
		
  function s__SynchronizedUnit_allocate takes nothing returns integer
   local integer this= s__SynchronizedUnit_Alloc___recycler[0]
			


			
			if ( s__SynchronizedUnit_Alloc___recycler[this] == 0 ) then
				set s__SynchronizedUnit_Alloc___recycler[0]=this + 1
			else
				set s__SynchronizedUnit_Alloc___recycler[0]=s__SynchronizedUnit_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__SynchronizedUnit_deallocate takes integer this returns nothing


			


			
			set s__SynchronizedUnit_Alloc___recycler[this]=s__SynchronizedUnit_Alloc___recycler[0]
			set s__SynchronizedUnit_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__SynchronizedUnit_Alloc___onInit takes nothing returns nothing
			set s__SynchronizedUnit_Alloc___recycler[0]=1
  endfunction
				
  function s__SynchronizedUnit_Stop takes integer this returns nothing
			if s__SynchronizedUnit_Unit[this] != null then
				call Recycle_ReleaseUnit(s__SynchronizedUnit_Unit[this])
				set s__SynchronizedUnit_Unit[this]=null
			endif
  endfunction
  function s__SynchronizedUnit_Start takes integer this returns nothing
			if s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[this]] != 0 then
				set s__SynchronizedUnit_CurrentOrder[this]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[this]]
				
				set s__SynchronizedUnit_Unit[this]=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((s__SynchronizedUnit_UnitID[this] )))),(( s__vector2_x[(s__SimpleList_ListNode_value[s__SynchronizedUnit_CurrentOrder[this]])] )*1.0) , (( s__vector2_y[(s__SimpleList_ListNode_value[s__SynchronizedUnit_CurrentOrder[this]])])*1.0))) // INLINED!!
				if s__SynchronizedUnit_MoveSpeed[this] != 0 then
					call SetUnitMoveSpeed(s__SynchronizedUnit_Unit[this], s__SynchronizedUnit_MoveSpeed[this])
				endif
				set s__SynchronizedUnit_Ready[this]=false
				set s__SynchronizedUnit_CurrentOrder[this]=s__SimpleList_ListNode_next[s__SynchronizedUnit_CurrentOrder[this]]
				
				call IssuePointOrder(s__SynchronizedUnit_Unit[this], "move", s__vector2_x[(s__SimpleList_ListNode_value[s__SynchronizedUnit_CurrentOrder[this]])], s__vector2_y[(s__SimpleList_ListNode_value[s__SynchronizedUnit_CurrentOrder[this]])])
			endif
  endfunction
		
  function s__SynchronizedUnit_create takes integer unitID,integer parent returns integer
   local integer new= s__SynchronizedUnit_allocate()
			
			set s__SynchronizedUnit_UnitID[new]=unitID
			set s__SynchronizedUnit_ParentGroup[new]=parent
			
			//defaults
			set s__SynchronizedUnit_MoveSpeed[new]=0
			
			//predefined inits
			set s__SynchronizedUnit_Ready[new]=false
			set s__SynchronizedUnit_CurrentOrder[new]=0
			set s__SynchronizedUnit_AllOrders[new]=s__SimpleList_List_create()
			
			return new
  endfunction
	
		
		
  function s__SynchronizedGroup_Periodic takes nothing returns nothing
   local integer curGroup= s__SimpleList_List_first[s__SynchronizedGroup_ActiveGroups]
   local integer curUnit
   local boolean allReady
			
			loop
			exitwhen curGroup == 0
				set curUnit=s__SimpleList_List_first[s__SynchronizedGroup_AllUnits[(s__SimpleList_ListNode_value[curGroup])]]
				set allReady=true
				
				loop
				exitwhen curUnit == 0
					if not s__SynchronizedUnit_Ready[(s__SimpleList_ListNode_value[curUnit])] then
						//GetUnitCurrentOrder(u) == OrderId("none") or GetUnitCurrentOrder(u) == OrderId("stop")
						if s__SimpleList_ListNode_value[s__SynchronizedUnit_CurrentOrder[(s__SimpleList_ListNode_value[curUnit])]] == 0 or ( ( RAbsBJ(s__vector2_x[(s__SimpleList_ListNode_value[s__SynchronizedUnit_CurrentOrder[(s__SimpleList_ListNode_value[curUnit])]])] - GetUnitX(s__SynchronizedUnit_Unit[(s__SimpleList_ListNode_value[curUnit])])) < SynchronizedGroup___DESTINATION_TOLERANCE ) and ( RAbsBJ(s__vector2_y[(s__SimpleList_ListNode_value[s__SynchronizedUnit_CurrentOrder[(s__SimpleList_ListNode_value[curUnit])]])] - GetUnitY(s__SynchronizedUnit_Unit[(s__SimpleList_ListNode_value[curUnit])])) < SynchronizedGroup___DESTINATION_TOLERANCE ) ) then
							set s__SynchronizedUnit_Ready[(s__SimpleList_ListNode_value[curUnit])]=true
						else
							set allReady=false
						endif
					endif
				set curUnit=s__SimpleList_ListNode_next[curUnit]
				endloop
				
				if allReady then
					set curUnit=s__SimpleList_List_first[s__SynchronizedGroup_AllUnits[(s__SimpleList_ListNode_value[curGroup])]]
					loop
					exitwhen curUnit == 0
						if s__SimpleList_ListNode_next[s__SynchronizedUnit_CurrentOrder[(s__SimpleList_ListNode_value[curUnit])]] != 0 then
							set s__SynchronizedUnit_CurrentOrder[(s__SimpleList_ListNode_value[curUnit])]=s__SimpleList_ListNode_next[s__SynchronizedUnit_CurrentOrder[(s__SimpleList_ListNode_value[curUnit])]]
							set s__SynchronizedUnit_Ready[(s__SimpleList_ListNode_value[curUnit])]=false
							
							call IssuePointOrder(s__SynchronizedUnit_Unit[(s__SimpleList_ListNode_value[curUnit])], "move", s__vector2_x[(s__SimpleList_ListNode_value[s__SynchronizedUnit_CurrentOrder[(s__SimpleList_ListNode_value[curUnit])]])], s__vector2_y[(s__SimpleList_ListNode_value[s__SynchronizedUnit_CurrentOrder[(s__SimpleList_ListNode_value[curUnit])]])])
						//else //just leave unit in ready state
						endif
					set curUnit=s__SimpleList_ListNode_next[curUnit]
					endloop
				endif
			set curGroup=s__SimpleList_ListNode_next[curGroup]
			endloop
  endfunction
		
  function s__SynchronizedGroup_Stop takes integer this returns nothing
   local integer curUnit= s__SimpleList_List_first[s__SynchronizedGroup_AllUnits[this]]
			
			//timer is only active when there are any active groups
			call s__SimpleList_List_remove(s__SynchronizedGroup_ActiveGroups,this)
			if s__SimpleList_List_count[s__SynchronizedGroup_ActiveGroups] == 0 then
				call PauseTimer(s__SynchronizedGroup_t)
			endif
			
			//units in group are also unloaded when paused
			loop
			exitwhen curUnit == 0
				call s__SynchronizedUnit_Stop((s__SimpleList_ListNode_value[curUnit]))
			set curUnit=s__SimpleList_ListNode_next[curUnit]
			endloop
  endfunction
  function s__SynchronizedGroup_Start takes integer this returns nothing
   local integer curUnit= s__SimpleList_List_first[s__SynchronizedGroup_AllUnits[this]]
			
			//timer is only active when there are any active groups
			if s__SimpleList_List_count[s__SynchronizedGroup_ActiveGroups] == 0 then
				call TimerStart(s__SynchronizedGroup_t, SynchronizedGroup___TIMESTEP, true, function s__SynchronizedGroup_Periodic)
			endif
			call s__SimpleList_List_add(s__SynchronizedGroup_ActiveGroups,this)
			
			//units in group are also unloaded when paused
			loop
			exitwhen curUnit == 0
				call s__SynchronizedUnit_Start((s__SimpleList_ListNode_value[curUnit]))
			set curUnit=s__SimpleList_ListNode_next[curUnit]
			endloop
  endfunction
		
  function s__SynchronizedGroup_AddUnit takes integer this,integer unitID returns integer
   local integer su= s__SynchronizedUnit_create(unitID , this)
			
			call s__SimpleList_List_add(s__SynchronizedGroup_AllUnits[this],su)
			
			return su
  endfunction
		
  function s__SynchronizedGroup_create takes nothing returns integer
   local integer new= s__SynchronizedGroup__allocate()
			
			set s__SynchronizedGroup_AllUnits[new]=s__SimpleList_List_create()
			
			return new
  endfunction
		
  function s__SynchronizedGroup_onInit takes nothing returns nothing
			set s__SynchronizedGroup_ActiveGroups=s__SimpleList_List_create()
			set s__SynchronizedGroup_t=CreateTimer()
  endfunction

//library SynchronizedGroup ends
//library TeamSaveLocation:


    
//Implemented from module Alloc:
		
		

			

		
		
  function s__PlayerSaveLocation_allocate takes nothing returns integer
   local integer this= s__PlayerSaveLocation_Alloc___recycler[0]
			


			
			if ( s__PlayerSaveLocation_Alloc___recycler[this] == 0 ) then
				set s__PlayerSaveLocation_Alloc___recycler[0]=this + 1
			else
				set s__PlayerSaveLocation_Alloc___recycler[0]=s__PlayerSaveLocation_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__PlayerSaveLocation_deallocate takes integer this returns nothing


			


			
			set s__PlayerSaveLocation_Alloc___recycler[this]=s__PlayerSaveLocation_Alloc___recycler[0]
			set s__PlayerSaveLocation_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__PlayerSaveLocation_Alloc___onInit takes nothing returns nothing
			set s__PlayerSaveLocation_Alloc___recycler[0]=1
  endfunction
    
    function s__PlayerSaveLocation_create takes integer u returns integer
        local integer new= s__PlayerSaveLocation_allocate()
        
        if s__User_GameMode[u] == Teams_GAMEMODE_PLATFORMING then
            set s__PlayerSaveLocation_LocationX[new]=s__Platformer_XPosition[s__User_Platformer[u]]
            set s__PlayerSaveLocation_LocationY[new]=s__Platformer_YPosition[s__User_Platformer[u]]
        else
            set s__PlayerSaveLocation_LocationX[new]=GetUnitX(s__User_ActiveUnit[u])
            set s__PlayerSaveLocation_LocationY[new]=GetUnitY(s__User_ActiveUnit[u])
        endif
        
        set s__PlayerSaveLocation_PlayerID[new]=u
        set s__PlayerSaveLocation_GameMode[new]=s__User_GameMode[u]
        set s__PlayerSaveLocation_KeyColor[new]=s__MazerColor[u]
        
        return new
    endfunction

    //public rect Revive
    //can default game mode ever change mid level?
    //public integer DefaultGameMode
    
    
//Implemented from module Alloc:
		
		

			

		
		
  function s__TeamSaveLocation_allocate takes nothing returns integer
   local integer this= s__TeamSaveLocation_Alloc___recycler[0]
			


			
			if ( s__TeamSaveLocation_Alloc___recycler[this] == 0 ) then
				set s__TeamSaveLocation_Alloc___recycler[0]=this + 1
			else
				set s__TeamSaveLocation_Alloc___recycler[0]=s__TeamSaveLocation_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__TeamSaveLocation_deallocate takes integer this returns nothing


			


			
			set s__TeamSaveLocation_Alloc___recycler[this]=s__TeamSaveLocation_Alloc___recycler[0]
			set s__TeamSaveLocation_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__TeamSaveLocation_Alloc___onInit takes nothing returns nothing
			set s__TeamSaveLocation_Alloc___recycler[0]=1
  endfunction
    
 function s__TeamSaveLocation_RemoveInvulnCB takes nothing returns nothing
  local timer t= GetExpiredTimer()
  local integer invulnTeam= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
  local integer invulnPlayer= s__Teams_MazingTeam_FirstUser[invulnTeam]
		
		loop
		exitwhen invulnPlayer == null
			set s__MobImmune[s__SimpleList_ListNode_value[invulnPlayer]]= false
			set s__CanReviveOthers[s__SimpleList_ListNode_value[invulnPlayer]]= true
			
		set invulnPlayer=s__SimpleList_ListNode_next[invulnPlayer]
		endloop
		
		call ReleaseTimer(t)
		set t=null
 endfunction
 function s__TeamSaveLocation_UnpauseUnitCB takes nothing returns nothing
  local timer t= GetExpiredTimer()
  local integer pausedTeam= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
  local integer pausedPlayer= s__Teams_MazingTeam_FirstUser[pausedTeam]
		
		loop
		exitwhen pausedPlayer == null
			if s__User_GameMode[(s__SimpleList_ListNode_value[pausedPlayer])] == Teams_GAMEMODE_STANDARD_PAUSED then
				//set immune for  sec and create effect
				call s__DummyCaster_castTarget(('A006'),Player(s__SimpleList_ListNode_value[pausedPlayer]) , 1 , OrderId("bloodlust") , s__User_ActiveUnit[(s__SimpleList_ListNode_value[pausedPlayer])])
				set s__MobImmune[s__SimpleList_ListNode_value[pausedPlayer]]= true
				set s__CanReviveOthers[s__SimpleList_ListNode_value[pausedPlayer]]= false
			
				call sc__User_SwitchGameModesDefaultLocation((s__SimpleList_ListNode_value[pausedPlayer]),Teams_GAMEMODE_STANDARD)
			elseif s__User_GameMode[(s__SimpleList_ListNode_value[pausedPlayer])] == Teams_GAMEMODE_PLATFORMING_PAUSED then
				//set immune for  sec and create effect
				call s__DummyCaster_castTarget(('A006'),Player(s__SimpleList_ListNode_value[pausedPlayer]) , 1 , OrderId("bloodlust") , s__User_ActiveUnit[(s__SimpleList_ListNode_value[pausedPlayer])])
				set s__MobImmune[s__SimpleList_ListNode_value[pausedPlayer]]= true
				set s__CanReviveOthers[s__SimpleList_ListNode_value[pausedPlayer]]= false
				
				call sc__User_SwitchGameModesDefaultLocation((s__SimpleList_ListNode_value[pausedPlayer]),Teams_GAMEMODE_PLATFORMING)
			endif
		set pausedPlayer=s__SimpleList_ListNode_next[pausedPlayer]
		endloop
		
		call TimerStart(t, 2, false, function s__TeamSaveLocation_RemoveInvulnCB)
		set t=null
 endfunction
 function s__TeamSaveLocation_Restore takes integer this returns nothing
  local integer pSaveNode= s__SimpleList_List_first[s__TeamSaveLocation_PlayerSaves[this]]
  local integer pSave
  local integer u
		
		// call Teams_MazingTeam(this.TeamID).OnLevel.SwitchLevelsAnimated(this.TeamID, this.LevelID, false)
		call sc__Levels_Level_SwitchLevels(s__Teams_MazingTeam_OnLevel[(s__TeamSaveLocation_TeamID[this])],s__TeamSaveLocation_TeamID[this] , s__TeamSaveLocation_LevelID[this] , 0 , false)
		//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "2 Team on level " + I2S(Teams_MazingTeam(this.TeamID).OnLevel))
		call sc__Levels_Level_SetCheckpointForTeam(s__Teams_MazingTeam_OnLevel[(s__TeamSaveLocation_TeamID[this])],s__TeamSaveLocation_TeamID[this] , s__TeamSaveLocation_CheckpointID[this])
		//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Team on checkpoint " + I2S(Teams_MazingTeam(this.TeamID).OnCheckpoint))
		
		call sc__Teams_MazingTeam_SetContinueCount((s__TeamSaveLocation_TeamID[this]),s__TeamSaveLocation_ContinueCount[this])
		
		//reset player locations and statuses
		loop
		exitwhen pSaveNode == null
			set pSave=(s__SimpleList_ListNode_value[pSaveNode])
			set u=(s__PlayerSaveLocation_PlayerID[pSave])
			
			if s__PlayerSaveLocation_GameMode[pSave] == Teams_GAMEMODE_STANDARD or s__PlayerSaveLocation_GameMode[pSave] == Teams_GAMEMODE_STANDARD_PAUSED then
				call sc__User_SwitchGameModes(u,Teams_GAMEMODE_STANDARD_PAUSED , s__PlayerSaveLocation_LocationX[pSave] , s__PlayerSaveLocation_LocationY[pSave])
				
				// call SetDefaultCameraForPlayer(u, .5)
				call sc__User_ApplyDefaultCameras(u,.5)
			elseif s__PlayerSaveLocation_GameMode[pSave] == Teams_GAMEMODE_PLATFORMING or s__PlayerSaveLocation_GameMode[pSave] == Teams_GAMEMODE_PLATFORMING_PAUSED then
				call sc__User_SwitchGameModes(u,Teams_GAMEMODE_PLATFORMING_PAUSED , s__PlayerSaveLocation_LocationX[pSave] , s__PlayerSaveLocation_LocationY[pSave])
			elseif s__PlayerSaveLocation_GameMode[pSave] == Teams_GAMEMODE_DYING or s__PlayerSaveLocation_GameMode[pSave] == Teams_GAMEMODE_DEAD then
				call sc__User_SwitchGameModes(u,Teams_GAMEMODE_DEAD , s__PlayerSaveLocation_LocationX[pSave] , s__PlayerSaveLocation_LocationY[pSave])
				
				//reset camera to death location
				
				// call SetDefaultCameraForPlayer(u, .5)
				call sc__User_ApplyDefaultCameras(u,.5)
			endif
			
			call sc__User_SetKeyColor(u,s__PlayerSaveLocation_KeyColor[pSave])
		set pSaveNode=s__SimpleList_ListNode_next[pSaveNode]
		endloop
		
		// debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Restore Team - Finished updating players and team")
		
		//multiboard update
		call sc__Teams_MazingTeam_UpdateMultiboard((s__TeamSaveLocation_TeamID[this]))
		
		call TimerStart(NewTimerEx(s__TeamSaveLocation_TeamID[this]), 2, false, function s__TeamSaveLocation_UnpauseUnitCB)
 endfunction
	
    function s__TeamSaveLocation_GetFirstSave takes string saveName returns integer
        local integer iSave= s__SimpleList_List_first[TeamSaveLocation_ActiveSaves]
        
        loop
        exitwhen iSave == null
            if s__TeamSaveLocation_SaveName[(s__SimpleList_ListNode_value[iSave])] == saveName then
                return s__SimpleList_ListNode_value[iSave]
            endif
        set iSave=s__SimpleList_ListNode_next[iSave]
        endloop
        
        return 0
    endfunction
    function s__TeamSaveLocation_GetFirstSaveForTeam takes string saveName,integer teamID returns integer
        local integer iSave= s__SimpleList_List_first[TeamSaveLocation_ActiveSaves]
        
        loop
        exitwhen iSave == null
            if s__TeamSaveLocation_SaveName[(s__SimpleList_ListNode_value[iSave])] == saveName and s__TeamSaveLocation_TeamID[(s__SimpleList_ListNode_value[iSave])] == teamID then
                return s__SimpleList_ListNode_value[iSave]
            endif
        set iSave=s__SimpleList_ListNode_next[iSave]
        endloop
        
        return 0
    endfunction
    
    function s__TeamSaveLocation_destroy takes integer this returns nothing
        local integer curPlayerNode
        
		set s__TeamSaveLocation_SaveName[this]=null
		
		//clean up player saves / list
        loop
		set curPlayerNode=s__SimpleList_List_pop(s__TeamSaveLocation_PlayerSaves[this])
        exitwhen curPlayerNode == null
            call s__PlayerSaveLocation_deallocate((s__SimpleList_ListNode_value[curPlayerNode]))
        call s__SimpleList_ListNode_deallocate(curPlayerNode)
        endloop
		
		call s__SimpleList_List_destroy(s__TeamSaveLocation_PlayerSaves[this])
		
        //deallocate self
        call s__SimpleList_List_remove(TeamSaveLocation_ActiveSaves,this)
		call s__TeamSaveLocation_deallocate(this)
    endfunction
    
    function s__TeamSaveLocation_create takes string saveName,integer team returns integer
        local integer new= s__TeamSaveLocation_allocate()
        local integer curPlayerNode= s__Teams_MazingTeam_FirstUser[team]
        
        set s__TeamSaveLocation_SaveName[new]=saveName
        set s__TeamSaveLocation_TeamID[new]=team
        set s__TeamSaveLocation_LevelID[new]=s__Teams_MazingTeam_OnLevel[team]
        set s__TeamSaveLocation_CheckpointID[new]=s__Teams_MazingTeam_OnCheckpoint[team]
        set s__TeamSaveLocation_ContinueCount[new]=s__Teams_MazingTeam_ContinueCount[team]
        //set new.TeamID = teamID
        
        set s__TeamSaveLocation_PlayerSaves[new]=s__SimpleList_List_create()
        loop
        exitwhen curPlayerNode == null
            call s__SimpleList_List_add(s__TeamSaveLocation_PlayerSaves[new],s__PlayerSaveLocation_create((s__SimpleList_ListNode_value[curPlayerNode])))
        set curPlayerNode=s__SimpleList_ListNode_next[curPlayerNode]
        endloop
        
        //this is a queue
        call s__SimpleList_List_addEnd(TeamSaveLocation_ActiveSaves,new)
        
        return new
    endfunction

function TeamSaveLocation___Init takes nothing returns nothing
    set TeamSaveLocation_ActiveSaves=s__SimpleList_List_create()
endfunction

//library TeamSaveLocation ends
//library WeightedList:
        
        
//Implemented from module Alloc:
		
		

			

		
		
  function s__WeightedListNode_allocate takes nothing returns integer
   local integer this= s__WeightedListNode_Alloc___recycler[0]
			


			
			if ( s__WeightedListNode_Alloc___recycler[this] == 0 ) then
				set s__WeightedListNode_Alloc___recycler[0]=this + 1
			else
				set s__WeightedListNode_Alloc___recycler[0]=s__WeightedListNode_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__WeightedListNode_deallocate takes integer this returns nothing


			


			
			set s__WeightedListNode_Alloc___recycler[this]=s__WeightedListNode_Alloc___recycler[0]
			set s__WeightedListNode_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__WeightedListNode_Alloc___onInit takes nothing returns nothing
			set s__WeightedListNode_Alloc___recycler[0]=1
  endfunction
    
                
//Implemented from module Alloc:
		
		

			

		
		
  function s__WeightedList_allocate takes nothing returns integer
   local integer this= s__WeightedList_Alloc___recycler[0]
			


			
			if ( s__WeightedList_Alloc___recycler[this] == 0 ) then
				set s__WeightedList_Alloc___recycler[0]=this + 1
			else
				set s__WeightedList_Alloc___recycler[0]=s__WeightedList_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__WeightedList_deallocate takes integer this returns nothing


			


			
			set s__WeightedList_Alloc___recycler[this]=s__WeightedList_Alloc___recycler[0]
			set s__WeightedList_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__WeightedList_Alloc___onInit takes nothing returns nothing
			set s__WeightedList_Alloc___recycler[0]=1
  endfunction
        
        function s__WeightedList_add takes integer this,integer value,real weight returns nothing
            local integer curHead= s__WeightedList_first[this]
            
            set s__WeightedList_first[this]=s__WeightedListNode_allocate()
            set s__WeightedListNode_value[s__WeightedList_first[this]]=value
            set s__WeightedListNode_weight[s__WeightedList_first[this]]=weight
            set s__WeightedList_totalWeight[this]=s__WeightedList_totalWeight[this] + weight
            
            set s__WeightedListNode_prev[s__WeightedList_first[this]]=0
            set s__WeightedListNode_next[s__WeightedList_first[this]]=curHead
            
            if curHead != 0 then
                set s__WeightedListNode_prev[curHead]=s__WeightedList_first[this]
            else
                set s__WeightedList_last[this]=s__WeightedList_first[this]
            endif
            
            set s__WeightedList_count[this]=s__WeightedList_count[this] + 1
        endfunction
        function s__WeightedList_addEnd takes integer this,integer value,real weight returns nothing
            local integer curEnd= s__WeightedList_last[this]
            
            set s__WeightedList_last[this]=s__WeightedListNode_allocate()
            set s__WeightedListNode_value[s__WeightedList_last[this]]=value
            set s__WeightedListNode_weight[s__WeightedList_last[this]]=weight
            set s__WeightedList_totalWeight[this]=s__WeightedList_totalWeight[this] + weight
            
            set s__WeightedListNode_next[s__WeightedList_last[this]]=0
            set s__WeightedListNode_prev[s__WeightedList_last[this]]=curEnd
            
            if curEnd != 0 then
                set s__WeightedListNode_next[curEnd]=s__WeightedList_last[this]
            else
                set s__WeightedList_first[this]=s__WeightedList_last[this]
            endif
            
            set s__WeightedList_count[this]=s__WeightedList_count[this] + 1
        endfunction
        
        function s__WeightedList_remove takes integer this,integer value returns nothing
            local integer cur= s__WeightedList_first[this]
            
            loop
            exitwhen cur == 0
                if s__WeightedListNode_value[cur] == value then
                    set s__WeightedList_totalWeight[this]=s__WeightedList_totalWeight[this] - s__WeightedListNode_weight[cur]
                    
                    if s__WeightedListNode_next[cur] != 0 then
                        set s__WeightedListNode_prev[s__WeightedListNode_next[cur]]=s__WeightedListNode_prev[cur]
                    else
                        set s__WeightedList_last[this]=s__WeightedListNode_prev[cur]
                    endif
                    
                    if s__WeightedListNode_prev[cur] != 0 then
                        set s__WeightedListNode_next[s__WeightedListNode_prev[cur]]=s__WeightedListNode_next[cur]
                    else
                        set s__WeightedList_first[this]=s__WeightedListNode_next[cur]
                    endif
                    
                    call s__WeightedListNode_deallocate(cur)
                    
                    set s__WeightedList_count[this]=s__WeightedList_count[this] - 1
                    
                    return
                endif
            set cur=s__WeightedListNode_next[cur]
            endloop
        endfunction
        function s__WeightedList_removeNode takes integer this,integer node returns nothing
            set s__WeightedList_totalWeight[this]=s__WeightedList_totalWeight[this] - s__WeightedListNode_weight[node]
            
            if s__WeightedListNode_next[node] != 0 then
                set s__WeightedListNode_prev[s__WeightedListNode_next[node]]=s__WeightedListNode_prev[node]
            else
                set s__WeightedList_last[this]=s__WeightedListNode_prev[node]
            endif
            
            if s__WeightedListNode_prev[node] != 0 then
                set s__WeightedListNode_next[s__WeightedListNode_prev[node]]=s__WeightedListNode_next[node]
            else
                set s__WeightedList_first[this]=s__WeightedListNode_next[node]
            endif
            
            call s__WeightedListNode_deallocate(node)
            
            set s__WeightedList_count[this]=s__WeightedList_count[this] - 1
        endfunction
        function s__WeightedList_clear takes integer this returns nothing
            local integer cur
            
            //de-allocate all nodes in the list
            if s__WeightedList_count[this] > 0 then
                set cur=s__WeightedList_first[this]
                
                loop
                exitwhen s__WeightedListNode_next[cur] == 0
                    set cur=s__WeightedListNode_next[cur]
                    call s__WeightedListNode_deallocate(s__WeightedListNode_prev[cur])
                endloop
                
                call s__WeightedListNode_deallocate(cur)
            endif
            
            //reset list properties
            set s__WeightedList_totalWeight[this]=0
            set s__WeightedList_first[this]=0
            set s__WeightedList_last[this]=0
            set s__WeightedList_count[this]=0
        endfunction
        
//        public method insertAt takes integer value, integer position returns nothing
//            //TODO add an optional static table to make insert at efficient
//            
//            
//        endmethod
//        
        function s__WeightedList_contains takes integer this,integer value returns boolean
            local integer cur= s__WeightedList_first[this]
            
            loop
            exitwhen cur == 0
                if s__WeightedListNode_value[cur] == value then
                    return true
                endif
            set cur=s__WeightedListNode_next[cur]
            endloop
            
            return false
        endfunction
        function s__WeightedList_index takes integer this,integer value returns integer
            local integer cur= s__WeightedList_first[this]
            local integer i= 0
            
            loop
            exitwhen cur == 0
                if s__WeightedListNode_value[cur] == value then
                    return i
                endif
            set i=i + 1
            set cur=s__WeightedListNode_next[cur]
            endloop
            
            return - 1
        endfunction
        







































        
        function s__WeightedList_destroy takes integer this returns nothing
            call s__WeightedList_clear(this)
            call s__WeightedList_deallocate(this)
        endfunction
        
        function s__WeightedList_create takes nothing returns integer
            local integer new= s__WeightedList_allocate()
            
            set s__WeightedList_count[new]=0
            set s__WeightedList_first[new]=0
            set s__WeightedList_last[new]=0
            set s__WeightedList_totalWeight[new]=0
            
            return new
        endfunction

//library WeightedList ends
//library Wheel:
        
        
        
        //TODO convert to unit if ever want to make wheel move
        
        
        
        function s__Wheel_Rotate takes integer this returns nothing
            local integer wUnitNode= s__SimpleList_List_first[s__Wheel_Units[this]]
            
            //R2I translates to Math.floor
            local integer iLayer= 0
            local integer iSpoke= 0
            local real x
            local real y
            
            local real theta
            
            loop
            exitwhen wUnitNode == 0
                if iSpoke == s__Wheel_SpokeCount[this] then
                    set iSpoke=0
                    set iLayer=iLayer + 1
                    
                    set theta=0
                endif
                
                if s__SimpleList_ListNode_value[wUnitNode] != 0 then
                    set theta=s__Wheel_CurrentAngle[this] + iSpoke * s__Wheel_AngleBetween[this]
                    set x=s__vector2_x[s__Wheel_Center[this]] + s__Wheel_InitialOffset[this] * Cos(theta) + iLayer * s__Wheel_DistanceBetween[this] * Cos(theta)
                    set y=s__vector2_y[s__Wheel_Center[this]] + s__Wheel_InitialOffset[this] * Sin(theta) + iLayer * s__Wheel_DistanceBetween[this] * Sin(theta)
                    
                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "x: " + R2S(x))
                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "y: " + R2S(y))
                    
                    call SetUnitPosition(s__IndexedUnit_Unit[(s__SimpleList_ListNode_value[wUnitNode])], x, y)
                //else
                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Empty unit")
                endif
                
                
            set iSpoke=iSpoke + 1
            set wUnitNode=s__SimpleList_ListNode_next[wUnitNode]
            endloop
            
            set s__Wheel_CurrentAngle[this]=s__Wheel_CurrentAngle[this] + s__Wheel_RotationSpeed[this]
            if s__Wheel_CurrentAngle[this] >= 2 * bj_PI then
                set s__Wheel_CurrentAngle[this]=s__Wheel_CurrentAngle[this] - 2 * bj_PI
            endif
        endfunction
        
        function s__Wheel_Periodic takes nothing returns nothing
            local integer curWheel= s__SimpleList_List_first[s__Wheel_ActiveWheels]
            
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Wheel periodic!")
            
            loop
            exitwhen curWheel == 0
                call sc__Wheel_Rotate((s__SimpleList_ListNode_value[curWheel]))
            set curWheel=s__SimpleList_ListNode_next[curWheel]
            endloop
        endfunction
        
        function s__Wheel_Stop takes integer this returns nothing
            call s__SimpleList_List_remove(s__Wheel_ActiveWheels,this)
            
            if s__SimpleList_List_count[s__Wheel_ActiveWheels] == 0 then
                call PauseTimer(s__Wheel_Timer)
            endif
            
            //TODO hide all wheel units
        endfunction
        
        function s__Wheel_Start takes integer this returns nothing
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Starting wheel")
            
            if s__SimpleList_List_count[s__Wheel_ActiveWheels] == 0 then
                call TimerStart(s__Wheel_Timer, Wheel_TIMEOUT, true, function s__Wheel_Periodic)
            endif
            
			set s__Wheel_CurrentAngle[this]=s__Wheel_InitialAngle[this]
            call s__SimpleList_List_addEnd(s__Wheel_ActiveWheels,this)
            
            //TODO show all wheel units
        endfunction
        
        //adds units to spokes
        function s__Wheel_AddUnits takes integer this,integer unitID,integer count returns nothing
            local integer iUnit= 0
   local unit u
            
            //R2I translates to Math.floor
            local integer iLayer
            local integer iSpoke
            local real x
            local real y
            
            local real theta
            
            loop
            exitwhen iUnit >= count
                set iLayer=s__SimpleList_List_count[s__Wheel_Units[this]] / s__Wheel_SpokeCount[this]
                set iSpoke=s__SimpleList_List_count[s__Wheel_Units[this]] - iLayer * s__Wheel_SpokeCount[this]
                                
                set theta=s__Wheel_CurrentAngle[this] + iSpoke * s__Wheel_AngleBetween[this]
                set x=s__vector2_x[s__Wheel_Center[this]] + s__Wheel_InitialOffset[this] * Cos(theta) + iLayer * s__Wheel_DistanceBetween[this] * Cos(theta)
                set y=s__vector2_y[s__Wheel_Center[this]] + s__Wheel_InitialOffset[this] * Sin(theta) + iLayer * s__Wheel_DistanceBetween[this] * Sin(theta)
                
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "x: " + R2S(x))
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "y: " + R2S(y))
                
				set u=CreateUnit(Wheel_WISP_WHEEL_PLAYER, unitID, x, y, 0)
				call s__IndexedUnit_create(u)
                call AddUnitLocust(u)
                
                call s__SimpleList_List_addEnd(s__Wheel_Units[this],GetUnitUserData(u))
            set iUnit=iUnit + 1
            endloop
        endfunction
        
        function s__Wheel_AddEmptySpace takes integer this,integer count returns nothing
            local integer iUnit= 0
            
            loop
            exitwhen iUnit >= count
                call s__SimpleList_List_addEnd(s__Wheel_Units[this],0)
            set iUnit=iUnit + 1
            endloop
        endfunction

        function s__Wheel_AddLayer takes integer this,integer unitID returns nothing
            local integer iUnit= 0
            local integer remainingInLayer= s__Wheel_SpokeCount[this] - ModuloInteger(s__SimpleList_List_count[s__Wheel_Units[this]], s__Wheel_SpokeCount[this])
            
            if remainingInLayer == 0 then
                set remainingInLayer=s__Wheel_SpokeCount[this]
            endif
            
            if unitID != 0 then
                call s__Wheel_AddUnits(this,unitID , remainingInLayer)
            else
                call s__Wheel_AddEmptySpace(this,remainingInLayer)
            endif
        endfunction
		
		//angle in rad
  function s__Wheel_SetInitialAngle takes integer this,real angle returns nothing
			set s__Wheel_InitialAngle[this]=angle
			set s__Wheel_CurrentAngle[this]=angle
			
			//TODO update existing unit locations in a more elegant way
			if s__SimpleList_List_count[s__Wheel_Units[this]] > 0 then
				call sc__Wheel_Rotate(this)
				set s__Wheel_RotationSpeed[this]=- s__Wheel_RotationSpeed[this]
				call sc__Wheel_Rotate(this)
				set s__Wheel_RotationSpeed[this]=- s__Wheel_RotationSpeed[this]
			endif
  endfunction
        
        function s__Wheel_onInit takes nothing returns nothing
            set s__Wheel_ActiveWheels=s__SimpleList_List_create()
            set s__Wheel_Timer=CreateTimer()
        endfunction
        
        function s__Wheel_create takes real x,real y returns integer
            local integer new= s__Wheel__allocate()
            
            set s__Wheel_Center[new]=s__vector2_create(x , y)
            
            set s__Wheel_LayerCount[new]=1
            set s__Wheel_InitialOffset[new]=0
            set s__Wheel_RotationSpeed[new]=Wheel___DEFAULT_ROTATION_SPEED
			set s__Wheel_InitialAngle[new]=0
            set s__Wheel_CurrentAngle[new]=s__Wheel_InitialAngle[new]
            set s__Wheel_Units[new]=s__SimpleList_List_create()
            
            return new
        endfunction
  function s__Wheel_createFromPoint takes rect point returns integer
			return s__Wheel_create(GetRectCenterX(point) , GetRectCenterY(point))
  endfunction

//library Wheel ends
//library isMoving:
	
		
		
  function s__IsMoving_stopCallback takes nothing returns nothing
   local timer t= GetExpiredTimer()
   local integer pID= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
			
			set s__isMoving[pID]= false
			call IssueImmediateOrder(s__MazersArray[pID], "stop")
			
			call ReleaseTimer(t)
			set t=null
  endfunction

  function s__IsMoving_applyTeleportMovement takes integer pID returns nothing
   local real curX= GetUnitX(s__User_ActiveUnit[pID])
   local real curY= GetUnitY(s__User_ActiveUnit[pID])
   local real deltaX= s__OrderDestinationX[pID] - curX
   local real deltaY= s__OrderDestinationY[pID] - curY
			
   local real theta= Atan2(deltaY, deltaX)
   local integer i= 1
			
			//local real dist = SquareRoot(deltaX * deltaX + deltaY * deltaY)
			
			//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Teleporting with angle: " + R2S(theta * 180 / bj_PI))
			
			if ( theta < 0 and theta >= - bj_PI / 4 ) or ( theta >= 0 and theta < bj_PI / 4 ) then
				//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "East")
				set deltaY=0
				
				loop
				exitwhen i == TELEPORT_MAXDISTANCE or GetTerrainType(curX + i * TERRAIN_TILE_SIZE, curY) != ABYSS
				set i=i + 1
				endloop
				set deltaX=i * TERRAIN_TILE_SIZE
			elseif theta >= bj_PI / 4 and theta < bj_PI * 3 / 4 then
				//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "North")
				loop
				exitwhen i == TELEPORT_MAXDISTANCE or GetTerrainType(curX, curY + i * TERRAIN_TILE_SIZE) != ABYSS
				set i=i + 1
				endloop
				set deltaY=i * TERRAIN_TILE_SIZE
				
				set deltaX=0
			elseif ( theta < 0 and theta < - bj_PI * 3 / 4 ) or ( theta >= 0 and theta >= bj_PI * 3 / 4 ) then
				//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "West")
				set deltaY=0
				
				loop
				exitwhen i == TELEPORT_MAXDISTANCE or GetTerrainType(curX - i * TERRAIN_TILE_SIZE, curY) != ABYSS
				set i=i + 1
				endloop
				set deltaX=- i * TERRAIN_TILE_SIZE
			else //if theta >= -bj_PI * 3/4 and theta < -bj_PI/4 then
				//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "South")
				loop
				exitwhen i == TELEPORT_MAXDISTANCE or GetTerrainType(curX, curY - i * TERRAIN_TILE_SIZE) != ABYSS
				set i=i + 1
				endloop
				set deltaY=- i * TERRAIN_TILE_SIZE
				
				set deltaX=0
			endif
			
			call DestroyEffect(AddSpecialEffect(isMoving___TELEPORT_MOVEMENT_FROM_FX, GetUnitX(s__User_ActiveUnit[pID]), GetUnitY(s__User_ActiveUnit[pID])))
			// call CreateInstantSpecialEffect(TELEPORT_MOVEMENT_FX, GetUnitX(pID.ActiveUnit), GetUnitY(pID.ActiveUnit), Player(pID))
			call SetUnitPosition(s__User_ActiveUnit[pID], curX + deltaX, curY + deltaY)
			call DestroyEffect(AddSpecialEffect(isMoving___TELEPORT_MOVEMENT_TO_FX, GetUnitX(s__User_ActiveUnit[pID]), GetUnitY(s__User_ActiveUnit[pID])))
			//call SetUnitX(u, OrderDestinationX[i] - x)
			//call SetUnitY(u, OrderDestinationY[i] - y)
			
			call TimerStart(NewTimerEx(pID), 0.0, false, function s__IsMoving_stopCallback)
  endfunction
		
  function s__IsMoving_moves takes nothing returns nothing
   local integer i= GetPlayerId(GetOwningPlayer(GetTriggerUnit()))
			
			set s__isMoving[i]= true
			set s__OrderDestinationX[i]= GetOrderPointX()
			set s__OrderDestinationY[i]= GetOrderPointY()
			
			if s__UseTeleportMovement[i] and GetTerrainType(GetUnitX(GetTriggerUnit()), GetUnitY(GetTriggerUnit())) == RTILE then
				call s__IsMoving_applyTeleportMovement(i)
			endif
			
			//call DisplayTextToForce(bj_FORCE_PLAYER[0], "MOVING")
  endfunction

  function s__IsMoving_stops takes nothing returns nothing
			if GetIssuedOrderId() == ORDER_stop then
				set s__isMoving[GetPlayerId(GetOwningPlayer(GetOrderedUnit()))]= false
				



			endif
  endfunction

  function s__IsMoving_checkDestination takes nothing returns nothing
   local group tempGroup= NewGroup()
   local integer curUserNode= s__SimpleList_List_first[s__IsMoving_DestinationUsers]
   local integer user
			loop
			exitwhen curUserNode == 0
				set user=(s__SimpleList_ListNode_value[curUserNode])
				if s__isMoving[user] and ( ( RAbsBJ(s__OrderDestinationX[user] - GetUnitX(s__User_ActiveUnit[user])) < TOLERANCE ) and ( RAbsBJ(s__OrderDestinationY[user] - GetUnitY(s__User_ActiveUnit[user])) < TOLERANCE ) ) then
					set s__isMoving[user]= false
					call IssueImmediateOrder(s__User_ActiveUnit[user], "stop")
					//call DisplayTextToForce(bj_FORCE_PLAYER[0], "NOT MOVING")
					



				endif
			
			set curUserNode=s__SimpleList_ListNode_next[curUserNode]
			endloop
  endfunction

  function s__IsMoving_Add takes integer user returns nothing
			if s__SimpleList_List_count[s__IsMoving_DestinationUsers] == 0 then
				call TimerStart(s__IsMoving_DestinationTimer, .1, true, function s__IsMoving_checkDestination)
			endif
			
			call s__SimpleList_List_addEnd(s__IsMoving_DestinationUsers,user)
			
			//check if unit is moving currently, set initial value for isMoving appropriately
			if GetUnitCurrentOrder(s__User_ActiveUnit[user]) == OrderId("none") or GetUnitCurrentOrder(s__User_ActiveUnit[user]) == OrderId("stop") then
				set s__isMoving[user]= false
			else
				set s__isMoving[user]= true
			endif
  endfunction
  function s__IsMoving_Remove takes integer user returns nothing
			call s__SimpleList_List_remove(s__IsMoving_DestinationUsers,user)
			
			if s__SimpleList_List_count[s__IsMoving_DestinationUsers] == 0 then
				call PauseTimer(s__IsMoving_DestinationTimer)
			endif
  endfunction
		
  function s__IsMoving_onInit takes nothing returns nothing
			set s__IsMoving_DestinationUsers=s__SimpleList_List_create()
		
			call TriggerAddAction(s__IsMoving_Click, function s__IsMoving_moves)
			call TriggerAddAction(s__IsMoving_StopEvent, function s__IsMoving_stops)
  endfunction
		
  function s__IsMoving_RegisterMazingClickEvents takes integer pID returns nothing
			//click event
			call TriggerRegisterUnitEvent(s__IsMoving_Click, s__MazersArray[pID], EVENT_UNIT_ISSUED_TARGET_ORDER)
			call TriggerRegisterUnitEvent(s__IsMoving_Click, s__MazersArray[pID], EVENT_UNIT_ISSUED_POINT_ORDER)
			
			//stop event
			call TriggerRegisterUnitEvent(s__IsMoving_StopEvent, s__MazersArray[pID], EVENT_UNIT_ISSUED_ORDER)
  endfunction

//library isMoving ends
//library All:
	
 function All___onPromiseResolve takes integer result,integer all returns integer
		set All___CountFinished[all]=All___CountFinished[all] + 1
					
		if All___CountFinished[all] == All___CountWaiting[all] then
			call s__Deferred_Resolve(all,result)
		else
			call s__Deferred_Progress(all,result)
		endif
		
		return 0
	endfunction
 function All___onPromiseProgress takes integer result,integer all returns integer
		call s__Deferred_Progress(all,result)
		
		return 0
	endfunction
	
 function All takes integer allPromises returns integer
  local integer new= s__Deferred_create()
  local integer curPromiseNode= s__SimpleList_List_first[allPromises]
		
		set All___CountFinished[new]=0
		set All___CountWaiting[new]=s__SimpleList_List_count[allPromises]
		
		loop
		exitwhen curPromiseNode == 0
			call s__Deferred_Then((s__SimpleList_ListNode_value[curPromiseNode]),(1) , (2) , new)
		set curPromiseNode=s__SimpleList_ListNode_next[curPromiseNode]
		endloop
		
		return new
	endfunction

//library All ends
//library Any:
 function Any___onPromiseResolve takes integer result,integer any returns integer
		call s__Deferred_Resolve(any,result)
		
		return 0
	endfunction
 function Any___onPromiseProgress takes integer result,integer any returns integer
		call s__Deferred_Progress(any,result)
		
		return 0
	endfunction
	
 function Any takes integer allPromises returns integer
  local integer new= s__Deferred_create()
  local integer curPromiseNode= s__SimpleList_List_first[allPromises]
			
		loop
		exitwhen curPromiseNode == 0
			call s__Deferred_Then((s__SimpleList_ListNode_value[curPromiseNode]),(3) , (4) , new)
		set curPromiseNode=s__SimpleList_ListNode_next[curPromiseNode]
		endloop
		
		return new
	endfunction

//library Any ends
//library MazerGlobals:
            
    function MazerGlobals_Init takes nothing returns nothing
        local integer i= 0
        //local trigger t = CreateTrigger()
        
        //mazing unit array
        set s__MazersArray[0]= gg_unit_Edem_0001
        set s__MazersArray[1]= gg_unit_Edem_0002
        set s__MazersArray[2]= gg_unit_Edem_0014
        set s__MazersArray[3]= gg_unit_Edem_0015
        set s__MazersArray[4]= gg_unit_Edem_0016
        set s__MazersArray[5]= gg_unit_Edem_0017
        set s__MazersArray[6]= gg_unit_Edem_0018
        set s__MazersArray[7]= gg_unit_Edem_0019
		
		set StandardMazingUsers=s__SimpleList_List_create()
        
        //loop which adds playing mazing units to a group and removes the units which are not playing from the game
        loop
        exitwhen i >= NumberPlayers
            ////only mazers who are not playing will be on level -1... level -1 does not exist
            //set MazerOnLevel[i] = -1
            set s__MazerColor[i]= 0
            //set Score[i] = 0
            set s__AbyssImmune[i]= false
            set s__isMoving[i]= false
            set s__UseTeleportMovement[i]= false
            
            set s__CanReviveOthers[i]= true
            set s__MobImmune[i]= false
			
			set s__MazerOnLevel[i]= 0
            
			//call AddUnitLocust(MazersArray[i])
			call PauseUnit(s__MazersArray[i], true)
			call SetUnitInvulnerable(s__MazersArray[i], false)
			
			if MazerGlobals___FORCE_DEBUG_TELE or false or CONFIGURATION_PROFILE != RELEASE then
				call UnitAddItemById(s__MazersArray[i], MazerGlobals___DEBUG_TELE_ITEM_ID)
			endif
			            
            set i=i + 1
        endloop
    endfunction

//library MazerGlobals ends
//library RespawningGateway:


	
	
	
	
	//keeps respawn update interval consistent throughout respawn timeout
 function s__RespawningGateway__get_RespawnTimeout takes integer this returns integer
		if s__RespawningGateway_RespawnTime[this] >= 180 then
			return 60
		elseif s__RespawningGateway_RespawnTime[this] >= 60 then
			return 30
		elseif s__RespawningGateway_RespawnTime[this] >= 30 then
			return 15
		elseif s__RespawningGateway_RespawnTime[this] >= 15 then
			return 5
		else
			return 1
		endif
 endfunction
	
 function s__RespawningGateway_UpdateTimeRemainingDisplay takes integer this returns nothing
  local string timeTagLabel
		
		if s__RespawningGateway_RespawnTimeRemaining[this] == s__RespawningGateway__get_RespawnTimeout(this) then
			call SetTextTagColor(s__RespawningGateway_RespawnTimeTag[this], 255, 0, 0, 1)
		endif
		
		if s__RespawningGateway_RespawnTimeRemaining[this] >= 60 then
			set timeTagLabel=I2S(R2I(s__RespawningGateway_RespawnTimeRemaining[this] / 60.)) + " minute"
			
			if R2I(s__RespawningGateway_RespawnTimeRemaining[this] / 60.) != 60 then
				set timeTagLabel=timeTagLabel + "s"
			endif
		else
			set timeTagLabel=I2S(s__RespawningGateway_RespawnTimeRemaining[this]) + " second"
			
			if s__RespawningGateway_RespawnTimeRemaining[this] != 1 then
				set timeTagLabel=timeTagLabel + "s"
			endif
		endif
		
		call SetTextTagText(s__RespawningGateway_RespawnTimeTag[this], timeTagLabel, TextTagSize2Height(RespawningGateway___RESPAWN_TEXTTAG_FONT_SIZE))
 endfunction
	
 function s__RespawningGateway_OnGatewayRespawnTick takes nothing returns nothing
  local timer t= GetExpiredTimer()
  local integer gateway= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
		
		set s__RespawningGateway_RespawnTimeRemaining[gateway]=s__RespawningGateway_RespawnTimeRemaining[gateway] - s__RespawningGateway__get_RespawnTimeout(gateway)
		call s__RespawningGateway_UpdateTimeRemainingDisplay(gateway)
		
		if s__RespawningGateway_RespawnTimeRemaining[gateway] == 0 then
			set s__RespawningGateway_WallUnit[gateway]=s__RespawningUnit_respawn(s__RespawningGateway_WallRespawnData[gateway])
			call s__RespawningUnit_destroy(s__RespawningGateway_WallRespawnData[gateway])
			set s__RespawningGateway_WallRespawnData[gateway]=0
			
			call DestructableRestoreLife(s__RespawningGateway_ActivationDoodad[gateway], GetDestructableMaxLife(s__RespawningGateway_ActivationDoodad[gateway]), true)
			
			call DestroyTextTag(s__RespawningGateway_RespawnTimeTag[gateway])
			set s__RespawningGateway_RespawnTimeTag[gateway]=null
			
			call ReleaseTimer(t)
		endif
		
		set t=null
 endfunction
	
 function s__RespawningGateway_CheckActiveGateways takes nothing returns nothing
  local integer curGateway= s__SimpleList_List_first[s__RespawningGateway_ActiveGateways]
  local integer curTeam
  local integer curUser
		
		loop
		exitwhen curGateway == 0
			//only check gateways that are still alive
			if s__RespawningGateway_WallUnit[(s__SimpleList_ListNode_value[curGateway])] != null then
				set curTeam=s__SimpleList_List_first[s__Levels_Level_ActiveTeams[s__IStartable_ParentLevel[(s__SimpleList_ListNode_value[curGateway])]]]
						
				loop
				exitwhen curTeam == 0
					//call DisplayTextToForce(bj_FORCE_PLAYER[0], "Checking team " + I2S(curTeam.value))
					set curUser=s__SimpleList_List_first[s__Teams_MazingTeam_Users[(s__SimpleList_ListNode_value[curTeam])]]
											
					loop
					exitwhen curUser == 0
						if RectContainsCoords(s__RespawningGateway_ActivationArea[(s__SimpleList_ListNode_value[curGateway])], GetUnitX(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUser])]), GetUnitY(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUser])])) then
							call CreateInstantSpecialEffect("Abilities\\Spells\\Demon\\DarkPortal\\DarkPortalTarget.mdl" , GetUnitX(s__RespawningGateway_WallUnit[(s__SimpleList_ListNode_value[curGateway])]) , GetUnitY(s__RespawningGateway_WallUnit[(s__SimpleList_ListNode_value[curGateway])]) , Player(s__SimpleList_ListNode_value[curUser]))
							
							set s__RespawningGateway_WallRespawnData[(s__SimpleList_ListNode_value[curGateway])]=s__RespawningUnit_create(GetUnitX(s__RespawningGateway_WallUnit[(s__SimpleList_ListNode_value[curGateway])]) , GetUnitY(s__RespawningGateway_WallUnit[(s__SimpleList_ListNode_value[curGateway])]) , s__RespawningGateway_WallUnitID[(s__SimpleList_ListNode_value[curGateway])] , GetUnitFacing(s__RespawningGateway_WallUnit[(s__SimpleList_ListNode_value[curGateway])]))
							call Recycle_ReleaseUnit(s__RespawningGateway_WallUnit[(s__SimpleList_ListNode_value[curGateway])])
							set s__RespawningGateway_WallUnit[(s__SimpleList_ListNode_value[curGateway])]=null
							
							call KillDestructable(s__RespawningGateway_ActivationDoodad[(s__SimpleList_ListNode_value[curGateway])])
							
							set s__RespawningGateway_RespawnTimeRemaining[(s__SimpleList_ListNode_value[curGateway])]=s__RespawningGateway_RespawnTime[(s__SimpleList_ListNode_value[curGateway])]
							set s__RespawningGateway_RespawnTimeTag[(s__SimpleList_ListNode_value[curGateway])]=CreateTextTag()
							call SetTextTagPos(s__RespawningGateway_RespawnTimeTag[(s__SimpleList_ListNode_value[curGateway])], GetRectCenterX(s__RespawningGateway_ActivationArea[(s__SimpleList_ListNode_value[curGateway])]), GetRectCenterY(s__RespawningGateway_ActivationArea[(s__SimpleList_ListNode_value[curGateway])]) + RespawningGateway___REPSAWN_TEXTTAG_VERTICAL_OFFSET, 0)
							call SetTextTagPermanent(s__RespawningGateway_RespawnTimeTag[(s__SimpleList_ListNode_value[curGateway])], true)
							call SetTextTagColor(s__RespawningGateway_RespawnTimeTag[(s__SimpleList_ListNode_value[curGateway])], 255, 255, 255, 1)
							call SetTextTagVisibility(s__RespawningGateway_RespawnTimeTag[(s__SimpleList_ListNode_value[curGateway])], true)
							
							call s__RespawningGateway_UpdateTimeRemainingDisplay((s__SimpleList_ListNode_value[curGateway]))
							
							call TimerStart(NewTimerEx(s__SimpleList_ListNode_value[curGateway]), s__RespawningGateway__get_RespawnTimeout((s__SimpleList_ListNode_value[curGateway])), true, function s__RespawningGateway_OnGatewayRespawnTick)
						endif
					set curUser=s__SimpleList_ListNode_next[curUser]
					endloop
					
				set curTeam=s__SimpleList_ListNode_next[curTeam]
				endloop
			endif
		set curGateway=s__SimpleList_ListNode_next[curGateway]
		endloop
 endfunction
	
 function s__RespawningGateway_Stop takes integer this returns nothing
		call s__SimpleList_List_remove(s__RespawningGateway_ActiveGateways,this)
		if s__SimpleList_List_count[s__RespawningGateway_ActiveGateways] == 0 then
			call PauseTimer(s__RespawningGateway_ActiveGatewayTimer)
		endif
 endfunction
 function s__RespawningGateway_Start takes integer this returns nothing
		if s__SimpleList_List_count[s__RespawningGateway_ActiveGateways] == 0 then
			call TimerStart(s__RespawningGateway_ActiveGatewayTimer, RespawningGateway___ACTIVATION_CHECK_TIMESTEP, true, function s__RespawningGateway_CheckActiveGateways)
		endif
		call s__SimpleList_List_add(s__RespawningGateway_ActiveGateways,this)
				
		if s__RespawningGateway_RespawnTimeRemaining[this] > 0 then
			call s__RespawningGateway_UpdateTimeRemainingDisplay(this)
		endif
 endfunction
	
 function s__RespawningGateway_create takes integer wallUnitID,real wallX,real wallY,real activationX,real activationY,integer respawnTime returns integer
  local integer new= s__RespawningGateway__allocate()
		
		set s__RespawningGateway_WallUnitID[new]=wallUnitID
		set s__RespawningGateway_WallUnit[new]=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((wallUnitID )))),(( wallX )*1.0) , (( wallY)*1.0))) // INLINED!!
		
		set s__RespawningGateway_ActivationArea[new]=Rect(activationX - FOOT_SWITCH_SIZE, activationY - FOOT_SWITCH_SIZE, activationX + FOOT_SWITCH_SIZE, activationY + FOOT_SWITCH_SIZE)
		set s__RespawningGateway_ActivationDoodad[new]=CreateDestructable(FOOT_SWITCH, activationX, activationY, 270., 1., 0)
		
		//set respawn time to the nearest number of update intervals for raw respawn time
		set s__RespawningGateway_RespawnTime[new]=respawnTime
		set s__RespawningGateway_RespawnTime[new]=( s__RespawningGateway_RespawnTime[new] / s__RespawningGateway__get_RespawnTimeout(new) ) * s__RespawningGateway__get_RespawnTimeout(new)
		
		return new
 endfunction
 function s__RespawningGateway_CreateFromVectors takes integer wallUnitID,integer wallPosition,integer activationPosition,integer respawnTime returns integer
		return s__RespawningGateway_create(wallUnitID , s__vector2_x[wallPosition] , s__vector2_y[wallPosition] , s__vector2_x[activationPosition] , s__vector2_y[activationPosition] , respawnTime)
 endfunction
	
 function s__RespawningGateway_onInit takes nothing returns nothing
		set s__RespawningGateway_ActiveGateways=s__SimpleList_List_create()
		set s__RespawningGateway_ActiveGatewayTimer=CreateTimer()
 endfunction

//library RespawningGateway ends
//library SyncRequest:
	
		// private static trigger SyncTrigger
		
		
  function s__SyncRequest__get_Promise takes integer this returns integer
			return this
  endfunction
  function s__SyncRequest__get_Data takes integer this returns string
			return s__SyncRequest_RequestData[this]
  endfunction
		
  function s__SyncRequest_OnSync takes nothing returns boolean
			//no way to look up event handle in callback, no way to get back to original context, no way to resolve original deferred, gg
			//also current deferred API only supports ints, strings are a whole new ballgame
			
			//Idea: encode a "sync data request" ID at the start of every request's result
			//then decode the ID portion of the result and use ID to retrieve the original Deferred (returned at the start of the request) and resolve it
			//resolve with the same ID/object, which can then be used to retrieve the data via API (which resolves via a dictionary or some shit)
   local string rawData= BlzGetTriggerSyncData()
   local integer curDataPosition= 0
   local integer request= 0
			
			// call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "raw data: " + rawData)
			
			loop
			exitwhen curDataPosition + 1 >= StringLength(rawData) or request != 0
				if SubString(rawData, curDataPosition, curDataPosition + 1) == SyncRequest___DATA_DELIMITER then
					set request=S2I(SubString(rawData, 0, curDataPosition))
				endif
			set curDataPosition=curDataPosition + 1
			endloop
			
			set s__SyncRequest_RequestData[request]=SubString(rawData, curDataPosition, StringLength(rawData))
			
			// call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "sync request: " + I2S(request) + ", data: " + request.RequestData)
			
			call s__Deferred_Resolve((request),request)
			
			return false
  endfunction
  function s__SyncRequest_Sync takes integer this,string data returns nothing
			call BlzSendSyncData("SyncRequest___" + SyncRequest___EVENT_PREFIX, I2S(this) + SyncRequest___DATA_DELIMITER + data)
  endfunction
		
  function s__SyncRequest_create takes integer success,integer callbackData returns integer
   local integer new= s__Deferred_create()
			call s__Deferred_Then(new,success , 0 , callbackData)
			
			return new
  endfunction
  function s__SyncRequest_destroy takes integer this returns nothing
			set s__SyncRequest_RequestData[this]=null
			call s__Deferred_destroy((this))
  endfunction
		
  function s__SyncRequest_onInit takes nothing returns nothing
   local integer playerIndex= 0
   local trigger syncTrigger= CreateTrigger()
			
			call TriggerAddCondition(syncTrigger, Condition(function s__SyncRequest_OnSync))
			
			//listen for sync calls from all players, ye symbols all equals before o holy compiler
			loop

					call BlzTriggerRegisterPlayerSyncEvent(syncTrigger, Player(playerIndex), "SyncRequest___" + SyncRequest___EVENT_PREFIX, false)



			set playerIndex=playerIndex + 1
			exitwhen playerIndex == bj_MAX_PLAYER_SLOTS
			endloop
  endfunction

//library SyncRequest ends
//library VisualVote:
        
        
        
        
        function s__VisualVote_voteInfo_destroy takes integer this returns nothing
            call RemoveUnit(s__VisualVote_voteInfo_playerVoteUnit[this])
            set s__VisualVote_voteInfo_playerVoteUnit[this]=null
        endfunction
        
//Implemented from module Alloc:
		
		

			

		
		
  function s__VisualVote_voteInfo_allocate takes nothing returns integer
   local integer this= s__VisualVote_voteInfo_Alloc___recycler[0]
			


			
			if ( s__VisualVote_voteInfo_Alloc___recycler[this] == 0 ) then
				set s__VisualVote_voteInfo_Alloc___recycler[0]=this + 1
			else
				set s__VisualVote_voteInfo_Alloc___recycler[0]=s__VisualVote_voteInfo_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__VisualVote_voteInfo_deallocate takes integer this returns nothing


			


			
			set s__VisualVote_voteInfo_Alloc___recycler[this]=s__VisualVote_voteInfo_Alloc___recycler[0]
			set s__VisualVote_voteInfo_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__VisualVote_voteInfo_Alloc___onInit takes nothing returns nothing
			set s__VisualVote_voteInfo_Alloc___recycler[0]=1
  endfunction
    
        
        
        
        //public UnitStack playerVoteUnits
        
        
//Implemented from module Alloc:
		
		

			

		
		
  function s__VisualVote_voteOption_allocate takes nothing returns integer
   local integer this= s__VisualVote_voteOption_Alloc___recycler[0]
			


			
			if ( s__VisualVote_voteOption_Alloc___recycler[this] == 0 ) then
				set s__VisualVote_voteOption_Alloc___recycler[0]=this + 1
			else
				set s__VisualVote_voteOption_Alloc___recycler[0]=s__VisualVote_voteOption_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__VisualVote_voteOption_deallocate takes integer this returns nothing


			


			
			set s__VisualVote_voteOption_Alloc___recycler[this]=s__VisualVote_voteOption_Alloc___recycler[0]
			set s__VisualVote_voteOption_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__VisualVote_voteOption_Alloc___onInit takes nothing returns nothing
			set s__VisualVote_voteOption_Alloc___recycler[0]=1
  endfunction
        
        function s__VisualVote_voteOption_setColorDisabled takes texttag tt returns nothing
            call SetTextTagColor(tt, 128, 128, 128, 50)
        endfunction
        
        function s__VisualVote_voteOption_didPlayerVoteYes takes integer this,integer pID returns boolean
            return (HaveSavedInteger(Table___ht, (s__VisualVote_voteOption_playerVotes[this]), (pID))) // INLINED!!
        endfunction
        
        function s__VisualVote_voteOption_removePlayerVote takes integer this,integer pID returns nothing
            local integer cur= s__SimpleList_List_first[s__VisualVote_voteOption_playerVotesKeys[this]]
            local integer siFound
            
            local integer info
            
            //call playerVotesKeys.print(pID)
            
            //call DisplayTextToPlayer(Player(pID), 0, 0, "Searching for player: " + I2S(pID))
            
            //iterate till we find our player
            loop
            exitwhen cur == 0 or s__SimpleList_ListNode_value[cur] == pID
                //call DisplayTextToPlayer(Player(pID), 0, 0, "cur: " + I2S(cur.value))
            set cur=s__SimpleList_ListNode_next[cur]
            endloop
            
            if cur > 0 then
                //call DisplayTextToPlayer(Player(pID), 0, 0, "Found: " + I2S(cur.value))
                
                //iterate the remaining items in the stack, shifting the matching unit up 1 space
                set cur=s__SimpleList_ListNode_next[cur]
                
                loop
                exitwhen cur == 0
                    set info=(LoadInteger(Table___ht, (s__VisualVote_voteOption_playerVotes[this]), (s__SimpleList_ListNode_value[cur]))) // INLINED!!
                    //call DisplayTextToPlayer(Player(0), 0, 0, "Shifting player: " + I2S(cur.value))
                    //call DisplayTextToPlayer(Player(0), 0, 0, "From: " + R2S(GetUnitX(info.playerVoteUnit)) + ", to: " + R2S(GetUnitX(info.playerVoteUnit) - PLAYER_VOTE_UNIT_OFFSET))
                    call SetUnitPosition(s__VisualVote_voteInfo_playerVoteUnit[info], GetUnitX(s__VisualVote_voteInfo_playerVoteUnit[info]) - VisualVote_PLAYER_VOTE_UNIT_OFFSET, GetUnitY(s__VisualVote_voteInfo_playerVoteUnit[info]))
                set cur=s__SimpleList_ListNode_next[cur]
                endloop
                
                //remove the player from the stack, stack shifts automatically
                call s__SimpleList_List_remove(s__VisualVote_voteOption_playerVotesKeys[this],pID)
                
                //finally deallocate the info object, and all child properties
                set info=(LoadInteger(Table___ht, (s__VisualVote_voteOption_playerVotes[this]), (pID))) // INLINED!!
                
                call RemoveUnit(s__VisualVote_voteInfo_playerVoteUnit[info])
                set s__VisualVote_voteInfo_playerVoteUnit[info]=null
                
                call s__VisualVote_voteInfo_destroy(info)
                call RemoveSavedInteger(Table___ht, (s__VisualVote_voteOption_playerVotes[this]), (pID)) // INLINED!!
                
                //call DisplayTextToPlayer(Player(pID), 0, 0, "Finished removing player vote")
            endif
        endfunction
        
        function s__VisualVote_voteOption_addPlayerVote takes integer this,integer pID returns nothing
            local integer info= s__VisualVote_voteInfo_allocate()
            
            //select this option
            //need to push player ID + 1 so it doesn't conflict with stack returning 0 to mark the end of a stack (otherwise player 1 is seen as end of stack)
            //call playerVotesKeys.push(pID + 1)
            call s__SimpleList_List_addEnd(s__VisualVote_voteOption_playerVotesKeys[this],pID)
            
            //put vote into Table
            set s__VisualVote_voteInfo_playerVoteUnit[info]=CreateUnit(Player(pID), VisualVote_PLAYER_VOTE_UNIT_ID, GetUnitX(s__VisualVote_voteOption_voteUnit[this]) + s__SimpleList_List_count[s__VisualVote_voteOption_playerVotesKeys[this]] * VisualVote_PLAYER_VOTE_UNIT_OFFSET, GetUnitY(s__VisualVote_voteOption_voteUnit[this]), 0)
            call AddUnitLocust(s__VisualVote_voteInfo_playerVoteUnit[info])
            
            call SaveInteger(Table___ht, (s__VisualVote_voteOption_playerVotes[this]), (pID), ( info)) // INLINED!!
        endfunction
        
        //providing the function here guarantees that the option is only the default for its parent, and that there is only 1 default at a time
        function s__VisualVote_voteOption_setDefault takes integer this returns nothing
            set s__VisualVote_voteContainer_defaultOption[s__VisualVote_voteOption_parent[this]]=this
        endfunction
        
        function s__VisualVote_voteOption_onSelect takes integer this,player p returns nothing
            
            local integer pID= GetPlayerId(p)
            
            if s__VisualVote_voteOption_enabled[this] then
                if s__VisualVote_voteContainer_multipick[s__VisualVote_voteOption_parent[this]] then
                    //allow de-selection for multipicks
                    if (HaveSavedInteger(Table___ht, (s__VisualVote_voteOption_playerVotes[(this)]), ((pID)))) then // INLINED!!
                        call s__VisualVote_voteOption_removePlayerVote(this,pID)
                    else
                        call s__VisualVote_voteOption_addPlayerVote(this,pID)
                    endif
                else
                    //only one vote selection allowed for this category
                    //check that this player hasn't already voted for this option
                    if (HaveSavedInteger(Table___ht, (s__VisualVote_voteOption_playerVotes[(this)]), ((pID)))) then // INLINED!!
                        if s__VisualVote_voteContainer_allowDeselect[s__VisualVote_voteOption_parent[this]] then
                            call s__VisualVote_voteOption_removePlayerVote(this,pID)
                        else
                            call DisplayTextToPlayer(p, 0, 0, "Already voted yes!")
                        endif
                        return
                    endif
                    
                    //call DisplayTextToPlayer(p, 0, 0, "Clearing")
                    //check the other options and remove the player's vote from any they've voted on
                    call sc__VisualVote_voteContainer_clearVoteOptionsForPlayer(s__VisualVote_voteOption_parent[this],pID)
                    //call DisplayTextToPlayer(p, 0, 0, "Cleared")
                    
                    //call DisplayTextToPlayer(p, 0, 0, "Adding")
                    //select this option
                    call s__VisualVote_voteOption_addPlayerVote(this,pID)
                    //call DisplayTextToPlayer(p, 0, 0, "Added")
                    
                    //call playerVotesKeys.print(pID)
                endif
                
                //TODO check if all players have finished voting
                //1st parent: container
                //2nd parent: column
                //3rd parent: menu
                //call .parent.parent.parent.checkAndApplyPlayersFinishedVoting()
                
                if sc__VisualVote_voteMenu_checkPlayersFinishedVoting(s__VisualVote_voteColumn_parent[s__VisualVote_voteContainer_parent[s__VisualVote_voteOption_parent[this]]]) then
                    call sc__VisualVote_voteMenu_applyPlayerVote(s__VisualVote_voteColumn_parent[s__VisualVote_voteContainer_parent[s__VisualVote_voteOption_parent[this]]])
                endif
            else
                call DisplayTextToPlayer(p, 0, 0, s__VisualVote_voteContainer_text[s__VisualVote_voteOption_parent[this]] + ": " + s__VisualVote_voteOption_text[this] + " is not available yet, check back soon!")
            endif
        endfunction
        
        function s__VisualVote_voteOption_render takes integer this,real x,real y returns real
            set s__VisualVote_voteOption_gameText[this]=CreateTextTag()
            
            if s__VisualVote_voteOption_voteUnit[this] == null then
                
                if s__VisualVote_voteOption_enabled[this] then
                    set s__VisualVote_voteOption_voteUnit[this]=CreateUnit(Player(VisualVote_VOTE_PLAYER_ID), VisualVote_VOTE_UNIT_ID, x + VisualVote_VOTE_UNIT_OFFSET, y, 0)
                else
                    set s__VisualVote_voteOption_voteUnit[this]=CreateUnit(Player(VisualVote_DISABLED_PLAYER_ID), VisualVote_VOTE_UNIT_ID, x + VisualVote_VOTE_UNIT_OFFSET, y, 0)
                endif
            endif
            
            call SetTextTagText(s__VisualVote_voteOption_gameText[this], s__VisualVote_voteOption_text[this], TextTagSize2Height(VisualVote_TEXT_OPTION_SIZE))
            call SetTextTagPermanent(s__VisualVote_voteOption_gameText[this], true)
            call SetTextTagPos(s__VisualVote_voteOption_gameText[this], x, y, VisualVote_TEXT_OFFSET_HEIGHT)
            
            //call DisplayTextToPlayer(Player(0), 0, 0, "Rendering option text: " + .text)
            
            if s__VisualVote_voteOption_enabled[this] then
                
            else
                call SetTextTagColor((s__VisualVote_voteOption_gameText[this]), 128, 128, 128, 50) // INLINED!!
            endif
            
            //call DisplayTextToPlayer(Player(0), 0, 0, "Finished rendering option text")
            
            call SetTextTagVisibility(s__VisualVote_voteOption_gameText[this], true)
            
            return y - VisualVote_TEXT_OPTION_SIZE * VisualVote_TEXT_HEIGHT
                        
            //display the container header
//            set .gameText = CreateTextTag()
//            
//            call SetTextTagText(.gameText, .text, TextTagSize2Height(TEXT_HEADER2_SIZE))
//            call SetTextTagPermanent(.gameText, true)
//            call SetTextTagPos(.gameText, x, y, TEXT_OFFSET_HEIGHT)
//            
//            call SetTextTagVisibility(.gameText, true)
//            
//            return y - TEXT_HEADER2_SIZE * TEXT_HEIGHT
        endfunction
              
        function s__VisualVote_voteOption_destroy takes integer this returns nothing
            local integer iP= 0
            local integer cur= s__SimpleList_List_first[s__VisualVote_voteOption_playerVotesKeys[this]]
            
            loop
            exitwhen cur == 0
                call s__VisualVote_voteInfo_destroy(((LoadInteger(Table___ht, (s__VisualVote_voteOption_playerVotes[this]), (s__SimpleList_ListNode_value[cur]))))) // INLINED!!
            set cur=s__SimpleList_ListNode_next[cur]
            endloop
            
            
            call s__Table_destroy(s__VisualVote_voteOption_playerVotes[this])
            call s__SimpleList_List_destroy(s__VisualVote_voteOption_playerVotesKeys[this])
            
            call DestroyTextTag(s__VisualVote_voteOption_gameText[this])
            set s__VisualVote_voteOption_gameText[this]=null
            
            call RemoveUnit(s__VisualVote_voteOption_voteUnit[this])
            set s__VisualVote_voteOption_voteUnit[this]=null
            
//            loop
//            exitwhen iP >= NUMBER_PLAYERS
//                if playerVoteUnits[iP] != null then
//                    call RemoveUnit(playerVoteUnits[iP])
//                    set playerVoteUnits[iP] = null
//                endif
//            set iP = iP + 1
//            endloop
        endfunction
        
        function s__VisualVote_voteOption_create takes string text,string callback returns integer
            local integer new= s__VisualVote_voteOption_allocate()
            
            set s__VisualVote_voteOption_playerVotes[new]=s__Table_create()
            set s__VisualVote_voteOption_playerVotesKeys[new]=s__SimpleList_List_create()
            
            set s__VisualVote_voteOption_enabled[new]=true
            
            set s__VisualVote_voteOption_text[new]=text
            set s__VisualVote_voteOption_onVoteWinCallback[new]=callback
            
            return new
        endfunction
    
        
        
        
        
        //private static trigger theExecutioner
        
        
//Implemented from module Alloc:
		
		

			

		
		
  function s__VisualVote_voteContainer_allocate takes nothing returns integer
   local integer this= s__VisualVote_voteContainer_Alloc___recycler[0]
			


			
			if ( s__VisualVote_voteContainer_Alloc___recycler[this] == 0 ) then
				set s__VisualVote_voteContainer_Alloc___recycler[0]=this + 1
			else
				set s__VisualVote_voteContainer_Alloc___recycler[0]=s__VisualVote_voteContainer_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__VisualVote_voteContainer_deallocate takes integer this returns nothing


			


			
			set s__VisualVote_voteContainer_Alloc___recycler[this]=s__VisualVote_voteContainer_Alloc___recycler[0]
			set s__VisualVote_voteContainer_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__VisualVote_voteContainer_Alloc___onInit takes nothing returns nothing
			set s__VisualVote_voteContainer_Alloc___recycler[0]=1
  endfunction
        
        function s__VisualVote_voteContainer_render takes integer this,real x,real y returns real
            local integer iVO= 0
            local integer vo
            
            local real curY= y
            
            //display the container header
            set s__VisualVote_voteContainer_gameText[this]=CreateTextTag()
            
            call SetTextTagText(s__VisualVote_voteContainer_gameText[this], s__VisualVote_voteContainer_text[this], TextTagSize2Height(VisualVote_TEXT_HEADER2_SIZE))
            call SetTextTagPermanent(s__VisualVote_voteContainer_gameText[this], true)
            call SetTextTagPos(s__VisualVote_voteContainer_gameText[this], x, curY, VisualVote_TEXT_OFFSET_HEIGHT)
            
            call SetTextTagVisibility(s__VisualVote_voteContainer_gameText[this], true)
            
            set curY=curY - VisualVote_TEXT_HEADER2_SIZE * VisualVote_TEXT_HEIGHT
            
            //call DisplayTextToForce(bj_FORCE_PLAYER[0], "rendered container header")
            loop
            exitwhen iVO >= s__VisualVote_voteContainer_optionCount[this]
                set vo=(LoadInteger(Table___ht, (s__VisualVote_voteContainer_options[this]), (iVO))) // INLINED!!
                
                //call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,60000,Fields.lastError)
                //call DisplayTextToForce(bj_FORCE_PLAYER[0], "rendering option: " + I2S(iVO))
                //call DisplayTextToForce(bj_FORCE_PLAYER[0], "x: " + R2S(x) + ", y: " + R2S(curY))
                
                set curY=s__VisualVote_voteOption_render(vo,x , curY)
            set iVO=iVO + 1
            endloop
            
            return curY
        endfunction
        
        function s__VisualVote_voteContainer_clearVoteOptionsForPlayer takes integer this,integer pID returns nothing
            local integer iVO= 0
            local integer vo
            
            loop
            exitwhen iVO >= s__VisualVote_voteContainer_optionCount[this]
                set vo=(LoadInteger(Table___ht, (s__VisualVote_voteContainer_options[this]), (iVO))) // INLINED!!
                                    
                if (HaveSavedInteger(Table___ht, (s__VisualVote_voteOption_playerVotes[(vo)]), ((pID)))) then // INLINED!!
                    //call DisplayTextToPlayer(Player(pID), 0, 0, "Removing: " + vo.text)
                    
                    call s__VisualVote_voteOption_removePlayerVote(vo,pID)
                    
                    //can only vote on one thing at a time
                    return
                endif
            set iVO=iVO + 1
            endloop
        endfunction
        
        function s__VisualVote_voteContainer_getVoteOptionFromSelectedUnit takes integer this,unit selectedUnit returns integer
            local integer iVO= 0
            local integer vo
            
            loop
            exitwhen iVO >= s__VisualVote_voteContainer_optionCount[this]
                set vo=(LoadInteger(Table___ht, (s__VisualVote_voteContainer_options[this]), (iVO))) // INLINED!!
                                    
                if s__VisualVote_voteOption_voteUnit[vo] == selectedUnit then
                    return vo
                endif
            set iVO=iVO + 1
            endloop
            
            return 0
        endfunction
                
        function s__VisualVote_voteContainer_addOption takes integer this,string text,string callback returns integer
            local integer option= s__VisualVote_voteOption_create(text , callback)
            set s__VisualVote_voteOption_parent[option]=this
            set s__VisualVote_voteOption_enabled[option]=s__VisualVote_voteContainer_enabled[this]
            
            call SaveInteger(Table___ht, (s__VisualVote_voteContainer_options[this]), (s__VisualVote_voteContainer_optionCount[this]), ( option)) // INLINED!!
            set s__VisualVote_voteContainer_optionCount[this]=s__VisualVote_voteContainer_optionCount[this] + 1
            
            return option
        endfunction
        
        function s__VisualVote_voteContainer_getMajorityOption takes integer this returns integer
            local integer iVO= 0
            local integer leaders= s__Table_create()
            local integer leaderOptionCount= 0
            local integer leaderVoteCount= 0
            local integer vo
            
            //get the set of options with the most votes
            loop
            exitwhen iVO >= s__VisualVote_voteContainer_optionCount[this]
                set vo=(LoadInteger(Table___ht, (s__VisualVote_voteContainer_options[this]), (iVO))) // INLINED!!
                
                //call DisplayTextToPlayer(Player(0), 0, 0, "current leader: " + I2S(leaderVoteCount) + ", current option: " + I2S(vo.playerVotesKeys.count))
                //set tally = tally + vo.playerVotes.count
                if s__SimpleList_List_count[s__VisualVote_voteOption_playerVotesKeys[vo]] > leaderVoteCount then
                    //clear any existing leaders and update the counts
                    call FlushChildHashtable(Table___ht, (leaders)) // INLINED!!
                    
                    set leaderVoteCount=s__SimpleList_List_count[s__VisualVote_voteOption_playerVotesKeys[vo]]
                    call SaveInteger(Table___ht, (leaders), (0), ( vo)) // INLINED!!
                    set leaderOptionCount=1
                elseif s__SimpleList_List_count[s__VisualVote_voteOption_playerVotesKeys[vo]] == leaderVoteCount then
                    //call DisplayTextToPlayer(Player(0), 0, 0, "current leader count: " + I2S(leaderOptionCount))
                    call SaveInteger(Table___ht, (leaders), (leaderOptionCount), ( vo)) // INLINED!!
                    set leaderOptionCount=leaderOptionCount + 1
                    //call DisplayTextToPlayer(Player(0), 0, 0, "new leader count: " + I2S(leaderOptionCount))
                endif
            set iVO=iVO + 1
            endloop
            
            //either take the leader or, in the case of a tie, make a random roll selection from all leaders
            if leaderOptionCount == 1 then
                return ((LoadInteger(Table___ht, (leaders), (0)))) // INLINED!!
            elseif leaderOptionCount > 1 then
                //check if the default option is among the leaders and pick it if it is, otherwise take a random choice among the leaders
                if s__VisualVote_voteContainer_defaultOption[this] != 0 then
                    set iVO=0
                    loop
                    exitwhen iVO >= leaderOptionCount
                        if s__VisualVote_voteContainer_defaultOption[this] == (LoadInteger(Table___ht, (leaders), (iVO))) then // INLINED!!
                            return s__VisualVote_voteContainer_defaultOption[this]
                        endif
                    set iVO=iVO + 1
                    endloop
                endif
                
                //default option not present or not defined, pick a random option from among the leaders
                //reuse iVO
                return ((LoadInteger(Table___ht, (leaders), (GetRandomInt(0, leaderOptionCount - 1))))) // INLINED!!
            else
                //not sure what this case is, no one votes should be a tie for 0 votes, but just in case either return the default option if defined or a random option if not
                if s__VisualVote_voteContainer_defaultOption[this] != 0 then
                    return s__VisualVote_voteContainer_defaultOption[this]
                else
                    return ((LoadInteger(Table___ht, (s__VisualVote_voteContainer_options[this]), (GetRandomInt(0, s__VisualVote_voteContainer_optionCount[this] - 1))))) // INLINED!!
                endif
            endif
            
            call s__Table_destroy(leaders)
            
            return 0
        endfunction
        function s__VisualVote_voteContainer_executeMajorityOption takes integer this returns nothing
            local integer majority
            
            if s__VisualVote_voteContainer_enabled[this] then
                set majority=s__VisualVote_voteContainer_getMajorityOption(this)
                
                if majority != 0 then
                    //execute vote option, on vote succeed function
                    //call TriggerAddAction(theExecutioner, majority.onVoteWinCallback)
                    //debug call DisplayTextToPlayer(Player(0), 0, 0, "Executing callback: " + majority.onVoteWinCallback)
                    if s__VisualVote_voteOption_onVoteWinCallback[majority] != null and s__VisualVote_voteOption_onVoteWinCallback[majority] != "" then
                        call ExecuteFunc(s__VisualVote_voteOption_onVoteWinCallback[majority])
                    endif
                endif
            endif
        endfunction
        
        function s__VisualVote_voteContainer_tallyNumberVotes takes integer this returns integer
            local integer iVO= 0
            local integer tally= 0
            local integer vo
            
            loop
            exitwhen iVO >= s__VisualVote_voteContainer_optionCount[this]
                set vo=(LoadInteger(Table___ht, (s__VisualVote_voteContainer_options[this]), (iVO))) // INLINED!!
                
                //set tally = tally + vo.playerVotes.count
                set tally=tally + s__SimpleList_List_count[s__VisualVote_voteOption_playerVotesKeys[vo]]
            set iVO=iVO + 1
            endloop
            
            return tally
        endfunction
        










        
        function s__VisualVote_voteContainer_destroy takes integer this returns nothing
            local integer iVO= 0
            local integer vo
            
            loop
            exitwhen iVO >= s__VisualVote_voteContainer_optionCount[this]
                set vo=(LoadInteger(Table___ht, (s__VisualVote_voteContainer_options[this]), (iVO))) // INLINED!!
                                    
                call s__VisualVote_voteOption_destroy(vo)
            set iVO=iVO + 1
            endloop
                        
            call s__Table_destroy(s__VisualVote_voteContainer_options[this])
            
            call DestroyTextTag(s__VisualVote_voteContainer_gameText[this])
            set s__VisualVote_voteContainer_gameText[this]=null
            
            call s__VisualVote_voteContainer_deallocate(this)
        endfunction
        
        function s__VisualVote_voteContainer_create takes string text returns integer
            local integer new= s__VisualVote_voteContainer_allocate()
            
            set s__VisualVote_voteContainer_options[new]=s__Table_create()
            set s__VisualVote_voteContainer_optionCount[new]=0
            set s__VisualVote_voteContainer_defaultOption[new]=0
            
            set s__VisualVote_voteContainer_enabled[new]=true
            set s__VisualVote_voteContainer_multipick[new]=false
            set s__VisualVote_voteContainer_allowDeselect[new]=false
            set s__VisualVote_voteContainer_required[new]=true
            
            set s__VisualVote_voteContainer_text[new]=text
            
            return new
        endfunction
    
//        public static method onInit takes nothing returns nothing
//            set voteContainer.theExecutioner = CreateTrigger()
//        endmethod
    
        
        
//Implemented from module Alloc:
		
		

			

		
		
  function s__VisualVote_voteColumn_allocate takes nothing returns integer
   local integer this= s__VisualVote_voteColumn_Alloc___recycler[0]
			


			
			if ( s__VisualVote_voteColumn_Alloc___recycler[this] == 0 ) then
				set s__VisualVote_voteColumn_Alloc___recycler[0]=this + 1
			else
				set s__VisualVote_voteColumn_Alloc___recycler[0]=s__VisualVote_voteColumn_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__VisualVote_voteColumn_deallocate takes integer this returns nothing


			


			
			set s__VisualVote_voteColumn_Alloc___recycler[this]=s__VisualVote_voteColumn_Alloc___recycler[0]
			set s__VisualVote_voteColumn_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__VisualVote_voteColumn_Alloc___onInit takes nothing returns nothing
			set s__VisualVote_voteColumn_Alloc___recycler[0]=1
  endfunction
        
        function s__VisualVote_voteColumn_render takes integer this,integer topLeft returns integer
            local integer iVC= 0
            local integer vc
            
            set topLeft=s__vector2_create(s__vector2_x[topLeft] , s__vector2_y[topLeft])
            set s__VisualVote_voteColumn_botRight[this]=s__vector2_create(s__vector2_x[topLeft] + s__VisualVote_voteColumn_columnWidth[this] , s__vector2_y[topLeft])
            
            loop
            exitwhen iVC >= s__VisualVote_voteColumn_voteContainerCount[this]
                set vc=(LoadInteger(Table___ht, (s__VisualVote_voteColumn_voteContainers[this]), (iVC))) // INLINED!!
                
                //call DisplayTextToForce(bj_FORCE_PLAYER[0], "rendering container: " + I2S(iVC))
                set s__vector2_y[s__VisualVote_voteColumn_botRight[this]]=s__VisualVote_voteContainer_render(vc,s__vector2_x[topLeft] , s__vector2_y[s__VisualVote_voteColumn_botRight[this]]) - VisualVote_COLUMN_MARGIN_BOTTOM
            set iVC=iVC + 1
            endloop
            
            return s__VisualVote_voteColumn_botRight[this]
        endfunction
        
        //TODO implement
        //ideally this would happen during render, but that would mean storing the border type, and i don't think that's necessary
        function s__VisualVote_voteColumn_setBorder takes integer this,integer borderType returns nothing
        
        endfunction
        
        function s__VisualVote_voteColumn_havePlayersFinishedVoting takes integer this,integer playerCount returns boolean
            local integer iVC= 0
            local integer vc
            
            //check that all voting categories have had all players vote
            loop
            exitwhen iVC >= s__VisualVote_voteColumn_voteContainerCount[this]
                set vc=(LoadInteger(Table___ht, (s__VisualVote_voteColumn_voteContainers[this]), (iVC))) // INLINED!!
                
                if s__VisualVote_voteContainer_required[vc] and s__VisualVote_voteContainer_tallyNumberVotes(vc) != playerCount then
                    return false
                endif
            set iVC=iVC + 1
            endloop
            
            return true
        endfunction
        
        function s__VisualVote_voteColumn_getVoteOptionFromSelectedUnit takes integer this,unit selectedUnit returns integer
            local integer iVC= 0
            local integer vc
            local integer vo
            
            loop
            exitwhen iVC >= s__VisualVote_voteColumn_voteContainerCount[this]
                set vc=(LoadInteger(Table___ht, (s__VisualVote_voteColumn_voteContainers[this]), (iVC))) // INLINED!!
                
                set vo=s__VisualVote_voteContainer_getVoteOptionFromSelectedUnit(vc,selectedUnit)
                if vo != 0 then
                    return vo
                endif
            set iVC=iVC + 1
            endloop
            
            return 0
        endfunction
        
        function s__VisualVote_voteColumn_addContainer takes integer this,string containerText returns integer
            local integer container= s__VisualVote_voteContainer_create(containerText)
            set s__VisualVote_voteContainer_parent[container]=this
            
            call SaveInteger(Table___ht, (s__VisualVote_voteColumn_voteContainers[this]), (s__VisualVote_voteColumn_voteContainerCount[this]), ( container)) // INLINED!!
            set s__VisualVote_voteColumn_voteContainerCount[this]=s__VisualVote_voteColumn_voteContainerCount[this] + 1
            
            return container
        endfunction
        














        
        function s__VisualVote_voteColumn_destroy takes integer this returns nothing
            local integer iVC= 0
            local integer vc
            
            loop
            exitwhen iVC >= s__VisualVote_voteColumn_voteContainerCount[this]
                set vc=(LoadInteger(Table___ht, (s__VisualVote_voteColumn_voteContainers[this]), (iVC))) // INLINED!!
                
                call s__VisualVote_voteContainer_destroy(vc)
            set iVC=iVC + 1
            endloop
            
            call s__Table_destroy(s__VisualVote_voteColumn_voteContainers[this])
            //call .topLeft.destroy()
            call s__vector2_deallocate((s__VisualVote_voteColumn_botRight[this])) // INLINED!!
            
            call s__VisualVote_voteColumn_deallocate(this)
        endfunction
        
        function s__VisualVote_voteColumn_create takes real width returns integer
            local integer new= s__VisualVote_voteColumn_allocate()
            
            set s__VisualVote_voteColumn_voteContainers[new]=s__Table_create()
            set s__VisualVote_voteColumn_voteContainerCount[new]=0
            
            set s__VisualVote_voteColumn_columnWidth[new]=width
            
            return new
        endfunction
    
        
        
        
        
        
                
        //implement Alloc
//Implemented from module List:
    
    
    
    function s__VisualVote_voteMenu__get_first takes nothing returns integer
        return s__VisualVote_voteMenu_next[(0)]
    endfunction
    
    function s__VisualVote_voteMenu__get_last takes nothing returns integer
        return s__VisualVote_voteMenu_prev[(0)]
    endfunction
        
    function s__VisualVote_voteMenu_listRemove takes integer this returns nothing
        if not s__VisualVote_voteMenu_List__inlist[this] then
            return
        endif
        set s__VisualVote_voteMenu_List__inlist[this]=false
        set s__VisualVote_voteMenu_next[s__VisualVote_voteMenu_prev[this]]=s__VisualVote_voteMenu_next[this]
        set s__VisualVote_voteMenu_prev[s__VisualVote_voteMenu_next[this]]=s__VisualVote_voteMenu_prev[this]
        set s__VisualVote_voteMenu_count=s__VisualVote_voteMenu_count - 1
    endfunction

    function s__VisualVote_voteMenu_listAdd takes integer this returns nothing
        if s__VisualVote_voteMenu_List__inlist[this] or s__VisualVote_voteMenu_List__destroying or this == 0 then
            return
        endif
        set s__VisualVote_voteMenu_List__inlist[this]=true
        set s__VisualVote_voteMenu_next[(s__VisualVote_voteMenu_prev[(0)])]=this // INLINED!!
        set s__VisualVote_voteMenu_prev[this]=(s__VisualVote_voteMenu_prev[(0)]) // INLINED!!
        set s__VisualVote_voteMenu_prev[(0)]=this
        set s__VisualVote_voteMenu_next[this]=(0)
        set s__VisualVote_voteMenu_count=s__VisualVote_voteMenu_count + 1
    endfunction
    
    function s__VisualVote_voteMenu_listDestroy takes nothing returns nothing
        local integer this= (s__VisualVote_voteMenu_prev[(0)]) // INLINED!!
            set s__VisualVote_voteMenu_List__destroying=true
            loop
                exitwhen this == 0
                call sc__VisualVote_voteMenu_destroy(this)
                set this=s__VisualVote_voteMenu_prev[this]
            endloop
            set s__VisualVote_voteMenu_List__destroying=false
    endfunction
    
        
        function s__VisualVote_voteMenu_render takes integer this returns nothing
            local integer iVC= 0
            local integer vc
            
            local real curX= s__vector2_x[s__VisualVote_voteMenu_topLeft[this]]
            local integer colBotRight
            
            if not s__VisualVote_voteMenu_rendered[this] then
                set s__VisualVote_voteMenu_rendered[this]=true
                
                loop
                exitwhen iVC >= s__VisualVote_voteMenu_voteColumnCount[this]
                    set vc=(LoadInteger(Table___ht, (s__VisualVote_voteMenu_voteColumns[this]), (iVC))) // INLINED!!
                    
                    //render from the top left of the full menu, offset for whatever column we're on
                    //set botRight to the bottom right of the column we just rendered
                    set colBotRight=s__VisualVote_voteColumn_render(vc,s__vector2_create(curX , s__vector2_y[s__VisualVote_voteMenu_topLeft[this]]))
                    
                    //update the full vote menu's bottom to be the column we just made, if it's bigger than any before (columns always gain negative y as they increase in size)
                    if RAbsBJ(s__vector2_y[colBotRight]) < RAbsBJ(s__vector2_y[s__VisualVote_voteMenu_botRight[this]]) then
                        set s__vector2_y[s__VisualVote_voteMenu_botRight[this]]=s__vector2_y[colBotRight]
                    endif
                    
                    //i don't think i destroy colBotRight here, because it should be a pointer to the columns actual botRight property
                    
                    //update top left X for constant column width
                    set curX=curX + s__VisualVote_voteColumn_columnWidth[vc] + VisualVote_COLUMN_MARGIN_RIGHT
                set iVC=iVC + 1
                endloop
                
                //the last column rendered will always be the furthest right
                set s__vector2_x[s__VisualVote_voteMenu_botRight[this]]=s__vector2_x[colBotRight]
                
                //menu should be usable after rendering (by default)
                set s__VisualVote_voteMenu_enabled[this]=true
            endif
        endfunction
        
        function s__VisualVote_voteMenu_onTimerExpire takes nothing returns nothing
            local timer t= GetExpiredTimer()
            local integer menu= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
            
            //this automatically destroys the menu (and all components) after a bit
            call sc__VisualVote_voteMenu_applyPlayerVote(menu)
            
            call ReleaseTimer(t)
            set t=null
        endfunction
        
        function s__VisualVote_voteMenu_enforceVoteMode takes integer this returns nothing
            local integer fp
            local timer t
            
            if s__VisualVote_voteMenu_rendered[this] then
                set fp=s__SimpleList_List_first[s__VisualVote_voteMenu_forPlayers[this]]
                
                //call DisplayTextToForce(bj_FORCE_PLAYER[0], "enforcing top left x: " + R2S(topLeft.x) + ", y: " + R2S(topLeft.y))
                //call DisplayTextToForce(bj_FORCE_PLAYER[0], "enforcing bot right x: " + R2S(botRight.x) + ", y: " + R2S(botRight.y))
                
                //create expiration timer
                set t=NewTimerEx(this)
                call TimerStart(t, s__VisualVote_voteMenu_initialTime[this], false, function s__VisualVote_voteMenu_onTimerExpire)
                
                set s__VisualVote_voteMenu_td[this]=CreateTimerDialog(t)
                call TimerDialogSetTitle(s__VisualVote_voteMenu_td[this], "Game Mode Selection:")
                
                loop
                exitwhen fp == 0
                    if GetLocalPlayer() == Player(s__SimpleList_ListNode_value[fp]) then
						//for some reason, this will only work properly for all effected players when applied only to each effected player locally. Otherwise, only the first player see's it
                        call FogModifierStart(CreateFogModifierRect(Player(s__SimpleList_ListNode_value[fp]), FOG_OF_WAR_VISIBLE, Rect(s__vector2_x[s__VisualVote_voteMenu_topLeft[this]], s__vector2_y[s__VisualVote_voteMenu_botRight[this]], s__vector2_x[s__VisualVote_voteMenu_botRight[this]], s__vector2_y[s__VisualVote_voteMenu_topLeft[this]]), false, true))
						
						//only show timer dialog for players it effects
                        call TimerDialogDisplay(s__VisualVote_voteMenu_td[this], true)
						
                        call SetCameraBounds(s__vector2_x[s__VisualVote_voteMenu_topLeft[this]], s__vector2_y[s__VisualVote_voteMenu_topLeft[this]], s__vector2_x[s__VisualVote_voteMenu_topLeft[this]], s__vector2_y[s__VisualVote_voteMenu_botRight[this]], s__vector2_x[s__VisualVote_voteMenu_botRight[this]], s__vector2_y[s__VisualVote_voteMenu_botRight[this]], s__vector2_x[s__VisualVote_voteMenu_botRight[this]], s__vector2_y[s__VisualVote_voteMenu_topLeft[this]])
                        call PanCameraToTimed(( s__vector2_x[s__VisualVote_voteMenu_topLeft[this]] + s__vector2_x[s__VisualVote_voteMenu_botRight[this]] ) / 2, ( s__vector2_y[s__VisualVote_voteMenu_topLeft[this]] + s__vector2_y[s__VisualVote_voteMenu_botRight[this]] ) / 2, 0.01)
                        
                        //pivot camera to top down view
                        //static if Library_Platformer then
                        call CameraSetupApply(s__Platformer_PlatformingCamera, false, false)
                        //endif
                    endif
                set fp=s__SimpleList_ListNode_next[fp]
                endloop
                
                set t=null
            endif
        endfunction
        
        function s__VisualVote_voteMenu_destroyMenuCallback takes nothing returns nothing
            local timer expired= GetExpiredTimer()
            local integer menuExpired= (LoadInteger(TimerUtils___ht, 0, GetHandleId((expired)))) // INLINED!!
            
            
            call sc__VisualVote_voteMenu_destroy(menuExpired)
            call ReleaseTimer(expired)
            set expired=null
            
        endfunction
        
        function s__VisualVote_voteMenu_applyPlayerVote takes integer this returns nothing
            local integer fp
            
            local integer iVC= 0
            local integer vc
            local integer iVCont
            local integer vCont
            
            if s__VisualVote_voteMenu_enabled[this] then
                //menu should be unusable after voting is finished
                set s__VisualVote_voteMenu_enabled[this]=false
                
                //unrestrict the camera view
                set fp=s__SimpleList_List_first[s__VisualVote_voteMenu_forPlayers[this]]
                loop
                exitwhen fp == 0
                    if GetLocalPlayer() == Player(s__SimpleList_ListNode_value[fp]) then
                        //call SetCameraBounds(GetCameraBoundMinX(), GetCameraBoundMinY(), GetCameraBoundMinX(), GetCameraBoundMaxY(), GetCameraBoundMaxX(), GetCameraBoundMaxY(), GetCameraBoundMaxX(), GetCameraBoundMinY())
                        call TimerDialogDisplay(s__VisualVote_voteMenu_td[this], false)
                        call SetCameraBoundsToRect(bj_mapInitialCameraBounds)
                    endif
                set fp=s__SimpleList_ListNode_next[fp]
                endloop
                
                //execute majority option for each container, regardless of if everyones voted or not
                set iVC=0
                loop
                exitwhen iVC >= s__VisualVote_voteMenu_voteColumnCount[this]
                    set vc=(LoadInteger(Table___ht, (s__VisualVote_voteMenu_voteColumns[this]), (iVC))) // INLINED!!
                    set iVCont=0
                    
                    loop
                    exitwhen iVCont > s__VisualVote_voteColumn_voteContainerCount[vc]
                        set vCont=(LoadInteger(Table___ht, (s__VisualVote_voteColumn_voteContainers[vc]), (iVCont))) // INLINED!!
                        
                        call s__VisualVote_voteContainer_executeMajorityOption(vCont)
                    set iVCont=iVCont + 1
                    endloop
                set iVC=iVC + 1
                endloop
                
                //callback for after options have been applied -- mostly useful for when logic requires all options to be decided first
                set VisualVote_LastFinishedMenu=this
				
				if s__VisualVote_voteMenu_onOptionExecuteFinish[this] != null then
					call ExecuteFunc(s__VisualVote_voteMenu_onOptionExecuteFinish[this])
                endif
				
                //create a timer to expire in a little bit to clean up the vote menu struct
                //don't do it right away in case any selection events are finishing up
                call TimerStart(NewTimerEx(this), VisualVote_MENU_DESTROY_TIMEOUT, false, function s__VisualVote_voteMenu_destroyMenuCallback)
            endif
        endfunction
        
        function s__VisualVote_voteMenu_checkPlayersFinishedVoting takes integer this returns boolean
            local integer iVC= 0
            
            if s__VisualVote_voteMenu_enabled[this] then
                //check that all voting categories have had all players vote
                loop
                exitwhen iVC >= s__VisualVote_voteMenu_voteColumnCount[this]
                    if not s__VisualVote_voteColumn_havePlayersFinishedVoting(((LoadInteger(Table___ht, (s__VisualVote_voteMenu_voteColumns[this]), (iVC)))),s__SimpleList_List_count[s__VisualVote_voteMenu_forPlayers[this]]) then // INLINED!!
                        return false
                    endif
                set iVC=iVC + 1
                endloop
                
                return true
            endif
            
            return false
        endfunction
        
        function s__VisualVote_voteMenu_addAllPlayersToMenu takes integer this returns nothing
            local integer fp= PlayerUtils_FirstPlayer
            
            call s__SimpleList_List_clear(s__VisualVote_voteMenu_forPlayers[this])
            
            loop
            exitwhen fp == 0
                call s__SimpleList_List_addEnd(s__VisualVote_voteMenu_forPlayers[this],s__SimpleList_ListNode_value[fp])
            set fp=s__SimpleList_ListNode_next[fp]
            endloop
        endfunction
        
        function s__VisualVote_voteMenu_getVoteOptionFromSelectedUnit takes integer this,unit selectedUnit returns integer
            local integer iVC= 0
            local integer vc
            local integer vo
            
            loop
            exitwhen iVC >= s__VisualVote_voteMenu_voteColumnCount[this]
                set vc=(LoadInteger(Table___ht, (s__VisualVote_voteMenu_voteColumns[this]), (iVC))) // INLINED!!
                
                set vo=s__VisualVote_voteColumn_getVoteOptionFromSelectedUnit(vc,selectedUnit)
                if vo != 0 then
                    return vo
                endif
            set iVC=iVC + 1
            endloop
            
            return 0
        endfunction
        function s__VisualVote_voteMenu_globalGetVoteOptionFromSelectedUnit takes unit selectedUnit returns integer
            local integer vm= (s__VisualVote_voteMenu_next[(0)]) // INLINED!!
            local integer vo
            
            loop
            exitwhen vm == 0
                if s__VisualVote_voteMenu_enabled[vm] then
                    set vo=s__VisualVote_voteMenu_getVoteOptionFromSelectedUnit(vm,selectedUnit)
                    if vo != 0 then
                        return vo
                    endif
                endif
            set vm=s__VisualVote_voteMenu_next[vm]
            endloop
            
            return 0
        endfunction
        
        function s__VisualVote_voteMenu_addColumn takes integer this,real columnWidth returns integer
            local integer column= s__VisualVote_voteColumn_create(columnWidth)
            set s__VisualVote_voteColumn_parent[column]=this
            
            call SaveInteger(Table___ht, (s__VisualVote_voteMenu_voteColumns[this]), (s__VisualVote_voteMenu_voteColumnCount[this]), ( column)) // INLINED!!
            set s__VisualVote_voteMenu_voteColumnCount[this]=s__VisualVote_voteMenu_voteColumnCount[this] + 1
            
            return column
        endfunction
        














		
  function s__VisualVote_voteMenu_filterVisualVoteSelection takes nothing returns boolean
			return GetUnitTypeId(GetFilterUnit()) == VisualVote_VOTE_UNIT_ID
  endfunction
  function s__VisualVote_voteMenu_onVisualVoteSelection takes nothing returns nothing
   local unit selected= GetTriggerUnit()
   local player p= GetTriggerPlayer()
			
   local integer vo= s__VisualVote_voteMenu_globalGetVoteOptionFromSelectedUnit(selected)
			
			//check that this player is a member of the menu
			if vo != 0 and s__SimpleList_List_contains(s__VisualVote_voteMenu_forPlayers[s__VisualVote_voteColumn_parent[s__VisualVote_voteContainer_parent[s__VisualVote_voteOption_parent[vo]]]],GetPlayerId(p)) then
				//debug call DisplayTextToPlayer(p, 0, 0, "Selection Found")
				call s__VisualVote_voteOption_onSelect(vo,p)
			else
			endif
  endfunction
        
        function s__VisualVote_voteMenu_destroy takes integer this returns nothing
            local integer iVC= 0
            local integer vc
            
            call s__VisualVote_voteMenu_listRemove(this)
            
            loop
            exitwhen iVC >= s__VisualVote_voteMenu_voteColumnCount[this]
                set vc=(LoadInteger(Table___ht, (s__VisualVote_voteMenu_voteColumns[this]), (iVC))) // INLINED!!
                
                call s__VisualVote_voteColumn_destroy(vc)
            set iVC=iVC + 1
            endloop
            
            call DestroyTimerDialog(s__VisualVote_voteMenu_td[this])
            set s__VisualVote_voteMenu_td[this]=null
            
            call s__Table_destroy(s__VisualVote_voteMenu_voteColumns[this])
            call s__SimpleList_List_destroy(s__VisualVote_voteMenu_forPlayers[this])
            call s__vector2_deallocate((s__VisualVote_voteMenu_topLeft[this])) // INLINED!!
            call s__vector2_deallocate((s__VisualVote_voteMenu_botRight[this])) // INLINED!!
            
            call s__VisualVote_voteMenu_deallocate(this)
            
            if s__VisualVote_voteMenu_onDestroyFinish[this] != null then
                call ExecuteFunc(s__VisualVote_voteMenu_onDestroyFinish[this])
            endif
        endfunction
        
        function s__VisualVote_voteMenu_create takes real topLeftX,real topLeftY,real time,string onOptionFinishCallback returns integer
            local integer new= s__VisualVote_voteMenu__allocate()
            
            call s__VisualVote_voteMenu_listAdd(new)
            
            set s__VisualVote_voteMenu_voteColumns[new]=s__Table_create()
            set s__VisualVote_voteMenu_voteColumnCount[new]=0
            
            set s__VisualVote_voteMenu_forPlayers[new]=s__SimpleList_List_create()
            
            set s__VisualVote_voteMenu_onDestroyFinish[new]=null
            set s__VisualVote_voteMenu_rendered[new]=false
            set s__VisualVote_voteMenu_enabled[new]=true
            
            set s__VisualVote_voteMenu_topLeft[new]=s__vector2_create(topLeftX , topLeftY)
            set s__VisualVote_voteMenu_botRight[new]=s__vector2_create(topLeftX , topLeftY)
            set s__VisualVote_voteMenu_initialTime[new]=time
            set s__VisualVote_voteMenu_onOptionExecuteFinish[new]=onOptionFinishCallback
            
            return new
        endfunction
    
 function VisualVote_Init takes nothing returns nothing
        local trigger t= CreateTrigger()
        local integer pn= PlayerUtils_FirstPlayer
        
        loop
        exitwhen pn == 0
            if GetPlayerSlotState(Player(s__SimpleList_ListNode_value[pn])) == PLAYER_SLOT_STATE_PLAYING then
                call TriggerRegisterPlayerUnitEvent(t, Player(s__SimpleList_ListNode_value[pn]), EVENT_PLAYER_UNIT_SELECTED, Condition(function s__VisualVote_voteMenu_filterVisualVoteSelection))
            endif
        set pn=s__SimpleList_ListNode_next[pn]
		endloop
		
		call TriggerAddAction(t, function s__VisualVote_voteMenu_onVisualVoteSelection)
		set t=null
	endfunction
	
 function VisualVote_InitForPlayer takes integer i returns nothing
  local trigger t= CreateTrigger()
		
		call TriggerRegisterPlayerUnitEvent(t, Player(i), EVENT_PLAYER_UNIT_SELECTED, Condition(function s__VisualVote_voteMenu_filterVisualVoteSelection))
		call TriggerAddAction(t, function s__VisualVote_voteMenu_onVisualVoteSelection)
		
		set t=null
	endfunction

//library VisualVote ends
//library EDWPowerup:
    
        
        
//Implemented from module Alloc:
		
		

			

		
		
  function s__InWorldPowerup_allocate takes nothing returns integer
   local integer this= s__InWorldPowerup_Alloc___recycler[0]
			


			
			if ( s__InWorldPowerup_Alloc___recycler[this] == 0 ) then
				set s__InWorldPowerup_Alloc___recycler[0]=this + 1
			else
				set s__InWorldPowerup_Alloc___recycler[0]=s__InWorldPowerup_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__InWorldPowerup_deallocate takes integer this returns nothing


			


			
			set s__InWorldPowerup_Alloc___recycler[this]=s__InWorldPowerup_Alloc___recycler[0]
			set s__InWorldPowerup_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__InWorldPowerup_Alloc___onInit takes nothing returns nothing
			set s__InWorldPowerup_Alloc___recycler[0]=1
  endfunction
        
        function s__InWorldPowerup_SoloInvulnCB takes nothing returns nothing
            local timer t= GetExpiredTimer()
            local integer user= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
            
            set s__MobImmune[user]= false
            
            call ReleaseTimer(t)
            set t=null
        endfunction
        
        function s__InWorldPowerup_TeamInvulnCB takes nothing returns nothing
            local timer t= GetExpiredTimer()
            local integer team= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
            local integer cur= s__Teams_MazingTeam_FirstUser[team]
            
            loop
            exitwhen cur == 0
                set s__MobImmune[s__SimpleList_ListNode_value[cur]]= false
            set cur=s__SimpleList_ListNode_next[cur]
            endloop
            
            call ReleaseTimer(t)
            set t=null
        endfunction
        
        function s__InWorldPowerup_OnUserAcquire takes integer this,integer user returns nothing
            local integer cur
            local integer team
			
            if not s__SimpleList_List_contains(s__InWorldPowerup_TeamsUsed[this],s__User_Team[user]) then
                call s__SimpleList_List_add(s__InWorldPowerup_TeamsUsed[this],s__User_Team[user])
				
				call sc__Teams_MazingTeam_SetUnitLocalOpacityForTeam(s__User_Team[user],s__InWorldPowerup_Unit[this] , INACTIVE_UNIT_OPACITY)
            else
                return
            endif
            
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "User " + I2S(user) + " acquired powerup")
            
            if GetUnitTypeId(s__InWorldPowerup_Unit[this]) == POWERUP_SOLO_INVULN then
                call s__DummyCaster_castTarget(('A001'),Player(user) , 1 , OrderId("bloodlust") , s__User_ActiveUnit[user])
                
                set s__MobImmune[user]= true
                
                call TimerStart(NewTimerEx(user), EDWPowerup___SOLO_INVULN_TIME, false, function s__InWorldPowerup_SoloInvulnCB)
            elseif GetUnitTypeId(s__InWorldPowerup_Unit[this]) == POWERUP_TEAM_INVULN then
                call sc__Teams_MazingTeam_PrintMessage(s__User_Team[user],sc__User_GetStylizedPlayerName(user) + " picked up a team invulnerability powerup")
                
                set cur=s__Teams_MazingTeam_FirstUser[s__User_Team[user]]
                
                loop
                exitwhen cur == 0
                    call s__DummyCaster_castTarget(('A002'),Player(s__SimpleList_ListNode_value[cur]) , 1 , OrderId("bloodlust") , s__User_ActiveUnit[(s__SimpleList_ListNode_value[cur])])
                    
                    set s__MobImmune[s__SimpleList_ListNode_value[cur]]= true
                set cur=s__SimpleList_ListNode_next[cur]
                endloop
                
                call TimerStart(NewTimerEx(s__User_Team[user]), EDWPowerup___TEAM_INVULN_TIME, false, function s__InWorldPowerup_TeamInvulnCB)
            elseif GetUnitTypeId(s__InWorldPowerup_Unit[this]) == POWERUP_TEAM_ADDCONT then
                call AddContinueEffect(this , user)
				
				call sc__Teams_MazingTeam_ChangeContinueCount(s__User_Team[user],EDWPowerup___TEAM_ADDCONT_COUNT)
				call sc__Teams_MazingTeam_PrintMessage(s__User_Team[user],sc__User_GetStylizedPlayerName(user) + " gained your team " + I2S(EDWPowerup___TEAM_ADDCONT_COUNT) + " continues")
			elseif GetUnitTypeId(s__InWorldPowerup_Unit[this]) == POWERUP_TEAM_STEALCONT then
				set team=sc__Teams_MazingTeam_GetRandomTeam(s__User_Team[user])
				
				if team != 0 then
					call sc__Teams_MazingTeam_ChangeContinueCount(team,- EDWPowerup___TEAM_STEALCONT_COUNT)
					call sc__Teams_MazingTeam_PrintMessage(team,sc__User_GetStylizedPlayerName(user) + " stole " + I2S(EDWPowerup___TEAM_STEALCONT_COUNT) + " continue from your team!")
					
					call StealContinueEffect(this , user)
					call sc__Teams_MazingTeam_ChangeContinueCount(s__User_Team[user],EDWPowerup___TEAM_STEALCONT_COUNT)
					call sc__Teams_MazingTeam_PrintMessage(s__User_Team[user],sc__User_GetStylizedPlayerName(user) + " stole " + I2S(EDWPowerup___TEAM_STEALCONT_COUNT) + " continue from team " + s__Teams_MazingTeam_TeamName[team] + "!")
				else
					call AddContinueEffect(this , user)
					
					call sc__Teams_MazingTeam_ChangeContinueCount(s__User_Team[user],EDWPowerup___TEAM_ADDCONT_COUNT)
					call sc__Teams_MazingTeam_PrintMessage(s__User_Team[user],sc__User_GetStylizedPlayerName(user) + " gained your team " + I2S(EDWPowerup___TEAM_ADDCONT_COUNT) + " continues")
				endif
			elseif GetUnitTypeId(s__InWorldPowerup_Unit[this]) == POWERUP_TEAM_ADDSCORE then
				call AddScoreEffect(this , user)
				
				call sc__Teams_MazingTeam_ChangeScore(s__User_Team[user],EDWPowerup___TEAM_ADDSCORE_COUNT)
				call sc__Teams_MazingTeam_PrintMessage(s__User_Team[user],sc__User_GetStylizedPlayerName(user) + " gained your team " + I2S(EDWPowerup___TEAM_ADDSCORE_COUNT) + " points")
			elseif GetUnitTypeId(s__InWorldPowerup_Unit[this]) == POWERUP_TEAM_STEALSCORE then
				set team=sc__Teams_MazingTeam_GetRandomTeam(s__User_Team[user])
				
				if team != 0 then
					call sc__Teams_MazingTeam_ChangeScore(team,- EDWPowerup___TEAM_STEALSCORE_COUNT)
					call sc__Teams_MazingTeam_PrintMessage(team,sc__User_GetStylizedPlayerName(user) + " stole " + I2S(EDWPowerup___TEAM_STEALSCORE_COUNT) + " point from your team!")
					
					call StealScoreEffect(this , user)
					call sc__Teams_MazingTeam_ChangeScore(s__User_Team[user],EDWPowerup___TEAM_STEALSCORE_COUNT)
					call sc__Teams_MazingTeam_PrintMessage(s__User_Team[user],sc__User_GetStylizedPlayerName(user) + " stole " + I2S(EDWPowerup___TEAM_STEALSCORE_COUNT) + " point from team " + s__Teams_MazingTeam_TeamName[team] + "!")
				else
					call AddScoreEffect(this , user)
					
					call sc__Teams_MazingTeam_ChangeScore(s__User_Team[user],EDWPowerup___TEAM_ADDSCORE_COUNT)
					call sc__Teams_MazingTeam_PrintMessage(s__User_Team[user],sc__User_GetStylizedPlayerName(user) + " gained your team " + I2S(EDWPowerup___TEAM_ADDSCORE_COUNT) + " points")
				endif
            endif
            //call ExecuteFunc(.OnAcquireCB)
        endfunction
                
        function s__InWorldPowerup_IsPowerupUnit takes integer unitTypeID returns boolean
            return unitTypeID == POWERUP_SOLO_INVULN or unitTypeID == POWERUP_TEAM_INVULN or unitTypeID == POWERUP_TEAM_ADDCONT or unitTypeID == POWERUP_TEAM_STEALCONT or unitTypeID == POWERUP_TEAM_ADDSCORE or unitTypeID == POWERUP_TEAM_STEALSCORE
        endfunction

        function s__InWorldPowerup_GetFromUnit takes unit u returns integer
            return (LoadInteger(Table___ht, (s__InWorldPowerup_AllPowerups), (GetHandleId(u)))) // INLINED!!
        endfunction
        
        function s__InWorldPowerup_CreateRandom takes real x,real y returns integer
            local integer rand= GetRandomInt(0, 3)
            
            if rand == 0 then
				return sc__InWorldPowerup_create(POWERUP_TEAM_ADDCONT , x , y)
            elseif rand == 1 then
				return sc__InWorldPowerup_create(POWERUP_TEAM_STEALCONT , x , y)
            elseif rand == 2 then
				return sc__InWorldPowerup_create(POWERUP_TEAM_ADDSCORE , x , y)
            elseif rand == 3 then
				return sc__InWorldPowerup_create(POWERUP_TEAM_STEALSCORE , x , y)
            endif
            
            return 0
        endfunction
        
        function s__InWorldPowerup_create takes integer unitTypeID,real x,real y returns integer
            local integer new
			
			if s__InWorldPowerup_IsPowerupUnit(unitTypeID) then
				set new=s__InWorldPowerup_allocate()
				
				//defaults
				set s__InWorldPowerup_TeamsUsed[new]=s__SimpleList_List_create()
				
				//create item in game
				set s__InWorldPowerup_Unit[new]=CreateUnit(POWERUP_PLAYER, unitTypeID, x, y, 0)
				call s__IndexedUnit_create(s__InWorldPowerup_Unit[new])
				
				call UnitAddAbility(s__InWorldPowerup_Unit[new], 'Aloc')
				call ShowUnit(s__InWorldPowerup_Unit[new], false)
				call ShowUnit(s__InWorldPowerup_Unit[new], true)
				
				call SaveInteger(Table___ht, (s__InWorldPowerup_AllPowerups), (GetHandleId(s__InWorldPowerup_Unit[new])), ( new)) // INLINED!!
				
				return new
			else
				return 0
			endif
        endfunction
        function s__InWorldPowerup_CreateFromUnit takes unit u returns integer
   local integer new
			
			if GetUnitTypeId(u) == POWERUP_MARKER then
				set new=s__InWorldPowerup_CreateRandom(GetUnitX(u) , GetUnitY(u))
				call RemoveUnit(u)
				set u=null
			elseif s__InWorldPowerup_IsPowerupUnit(GetUnitTypeId(u)) then
				set new=s__InWorldPowerup_allocate()
				
				set s__InWorldPowerup_TeamsUsed[new]=s__SimpleList_List_create()
				
				set s__InWorldPowerup_Unit[new]=u
				call s__IndexedUnit_create(u)
				call UnitAddAbility(s__InWorldPowerup_Unit[new], 'Aloc')
				call ShowUnit(s__InWorldPowerup_Unit[new], false)
				call ShowUnit(s__InWorldPowerup_Unit[new], true)
				
				call SaveInteger(Table___ht, (s__InWorldPowerup_AllPowerups), (GetHandleId(s__InWorldPowerup_Unit[new])), ( new)) // INLINED!!
			else
				set new=0
			endif
						
			return new
  endfunction
        
        function s__InWorldPowerup_onInit takes nothing returns nothing
            local integer fp= PlayerUtils_FirstPlayer
        
            loop
            exitwhen fp == 0
                set s__MobImmune[fp]= false
                
                set fp=s__SimpleList_ListNode_next[fp]
            endloop
            
            set s__InWorldPowerup_AllPowerups=s__Table_create()
        endfunction

//library EDWPowerup ends
//library IceMovement:


function AdvancedIceMovement takes nothing returns nothing
    local group swap= NewGroup()
    local unit u
    local integer i
	
	loop
	set u=FirstOfGroup(IceMovement___g)
	exitwhen u == null
		set i=GetPlayerId(GetOwningPlayer(u))
		
		if i <= 8 then
			//apply player only actions
			//decrement remaining velocity, if any
			if s__VelocityX[i] != 0 then
				if s__VelocityX[i] > 0 then
					if s__VelocityX[i] < IceMovement___VELOCITY_CUTOFF then
						set s__VelocityX[i]= 0
					else
						set s__VelocityX[i]= s__VelocityX[i] - IceMovement___VELOCITY_FALLOFF
					endif
				else
					if s__VelocityX[i] > - IceMovement___VELOCITY_CUTOFF then
						set s__VelocityX[i]= 0
					else
						set s__VelocityX[i]= s__VelocityX[i] + IceMovement___VELOCITY_FALLOFF
					endif
				endif
			endif
			if s__VelocityY[i] != 0 then
				if s__VelocityY[i] > 0 then
					if s__VelocityY[i] < IceMovement___VELOCITY_CUTOFF then
						set s__VelocityY[i]= 0
					else
						set s__VelocityY[i]= s__VelocityY[i] - IceMovement___VELOCITY_FALLOFF
					endif
				else
					if s__VelocityY[i] > - IceMovement___VELOCITY_CUTOFF then
						set s__VelocityY[i]= 0
					else
						set s__VelocityY[i]= s__VelocityY[i] + IceMovement___VELOCITY_FALLOFF
					endif
				endif
			endif
			
			//physically move the unit a constant distance in the direction it's facing
			call SetUnitX(u, GetUnitX(u) + s__VelocityX[i] + s__SkateSpeed[i] * Cos(GetUnitFacing(u) * DEGREE_TO_RADIANS))
			call SetUnitY(u, GetUnitY(u) + s__VelocityY[i] + s__SkateSpeed[i] * Sin(GetUnitFacing(u) * DEGREE_TO_RADIANS))
			call IssueImmediateOrder(u, "stop")
		else
			//handle non-player units
			//call DisplayTextToForce(bj_FORCE_PLAYER[0], "Skating NPC in direction: " + R2S(GetUnitFacing(u)))
			call SetUnitX(u, GetUnitX(u) + IceMovement___NPC_SKATE_SPEED * Cos(GetUnitFacing(u) * DEGREE_TO_RADIANS))
			call SetUnitY(u, GetUnitY(u) + IceMovement___NPC_SKATE_SPEED * Sin(GetUnitFacing(u) * DEGREE_TO_RADIANS))
			call IssueImmediateOrder(u, "stop")
		endif
		
		//TODO index mazer units
		//TODO modify skate speed array to use unit index
		//TODO move above action code to be generalized to include non-player units as well
		
	call GroupAddUnit(swap, u)
	call GroupRemoveUnit(IceMovement___g, u)
	endloop
	
	call ReleaseGroup(IceMovement___g)
	set IceMovement___g=swap
	
	set u=null
	set swap=null
endfunction

function IceMovement_Add takes unit u returns nothing
	if (FirstOfGroup((IceMovement___g)) == null) then // INLINED!!
		call TimerStart(IceMovement___t, IceMovement___TIMEOUT, true, function AdvancedIceMovement)
	endif
	
	call GroupAddUnit(IceMovement___g, u)
endfunction

function IceMovement_Remove takes unit u returns nothing
	call GroupRemoveUnit(IceMovement___g, u)
	
	if (FirstOfGroup((IceMovement___g)) == null) then // INLINED!!
        call PauseTimer(IceMovement___t)
    endif
endfunction

function IceMovement_Init takes nothing returns nothing
    set IceMovement___g=NewGroup()
	set IceMovement___t=CreateTimer()
endfunction


//library IceMovement ends
//library MazingCollision:


function MazingCollision___AfterCollisionCB takes nothing returns nothing
    local timer t= GetExpiredTimer()
    local integer pID= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
    
    set s__MazingCollision___LastCollidedUnit[pID]= null
    
    call ReleaseTimer(t)
    set t=null
endfunction
function MazingCollision___AfterMazerInvulnCB takes nothing returns nothing
    local timer t= GetExpiredTimer()
    local integer pID= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
    
    set s__MobImmune[pID]= false
    set s__CanReviveOthers[pID]= true
    
	call ReleaseTimer(t)
    set t=null
endfunction
function MazingCollision___AfterMazerReviveCB takes nothing returns nothing
    local timer t= GetExpiredTimer()
    local integer pID= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
    
    //check that the unit is still paused
    if s__User_GameMode[(pID)] == Teams_GAMEMODE_STANDARD_PAUSED then
        call sc__User_SwitchGameModesDefaultLocation((pID),Teams_GAMEMODE_STANDARD)
	elseif s__User_GameMode[(pID)] == Teams_GAMEMODE_PLATFORMING_PAUSED then
		call sc__User_SwitchGameModesDefaultLocation((pID),Teams_GAMEMODE_PLATFORMING)
    endif
    
    //set immune for 1 sec and create effect
    call s__DummyCaster_castTarget(('A006'),Player(pID) , 1 , OrderId("bloodlust") , s__User_ActiveUnit[(pID)])
    set s__MobImmune[pID]= true
    set s__CanReviveOthers[pID]= false
    
    call TimerStart(t, P2P_REVIVE_PAUSE_TIME, false, function MazingCollision___AfterMazerInvulnCB)
    set t=null
endfunction



function MazingCollision___CollisionIteration takes nothing returns nothing
 local integer curUserNode= PlayerUtils_FirstPlayer
	
	//all collision
 local real muX
 local real muY
	
 local unit cu
    local integer cuTypeID
 local integer cuInfo
 local real cuX
 local real cuY
	
 local real dx
    local real dy
	
	//circle collision
    local real dist
	
	//rect collision
 local real cosA
 local real sinA
	
	loop
	exitwhen curUserNode == 0
		//only collide when in standard on platforming modes
		if s__User_GameMode[(s__SimpleList_ListNode_value[curUserNode])] == Teams_GAMEMODE_STANDARD or s__User_GameMode[(s__SimpleList_ListNode_value[curUserNode])] == Teams_GAMEMODE_PLATFORMING then
			set muX=GetUnitX(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUserNode])])
			set muY=GetUnitY(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUserNode])])
						
			//max enum range is determined by level to accomodate level's typically having a theme for model size, but that can vary widely for how small/big
			call GroupEnumUnitsInRange(MazingCollision___NearbyUnits, muX, muY, s__Levels_Level_MaxCollisionSize[s__Teams_MazingTeam_OnLevel[s__User_Team[(s__SimpleList_ListNode_value[curUserNode])]]], null)
			
			loop
			set cu=FirstOfGroup(MazingCollision___NearbyUnits)
			exitwhen cu == null
				if s__MazingCollision___LastCollidedUnit[s__SimpleList_ListNode_value[curUserNode]] != cu then
					set cuInfo=(GetUnitUserData(cu))
					set cuTypeID=GetUnitTypeId(cu)
					set cuX=GetUnitX(cu)
					set cuY=GetUnitY(cu)
					
					//filter units that appear in EDW but do not collide
					if cuInfo != 0 and s__IndexedUnit_Collideable[cuInfo] then
					// if cuTypeID != MAZER then
						//get collision geometry type from the units indexed property RectangularGeometry
						if s__IndexedUnit_RectangularGeometry[cuInfo] then
						// if cuTypeID == TANK or cuTypeID == TRUCK or cuTypeID == FIRETRUCK or cuTypeID == AMBULANCE or cuTypeID == JEEP or cuTypeID == PASSENGERCAR or cuTypeID == CORVETTE or cuTypeID == POLICECAR then
							//*********************
							//RECTANGULAR COLLISION
							//*********************
							set dx=( 360. - GetUnitFacing(cu) ) * bj_DEGTORAD
							set cosA=Cos(dx)
							set sinA=Sin(dx)
							set dx=cosA * ( muX - cuX ) - sinA * ( muY - cuY ) + cuX
							set dy=sinA * ( muX - cuX ) + cosA * ( muY - cuY ) + cuY
							







														
							if cuTypeID == TANK then
//textmacro instance: IfInAxisRectEx("65.", "115.", "65.", "65.")
	if cuX - 65. <= dx and cuX + 115. >= dx and cuY - 65. <= dy and cuY + 65. >= dy then
//end of: IfInAxisRectEx("65.", "115.", "65.", "65.")

										//TODO special splat if in front
										call CollisionDeathEffect(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUserNode])] , cu)
										
										call sc__User_SwitchGameModesDefaultLocation((s__SimpleList_ListNode_value[curUserNode]),Teams_GAMEMODE_DYING)


								endif
							elseif cuTypeID == TRUCK then
//textmacro instance: IfInAxisRectEx("205.", "215.", "68.", "68.")
	if cuX - 205. <= dx and cuX + 215. >= dx and cuY - 68. <= dy and cuY + 68. >= dy then
//end of: IfInAxisRectEx("205.", "215.", "68.", "68.")

										//TODO special splat if in front
										call CollisionDeathEffect(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUserNode])] , cu)
										
										call sc__User_SwitchGameModesDefaultLocation((s__SimpleList_ListNode_value[curUserNode]),Teams_GAMEMODE_DYING)


								endif
							elseif cuTypeID == FIRETRUCK then
//textmacro instance: IfInAxisRectEx("215.", "200.", "68.", "68.")
	if cuX - 215. <= dx and cuX + 200. >= dx and cuY - 68. <= dy and cuY + 68. >= dy then
//end of: IfInAxisRectEx("215.", "200.", "68.", "68.")

										//TODO special splat if in front
										call CollisionDeathEffect(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUserNode])] , cu)
										
										call sc__User_SwitchGameModesDefaultLocation((s__SimpleList_ListNode_value[curUserNode]),Teams_GAMEMODE_DYING)


								endif
							elseif cuTypeID == AMBULANCE then
//textmacro instance: IfInAxisRectEx("240.", "175.", "80.", "80.")
	if cuX - 240. <= dx and cuX + 175. >= dx and cuY - 80. <= dy and cuY + 80. >= dy then
//end of: IfInAxisRectEx("240.", "175.", "80.", "80.")

										//TODO special splat if in front
										call CollisionDeathEffect(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUserNode])] , cu)
										
										call sc__User_SwitchGameModesDefaultLocation((s__SimpleList_ListNode_value[curUserNode]),Teams_GAMEMODE_DYING)


								endif
							elseif cuTypeID == JEEP then
//textmacro instance: IfInAxisRectEx("145.", "135.", "64.", "64.")
	if cuX - 145. <= dx and cuX + 135. >= dx and cuY - 64. <= dy and cuY + 64. >= dy then
//end of: IfInAxisRectEx("145.", "135.", "64.", "64.")

										//TODO special splat if in front
										call CollisionDeathEffect(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUserNode])] , cu)
										
										call sc__User_SwitchGameModesDefaultLocation((s__SimpleList_ListNode_value[curUserNode]),Teams_GAMEMODE_DYING)


								endif
							elseif cuTypeID == CORVETTE then
//textmacro instance: IfInAxisRectEx("140.", "140.", "64.", "64.")
	if cuX - 140. <= dx and cuX + 140. >= dx and cuY - 64. <= dy and cuY + 64. >= dy then
//end of: IfInAxisRectEx("140.", "140.", "64.", "64.")

										//TODO special splat if in front
										call CollisionDeathEffect(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUserNode])] , cu)
										
										call sc__User_SwitchGameModesDefaultLocation((s__SimpleList_ListNode_value[curUserNode]),Teams_GAMEMODE_DYING)


								endif
							elseif cuTypeID == PASSENGERCAR then
//textmacro instance: IfInAxisRectEx("125.", "115.", "62.", "62.")
	if cuX - 125. <= dx and cuX + 115. >= dx and cuY - 62. <= dy and cuY + 62. >= dy then
//end of: IfInAxisRectEx("125.", "115.", "62.", "62.")

										//TODO special splat if in front
										call CollisionDeathEffect(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUserNode])] , cu)
										
										call sc__User_SwitchGameModesDefaultLocation((s__SimpleList_ListNode_value[curUserNode]),Teams_GAMEMODE_DYING)


								endif
							elseif cuTypeID == POLICECAR then
//textmacro instance: IfInAxisRectEx("150.", "150.", "62.", "62.")
	if cuX - 150. <= dx and cuX + 150. >= dx and cuY - 62. <= dy and cuY + 62. >= dy then
//end of: IfInAxisRectEx("150.", "150.", "62.", "62.")

										//TODO special splat if in front
										call CollisionDeathEffect(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUserNode])] , cu)
										
										call sc__User_SwitchGameModesDefaultLocation((s__SimpleList_ListNode_value[curUserNode]),Teams_GAMEMODE_DYING)


								endif
							endif
						else
							//******************
							//CIRCULAR COLLISION
							//******************
							set dx=cuX - muX
							set dy=cuY - muY
							set dist=SquareRoot(dx * dx + dy * dy)
							
							if dist <= s__User_ActiveUnitRadius[(s__SimpleList_ListNode_value[curUserNode])] + s__IndexedUnit_Radius[cuInfo] then
								if not s__MobImmune[s__SimpleList_ListNode_value[curUserNode]] and ( cuTypeID == GUARD or cuTypeID == LGUARD or cuTypeID == ICETROLL or cuTypeID == SPIRITWALKER or cuTypeID == CLAWMAN or cuTypeID == WWWISP or cuTypeID == WWSKUL ) then
									call CollisionDeathEffect(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUserNode])] , cu)
									
									call sc__User_SwitchGameModesDefaultLocation((s__SimpleList_ListNode_value[curUserNode]),Teams_GAMEMODE_DYING)
								endif
									
								if cuTypeID == REGRET or cuTypeID == LMEMORY or cuTypeID == GUILT then
									call CollisionDeathEffect(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUserNode])] , cu)
									
									call sc__User_SwitchGameModesDefaultLocation((s__SimpleList_ListNode_value[curUserNode]),Teams_GAMEMODE_DYING)
								elseif s__InWorldPowerup_IsPowerupUnit(cuTypeID) then
									set s__MazingCollision___LastCollidedUnit[s__SimpleList_ListNode_value[curUserNode]]= cu
									//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Colliding with powerup")
									call s__InWorldPowerup_OnUserAcquire((LoadInteger(Table___ht, (s__InWorldPowerup_AllPowerups), (GetHandleId((cu))))),s__SimpleList_ListNode_value[curUserNode]) // INLINED!!
									
									call TimerStart(NewTimerEx(s__SimpleList_ListNode_value[curUserNode]), MazingCollision___COLLISION_TIME, false, function MazingCollision___AfterCollisionCB)
									//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Finished colliding")
									//keys
								elseif cuTypeID == RKEY then
									set s__MazingCollision___LastCollidedUnit[s__SimpleList_ListNode_value[curUserNode]]= cu
									
									call RShieldEffect(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUserNode])])
									call sc__User_SetKeyColor((s__SimpleList_ListNode_value[curUserNode]),KEY_RED)
									// set MazerColor[curUserNode.value] = KEY_RED
									// call SetUnitVertexColor(MazersArray[curUserNode.value], 255, 0, 0, 255)
									
									call TimerStart(NewTimerEx(s__SimpleList_ListNode_value[curUserNode]), MazingCollision___COLLISION_TIME, false, function MazingCollision___AfterCollisionCB)
								elseif cuTypeID == BKEY then
									set s__MazingCollision___LastCollidedUnit[s__SimpleList_ListNode_value[curUserNode]]= cu
									
									call BShieldEffect(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUserNode])])
									call sc__User_SetKeyColor((s__SimpleList_ListNode_value[curUserNode]),KEY_BLUE)
									// set MazerColor[curUserNode.value] = KEY_BLUE
									// call SetUnitVertexColor(MazersArray[curUserNode.value], 0, 0, 255, 255)
									
									call TimerStart(NewTimerEx(s__SimpleList_ListNode_value[curUserNode]), MazingCollision___COLLISION_TIME, false, function MazingCollision___AfterCollisionCB)
								elseif cuTypeID == GKEY then
									set s__MazingCollision___LastCollidedUnit[s__SimpleList_ListNode_value[curUserNode]]= cu
									
									call GShieldEffect(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUserNode])])
									call sc__User_SetKeyColor((s__SimpleList_ListNode_value[curUserNode]),KEY_GREEN)
									// set MazerColor[curUserNode.value] = KEY_GREEN
									// call SetUnitVertexColor(MazersArray[curUserNode.value], 0, 255, 0, 255)
									
									call TimerStart(NewTimerEx(s__SimpleList_ListNode_value[curUserNode]), MazingCollision___COLLISION_TIME, false, function MazingCollision___AfterCollisionCB)
								elseif cuTypeID == TEAM_REVIVE_UNIT_ID then
									//currently you will revive anyone whose circle you hit, this may change how you play
									if s__CanReviveOthers[s__SimpleList_ListNode_value[curUserNode]] then
										//revive unit at position of mazer to avoid reviving in an illegal position
										if s__User_GameMode[(s__SimpleList_ListNode_value[curUserNode])] == Teams_GAMEMODE_STANDARD then
											call sc__User_SwitchGameModes((GetPlayerId(GetOwningPlayer(cu))),Teams_GAMEMODE_STANDARD_PAUSED , GetUnitX(s__User_ActiveUnit[(GetPlayerId(GetOwningPlayer(cu)))]) , GetUnitY(s__User_ActiveUnit[(GetPlayerId(GetOwningPlayer(cu)))]))
											// call SetDefaultCameraForPlayer(GetPlayerId(GetOwningPlayer(cu)), .5)
											call sc__User_ApplyDefaultCameras((GetPlayerId(GetOwningPlayer(cu))),.5)
											call sc__User_ApplyDefaultSelections((GetPlayerId(GetOwningPlayer(cu))))
										elseif s__User_GameMode[(s__SimpleList_ListNode_value[curUserNode])] == Teams_GAMEMODE_PLATFORMING then
											call sc__User_SwitchGameModes((GetPlayerId(GetOwningPlayer(cu))),Teams_GAMEMODE_PLATFORMING_PAUSED , GetUnitX(s__User_ActiveUnit[(GetPlayerId(GetOwningPlayer(cu)))]) , GetUnitY(s__User_ActiveUnit[(GetPlayerId(GetOwningPlayer(cu)))]))
										endif
										
										call TimerStart(NewTimerEx(GetPlayerId(GetOwningPlayer(cu))), P2P_REVIVE_PAUSE_TIME, false, function MazingCollision___AfterMazerReviveCB)
									endif
								elseif cuTypeID == KEYR then
									set s__MazingCollision___LastCollidedUnit[s__SimpleList_ListNode_value[curUserNode]]= cu
									
									call ShieldRemoveEffect(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUserNode])])
									call sc__User_SetKeyColor((s__SimpleList_ListNode_value[curUserNode]),KEY_NONE)
									
									call TimerStart(NewTimerEx(s__SimpleList_ListNode_value[curUserNode]), MazingCollision___COLLISION_TIME, false, function MazingCollision___AfterCollisionCB)
								elseif cuTypeID == TELEPORT then
									call TeleportEffect(cu , s__SimpleList_ListNode_value[curUserNode])
									
									call sc__User_RespawnAtRect((s__SimpleList_ListNode_value[curUserNode]),s__Teams_MazingTeam_Revive[s__User_Team[(s__SimpleList_ListNode_value[curUserNode])]] , true)
								endif
								
								//check units that only collide with specific game modes / active unit types
								//if any of the above kill a User, the users gamemode will currently by DYING
								if s__User_GameMode[(s__SimpleList_ListNode_value[curUserNode])] == Teams_GAMEMODE_STANDARD then
									if cuTypeID == RFIRE then
										if ( s__MazerColor[s__SimpleList_ListNode_value[curUserNode]] != KEY_RED ) then
											call RFireEffect(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUserNode])] , cu)
											
											call sc__User_SwitchGameModesDefaultLocation((s__SimpleList_ListNode_value[curUserNode]),Teams_GAMEMODE_DYING)
										else
											set s__MazingCollision___LastCollidedUnit[s__SimpleList_ListNode_value[curUserNode]]= cu
											
											call TimerStart(NewTimerEx(s__SimpleList_ListNode_value[curUserNode]), MazingCollision___COLLISION_TIME, false, function MazingCollision___AfterCollisionCB)
										endif
									elseif cuTypeID == BFIRE then
										if ( s__MazerColor[s__SimpleList_ListNode_value[curUserNode]] != KEY_BLUE ) then
											call BFireEffect(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUserNode])])
											
											call sc__User_SwitchGameModesDefaultLocation((s__SimpleList_ListNode_value[curUserNode]),Teams_GAMEMODE_DYING)
										else
											set s__MazingCollision___LastCollidedUnit[s__SimpleList_ListNode_value[curUserNode]]= cu
											
											call TimerStart(NewTimerEx(s__SimpleList_ListNode_value[curUserNode]), MazingCollision___COLLISION_TIME, false, function MazingCollision___AfterCollisionCB)
										endif
									elseif cuTypeID == GFIRE then
										if ( s__MazerColor[s__SimpleList_ListNode_value[curUserNode]] != KEY_GREEN ) then
											call GFireEffect(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUserNode])] , cu)
											
											call sc__User_SwitchGameModesDefaultLocation((s__SimpleList_ListNode_value[curUserNode]),Teams_GAMEMODE_DYING)
										else
											set s__MazingCollision___LastCollidedUnit[s__SimpleList_ListNode_value[curUserNode]]= cu
											
											call TimerStart(NewTimerEx(s__SimpleList_ListNode_value[curUserNode]), MazingCollision___COLLISION_TIME, false, function MazingCollision___AfterCollisionCB)
										endif
									endif
								elseif s__User_GameMode[(s__SimpleList_ListNode_value[curUserNode])] == Teams_GAMEMODE_PLATFORMING then
									if cuTypeID == GRAVITY then
										if s__PlatformerPropertyEquation_getAdjustment(s__Platformer_GravityEquation[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , GRAVITY) != 0 then
											set s__PlatformerPropertyAdjustment_Value[s__PlatformerPropertyEquation_getAdjustment(s__Platformer_GravityEquation[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , GRAVITY)]=- 1 * s__PlatformerPropertyAdjustment_Value[s__PlatformerPropertyEquation_getAdjustment(s__Platformer_GravityEquation[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , GRAVITY)]
										else
											call s__PlatformerPropertyEquation_addAdjustment(s__Platformer_GravityEquation[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , GRAVITY , - 1)
										endif
										set s__Platformer_GravitationalAccel[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_GravityEquation[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]],s__PlatformerProfile_GravitationalAccel[s__Platformer_BaseProfile[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]]])
										//set User(curUserNode.value).Platformer.GravitationalAccel = -1 * User(curUserNode.value).Platformer.GravitationalAccel
										set s__Platformer_YVelocity[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]]=0
										
										set s__MazingCollision___LastCollidedUnit[s__SimpleList_ListNode_value[curUserNode]]= cu
										call TimerStart(NewTimerEx(s__SimpleList_ListNode_value[curUserNode]), 1., false, function MazingCollision___AfterCollisionCB)
										
										call GravityEffect(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUserNode])] , cu)
									elseif cuTypeID == BOUNCER then
										if s__Platformer_GravitationalAccel[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]] >= 0 then
											if s__Platformer_YVelocity[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]] > 0 then
												set s__Platformer_YVelocity[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]]=- BOUNCER_SPEED
											else
												if s__Platformer_YVelocity[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]] > BOUNCER_MAX_SPEED and s__Platformer_YVelocity[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]] - BOUNCER_SPEED <= - BOUNCER_MAX_SPEED then
													set s__Platformer_YVelocity[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]]=- BOUNCER_MAX_SPEED
												else
													set s__Platformer_YVelocity[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]]=s__Platformer_YVelocity[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]] - BOUNCER_SPEED
												endif
											endif
										else
											if s__Platformer_YVelocity[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]] < 0 then
												set s__Platformer_YVelocity[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]]=BOUNCER_SPEED
											else
												if s__Platformer_YVelocity[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]] < BOUNCER_MAX_SPEED and s__Platformer_YVelocity[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]] + BOUNCER_SPEED >= BOUNCER_MAX_SPEED then
													set s__Platformer_YVelocity[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]]=BOUNCER_MAX_SPEED
												else
													set s__Platformer_YVelocity[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]]=s__Platformer_YVelocity[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]] + BOUNCER_SPEED
												endif
											endif
										endif
										
										set s__MazingCollision___LastCollidedUnit[s__SimpleList_ListNode_value[curUserNode]]= cu
										call TimerStart(NewTimerEx(s__SimpleList_ListNode_value[curUserNode]), .1, false, function MazingCollision___AfterCollisionCB)
										
										call BounceEffect(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUserNode])] , cu)
									elseif cuTypeID == UBOUNCE then
										set s__Platformer_YVelocity[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]]=s__Platformer_YVelocity[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]] + DIR_BOUNCER_SPEED
														
										call s__AutoRespawningUnit_create(GetUnitX(cu) , GetUnitY(cu) , UBOUNCE , 90 , DIR_BOUNCER_RESPAWN_TIME)
										call Recycle_ReleaseUnit(cu)
										
										call DirectionalBounceEffect(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUserNode])] , cu)
									elseif cuTypeID == RBOUNCE then
										set s__Platformer_XVelocity[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]]=s__Platformer_XVelocity[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]] + DIR_BOUNCER_SPEED
										
										call s__AutoRespawningUnit_create(GetUnitX(cu) , GetUnitY(cu) , RBOUNCE , 0 , DIR_BOUNCER_RESPAWN_TIME)
										call Recycle_ReleaseUnit(cu)
										
										call DirectionalBounceEffect(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUserNode])] , cu)
									elseif cuTypeID == DBOUNCE then
										set s__Platformer_YVelocity[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]]=s__Platformer_YVelocity[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]] - DIR_BOUNCER_SPEED
										
										call s__AutoRespawningUnit_create(GetUnitX(cu) , GetUnitY(cu) , DBOUNCE , 270 , DIR_BOUNCER_RESPAWN_TIME)
										call Recycle_ReleaseUnit(cu)
										
										call DirectionalBounceEffect(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUserNode])] , cu)
									elseif cuTypeID == LBOUNCE then
										set s__Platformer_XVelocity[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]]=s__Platformer_XVelocity[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]] - DIR_BOUNCER_SPEED
														
										call s__AutoRespawningUnit_create(GetUnitX(cu) , GetUnitY(cu) , LBOUNCE , 180 , DIR_BOUNCER_RESPAWN_TIME)
										call Recycle_ReleaseUnit(cu)
										
										call DirectionalBounceEffect(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUserNode])] , cu)
									elseif cuTypeID == SUPERSPEED then
										//repurpose var for angle
										set dx=GetUnitFacing(cu) * bj_DEGTORAD
										set s__Platformer_XVelocity[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]]=SUPERSPEED_SPEED * Cos(dx)
										set s__Platformer_YVelocity[s__User_Platformer[(s__SimpleList_ListNode_value[curUserNode])]]=SUPERSPEED_SPEED * Sin(dx)
										
										//call DisplayTextToForce(bj_FORCE_PLAYER[0], "unit is angle: " + R2S(dx))
										
										set s__MazingCollision___LastCollidedUnit[s__SimpleList_ListNode_value[curUserNode]]= cu
										call TimerStart(NewTimerEx(s__SimpleList_ListNode_value[curUserNode]), 1., false, function MazingCollision___AfterCollisionCB)
										
										call SuperSpeedEffect(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUserNode])] , cu)
									endif
								endif
							endif
						endif
					endif
				endif
			call GroupRemoveUnit(MazingCollision___NearbyUnits, cu)
			endloop
		endif
	set curUserNode=s__SimpleList_ListNode_next[curUserNode]
	endloop
endfunction

//===========================================================================

function MazingCollision___Init takes nothing returns nothing
    //set tc = CreateTimer()
    //call TimerStart(tc, TIMESTEP, true, function CollisionIterInit)
    call TimerStart(CreateTimer(), MazingCollision___COLLISION_TIMESTEP, true, function MazingCollision___CollisionIteration)
endfunction


//library MazingCollision ends
//library SandMovement:


	
	
 function s__SandMovement_SandFX takes nothing returns nothing
  local integer curUserNode= s__SimpleList_List_first[s__SandMovement_SandUsers]
  local real speed
		
		loop
		exitwhen curUserNode == 0
			set speed=SquareRoot(s__VelocityX[(s__SimpleList_ListNode_value[curUserNode])] * s__VelocityX[(s__SimpleList_ListNode_value[curUserNode])] + s__VelocityY[(s__SimpleList_ListNode_value[curUserNode])] * s__VelocityY[(s__SimpleList_ListNode_value[curUserNode])])
			if s__User_ActiveEffect[(s__SimpleList_ListNode_value[curUserNode])] == null and speed >= SAND_FX_THRESHOLD_START then
				call sc__User_SetActiveEffect((s__SimpleList_ListNode_value[curUserNode]),SAND_MOVEMENT_FX , "origin")
			elseif s__User_ActiveEffect[(s__SimpleList_ListNode_value[curUserNode])] != null and speed <= SAND_FX_THRESHOLD_STOP then
				call sc__User_ClearActiveEffect((s__SimpleList_ListNode_value[curUserNode]))
			endif
		set curUserNode=s__SimpleList_ListNode_next[curUserNode]
		endloop
 endfunction
 function s__SandMovement_SandMove takes nothing returns nothing
  local integer curUserNode= s__SimpleList_List_first[s__SandMovement_SandUsers]
  local integer user
  local real facingRad
		
		loop
		exitwhen curUserNode == 0
			set user=s__SimpleList_ListNode_value[curUserNode]
			
			if s__isMoving[user] then
				set facingRad=GetUnitFacing(s__User_ActiveUnit[user]) * bj_DEGTORAD
				
				set s__VelocityX[user]= s__VelocityX[user] + Cos(facingRad) * SandMovement___ACCELERATION
				set s__VelocityY[user]= s__VelocityY[user] + Sin(facingRad) * SandMovement___ACCELERATION
			else
				set s__VelocityX[user]= s__VelocityX[user] / SandMovement___FALLOFF
				set s__VelocityY[user]= s__VelocityY[user] / SandMovement___FALLOFF
			endif
			
			call SetUnitX(s__User_ActiveUnit[user], GetUnitX(s__User_ActiveUnit[user]) + s__VelocityX[user])
			call SetUnitY(s__User_ActiveUnit[user], GetUnitY(s__User_ActiveUnit[user]) + s__VelocityY[user])
			
			// //reuse facingRad
			// set facingRad = SquareRoot(VelocityX[user]*VelocityX[user] + VelocityY[user]*VelocityY[user])
			// if user.ActiveEffect == null and facingRad >= SAND_FX_THRESHOLD_START then
				// call user.SetActiveEffect(SAND_MOVEMENT_FX, "origin")
			// elseif user.ActiveEffect != null and facingRad <= SAND_FX_THRESHOLD_STOP then
				// call user.ClearActiveEffect()
			// endif
		set curUserNode=s__SimpleList_ListNode_next[curUserNode]
		endloop
 endfunction

 function s__SandMovement_Add takes integer user returns nothing
		//register dependencies
		call s__IsMoving_Add(user)
		
		//register self
		if s__SimpleList_List_count[s__SandMovement_SandUsers] == 0 then
			call TimerStart(s__SandMovement_MovementTimer, SandMovement___TIMESTEP, true, function s__SandMovement_SandMove)
			call TimerStart(s__SandMovement_FXTimer, SandMovement___FX_TIMESTEP, true, function s__SandMovement_SandFX)
		endif
		
		call s__SimpleList_List_addEnd(s__SandMovement_SandUsers,user)
 endfunction
	
 function s__SandMovement_Remove takes integer user returns nothing
		//deregister dependencies
		call s__IsMoving_Remove(user)
		
		//deregister self
		call s__SimpleList_List_remove(s__SandMovement_SandUsers,user)
		
		if s__SimpleList_List_count[s__SandMovement_SandUsers] == 0 then
			call PauseTimer(s__SandMovement_MovementTimer)
			call PauseTimer(s__SandMovement_FXTimer)
		endif
 endfunction
	
 function s__SandMovement_onInit takes nothing returns nothing
		set s__SandMovement_SandUsers=s__SimpleList_List_create()
 endfunction


//library SandMovement ends
//library SnowMovement:


	
 function s__SnowMovement_SnowMove takes nothing returns nothing
  local group swap= NewGroup()
  local unit u
		
  local integer i
  local real x
  local real y
		
		loop
		set u=FirstOfGroup(s__SnowMovement_g)
		exitwhen u == null
			set i=GetPlayerId(GetOwningPlayer(u))
			set x=Cos(GetUnitFacing(u) * bj_DEGTORAD)
			set y=Sin(GetUnitFacing(u) * bj_DEGTORAD)
			
			if ( x > 0 and s__VelocityX[i] < 0 ) or ( x < 0 and s__VelocityX[i] > 0 ) then
				set x=x * SnowMovement___OPPOSITION_BONUS * SnowMovement___ACCELERATION
			else
				set x=x * SnowMovement___ACCELERATION
			endif
			
			if ( y > 0 and s__VelocityY[i] < 0 ) or ( y < 0 and s__VelocityY[i] > 0 ) then
				set y=y * SnowMovement___OPPOSITION_BONUS * SnowMovement___ACCELERATION
			else
				set y=y * SnowMovement___ACCELERATION
			endif
			
			set s__VelocityX[i]= s__VelocityX[i] + x
			set s__VelocityY[i]= s__VelocityY[i] + y
			
			call SetUnitX(u, GetUnitX(u) + s__VelocityX[i])
			call SetUnitY(u, GetUnitY(u) + s__VelocityY[i])
			call IssueImmediateOrder(u, "stop")
			
		call GroupAddUnit(swap, u)
		call GroupRemoveUnit(s__SnowMovement_g, u)
		endloop
		
		call ReleaseGroup(s__SnowMovement_g)
		set s__SnowMovement_g=swap
		
		set u=null
		set swap=null
 endfunction

 function s__SnowMovement_Add takes unit u returns nothing
		if s__SnowMovement_g == null then
			set s__SnowMovement_g=NewGroup()
			set s__SnowMovement_t=(NewTimerEx(0)) // INLINED!!
			
			call TimerStart(s__SnowMovement_t, SnowMovement___TIMESTEP, true, function s__SnowMovement_SnowMove)
		endif
		
		call GroupAddUnit(s__SnowMovement_g, u)
 endfunction
	
 function s__SnowMovement_Remove takes unit u returns nothing
		call GroupRemoveUnit(s__SnowMovement_g, u)
		
		if (FirstOfGroup((s__SnowMovement_g)) == null) then // INLINED!!
			call ReleaseTimer(s__SnowMovement_t)
			call ReleaseGroup(s__SnowMovement_g)
			
			set s__SnowMovement_g=null
			set s__SnowMovement_t=null
		endif
 endfunction


//library SnowMovement ends
//library IceSkater:
	
		//TODO replace with vector containing slope and offset values for line orthogonal to path from previous destination, and intersecting next destinations position
		//TODO metadata about destination
		//public vector2 PositionNormal //normal through .Position with x = m, y = b for equation thats perpindicular to the straight line between the previous destination and this one
		
//Implemented from module Alloc:
		
		

			

		
		
  function s__IceSkater___Destination_allocate takes nothing returns integer
   local integer this= s__IceSkater___Destination_Alloc___recycler[0]
			


			
			if ( s__IceSkater___Destination_Alloc___recycler[this] == 0 ) then
				set s__IceSkater___Destination_Alloc___recycler[0]=this + 1
			else
				set s__IceSkater___Destination_Alloc___recycler[0]=s__IceSkater___Destination_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__IceSkater___Destination_deallocate takes integer this returns nothing


			


			
			set s__IceSkater___Destination_Alloc___recycler[this]=s__IceSkater___Destination_Alloc___recycler[0]
			set s__IceSkater___Destination_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__IceSkater___Destination_Alloc___onInit takes nothing returns nothing
			set s__IceSkater___Destination_Alloc___recycler[0]=1
  endfunction
		
  function s__IceSkater___Destination_print takes integer this returns nothing
			call DisplayTextToForce(bj_FORCE_PLAYER[0], "Printing Destination: " + I2S(this))
			call DisplayTextToForce(bj_FORCE_PLAYER[0], "Position: " + s__vector2_toString(s__IceSkater___Destination_Position[this]))
			call DisplayTextToForce(bj_FORCE_PLAYER[0], "Quadrant From Previous: " + s__vector2_toString(s__IceSkater___Destination_QuadrantDirection[this]))
			call DisplayTextToForce(bj_FORCE_PLAYER[0], "Angle From Previous: " + R2S(s__IceSkater___Destination_AngleFromPrevious[this]))
  endfunction
		
  function s__IceSkater___Destination_destroy takes integer this returns nothing
			call s__vector2_deallocate((s__IceSkater___Destination_Position[this])) // INLINED!!
			call s__vector2_deallocate((s__IceSkater___Destination_QuadrantDirection[this])) // INLINED!!
  endfunction
		
  function s__IceSkater___Destination_create takes integer position,integer previousDestination returns integer
   local integer new= s__IceSkater___Destination_allocate()
   local integer rel
			
			set s__IceSkater___Destination_Position[new]=position
			
			//create metadata for later use
			if previousDestination != 0 then
				set rel=s__vector2_create(s__vector2_x[position] , s__vector2_y[position])
				call s__vector2_subtract(rel,s__IceSkater___Destination_Position[previousDestination])
				







				
				set s__IceSkater___Destination_AngleFromPrevious[new]=s__vector2_getAngleHorizontal(rel) * bj_RADTODEG
				
				call s__vector2_deallocate((rel)) // INLINED!!
			
				if s__vector2_x[position] >= s__vector2_x[s__IceSkater___Destination_Position[previousDestination]] - IceSkater___AXIS_BUFFER and s__vector2_x[position] <= s__vector2_x[s__IceSkater___Destination_Position[previousDestination]] + IceSkater___AXIS_BUFFER then
					if s__vector2_y[position] >= s__vector2_y[s__IceSkater___Destination_Position[previousDestination]] then
						set s__IceSkater___Destination_QuadrantDirection[new]=s__vector2_create(0 , 1)
					else
						set s__IceSkater___Destination_QuadrantDirection[new]=s__vector2_create(0 , - 1)
					endif
				elseif s__vector2_y[position] >= s__vector2_y[s__IceSkater___Destination_Position[previousDestination]] - IceSkater___AXIS_BUFFER and s__vector2_y[position] <= s__vector2_y[s__IceSkater___Destination_Position[previousDestination]] + IceSkater___AXIS_BUFFER then
					if s__vector2_x[position] >= s__vector2_x[s__IceSkater___Destination_Position[previousDestination]] then
						set s__IceSkater___Destination_QuadrantDirection[new]=s__vector2_create(1 , 0)
					else
						set s__IceSkater___Destination_QuadrantDirection[new]=s__vector2_create(- 1 , 0)
					endif
				elseif s__vector2_x[position] >= s__vector2_x[s__IceSkater___Destination_Position[previousDestination]] then
					if s__vector2_y[position] >= s__vector2_y[s__IceSkater___Destination_Position[previousDestination]] then
						set s__IceSkater___Destination_QuadrantDirection[new]=s__vector2_create(1 , 1)
					else
						set s__IceSkater___Destination_QuadrantDirection[new]=s__vector2_create(1 , - 1)
					endif
				else
					if s__vector2_y[position] >= s__vector2_y[s__IceSkater___Destination_Position[previousDestination]] then
						set s__IceSkater___Destination_QuadrantDirection[new]=s__vector2_create(- 1 , 1)
					else
						set s__IceSkater___Destination_QuadrantDirection[new]=s__vector2_create(- 1 , - 1)
					endif
				endif
			endif
			
			//call DisplayTextToForce(bj_FORCE_PLAYER[0], "Creating destination " + I2S(new))
			//call new.print()
			
			return new
  endfunction
	
		
		
		
  function s__IceSkater_print takes integer this returns nothing
   local integer curDestination= s__SimpleList_List_first[s__IceSkater_Destinations[this]]
			
			call DisplayTextToForce(bj_FORCE_PLAYER[0], "Printing Skater: " + I2S(this))
			
			//circular loop safe
			if curDestination != 0 then
				call s__IceSkater___Destination_print((s__SimpleList_ListNode_value[curDestination]))
				set curDestination=s__SimpleList_ListNode_next[curDestination]
			endif
			
			loop
			exitwhen curDestination == 0 or curDestination == s__SimpleList_List_first[s__IceSkater_Destinations[this]]
				call s__IceSkater___Destination_print((s__SimpleList_ListNode_value[curDestination]))
			set curDestination=s__SimpleList_ListNode_next[curDestination]
			endloop
  endfunction
		
  function s__IceSkater_AddDestination takes integer this,integer destination returns nothing
			if s__SimpleList_List_count[s__IceSkater_Destinations[this]] > 0 then
				call s__SimpleList_List_addEnd(s__IceSkater_Destinations[this],s__IceSkater___Destination_create(destination , (s__SimpleList_ListNode_value[s__SimpleList_List_last[s__IceSkater_Destinations[this]]])))
			else
				call s__SimpleList_List_addEnd(s__IceSkater_Destinations[this],s__IceSkater___Destination_create(destination , 0))
			endif
  endfunction
  function s__IceSkater_ConnectEnds takes integer this returns nothing
   local integer start= s__SimpleList_ListNode_value[s__SimpleList_List_first[s__IceSkater_Destinations[this]]]
   local integer end= s__SimpleList_ListNode_value[s__SimpleList_List_last[s__IceSkater_Destinations[this]]]
			
   local integer rel= s__vector2_create(s__vector2_x[s__IceSkater___Destination_Position[(s__SimpleList_ListNode_value[s__SimpleList_List_first[s__IceSkater_Destinations[this]]])]] , s__vector2_y[s__IceSkater___Destination_Position[(s__SimpleList_ListNode_value[s__SimpleList_List_first[s__IceSkater_Destinations[this]]])]])
			call s__vector2_subtract(rel,s__IceSkater___Destination_Position[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__IceSkater_Destinations[this]]])])
			
			set s__IceSkater___Destination_AngleFromPrevious[start]=s__vector2_getAngleHorizontal(rel) * bj_RADTODEG

			call s__vector2_deallocate((rel)) // INLINED!!
			
			//set start.AngleFromPrevious = vector2.getAngle(end, start) * bj_RADTODEG
			
			if s__vector2_x[s__IceSkater___Destination_Position[start]] >= s__vector2_x[s__IceSkater___Destination_Position[end]] then
				if s__vector2_y[s__IceSkater___Destination_Position[start]] >= s__vector2_y[s__IceSkater___Destination_Position[end]] then
					set s__IceSkater___Destination_QuadrantDirection[start]=s__vector2_create(1 , 1)
				else
					set s__IceSkater___Destination_QuadrantDirection[start]=s__vector2_create(1 , - 1)
				endif
			else
				if s__vector2_y[s__IceSkater___Destination_Position[start]] >= s__vector2_y[s__IceSkater___Destination_Position[end]] then
					set s__IceSkater___Destination_QuadrantDirection[start]=s__vector2_create(- 1 , 1)
				else
					set s__IceSkater___Destination_QuadrantDirection[start]=s__vector2_create(- 1 , - 1)
				endif
			endif
			
			set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__IceSkater_Destinations[this]]]=s__SimpleList_List_first[s__IceSkater_Destinations[this]]
			set s__SimpleList_ListNode_prev[s__SimpleList_List_first[s__IceSkater_Destinations[this]]]=s__SimpleList_List_last[s__IceSkater_Destinations[this]]
  endfunction
		
  function s__IceSkater_SetDefaults takes integer this returns nothing
			set s__IceSkater_CurrentDestination[this]=s__SimpleList_ListNode_next[s__SimpleList_List_first[s__IceSkater_Destinations[this]]]
			call SetUnitPosition(s__IceSkater_SkateUnit[this], s__vector2_x[s__IceSkater___Destination_Position[(s__SimpleList_ListNode_value[s__SimpleList_List_first[s__IceSkater_Destinations[this]]])]], s__vector2_y[s__IceSkater___Destination_Position[(s__SimpleList_ListNode_value[s__SimpleList_List_first[s__IceSkater_Destinations[this]]])]])
			call SetUnitFacing(s__IceSkater_SkateUnit[this], s__IceSkater___Destination_AngleFromPrevious[(s__SimpleList_ListNode_value[s__IceSkater_CurrentDestination[this]])])
			
			set s__IceSkater_CurrentAngleDelta[this]=0
			set s__IceSkater_CurrentAngleDirection[this]=- 1
  endfunction
		
  function s__IceSkater_UpdateSkaters takes nothing returns nothing
   local integer currentSkaterNode= s__SimpleList_List_first[s__IceSkater_ActiveSkaters]
   local integer currentSkater
   local integer currentDestination
			//local vector2 unitDirection
			
			//TODO may need to replace this with a theoretical facing which matches expectations 
			//local real facing
			
			loop
			exitwhen currentSkaterNode == 0
				set currentSkater=(s__SimpleList_ListNode_value[currentSkaterNode])
				set currentDestination=(s__SimpleList_ListNode_value[s__IceSkater_CurrentDestination[currentSkater]])
				
				//check if skater has passed their current destination
				if s__vector2_x[s__IceSkater___Destination_QuadrantDirection[currentDestination]] > 0 then
					if s__vector2_y[s__IceSkater___Destination_QuadrantDirection[currentDestination]] > 0 then
						if GetUnitX(s__IceSkater_SkateUnit[currentSkater]) >= s__vector2_x[s__IceSkater___Destination_Position[currentDestination]] and GetUnitY(s__IceSkater_SkateUnit[currentSkater]) >= s__vector2_y[s__IceSkater___Destination_Position[currentDestination]] then
							set s__IceSkater_CurrentDestination[currentSkater]=s__SimpleList_ListNode_next[s__IceSkater_CurrentDestination[currentSkater]]
							if s__IceSkater_CurrentDestination[currentSkater] == 0 then
								//instantly reset to starting state -- only occurs if the ends of the destination chain are NOT connected
								call s__IceSkater_SetDefaults(currentSkater)
							endif
						endif
					elseif s__vector2_y[s__IceSkater___Destination_QuadrantDirection[currentDestination]] < 0 then
						if GetUnitX(s__IceSkater_SkateUnit[currentSkater]) >= s__vector2_x[s__IceSkater___Destination_Position[currentDestination]] and GetUnitY(s__IceSkater_SkateUnit[currentSkater]) < s__vector2_y[s__IceSkater___Destination_Position[currentDestination]] then
							set s__IceSkater_CurrentDestination[currentSkater]=s__SimpleList_ListNode_next[s__IceSkater_CurrentDestination[currentSkater]]
							if s__IceSkater_CurrentDestination[currentSkater] == 0 then
								//instantly reset to starting state -- only occurs if the ends of the destination chain are NOT connected
								call s__IceSkater_SetDefaults(currentSkater)
							endif
						endif
					else
						if GetUnitX(s__IceSkater_SkateUnit[currentSkater]) >= s__vector2_x[s__IceSkater___Destination_Position[currentDestination]] then
							set s__IceSkater_CurrentDestination[currentSkater]=s__SimpleList_ListNode_next[s__IceSkater_CurrentDestination[currentSkater]]
							if s__IceSkater_CurrentDestination[currentSkater] == 0 then
								//instantly reset to starting state -- only occurs if the ends of the destination chain are NOT connected
								call s__IceSkater_SetDefaults(currentSkater)
							endif
						endif
					endif
				elseif s__vector2_x[s__IceSkater___Destination_QuadrantDirection[currentDestination]] < 0 then
					if s__vector2_y[s__IceSkater___Destination_QuadrantDirection[currentDestination]] > 0 then
						if GetUnitX(s__IceSkater_SkateUnit[currentSkater]) < s__vector2_x[s__IceSkater___Destination_Position[currentDestination]] and GetUnitY(s__IceSkater_SkateUnit[currentSkater]) >= s__vector2_y[s__IceSkater___Destination_Position[currentDestination]] then
							set s__IceSkater_CurrentDestination[currentSkater]=s__SimpleList_ListNode_next[s__IceSkater_CurrentDestination[currentSkater]]
							if s__IceSkater_CurrentDestination[currentSkater] == 0 then
								//instantly reset to starting state -- only occurs if the ends of the destination chain are NOT connected
								call s__IceSkater_SetDefaults(currentSkater)
							endif
						endif
					elseif s__vector2_y[s__IceSkater___Destination_QuadrantDirection[currentDestination]] < 0 then
						if GetUnitX(s__IceSkater_SkateUnit[currentSkater]) < s__vector2_x[s__IceSkater___Destination_Position[currentDestination]] and GetUnitY(s__IceSkater_SkateUnit[currentSkater]) < s__vector2_y[s__IceSkater___Destination_Position[currentDestination]] then
							set s__IceSkater_CurrentDestination[currentSkater]=s__SimpleList_ListNode_next[s__IceSkater_CurrentDestination[currentSkater]]
							if s__IceSkater_CurrentDestination[currentSkater] == 0 then
								//instantly reset to starting state -- only occurs if the ends of the destination chain are NOT connected
								call s__IceSkater_SetDefaults(currentSkater)
							endif
						endif
					else
						if GetUnitX(s__IceSkater_SkateUnit[currentSkater]) < s__vector2_x[s__IceSkater___Destination_Position[currentDestination]] then
							set s__IceSkater_CurrentDestination[currentSkater]=s__SimpleList_ListNode_next[s__IceSkater_CurrentDestination[currentSkater]]
							if s__IceSkater_CurrentDestination[currentSkater] == 0 then
								//instantly reset to starting state -- only occurs if the ends of the destination chain are NOT connected
								call s__IceSkater_SetDefaults(currentSkater)
							endif
						endif
					endif
				else
					if s__vector2_y[s__IceSkater___Destination_QuadrantDirection[currentDestination]] >= 0 then
						if GetUnitY(s__IceSkater_SkateUnit[currentSkater]) >= s__vector2_y[s__IceSkater___Destination_Position[currentDestination]] then
							set s__IceSkater_CurrentDestination[currentSkater]=s__SimpleList_ListNode_next[s__IceSkater_CurrentDestination[currentSkater]]
							if s__IceSkater_CurrentDestination[currentSkater] == 0 then
								//instantly reset to starting state -- only occurs if the ends of the destination chain are NOT connected
								call s__IceSkater_SetDefaults(currentSkater)
							endif
						endif
					else
						if GetUnitY(s__IceSkater_SkateUnit[currentSkater]) < s__vector2_y[s__IceSkater___Destination_Position[currentDestination]] then
							set s__IceSkater_CurrentDestination[currentSkater]=s__SimpleList_ListNode_next[s__IceSkater_CurrentDestination[currentSkater]]
							if s__IceSkater_CurrentDestination[currentSkater] == 0 then
								//instantly reset to starting state -- only occurs if the ends of the destination chain are NOT connected
								call s__IceSkater_SetDefaults(currentSkater)
							endif
						endif
					endif
				endif
				
				
				
				//check if exceeding max delta
				if s__IceSkater_CurrentAngleDelta[currentSkater] + s__IceSkater_CurrentAngleDirection[currentSkater] * s__IceSkater_AngleChangeRate[currentSkater] > s__IceSkater_MaxAngleDelta[currentSkater] or s__IceSkater_CurrentAngleDelta[currentSkater] + s__IceSkater_CurrentAngleDirection[currentSkater] * s__IceSkater_AngleChangeRate[currentSkater] < - s__IceSkater_MaxAngleDelta[currentSkater] then
					set s__IceSkater_CurrentAngleDirection[currentSkater]=- s__IceSkater_CurrentAngleDirection[currentSkater]
				endif
				
				set s__IceSkater_CurrentAngleDelta[currentSkater]=s__IceSkater_CurrentAngleDelta[currentSkater] + s__IceSkater_CurrentAngleDirection[currentSkater] * s__IceSkater_AngleChangeRate[currentSkater]
				//set facing = facing + .CurrentAngleDelta
				//set unitDirection = vector2.create(Cos(facing + .CurrentAngleDelta), Sin(facing + .CurrentAngleDelta))
				
				call SetUnitFacingTimed(s__IceSkater_SkateUnit[currentSkater], s__IceSkater___Destination_AngleFromPrevious[(s__SimpleList_ListNode_value[s__IceSkater_CurrentDestination[currentSkater]])] + s__IceSkater_CurrentAngleDelta[currentSkater], IceSkater___TURN_SMOOTH_DURATION)
			set currentSkaterNode=s__SimpleList_ListNode_next[currentSkaterNode]
			endloop
  endfunction
		
  function s__IceSkater_Start takes integer this returns nothing
			if not s__SimpleList_List_contains(s__IceSkater_ActiveSkaters,this) then
				//set .CurrentDestination = .Destinations.first.next
				//call SetUnitPosition(.SkateUnit, Destination(.Destinations.first.value).Position.x, Destination(.Destinations.first.value).Position.y)
				//call SetUnitFacing(.SkateUnit, Destination(.CurrentDestination.value).AngleFromPrevious)
				call s__IceSkater_SetDefaults(this)
				
				call ShowUnit(s__IceSkater_SkateUnit[this], true)
				
				call s__SimpleList_List_add(s__IceSkater_ActiveSkaters,this)
				call IceMovement_Add(s__IceSkater_SkateUnit[this])
				
				if s__SimpleList_List_count[s__IceSkater_ActiveSkaters] == 1 then
                    call TimerStart(IceSkater___t, IceSkater___TIMESTEP, true, function s__IceSkater_UpdateSkaters)
                    call DisplayTextToForce(bj_FORCE_PLAYER[0], "Started NPC skater timer")
                endif
			endif
  endfunction
  function s__IceSkater_Stop takes integer this returns nothing
			if s__SimpleList_List_contains(s__IceSkater_ActiveSkaters,this) then
				call s__SimpleList_List_remove(s__IceSkater_ActiveSkaters,this)
				call IceMovement_Remove(s__IceSkater_SkateUnit[this])
				
				call ShowUnit(s__IceSkater_SkateUnit[this], false)
				
				if s__SimpleList_List_count[s__IceSkater_ActiveSkaters] == 0 then
                    call PauseTimer(IceSkater___t)
                    call DisplayTextToForce(bj_FORCE_PLAYER[0], "Paused NPC skater timer")
                endif
			endif
  endfunction
		
  function s__IceSkater_destroy takes integer this returns nothing
   local integer curDestination= s__SimpleList_List_first[s__IceSkater_Destinations[this]]
			
			//calling .Stop only does anything if currently active
			call s__IceSkater_Stop(this)
			
			loop
			exitwhen curDestination == 0
				call s__IceSkater___Destination_destroy((s__SimpleList_ListNode_value[curDestination]))
			set curDestination=s__SimpleList_ListNode_next[curDestination]
			endloop
			
			call s__SimpleList_List_destroy(s__IceSkater_Destinations[this])
			set s__IceSkater_CurrentDestination[this]=0
			
			call RemoveUnit(s__IceSkater_SkateUnit[this])
			set s__IceSkater_SkateUnit[this]=null
  endfunction
		
		//all angles are input in degrees and then converted to rads if necessary
  function s__IceSkater_create takes integer start,integer next,integer unitID,real maxAngle,real rawAngleChangeRate returns integer
   local integer new= s__IceSkater__allocate()
			
			set s__IceSkater_Destinations[new]=s__SimpleList_List_create()
			call s__IceSkater_AddDestination(new,start)
			call s__IceSkater_AddDestination(new,next)
			set s__IceSkater_CurrentDestination[new]=s__SimpleList_ListNode_next[s__SimpleList_List_first[s__IceSkater_Destinations[new]]]
			
			set s__IceSkater_SkateUnit[new]=CreateUnit(IceSkater___NPC_SKATE_PLAYER, unitID, s__vector2_x[start], s__vector2_y[start], s__IceSkater___Destination_AngleFromPrevious[(s__SimpleList_ListNode_value[s__IceSkater_CurrentDestination[new]])])
			call s__IndexedUnit_create(s__IceSkater_SkateUnit[new])
			//call ShowUnit(new.SkateUnit, false)
			
			set s__IceSkater_MaxAngleDelta[new]=maxAngle
			set s__IceSkater_AngleChangeRate[new]=rawAngleChangeRate * IceSkater___TIMESTEP
			
			//set new.CurrentAngleDelta = 0
			//set new.CurrentAngleDirection = -1
			call s__IceSkater_SetDefaults(new)
			
			return new
  endfunction
		
  function s__IceSkater_onInit takes nothing returns nothing
			set s__IceSkater_ActiveSkaters=s__SimpleList_List_create()
  endfunction

//library IceSkater ends
//library SuperFastMovement:

	
 function s__SuperFastMovement_FastMove takes nothing returns nothing
  local integer curUserNode= s__SimpleList_List_first[s__SuperFastMovement_SuperFastUsers]
  local unit u
  local real facingRad
		
		loop
		exitwhen curUserNode == 0
			if s__isMoving[s__SimpleList_ListNode_value[curUserNode]] then
				set u=s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUserNode])]
				set facingRad=GetUnitFacing(u) * bj_DEGTORAD
				
				call SetUnitX(u, GetUnitX(u) + Cos(facingRad) * SuperFastSpeed)
				call SetUnitY(u, GetUnitY(u) + Sin(facingRad) * SuperFastSpeed)
			endif
		set curUserNode=s__SimpleList_ListNode_next[curUserNode]
		endloop
 endfunction

 function s__SuperFastMovement_Add takes integer user returns nothing
		if s__SimpleList_List_count[s__SuperFastMovement_SuperFastUsers] == 0 then
			call TimerStart(s__SuperFastMovement_t, SuperFastMovement___TIMESTEP, true, function s__SuperFastMovement_FastMove)
		endif
		
		call s__SimpleList_List_addEnd(s__SuperFastMovement_SuperFastUsers,user)
		call s__IsMoving_Add(user)
 endfunction
	
 function s__SuperFastMovement_Remove takes integer user returns nothing
		call s__SimpleList_List_remove(s__SuperFastMovement_SuperFastUsers,user)
		call s__IsMoving_Remove(user)
		
		if s__SimpleList_List_count[s__SuperFastMovement_SuperFastUsers] == 0 then
			call PauseTimer(s__SuperFastMovement_t)
		endif
 endfunction
	
 function s__SuperFastMovement_onInit takes nothing returns nothing
		set s__SuperFastMovement_SuperFastUsers=s__SimpleList_List_create()
 endfunction


//library SuperFastMovement ends
//library StandardGameLoop:


function GetBestTerrainForPoint takes real x,real y returns integer
 local integer bestTType= GetTerrainType(x, y)
 local integer bestTPriority
	
 local integer curTType
 local integer curTPriority
	
	//special case for platforming tile -- always use exact boundaries when that is the ttype for the current location
	if bestTType == LRGBRICKS then
		return bestTType
	endif
	
	//initialize bestTPriority
//textmacro instance: GetTerrainPriority("bestTType", "bestTPriority")
	if bestTType == ABYSS or bestTType == RTILE or bestTType == ROAD then
		set bestTPriority=0
	elseif bestTType == LAVA then
		set bestTPriority=1
	elseif bestTType == NOEFFECT then
		set bestTPriority=3
	elseif bestTType == GRASS or bestTType == SNOW then
		set bestTPriority=4
	elseif bestTType == D_GRASS or bestTType == SLOWICE then
		set bestTPriority=5
	elseif bestTType == LEAVES or bestTType == MEDIUMICE then
		set bestTPriority=6
	elseif bestTType == FASTICE then
		set bestTPriority=7
	else //if bestTType == VINES or bestTType == SAND or bestTType == RSNOW then
		set bestTPriority=2
	endif
//end of: GetTerrainPriority("bestTType", "bestTPriority")
	
	//check cardinal directions
	set curTType=GetTerrainType(x + StandardGameLoop___STD_TERRAIN_OFFSET, y)
//textmacro instance: GetTerrainPriority("curTType", "curTPriority")
	if curTType == ABYSS or curTType == RTILE or curTType == ROAD then
		set curTPriority=0
	elseif curTType == LAVA then
		set curTPriority=1
	elseif curTType == NOEFFECT then
		set curTPriority=3
	elseif curTType == GRASS or curTType == SNOW then
		set curTPriority=4
	elseif curTType == D_GRASS or curTType == SLOWICE then
		set curTPriority=5
	elseif curTType == LEAVES or curTType == MEDIUMICE then
		set curTPriority=6
	elseif curTType == FASTICE then
		set curTPriority=7
	else //if curTType == VINES or curTType == SAND or curTType == RSNOW then
		set curTPriority=2
	endif
//end of: GetTerrainPriority("curTType", "curTPriority")
//textmacro instance: UpdatePriorityTerrain("curTType", "curTPriority", "bestTType", "bestTPriority")
	if curTPriority > bestTPriority then
		set bestTPriority=curTPriority
		set bestTType=curTType
	endif
//end of: UpdatePriorityTerrain("curTType", "curTPriority", "bestTType", "bestTPriority")
	
	set curTType=GetTerrainType(x - StandardGameLoop___STD_TERRAIN_OFFSET, y)
//textmacro instance: GetTerrainPriority("curTType", "curTPriority")
	if curTType == ABYSS or curTType == RTILE or curTType == ROAD then
		set curTPriority=0
	elseif curTType == LAVA then
		set curTPriority=1
	elseif curTType == NOEFFECT then
		set curTPriority=3
	elseif curTType == GRASS or curTType == SNOW then
		set curTPriority=4
	elseif curTType == D_GRASS or curTType == SLOWICE then
		set curTPriority=5
	elseif curTType == LEAVES or curTType == MEDIUMICE then
		set curTPriority=6
	elseif curTType == FASTICE then
		set curTPriority=7
	else //if curTType == VINES or curTType == SAND or curTType == RSNOW then
		set curTPriority=2
	endif
//end of: GetTerrainPriority("curTType", "curTPriority")
//textmacro instance: UpdatePriorityTerrain("curTType", "curTPriority", "bestTType", "bestTPriority")
	if curTPriority > bestTPriority then
		set bestTPriority=curTPriority
		set bestTType=curTType
	endif
//end of: UpdatePriorityTerrain("curTType", "curTPriority", "bestTType", "bestTPriority")
	
	set curTType=GetTerrainType(x, y + StandardGameLoop___STD_TERRAIN_OFFSET)
//textmacro instance: GetTerrainPriority("curTType", "curTPriority")
	if curTType == ABYSS or curTType == RTILE or curTType == ROAD then
		set curTPriority=0
	elseif curTType == LAVA then
		set curTPriority=1
	elseif curTType == NOEFFECT then
		set curTPriority=3
	elseif curTType == GRASS or curTType == SNOW then
		set curTPriority=4
	elseif curTType == D_GRASS or curTType == SLOWICE then
		set curTPriority=5
	elseif curTType == LEAVES or curTType == MEDIUMICE then
		set curTPriority=6
	elseif curTType == FASTICE then
		set curTPriority=7
	else //if curTType == VINES or curTType == SAND or curTType == RSNOW then
		set curTPriority=2
	endif
//end of: GetTerrainPriority("curTType", "curTPriority")
//textmacro instance: UpdatePriorityTerrain("curTType", "curTPriority", "bestTType", "bestTPriority")
	if curTPriority > bestTPriority then
		set bestTPriority=curTPriority
		set bestTType=curTType
	endif
//end of: UpdatePriorityTerrain("curTType", "curTPriority", "bestTType", "bestTPriority")
	
	set curTType=GetTerrainType(x, y - StandardGameLoop___STD_TERRAIN_OFFSET)
//textmacro instance: GetTerrainPriority("curTType", "curTPriority")
	if curTType == ABYSS or curTType == RTILE or curTType == ROAD then
		set curTPriority=0
	elseif curTType == LAVA then
		set curTPriority=1
	elseif curTType == NOEFFECT then
		set curTPriority=3
	elseif curTType == GRASS or curTType == SNOW then
		set curTPriority=4
	elseif curTType == D_GRASS or curTType == SLOWICE then
		set curTPriority=5
	elseif curTType == LEAVES or curTType == MEDIUMICE then
		set curTPriority=6
	elseif curTType == FASTICE then
		set curTPriority=7
	else //if curTType == VINES or curTType == SAND or curTType == RSNOW then
		set curTPriority=2
	endif
//end of: GetTerrainPriority("curTType", "curTPriority")
//textmacro instance: UpdatePriorityTerrain("curTType", "curTPriority", "bestTType", "bestTPriority")
	if curTPriority > bestTPriority then
		set bestTPriority=curTPriority
		set bestTType=curTType
	endif
//end of: UpdatePriorityTerrain("curTType", "curTPriority", "bestTType", "bestTPriority")
	
	
	//check diagonal directions
	set curTType=GetTerrainType(x + StandardGameLoop___STD_DIAGONAL_TERRAIN_OFFSET, y + StandardGameLoop___STD_DIAGONAL_TERRAIN_OFFSET)
//textmacro instance: GetTerrainPriority("curTType", "curTPriority")
	if curTType == ABYSS or curTType == RTILE or curTType == ROAD then
		set curTPriority=0
	elseif curTType == LAVA then
		set curTPriority=1
	elseif curTType == NOEFFECT then
		set curTPriority=3
	elseif curTType == GRASS or curTType == SNOW then
		set curTPriority=4
	elseif curTType == D_GRASS or curTType == SLOWICE then
		set curTPriority=5
	elseif curTType == LEAVES or curTType == MEDIUMICE then
		set curTPriority=6
	elseif curTType == FASTICE then
		set curTPriority=7
	else //if curTType == VINES or curTType == SAND or curTType == RSNOW then
		set curTPriority=2
	endif
//end of: GetTerrainPriority("curTType", "curTPriority")
//textmacro instance: UpdatePriorityTerrain("curTType", "curTPriority", "bestTType", "bestTPriority")
	if curTPriority > bestTPriority then
		set bestTPriority=curTPriority
		set bestTType=curTType
	endif
//end of: UpdatePriorityTerrain("curTType", "curTPriority", "bestTType", "bestTPriority")
	
	set curTType=GetTerrainType(x - StandardGameLoop___STD_DIAGONAL_TERRAIN_OFFSET, y + StandardGameLoop___STD_DIAGONAL_TERRAIN_OFFSET)
//textmacro instance: GetTerrainPriority("curTType", "curTPriority")
	if curTType == ABYSS or curTType == RTILE or curTType == ROAD then
		set curTPriority=0
	elseif curTType == LAVA then
		set curTPriority=1
	elseif curTType == NOEFFECT then
		set curTPriority=3
	elseif curTType == GRASS or curTType == SNOW then
		set curTPriority=4
	elseif curTType == D_GRASS or curTType == SLOWICE then
		set curTPriority=5
	elseif curTType == LEAVES or curTType == MEDIUMICE then
		set curTPriority=6
	elseif curTType == FASTICE then
		set curTPriority=7
	else //if curTType == VINES or curTType == SAND or curTType == RSNOW then
		set curTPriority=2
	endif
//end of: GetTerrainPriority("curTType", "curTPriority")
//textmacro instance: UpdatePriorityTerrain("curTType", "curTPriority", "bestTType", "bestTPriority")
	if curTPriority > bestTPriority then
		set bestTPriority=curTPriority
		set bestTType=curTType
	endif
//end of: UpdatePriorityTerrain("curTType", "curTPriority", "bestTType", "bestTPriority")
	
	set curTType=GetTerrainType(x + StandardGameLoop___STD_DIAGONAL_TERRAIN_OFFSET, y - StandardGameLoop___STD_DIAGONAL_TERRAIN_OFFSET)
//textmacro instance: GetTerrainPriority("curTType", "curTPriority")
	if curTType == ABYSS or curTType == RTILE or curTType == ROAD then
		set curTPriority=0
	elseif curTType == LAVA then
		set curTPriority=1
	elseif curTType == NOEFFECT then
		set curTPriority=3
	elseif curTType == GRASS or curTType == SNOW then
		set curTPriority=4
	elseif curTType == D_GRASS or curTType == SLOWICE then
		set curTPriority=5
	elseif curTType == LEAVES or curTType == MEDIUMICE then
		set curTPriority=6
	elseif curTType == FASTICE then
		set curTPriority=7
	else //if curTType == VINES or curTType == SAND or curTType == RSNOW then
		set curTPriority=2
	endif
//end of: GetTerrainPriority("curTType", "curTPriority")
//textmacro instance: UpdatePriorityTerrain("curTType", "curTPriority", "bestTType", "bestTPriority")
	if curTPriority > bestTPriority then
		set bestTPriority=curTPriority
		set bestTType=curTType
	endif
//end of: UpdatePriorityTerrain("curTType", "curTPriority", "bestTType", "bestTPriority")
	
	set curTType=GetTerrainType(x - StandardGameLoop___STD_DIAGONAL_TERRAIN_OFFSET, y - StandardGameLoop___STD_DIAGONAL_TERRAIN_OFFSET)
//textmacro instance: GetTerrainPriority("curTType", "curTPriority")
	if curTType == ABYSS or curTType == RTILE or curTType == ROAD then
		set curTPriority=0
	elseif curTType == LAVA then
		set curTPriority=1
	elseif curTType == NOEFFECT then
		set curTPriority=3
	elseif curTType == GRASS or curTType == SNOW then
		set curTPriority=4
	elseif curTType == D_GRASS or curTType == SLOWICE then
		set curTPriority=5
	elseif curTType == LEAVES or curTType == MEDIUMICE then
		set curTPriority=6
	elseif curTType == FASTICE then
		set curTPriority=7
	else //if curTType == VINES or curTType == SAND or curTType == RSNOW then
		set curTPriority=2
	endif
//end of: GetTerrainPriority("curTType", "curTPriority")
//textmacro instance: UpdatePriorityTerrain("curTType", "curTPriority", "bestTType", "bestTPriority")
	if curTPriority > bestTPriority then
		set bestTPriority=curTPriority
		set bestTType=curTType
	endif
//end of: UpdatePriorityTerrain("curTType", "curTPriority", "bestTType", "bestTPriority")
		
	return bestTType
endfunction

function HeroKill takes integer user returns nothing
    //call DisplayTextToForce(bj_FORCE_PLAYER[user], "Dead")
    call TerrainDeathEffect(s__MazersArray[user])
    
    //call KillUnit(MazersArray[user])
    call sc__User_SwitchGameModesDefaultLocation(user,Teams_GAMEMODE_DYING)
endfunction

function GameLoopRemoveTerrainAction takes unit u,integer i,integer oldterrain,integer curterrain returns nothing
    local real r
    //call DisplayTextToForce(bj_FORCE_PLAYER[i], "Removing: " + I2S(oldterrain) + " Adding: " + I2S(curterrain))
    
    if oldterrain == FASTICE then
        set s__CanSteer[i]= false
        call IceMovement_Remove(s__MazersArray[i])
        
        if curterrain == SNOW or curterrain == SAND or curterrain == RSNOW then
        
        elseif curterrain == SLOWICE then
            //set r = SquareRoot(RAbsBJ(VelocityX[i] * VelocityX[i] + VelocityY[i] * VelocityY[i]))            
            set s__VelocityX[i]= s__VelocityX[i] + ( FastIceSpeed - SlowIceSpeed ) * Cos(GetUnitFacing(u) / 180 * bj_PI)
            set s__VelocityY[i]= s__VelocityY[i] + ( FastIceSpeed - SlowIceSpeed ) * Sin(GetUnitFacing(u) / 180 * bj_PI)
        elseif curterrain == MEDIUMICE then
            set s__VelocityX[i]= s__VelocityX[i] + ( FastIceSpeed - MediumIceSpeed ) * Cos(GetUnitFacing(u) / 180 * bj_PI)
            set s__VelocityY[i]= s__VelocityY[i] + ( FastIceSpeed - MediumIceSpeed ) * Sin(GetUnitFacing(u) / 180 * bj_PI)
        else
            set s__VelocityX[i]= 0
            set s__VelocityY[i]= 0
        endif
    elseif oldterrain == MEDIUMICE then
        set s__CanSteer[i]= false
        call IceMovement_Remove(s__MazersArray[i])
                
        if curterrain == SNOW or curterrain == SAND or curterrain == RSNOW then
            //velocity carries over to sand, so do nothing
//        elseif (curterrain == RSNOW) then
//            set r = SquareRoot(RAbsBJ(VelocityX[i] * VelocityY[i]))
//            set VelocityX[i] = r * Cos(GetUnitFacing(u)/180*bj_PI)
//            set VelocityY[i] = r * Sin(GetUnitFacing(u)/180*bj_PI)
        elseif curterrain == SLOWICE then
            //set r = SquareRoot(RAbsBJ(VelocityX[i] * VelocityX[i] + VelocityY[i] * VelocityY[i]))            
            set s__VelocityX[i]= s__VelocityX[i] + ( MediumIceSpeed - SlowIceSpeed ) * Cos(GetUnitFacing(u) / 180 * bj_PI)
            set s__VelocityY[i]= s__VelocityY[i] + ( MediumIceSpeed - SlowIceSpeed ) * Sin(GetUnitFacing(u) / 180 * bj_PI)
        elseif curterrain == FASTICE then
            set s__VelocityX[i]= s__VelocityX[i] + ( MediumIceSpeed - FastIceSpeed ) * Cos(GetUnitFacing(u) / 180 * bj_PI)
            set s__VelocityY[i]= s__VelocityY[i] + ( MediumIceSpeed - FastIceSpeed ) * Sin(GetUnitFacing(u) / 180 * bj_PI)
        else
            set s__VelocityX[i]= 0
            set s__VelocityY[i]= 0
        endif
    elseif oldterrain == SLOWICE then
        set s__CanSteer[i]= false
        call IceMovement_Remove(s__MazersArray[i])
             
        if curterrain == SNOW or curterrain == SAND or curterrain == RSNOW or curterrain == MEDIUMICE or curterrain == FASTICE then
            //velocity carries over to sand, so do nothing
//        elseif (curterrain == RSNOW) then
//            set r = SquareRoot(RAbsBJ(VelocityX[i] * VelocityY[i]))
//            set VelocityX[i] = r * Cos(GetUnitFacing(u)/180*bj_PI)
//            set VelocityY[i] = r * Sin(GetUnitFacing(u)/180*bj_PI)
        elseif curterrain == MEDIUMICE then
            //set r = SquareRoot(RAbsBJ(VelocityX[i] * VelocityX[i] + VelocityY[i] * VelocityY[i]))            
            set s__VelocityX[i]= s__VelocityX[i] + ( SlowIceSpeed - MediumIceSpeed ) * Cos(GetUnitFacing(u) / 180 * bj_PI)
            set s__VelocityY[i]= s__VelocityY[i] + ( SlowIceSpeed - MediumIceSpeed ) * Sin(GetUnitFacing(u) / 180 * bj_PI)
        elseif curterrain == FASTICE then
            set s__VelocityX[i]= s__VelocityX[i] + ( SlowIceSpeed - FastIceSpeed ) * Cos(GetUnitFacing(u) / 180 * bj_PI)
            set s__VelocityY[i]= s__VelocityY[i] + ( SlowIceSpeed - FastIceSpeed ) * Sin(GetUnitFacing(u) / 180 * bj_PI)
        else
            set s__VelocityX[i]= 0
            set s__VelocityY[i]= 0
        endif
    elseif oldterrain == GRASS or oldterrain == D_GRASS or oldterrain == ROAD then
        call SetUnitMoveSpeed(u, DefaultMoveSpeed)
	elseif oldterrain == VINES then
		call SetUnitMoveSpeed(u, DefaultMoveSpeed)
		
		call sc__User_ClearActiveEffect((i))
    elseif oldterrain == SAND then
		call s__SandMovement_Remove(i)
		call SetUnitMoveSpeed(u, DefaultMoveSpeed)
		
		call sc__User_ClearActiveEffect((i))
        
        if curterrain == SNOW or curterrain == RSNOW or curterrain == SLOWICE or curterrain == MEDIUMICE or curterrain == FASTICE then
            //velocity carries over to snow
        else
            set s__VelocityX[i]= 0
            set s__VelocityY[i]= 0
        endif
        //call DisplayTextToForce(bj_FORCE_PLAYER[i], R2S(VelocityX[i]))
        //call DisplayTextToForce(bj_FORCE_PLAYER[i], R2S(VelocityY[i]))
    elseif oldterrain == SNOW then
        set s__CanSteer[i]= false
        call s__SnowMovement_Remove(u)
        
        if curterrain == SAND or curterrain == RSNOW or curterrain == SLOWICE or curterrain == MEDIUMICE or curterrain == FASTICE then
            //velocity carries over to sand, so do nothing
//        elseif (curterrain == RSNOW) then
//            set r = SquareRoot(RAbsBJ(VelocityX[i] * VelocityY[i]))
//            set VelocityX[i] = r * Cos(GetUnitFacing(u)/180*bj_PI)
//            set VelocityY[i] = r * Sin(GetUnitFacing(u)/180*bj_PI)
        else
            set s__VelocityX[i]= 0
            set s__VelocityY[i]= 0
        endif
        
        //call DisplayTextToForce(bj_FORCE_PLAYER[i], "P" + I2S(i) + "X: " + R2S(VelocityX[i]))
        //call DisplayTextToForce(bj_FORCE_PLAYER[i], "Y: " + R2S(VelocityY[i]))
    elseif oldterrain == RSNOW then
        set s__CanSteer[i]= false
        
        call s__RSnowMovement_Remove(u)
        
        if ( curterrain == SAND or curterrain == SNOW or curterrain == SLOWICE or curterrain == MEDIUMICE or curterrain == FASTICE ) then
            //velocity carries over to sand/snow, so do nothing
        else
            set s__VelocityX[i]= 0
            set s__VelocityY[i]= 0
        endif
        
        //call DisplayTextToForce(bj_FORCE_PLAYER[i], "P" + I2S(i) + "X: " + R2S(VelocityX[i]))
        //call DisplayTextToForce(bj_FORCE_PLAYER[i], "Y: " + R2S(VelocityY[i]))
    elseif oldterrain == LAVA then
        call s__LavaDamage_Remove(i)
		
		call sc__User_ClearActiveEffect((i))
    elseif oldterrain == LEAVES then
        call s__SuperFastMovement_Remove(i)
        
        call SetUnitMoveSpeed(u, DefaultMoveSpeed)
    elseif oldterrain == LRGBRICKS then
        //should do nothing
    elseif oldterrain == RTILE then
        //call RotationCameras[i].cPause()
        set s__UseTeleportMovement[i]= false
    endif
endfunction

function GameLoop takes nothing returns nothing
	//the loop for the map which periodically (every .05 seconds) checks the position of every playing mazing unit versus the types of terrain
	//which have effects
 local integer curUserNode= s__SimpleList_List_first[StandardMazingUsers]
 local integer user
 local unit u
    
    local real x
    local real y
    local integer previousterrain
    
    local real facingRad
   
    //flattened version of newTerrainCheckAdvancedFlexible(x, y, ABYSS, user)  
 local integer basicterrain
    local integer terrainCenterPoint
	
	loop
	exitwhen curUserNode == 0
		set user=(s__SimpleList_ListNode_value[curUserNode])
		
		if s__User_GameMode[user] == Teams_GAMEMODE_STANDARD then
			set u=s__User_ActiveUnit[user]
			set x=GetUnitX(u)
			set y=GetUnitY(u)
			set previousterrain=s__PreviousTerrainTypedx[user]
			
			//flattened version of newTerrainCheckAdvancedFlexible(x, y, ABYSS, user)  
			set basicterrain=GetBestTerrainForPoint(x , y)



			
			//if on abyss, then try to get the next nearest terrain
			if not s__AbyssImmune[user] and basicterrain == ABYSS then
				call HeroKill(user)
				return //skip remaining actions -- the player died lol
			endif
			
			//if last step in Gameloop had the same terrain as this step, nothing needs to be changed
			//otherwise proceed with GameLoopNewTerrainAction actions
			//always remove the old effect before adding a new one
			if previousterrain != basicterrain and basicterrain != ABYSS then



				
				//remove the previous terrain effect before applying a new one
				call GameLoopRemoveTerrainAction(u , user , previousterrain , basicterrain)
								
				//apply new terrain logic
				if ( basicterrain == FASTICE ) then
					set s__CanSteer[user]= true
					set s__SkateSpeed[user]= FastIceSpeed
					
					call IceMovement_Add(s__MazersArray[user])
				elseif ( basicterrain == MEDIUMICE ) then
					set s__CanSteer[user]= true
					set s__SkateSpeed[user]= MediumIceSpeed
					
					call IceMovement_Add(s__MazersArray[user])
				elseif ( basicterrain == SLOWICE ) then
					set s__CanSteer[user]= true
					set s__SkateSpeed[user]= SlowIceSpeed
					
					call IceMovement_Add(s__MazersArray[user])
				elseif ( basicterrain == VINES ) then
					call SetUnitMoveSpeed(u, SlowGrassSpeed)
					
					call sc__User_SetActiveEffect(user,StandardGameLoop_VINES_MOVEMENT_FX , "origin")
				elseif ( basicterrain == GRASS ) then
					call SetUnitMoveSpeed(u, MediumGrassSpeed)
				elseif ( basicterrain == D_GRASS ) then
					call SetUnitMoveSpeed(u, FastGrassSpeed)
				elseif ( basicterrain == RTILE ) then
					//call DisplayTextToForce(bj_FORCE_PLAYER[user], "R Tiles")
					//call RotationCameras[user].cUnpause()
					//functionality defined within Ice.isMoving
					set s__UseTeleportMovement[user]= true
					set terrainCenterPoint=GetTerrainCenterpoint(x , y)
					call SetUnitX(u, s__vector2_x[terrainCenterPoint])
					call SetUnitY(u, s__vector2_y[terrainCenterPoint])
					call IssueImmediateOrder(u, "stop")
					
					call s__vector2_deallocate((terrainCenterPoint)) // INLINED!!
				elseif ( basicterrain == SAND ) then
					//call DisplayTextToForce(bj_FORCE_PLAYER[user], "On Sand")
					call s__SandMovement_Add(user)
					call SetUnitMoveSpeed(u, SandMovement_MOVESPEED)
					
					//momentum going onto sand from regular ice (do momentum ice later)
					if ( previousterrain == FASTICE or previousterrain == MEDIUMICE or previousterrain == SLOWICE ) then
						set facingRad=( GetUnitFacing(u) / 180 ) * bj_PI
						
						set s__VelocityX[user]= Cos(facingRad) * s__SkateSpeed[user] * ICE2MOMENTUMFACTOR
						set s__VelocityY[user]= Sin(facingRad) * s__SkateSpeed[user] * ICE2MOMENTUMFACTOR
					endif
					
					// if isMoving[user] or XVelocity[user] != 0 or YVelocity[user] != 0 then
						// call user.SetActiveEffect(SAND_MOVEMENT_FX, "origin")
					// endif
				elseif ( basicterrain == SNOW ) then
					set s__CanSteer[user]= true
					call s__SnowMovement_Add(u)
					
					//momentum going onto sand from regular ice (do momentum ice later)
					if ( previousterrain == FASTICE or previousterrain == MEDIUMICE or previousterrain == SLOWICE ) then
						set facingRad=( GetUnitFacing(u) / 180 ) * bj_PI
						set s__VelocityX[user]= Cos(facingRad) * s__SkateSpeed[user] * ICE2MOMENTUMFACTOR
						set s__VelocityY[user]= Sin(facingRad) * s__SkateSpeed[user] * ICE2MOMENTUMFACTOR
					endif
				elseif basicterrain == RSNOW then
					//call DisplayTextToForce(bj_FORCE_PLAYER[user], "On RSnow")
					set s__CanSteer[user]= true
					
					call s__RSnowMovement_Add(u)
					
					//momentum going onto sand from regular ice (do momentum ice later)
					if previousterrain == FASTICE or previousterrain == MEDIUMICE or previousterrain == SLOWICE then
						set s__VelocityX[user]= Cos(s__RSFacing[user]) * s__SkateSpeed[user] * ICE2MOMENTUMFACTOR
						set s__VelocityY[user]= Sin(s__RSFacing[user]) * s__SkateSpeed[user] * ICE2MOMENTUMFACTOR
					endif
				elseif basicterrain == LAVA then
					//call DisplayTextToForce(bj_FORCE_PLAYER[user], "Lava")
					call s__LavaDamage_Add(user)
					
					call sc__User_SetActiveEffect(user,StandardGameLoop_LAVA_MOVEMENT_FX , "origin")
				elseif basicterrain == LEAVES then
					call SetUnitMoveSpeed(u, FastGrassSpeed)
					
					call s__SuperFastMovement_Add(user)
				elseif basicterrain == LRGBRICKS then
					call DestroyEffect(AddSpecialEffect(StandardGameLoop_PLATFORMING_FX, GetUnitX(s__User_ActiveUnit[user]), GetUnitY(s__User_ActiveUnit[user])))
					
					call sc__User_SwitchGameModesDefaultLocation(user,Teams_GAMEMODE_PLATFORMING)
				elseif basicterrain == ROAD then
					call SetUnitMoveSpeed(u, RoadSpeed)
				endif
				
				set s__PreviousTerrainTypedx[user]= basicterrain
			endif
		endif
	set curUserNode=s__SimpleList_ListNode_next[curUserNode]
	endloop
endfunction


//===========================================================================

function StandardGameLoop___init takes nothing returns nothing
	call TimerStart(StandardGameLoop_GameLoopTimer, StandardGameLoop___TIMESTEP, true, function GameLoop)
endfunction


//library StandardGameLoop ends
//library Platformer:


        
        //all properties that support code mechanics
        //public effect         FX                   //any visual effect needed for the platformer -- this shit was useless
        
        //all properties that support physics
        
        //TODO replace X and Y falloff with references to easing functions
        //public real          VelMoveSpeedOffset   //how much trying to oppose your velocity 
        
        //all properties that support terrain mechanics
        
        
		
        //static properties shared among all platformers/players (1:1 platformer per player)
        //static integer ActivePlatformers //same as List's .count, with how it's used
        //TODO add a unit group of platformer units to enum through to bypass the WC3 operations limit OR give each platformer their own timer and stagger them
        
		
//Implemented from module Alloc:
		
		

			

		
		
  function s__Platformer_allocate takes nothing returns integer
   local integer this= s__Platformer_Alloc___recycler[0]
			


			
			if ( s__Platformer_Alloc___recycler[this] == 0 ) then
				set s__Platformer_Alloc___recycler[0]=this + 1
			else
				set s__Platformer_Alloc___recycler[0]=s__Platformer_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__Platformer_deallocate takes integer this returns nothing


			


			
			set s__Platformer_Alloc___recycler[this]=s__Platformer_Alloc___recycler[0]
			set s__Platformer_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__Platformer_Alloc___onInit takes nothing returns nothing
			set s__Platformer_Alloc___recycler[0]=1
  endfunction
        
        function s__Platformer_IsPointInQuadrant takes real x,real y,integer diagonal returns boolean
            local real diffCenter
            //because position in a quadrant is a function of x, the query for whether a quadrant has changed must be only determined by x. including y leads to unexpected results, due to y not always following the exact same start point            
            if s__ComplexTerrainPathingResult_TerrainPathingForPoint[diagonal] == ComplexTerrainPathing_Left or s__ComplexTerrainPathingResult_TerrainPathingForPoint[diagonal] == ComplexTerrainPathing_Right then
                set diffCenter=y - s__ComplexTerrainPathingResult_TerrainMidpointY[diagonal]
                
                if ( diffCenter >= 0 and diffCenter <= TERRAIN_QUADRANT_SIZE ) or ( diffCenter < 0 and - diffCenter < TERRAIN_QUADRANT_SIZE ) then
                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Within same tile")                    
                    if s__ComplexTerrainPathingResult_QuadrantForPoint[diagonal] == ComplexTerrainPathing_NE and y >= s__ComplexTerrainPathingResult_TerrainMidpointY[diagonal] then
                        return true
                    elseif s__ComplexTerrainPathingResult_QuadrantForPoint[diagonal] == ComplexTerrainPathing_SE and y < s__ComplexTerrainPathingResult_TerrainMidpointY[diagonal] then
                        return true
                    elseif s__ComplexTerrainPathingResult_QuadrantForPoint[diagonal] == ComplexTerrainPathing_SW and y < s__ComplexTerrainPathingResult_TerrainMidpointY[diagonal] then
                        return true
                    elseif s__ComplexTerrainPathingResult_QuadrantForPoint[diagonal] == ComplexTerrainPathing_NW and y >= s__ComplexTerrainPathingResult_TerrainMidpointY[diagonal] then
                        return true
                    endif
                endif
            else
                set diffCenter=x - s__ComplexTerrainPathingResult_TerrainMidpointX[diagonal]
                
                if ( diffCenter >= 0 and diffCenter <= TERRAIN_QUADRANT_SIZE ) or ( diffCenter < 0 and - diffCenter < TERRAIN_QUADRANT_SIZE ) then
                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Within same tile")                    
                    if s__ComplexTerrainPathingResult_QuadrantForPoint[diagonal] == ComplexTerrainPathing_NE and x >= s__ComplexTerrainPathingResult_TerrainMidpointX[diagonal] then
                        return true
                    elseif s__ComplexTerrainPathingResult_QuadrantForPoint[diagonal] == ComplexTerrainPathing_SE and x >= s__ComplexTerrainPathingResult_TerrainMidpointX[diagonal] then
                        return true
                    elseif s__ComplexTerrainPathingResult_QuadrantForPoint[diagonal] == ComplexTerrainPathing_SW and x < s__ComplexTerrainPathingResult_TerrainMidpointX[diagonal] then
                        return true
                    elseif s__ComplexTerrainPathingResult_QuadrantForPoint[diagonal] == ComplexTerrainPathing_NW and x < s__ComplexTerrainPathingResult_TerrainMidpointX[diagonal] then
                        return true
                    endif
                endif
            endif
            
            return false
        endfunction
                
        //assuming that the point has been checked to escape the diagonal, and has been projected along the current one, there are only a few options left for where it could go next
        //there are only 3-4 possibilities for the next diagonal that should make this check less expensive than the full ComplexTerrainPathing_GetPathingForPoint check
        //corner piece: diagonal ends, continues as-is, or turns 45deg up or down
        //straight edge piece: continues as-is, or turns 45deg up or down
        function s__Platformer_GetNextDiagonal takes integer currentDiagonal,real currentX,real currentY,integer newPosition returns integer
            local integer ttype
            
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "CurrentX, Y: " + R2S(currentX) + ", " + R2S(currentY) + "; NewX, Y" + R2S(newPosition.x) + ", " + R2S(newPosition.y))
            
            //local integer ttypeY
            //are we still within the same quadrant?
            if s__Platformer_IsPointInQuadrant(currentX + s__vector2_x[newPosition] , currentY + s__vector2_y[newPosition] , currentDiagonal) then
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Point in quadrant")
                //then reuse same pathing info
                return currentDiagonal
            //does the diagonal continue
            //otherwise need to find new diagonal if any
            else //we've changed quadrants
                //this assumes that the next diagonal will be in an adjacent quadrant to this one
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "CurrentX, Y: " + R2S(currentX) + ", " + R2S(currentY) + "; NewX, Y" + R2S(currentX + newPosition.x) + ", " + R2S(currentY + newPosition.y))
                
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Quadrant " + I2S(currentDiagonal.QuadrantForPoint) + " has changed, getting next diagonal from: " + I2S(currentDiagonal.TerrainPathingForPoint))
                
                //change currentX and currentY to be center points for consistency
                set currentX=s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal]
                set currentY=s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal]
                
                //step 1: determine terrain center point for new point
                //step 2: determine which adjacent quadrant the new point is in, based on the possibilities for the current diagonal
                //step 3: determine what the diagonal type is for that quadrant of the new point's tile
                
                //get the center coordinates for the tile containing (x,y)
                //are there any differences if the centerpoint remains the same?
                    //know what the tiles around the previous quadrant looked like -- at least one of those tiles will still be relevant                
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Finding next diagonal from : " + I2S(currentDiagonal.TerrainPathingForPoint))
                
                if s__ComplexTerrainPathingResult_TerrainPathingForPoint[currentDiagonal] == ComplexTerrainPathing_Left then
                    //platformer movement will only be vertical at this point. if horizontal was big enough, they would have escaped the diagonal and been back on standard pathing
                    if s__vector2_y[newPosition] > 0 then
                        //moved up a quadrant
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Moved up from quadrant: " + I2S(currentDiagonal.QuadrantForPoint))
                        
                        if s__ComplexTerrainPathingResult_QuadrantForPoint[currentDiagonal] == ComplexTerrainPathing_NW then
                            //top left
                            //only 2 possibilites: bottom or more left wall
                            if TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY + TERRAIN_TILE_SIZE)) then
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "right top 1")
                                if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(currentX, currentY + TERRAIN_TILE_SIZE)) then
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Left , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] + TERRAIN_TILE_SIZE , ComplexTerrainPathing_SW , GetTerrainType(currentX, currentY + TERRAIN_TILE_SIZE) , 0)
                                else
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Square , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] + TERRAIN_TILE_SIZE , ComplexTerrainPathing_SW , GetTerrainType(currentX, currentY + TERRAIN_TILE_SIZE) , 0)
                                endif
                            else
                                //for this to be right wall on the NW quad, this tile would need to be square
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Square , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] - TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] + TERRAIN_TILE_SIZE , ComplexTerrainPathing_SE , 0 , GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY + TERRAIN_TILE_SIZE))
                            endif
                        else
                            //bottom left
                           //3 possibilites: top, NW (up), NE (down)
                            if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY + TERRAIN_TILE_SIZE)) then
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_SW , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] - TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NE , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY + TERRAIN_TILE_SIZE))
                            elseif TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX, currentY + TERRAIN_TILE_SIZE)) then
                                //check if platformer is going too fast to stick to this diagonal change -- ie return down or return 0 for no diag
                                if s__vector2_y[newPosition] >= DIAGONAL_STICKYDISTANCE then
                                    return 0
                                else
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_NW , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NW , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal])
                                endif
                            else
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Left , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NW , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , 0)
                            endif
                        endif
                    else
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Moved down from quadrant: " + I2S(currentDiagonal.QuadrantForPoint))
                        //moved down a quadrant
                        if s__ComplexTerrainPathingResult_QuadrantForPoint[currentDiagonal] == ComplexTerrainPathing_NW then
                            //top left
                            //3 possibilites: more left, NE, SE           
                            if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY - TERRAIN_TILE_SIZE)) then
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Left - NW")
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_NW , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] - TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SE , GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY - TERRAIN_TILE_SIZE) , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal])
                            elseif TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX, currentY - TERRAIN_TILE_SIZE)) then
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Left - SW")
                                
                                //check if platformer is going too fast to stick to this diagonal change -- ie return down or return 0 for no diag
                                if - s__vector2_y[newPosition] >= DIAGONAL_STICKYDISTANCE then
                                    return 0
                                else
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_SW , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SW , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal])
                                endif
                            else
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Left - Left")
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Left , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SW , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , 0)
                            endif
                        else
                            //bottom left
                           //only 2 possibilites: wall or more left
                            if TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY - TERRAIN_TILE_SIZE)) then
                                //top
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "left top 2")
                                if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(currentX, currentY - TERRAIN_TILE_SIZE)) then
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Left , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] - TERRAIN_TILE_SIZE , ComplexTerrainPathing_NW , GetTerrainType(currentX, currentY - TERRAIN_TILE_SIZE) , 0)
                                else
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Square , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] - TERRAIN_TILE_SIZE , ComplexTerrainPathing_NW , GetTerrainType(currentX, currentY - TERRAIN_TILE_SIZE) , 0)
                                endif
                            else
                                //square
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Square , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] - TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] - TERRAIN_TILE_SIZE , ComplexTerrainPathing_NE , 0 , GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY - TERRAIN_TILE_SIZE))
                            endif
                        endif
                    endif
                elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[currentDiagonal] == ComplexTerrainPathing_Right then
                    //platformer movement will only be vertical at this point. if horizontal was big enough, they would have escaped the diagonal and been back on standard pathing
                    //have we moved up or down a quadrant?
                    if s__vector2_y[newPosition] > 0 then
                        //moved right a quadrant
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Moved up from quadrant: " + I2S(currentDiagonal.QuadrantForPoint))
                        
                        if s__ComplexTerrainPathingResult_QuadrantForPoint[currentDiagonal] == ComplexTerrainPathing_NE then
                            //top right
                            //only 2 possibilites: bottom or more right wall
                            if TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY + TERRAIN_TILE_SIZE)) then
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "right top 1")
                                if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(currentX, currentY + TERRAIN_TILE_SIZE)) then
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Right , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] + TERRAIN_TILE_SIZE , ComplexTerrainPathing_SE , GetTerrainType(currentX, currentY + TERRAIN_TILE_SIZE) , 0)
                                else
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Square , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] + TERRAIN_TILE_SIZE , ComplexTerrainPathing_SE , GetTerrainType(currentX, currentY + TERRAIN_TILE_SIZE) , 0)
                                endif
                            else
                                //for this to be right wall on the NE quad, this tile would need to be square
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Square , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] + TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] + TERRAIN_TILE_SIZE , ComplexTerrainPathing_SW , 0 , GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY + TERRAIN_TILE_SIZE))
                            endif
                        else
                            //bottom right
                           //3 possibilites: top, NW (up), NE (down)                            
                            if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY + TERRAIN_TILE_SIZE)) then
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_SE , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] + TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NW , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY + TERRAIN_TILE_SIZE))
                            elseif TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX, currentY + TERRAIN_TILE_SIZE)) then
                                //check if platformer is going too fast to stick to this diagonal change -- ie return down or return 0 for no diag
                                if s__vector2_y[newPosition] >= DIAGONAL_STICKYDISTANCE then
                                    return 0
                                else
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_NE , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NE , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                                endif
                            else
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Right , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NE , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , 0)
                            endif
                        endif
                    else
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Moved down from quadrant: " + I2S(currentDiagonal.QuadrantForPoint))
                        //moved down a quadrant
                        if s__ComplexTerrainPathingResult_QuadrantForPoint[currentDiagonal] == ComplexTerrainPathing_NE then
                            //top right
                            //3 possibilites: more right, NE, SE           
                            if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY - TERRAIN_TILE_SIZE)) then
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Right - NE")
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_NE , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] + TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SW , GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY - TERRAIN_TILE_SIZE) , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                            elseif TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX, currentY - TERRAIN_TILE_SIZE)) then
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Right - SE")
                                if - s__vector2_y[newPosition] >= DIAGONAL_STICKYDISTANCE then
                                    return 0
                                else
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_SE , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SE , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                                endif
                            else
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Right - Right")
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Right , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SE , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , 0)
                            endif
                        else
                            //bottom right
                           //only 2 possibilites: wall or more right 
                            if TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY - TERRAIN_TILE_SIZE)) then
                                //top
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "left top 2")
                                if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(currentX, currentY - TERRAIN_TILE_SIZE)) then
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Right , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] - TERRAIN_TILE_SIZE , ComplexTerrainPathing_NE , GetTerrainType(currentX, currentY - TERRAIN_TILE_SIZE) , 0)
                                else
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Square , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] - TERRAIN_TILE_SIZE , ComplexTerrainPathing_NE , GetTerrainType(currentX, currentY - TERRAIN_TILE_SIZE) , 0)
                                endif
                            else
                                //square
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Square , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] + TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] - TERRAIN_TILE_SIZE , ComplexTerrainPathing_NW , 0 , GetTerrainType(currentX, currentY - TERRAIN_TILE_SIZE))
                            endif
                        endif
                    endif
                elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[currentDiagonal] == ComplexTerrainPathing_Top then
                    //have we moved left or right a quadrant?
                    if s__vector2_x[newPosition] > 0 then
                        //moved right a quadrant
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Moved right from quadrant: " + I2S(currentDiagonal.QuadrantForPoint))
                        
                        if s__ComplexTerrainPathingResult_QuadrantForPoint[currentDiagonal] == ComplexTerrainPathing_NE then
                            //top right
                            //only 2 possibilites: wall or more top
                            if TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY + TERRAIN_TILE_SIZE)) then
                                //top
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "right top 1")
                                if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] + TERRAIN_TILE_SIZE, s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal])) then
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Top , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] + TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NW , 0 , GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY))
                                else
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Square , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] + TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NW , 0 , GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY))
                                endif
                            else
                                //square
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Square , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] + TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] + TERRAIN_TILE_SIZE , ComplexTerrainPathing_SW , GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY + TERRAIN_TILE_SIZE) , 0)
                            endif
                        else
                            //top left
                           //3 possibilites: top, NW (up), NE (down)                            
                            if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY + TERRAIN_TILE_SIZE)) then
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Top - NW 1")
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_NW , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] + TERRAIN_TILE_SIZE , ComplexTerrainPathing_SE , GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY + TERRAIN_TILE_SIZE) , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                            elseif TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY)) then
                                //check if platformer is going too fast to stick to this diagonal change -- ie return down or return 0 for no diag
                                if s__vector2_x[newPosition] >= DIAGONAL_STICKYDISTANCE then
                                    return 0
                                else
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_NE , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NE , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal] , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                                endif
                            else
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Top , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NE , 0 , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                            endif
                        endif
                    else
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Moved left from quadrant: " + I2S(currentDiagonal.QuadrantForPoint))
                        //moved left a quadrant
                        if s__ComplexTerrainPathingResult_QuadrantForPoint[currentDiagonal] == ComplexTerrainPathing_NE then
                            //top left
                            //3 possibilites: top, NW (up), NE (down)                            
                            if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY + TERRAIN_TILE_SIZE)) then
                                //NE (up)
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_NE , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] + TERRAIN_TILE_SIZE , ComplexTerrainPathing_SW , GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY + TERRAIN_TILE_SIZE) , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                            elseif TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY)) then
                                //check if platformer is going too fast to stick to this diagonal change -- ie return down or return 0 for no diag
                                if - s__vector2_x[newPosition] >= DIAGONAL_STICKYDISTANCE then
                                    return 0
                                else
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_NW , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NW , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal] , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                                endif
                            else
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Top , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NW , 0 , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                            endif
                        else
                            //top left
                           //only 2 possibilites: wall or more top 
                            if TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY + TERRAIN_TILE_SIZE)) then
                                //top
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "left top 2")
                                if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] - TERRAIN_TILE_SIZE, s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal])) then
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Top , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] - TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NE , 0 , GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY))
                                else
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Square , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] - TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NE , 0 , GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY))
                                endif
                            else
                                //square
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Square , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] - TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] + TERRAIN_TILE_SIZE , ComplexTerrainPathing_SE , GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY + TERRAIN_TILE_SIZE) , 0)
                            endif
                        endif
                    endif
                elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[currentDiagonal] == ComplexTerrainPathing_Bottom then
                    //have we moved left or right a quadrant?
                    if s__vector2_x[newPosition] > 0 then
                        //moved right a quadrant
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Moved right from quadrant: " + I2S(currentDiagonal.QuadrantForPoint))
                        
                        if s__ComplexTerrainPathingResult_QuadrantForPoint[currentDiagonal] == ComplexTerrainPathing_SE then
                            //bottom right
                            //only 2 possibilites: wall or more bottom
                            if TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY - TERRAIN_TILE_SIZE)) then
                                //top
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "right top 1")
                                if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] + TERRAIN_TILE_SIZE, s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal])) then
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Bottom , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] + TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SW , 0 , GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY))
                                else
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Square , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] + TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SW , 0 , GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY))
                                endif
                            else
                                //square
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Square , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] + TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] - TERRAIN_TILE_SIZE , ComplexTerrainPathing_NW , GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY - TERRAIN_TILE_SIZE) , 0)
                            endif
                        else
                            //bottom left
                           //3 possibilites: bottom, NW (up), NE (down)                            
                            if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY - TERRAIN_TILE_SIZE)) then
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Bottom - SW 1")
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_SW , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] - TERRAIN_TILE_SIZE , ComplexTerrainPathing_NE , GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY - TERRAIN_TILE_SIZE) , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                            elseif TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY)) then
                                //check if platformer is going too fast to stick to this diagonal change -- ie return down or return 0 for no diag
                                if s__vector2_x[newPosition] >= DIAGONAL_STICKYDISTANCE then
                                    return 0
                                else
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_SE , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SE , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal] , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                                endif
                            else
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Bottom , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SE , 0 , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                            endif
                        endif
                    else
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Moved left from quadrant: " + I2S(currentDiagonal.QuadrantForPoint))
                        //moved left a quadrant
                        if s__ComplexTerrainPathingResult_QuadrantForPoint[currentDiagonal] == ComplexTerrainPathing_SE then
                            //bottom right
                            //3 possibilites: top, NW (up), NE (down)                            
                            if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY - TERRAIN_TILE_SIZE)) then
                                //NE (up)
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_SE , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] - TERRAIN_TILE_SIZE , ComplexTerrainPathing_NW , GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY - TERRAIN_TILE_SIZE) , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                            elseif TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY)) then
                                //check if platformer is going too fast to stick to this diagonal change -- ie return down or return 0 for no diag
                                if - s__vector2_x[newPosition] >= DIAGONAL_STICKYDISTANCE then
                                    return 0
                                else
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_SW , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SW , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal] , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                                endif
                            else
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Bottom , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SW , 0 , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                            endif
                        else
                            //bottom left
                           //only 2 possibilites: wall or more top 
                            if TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY - TERRAIN_TILE_SIZE)) then
                                //top
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "left top 2")
                                if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] - TERRAIN_TILE_SIZE, s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal])) then
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Bottom , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] - TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SE , 0 , GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY))
                                else
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Square , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] - TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SE , 0 , GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY))
                                endif
                            else
                                //square
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Square , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] - TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] - TERRAIN_TILE_SIZE , ComplexTerrainPathing_NE , GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY - TERRAIN_TILE_SIZE) , 0)
                            endif
                        endif
                    endif

                elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[currentDiagonal] == ComplexTerrainPathing_NE then
                    if s__vector2_x[newPosition] > 0 then
                        //4 options
                        //continue, left, right, top
                        //have we moved left or right a quadrant?

                        //moved right a quadrant
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Moved right from quadrant: " + I2S(currentDiagonal.QuadrantForPoint))
                        
                        if s__ComplexTerrainPathingResult_QuadrantForPoint[currentDiagonal] == ComplexTerrainPathing_NE then
                            //top right
                            //only 3 possibilites: continues, ends, or right wall 
                            
                            //only 3 possibilites: continues, ends, or flat 
                                                        
                            if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY - TERRAIN_TILE_SIZE)) then
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "NE 1")
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_NE , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] + TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SW , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                            elseif TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX, currentY - TERRAIN_TILE_SIZE)) then
                                return 0
                            else
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Right 1")
                                //right wall
                                if SquareRoot(s__vector2_x[newPosition] * s__vector2_x[newPosition] + s__vector2_y[newPosition] * s__vector2_y[newPosition]) >= DIAGONAL_STICKYDISTANCE then
									return 0
								else
									return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Right , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SE , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , 0)
								endif
                            endif
                        else //SW quadrant
                            //bottom left
                           //2 possibilites: diagonal continues or turns to top
                            if TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY)) then
                                if TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY - TERRAIN_TILE_SIZE)) then
                                    //TODO check if platformer is going too fast to stick to this diagonal change -- ie return down or return 0 for no diag
                                    //NE (down)
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "NE 2")
                                    set ttype=GetTerrainType(currentX, currentY - TERRAIN_TILE_SIZE)
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_NE , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] - TERRAIN_TILE_SIZE , ComplexTerrainPathing_NE , ttype , ttype)
                                else //going right, right tile not pathable. this will always be top
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Top 1")
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Top , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] - TERRAIN_TILE_SIZE , ComplexTerrainPathing_NE , 0 , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                                endif
                            else
                                if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY)) then
                                    //inside corner, in v shape
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_NW , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SE , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                                else
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Top , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] - TERRAIN_TILE_SIZE , ComplexTerrainPathing_NE , 0 , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                                endif
                                //return 0
                            endif
                        endif
                    else //x < 0
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Moved left from quadrant: " + I2S(currentDiagonal.QuadrantForPoint))
                        //moved left a quadrant                        
                        if s__ComplexTerrainPathingResult_QuadrantForPoint[currentDiagonal] == ComplexTerrainPathing_NE then
                            //top right
                            //only 3 possibilites: continues, ends, or flat 
                            if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY + TERRAIN_TILE_SIZE)) then
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "NE 3")
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_NE , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] + TERRAIN_TILE_SIZE , ComplexTerrainPathing_SW , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                            elseif TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY)) then
                                return 0
                            else
                                //top on same 128x128 tile
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Top 2")
								if SquareRoot(s__vector2_x[newPosition] * s__vector2_x[newPosition] + s__vector2_y[newPosition] * s__vector2_y[newPosition]) >= DIAGONAL_STICKYDISTANCE then
									return 0
								else
									return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Top , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NW , 0 , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
								endif
                            endif
                        else
                            //bottom left
                           //2 possibilites: diagonal continues or turns to left
                            if TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX, currentY + TERRAIN_TILE_SIZE)) then
                                if TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY + TERRAIN_TILE_SIZE)) then
                                    //TODO check if platformer is going too fast to stick to this diagonal change -- ie return down or return 0 for no diag
                                    //NE (down)
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "NE 4")
                                    set ttype=GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY)
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_NE , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] - TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NE , ttype , ttype)
                                else //going left, left tile not pathable. this will always be left wall
                                    //ttype can't be square because then this wouldn't be an inside diagonal
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Right 2")
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Right , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] - TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NE , GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY) , 0)
                                endif
                            else
                                if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(currentX, currentY + TERRAIN_TILE_SIZE)) then
                                    //inside corner, in < shape
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_SE , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NW , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                                else
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Right , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] - TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NE , GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY) , 0)
                                endif
                            endif
                        endif
                    endif
                    
                elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[currentDiagonal] == ComplexTerrainPathing_SE then
                    if s__vector2_x[newPosition] > 0 then
                        //moved right a quadrant
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Moved right from quadrant: " + I2S(currentDiagonal.QuadrantForPoint))
                        
                        if s__ComplexTerrainPathingResult_QuadrantForPoint[currentDiagonal] == ComplexTerrainPathing_SE then
                            //bottom right
                            //only 3 possibilites: continues, ends, or right wall 
                            
                            //only 3 possibilites: continues, ends, or flat 
                                                        
                            if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY + TERRAIN_TILE_SIZE)) then
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "NE 1")
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_SE , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] + TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NW , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                            elseif TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX, currentY + TERRAIN_TILE_SIZE)) then
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Zero 1")
                                return 0
                            else
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Right 1")
                                //right wall
								if SquareRoot(s__vector2_x[newPosition] * s__vector2_x[newPosition] + s__vector2_y[newPosition] * s__vector2_y[newPosition]) >= DIAGONAL_STICKYDISTANCE then
									return 0
								else
									return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Right , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NE , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , 0)
								endif
                            endif
                        else //NW quadrant
                            //bottom left
                           //2 possibilites: diagonal continues or turns to top
                            if TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY)) then
                                if TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY + TERRAIN_TILE_SIZE)) then
                                    //TODO check if platformer is going too fast to stick to this diagonal change -- ie return down or return 0 for no diag
                                    //NE (down)
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "NE 2")
                                    set ttype=GetTerrainType(currentX, currentY + TERRAIN_TILE_SIZE)
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_SE , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] + TERRAIN_TILE_SIZE , ComplexTerrainPathing_SE , ttype , ttype)
                                else //going right, right tile not pathable. this will always be top
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Top 1")
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Bottom , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] + TERRAIN_TILE_SIZE , ComplexTerrainPathing_SE , 0 , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                                endif
                            else
                                if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY)) then
                                    //inside corner, making ^ shape
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_SW , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NE , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                                else
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Bottom , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] + TERRAIN_TILE_SIZE , ComplexTerrainPathing_SE , 0 , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                                endif
                            endif
                        endif
                    else //x < 0
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Moved left from quadrant: " + I2S(currentDiagonal.QuadrantForPoint))
                        //moved left a quadrant                        
                        if s__ComplexTerrainPathingResult_QuadrantForPoint[currentDiagonal] == ComplexTerrainPathing_SE then
                            //bottom right
                            //only 3 possibilites: continues, ends, or flat 
                            if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY - TERRAIN_TILE_SIZE)) then
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "NE 3")
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_SE , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] - TERRAIN_TILE_SIZE , ComplexTerrainPathing_NW , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                            elseif TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY)) then
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Zero 2")
                                return 0
                            else
                                //top on same 128x128 tile
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Top 2")
								if SquareRoot(s__vector2_x[newPosition] * s__vector2_x[newPosition] + s__vector2_y[newPosition] * s__vector2_y[newPosition]) >= DIAGONAL_STICKYDISTANCE then
									return 0
								else
									return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Bottom , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SW , 0 , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
								endif
                            endif
                        else
                            //top left
                           //2 possibilites: diagonal continues or turns to left
                            if TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX, currentY - TERRAIN_TILE_SIZE)) then
                                if TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY - TERRAIN_TILE_SIZE)) then
                                    //TODO check if platformer is going too fast to stick to this diagonal change -- ie return down or return 0 for no diag
                                    //NE (down)
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "NE 4")
                                    set ttype=GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY)
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_SE , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] - TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SE , ttype , ttype)
                                else //going left, left tile not pathable. this will always be left wall
                                    //ttype can't be square because then this wouldn't be an inside diagonal
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Right 2")
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Right , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] - TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SE , GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY) , 0)
                                endif
                            else
                                if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(currentX, currentY - TERRAIN_TILE_SIZE)) then
                                    //inside corner, making < shape
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_NE , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SW , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                                else
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Right , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] - TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SE , GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY) , 0)
                                endif
                            endif
                        endif
                    endif
                    
                elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[currentDiagonal] == ComplexTerrainPathing_SW then
                    if s__vector2_x[newPosition] > 0 then
                        //moved right a quadrant
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Moved right from quadrant: " + I2S(currentDiagonal.QuadrantForPoint))
                        
                        if s__ComplexTerrainPathingResult_QuadrantForPoint[currentDiagonal] == ComplexTerrainPathing_SW then
                            //bottom right
                            //only 3 possibilites: continues, ends, or right wall 
                            
                            //only 3 possibilites: continues, ends, or flat 
                                                        
                            if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY - TERRAIN_TILE_SIZE)) then
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "NE 1")
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_SW , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] - TERRAIN_TILE_SIZE , ComplexTerrainPathing_NE , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                            elseif TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY)) then
                                return 0
                            else
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Right 1")
                                //right wall
								if SquareRoot(s__vector2_x[newPosition] * s__vector2_x[newPosition] + s__vector2_y[newPosition] * s__vector2_y[newPosition]) >= DIAGONAL_STICKYDISTANCE then
									return 0
								else
									return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Bottom , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SE , 0 , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
								endif
                            endif

                        else //NW quadrant
                            //bottom left
                           //2 possibilites: diagonal continues or turns to top
                            if TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX, currentY - TERRAIN_TILE_SIZE)) then
                                if TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY - TERRAIN_TILE_SIZE)) then
                                    //TODO check if platformer is going too fast to stick to this diagonal change -- ie return down or return 0 for no diag
                                    //NE (down)
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "NE 2")
                                    set ttype=GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY)
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_SW , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] + TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SW , ttype , ttype)
                                else //going right, right tile not pathable. this will always be top
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Top 1")
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Left , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] + TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SW , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , 0)
                                endif
                            else
                                if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(currentX, currentY - TERRAIN_TILE_SIZE)) then
                                    //inside corner, in > shape
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_NW , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SE , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                                    //return 0
                                else
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Left , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] + TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SW , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , 0)
                                endif
                            endif
                        endif
                    else //x < 0
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Moved left from quadrant: " + I2S(currentDiagonal.QuadrantForPoint))
                        //moved left a quadrant                        
                        if s__ComplexTerrainPathingResult_QuadrantForPoint[currentDiagonal] == ComplexTerrainPathing_SW then
                            //top right
                            //only 3 possibilites: continues, ends, or flat 
                            if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY + TERRAIN_TILE_SIZE)) then
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "NE 3")
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_SW , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] - TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NE , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                            elseif TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX, currentY + TERRAIN_TILE_SIZE)) then
                                return 0
                            else
                                //top on same 128x128 tile
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Top 2")
								if SquareRoot(s__vector2_x[newPosition] * s__vector2_x[newPosition] + s__vector2_y[newPosition] * s__vector2_y[newPosition]) >= DIAGONAL_STICKYDISTANCE then
									return 0
								else
									return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Left , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NW , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , 0)
								endif
                            endif
                        else
                            //bottom left
                           //2 possibilites: diagonal continues or turns to left
                            if TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY)) then
                                if TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY + TERRAIN_TILE_SIZE)) then
                                    //TODO check if platformer is going too fast to stick to this diagonal change -- ie return down or return 0 for no diag
                                    //NE (down)
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "NE 4")
                                    set ttype=GetTerrainType(currentX, currentY + TERRAIN_TILE_SIZE)
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_SW , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] + TERRAIN_TILE_SIZE , ComplexTerrainPathing_SW , ttype , ttype)
                                else //going left, left tile not pathable. this will always be left wall
                                    //ttype can't be square because then this wouldn't be an inside diagonal
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Right 2")
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Bottom , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] + TERRAIN_TILE_SIZE , ComplexTerrainPathing_SW , 0 , GetTerrainType(currentX, currentY + TERRAIN_TILE_SIZE))
                                endif
                            else
                                if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY)) then
                                    //inside corner, in ^ shape
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_SE , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NW , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                                else
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Bottom , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] + TERRAIN_TILE_SIZE , ComplexTerrainPathing_SW , 0 , GetTerrainType(currentX, currentY + TERRAIN_TILE_SIZE))
                                endif
                            endif
                        endif
                    endif
                
                elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[currentDiagonal] == ComplexTerrainPathing_NW then
                    //4 options
                    //continue, left, right, top
                    //have we moved left or right a quadrant?
                    if s__vector2_x[newPosition] > 0 then
                        //moved right a quadrant
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Moved right from quadrant: " + I2S(currentDiagonal.QuadrantForPoint))
                        
                        if s__ComplexTerrainPathingResult_QuadrantForPoint[currentDiagonal] == ComplexTerrainPathing_NW then
                            //top left
                            //only 3 possibilites: continues, ends, or top 
                            if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY + TERRAIN_TILE_SIZE)) then
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "NW 1")
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_NW , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] + TERRAIN_TILE_SIZE , ComplexTerrainPathing_SE , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                            elseif TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY)) then
                                return 0
                            else
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Top 1")
                                //top
								if SquareRoot(s__vector2_x[newPosition] * s__vector2_x[newPosition] + s__vector2_y[newPosition] * s__vector2_y[newPosition]) >= DIAGONAL_STICKYDISTANCE then
									return 0
								else
									return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Top , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NE , 0 , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
								endif
                            endif
                        else //SE quadrant
                           //2 possibilites: diagonal continues or turns to left
                            if TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX, currentY + TERRAIN_TILE_SIZE)) then
                                if TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY + TERRAIN_TILE_SIZE)) then
                                    //TODO check if platformer is going too fast to stick to this diagonal change -- ie return down or return 0 for no diag
                                    //NE (down)
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "NW 2")
                                    set ttype=GetTerrainType(currentX + TERRAIN_TILE_SIZE, currentY)
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_NW , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] + TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NW , ttype , ttype)
                                else //going right, right tile not pathable. this will always be a left wall
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Left 1")
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Left , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] + TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NW , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , 0)
                                endif
                            else
                                if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(currentX, currentY + TERRAIN_TILE_SIZE)) then
                                    //inside corner, in > shape
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_SW , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NE , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                                else
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Left , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] + TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_NW , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , 0)
                                endif
                                //return 0
                            endif
                        endif
                    else //x < 0
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Moved left from quadrant: " + I2S(currentDiagonal.QuadrantForPoint))
                        //moved left a quadrant                        
                        if s__ComplexTerrainPathingResult_QuadrantForPoint[currentDiagonal] == ComplexTerrainPathing_NW then
                            //top left
                            //only 3 possibilites: continues, ends, or left 
                            if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY - TERRAIN_TILE_SIZE)) then
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "NW 3")
                                return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_NW , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] - TERRAIN_TILE_SIZE , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SE , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                            elseif TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX, currentY - TERRAIN_TILE_SIZE)) then
                                return 0
                            else
                                //left on same 128x128 tile
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Left 2")
								if SquareRoot(s__vector2_x[newPosition] * s__vector2_x[newPosition] + s__vector2_y[newPosition] * s__vector2_y[newPosition]) >= DIAGONAL_STICKYDISTANCE then
									return 0
								else
									return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Left , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SW , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , 0)
								endif
                            endif
                        else
                            //bottom right
                           //2 possibilites: diagonal continues or turns to top
                            if TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY)) then
                                if TerrainGlobals_IsTerrainPathable(GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY - TERRAIN_TILE_SIZE)) then
                                    //TODO check if platformer is going too fast to stick to this diagonal change -- ie return down or return 0 for no diag
                                    //NE (down)
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "NE 4")
                                    set ttype=GetTerrainType(currentX, currentY - TERRAIN_TILE_SIZE)
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_NW , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] - TERRAIN_TILE_SIZE , ComplexTerrainPathing_NW , ttype , ttype)
                                else //going left, left tile not pathable. this will always be left wall
                                    //ttype can't be square because then this wouldn't be an inside diagonal
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Top 2")
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Top , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] - TERRAIN_TILE_SIZE , ComplexTerrainPathing_NW , 0 , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                                endif
                            else
                                if TerrainGlobals_IsTerrainDiagonal(GetTerrainType(currentX - TERRAIN_TILE_SIZE, currentY)) then
                                    //inside corner, in v shape
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_NE , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] , ComplexTerrainPathing_SW , s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[currentDiagonal] , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                                else
                                    return s__ComplexTerrainPathingResult_CreateComplex(ComplexTerrainPathing_Top , s__ComplexTerrainPathingResult_TerrainMidpointX[currentDiagonal] , s__ComplexTerrainPathingResult_TerrainMidpointY[currentDiagonal] - TERRAIN_TILE_SIZE , ComplexTerrainPathing_NW , 0 , s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[currentDiagonal])
                                endif
                                //return 0
                            endif
                        endif
                        
                    endif
                else
                endif
                
                return 0
            endif
        endfunction
        
        function s__Platformer_ProjectPositionAlongCurrentDiagonal takes integer currentDiagonal,integer newPosition returns nothing
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Projection before: " + R2S(newPosition.x) + "," + R2S(newPosition.y))
            
            if s__ComplexTerrainPathingResult_TerrainPathingForPoint[currentDiagonal] == ComplexTerrainPathing_Left then
                set s__vector2_x[newPosition]=0
            elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[currentDiagonal] == ComplexTerrainPathing_Right then
                set s__vector2_x[newPosition]=0
            elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[currentDiagonal] == ComplexTerrainPathing_Top then
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Top")
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Top Y midpoint: " + R2S(currentDiagonal.TerrainMidpointY))
                set s__vector2_y[newPosition]=0
            elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[currentDiagonal] == ComplexTerrainPathing_Bottom then
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Bottom")
                set s__vector2_y[newPosition]=0
            elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[currentDiagonal] == ComplexTerrainPathing_NE then
                call s__vector2_projectUnitVector(newPosition,ComplexTerrainPathing_SE_UnitVector)
            elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[currentDiagonal] == ComplexTerrainPathing_SE then
                call s__vector2_projectUnitVector(newPosition,ComplexTerrainPathing_NE_UnitVector)
            elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[currentDiagonal] == ComplexTerrainPathing_SW then
                call s__vector2_projectUnitVector(newPosition,ComplexTerrainPathing_NW_UnitVector)
            elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[currentDiagonal] == ComplexTerrainPathing_NW then
                call s__vector2_projectUnitVector(newPosition,ComplexTerrainPathing_SW_UnitVector)
            endif
            
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "after: " + R2S(newPosition.x) + "," + R2S(newPosition.y))
            
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Project Position Result: " + R2S(newPosition.x) + "," + R2S(newPosition.y))
        endfunction
                    
        function s__Platformer_DoesPointEscapeDiagonal takes integer diagonalType,real newX,real newY,real escapeDistance returns boolean
            local integer proj
            local integer orthogonal= ComplexTerrainPathing_GetUnitVectorForPathing(diagonalType)
            local boolean ret
            
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Does escape check: " + I2S(diagonalType))
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Orthogonal: " + orthogonal.toString())
            
            //SquareRoot(newX * newX + newY * newY) < DIAGONAL_NOMANUALESCAPEDISTANCE
            
            set proj=s__vector2_create(newX , newY)
            call s__vector2_projectUnitVector(proj,orthogonal)
            
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Escape check raw x: " + R2S(newX) + ", y: " + R2S(newY))
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Projected: " + proj.toString())
            
            //need to check direction!!! not enough that the length is big enough, if it's into the surface than that's burrowing not escaping!
            //first perform the least expensive check and make sure that the direction of the intended movement isn't into the surface of the diagonal
            //then see if the length of the projected vector is bigger than the supplied minimum escape distance
            //finally, check that the length of the original position change is less than the max distance before we can't manually escape the diagonal
            set ret=( ( diagonalType == ComplexTerrainPathing_Top and s__vector2_y[proj] >= 0 ) or ( diagonalType == ComplexTerrainPathing_Bottom and s__vector2_y[proj] < 0 ) or ( diagonalType == ComplexTerrainPathing_Right and s__vector2_x[proj] >= 0 ) or ( diagonalType == ComplexTerrainPathing_Left and s__vector2_x[proj] < 0 ) or ( diagonalType == ComplexTerrainPathing_NE and s__vector2_x[proj] >= 0 and s__vector2_y[proj] >= 0 ) or ( diagonalType == ComplexTerrainPathing_SE and s__vector2_x[proj] >= 0 and s__vector2_y[proj] < 0 ) or ( diagonalType == ComplexTerrainPathing_SW and s__vector2_x[proj] < 0 and s__vector2_y[proj] < 0 ) or ( diagonalType == ComplexTerrainPathing_NW and s__vector2_x[proj] < 0 and s__vector2_y[proj] >= 0 ) ) and SquareRoot(s__vector2_x[proj] * s__vector2_x[proj] + s__vector2_y[proj] * s__vector2_y[proj]) >= escapeDistance
            



			
            call s__vector2_deallocate((proj)) // INLINED!!
            
            return ret
        endfunction
        











        
        function s__Platformer_ApplyPhysics takes integer this returns nothing
            local real newX= 0
            local real newY= 0
            
            
   local real applyTimeDelta
            local real distance
            //local real angle
            
            local integer ttype
            local integer pathingResult= 0
            local integer newPosition
            
            local integer directionX
            local integer directionY
            
            






			
			//to apply physics properly over multiple, variable-length frames we need to keep track of % of physics already rendered during a single timer tick
			//the % of a single tick that should be applied in the current call, applyTimeDelta, should be factored once into all physical forces that are applied over time
			set applyTimeDelta=TimerGetElapsed(s__Platformer_GameloopTimer) / PlatformerGlobals_GAMELOOP_TIMESTEP - s__Platformer_PhysicsLoopDeltaApplied[this]
			




			
			if TimerGetElapsed(s__Platformer_GameloopTimer) == PlatformerGlobals_GAMELOOP_TIMESTEP then
				set s__Platformer_PhysicsLoopDeltaApplied[this]=0.
				



			else
				set s__Platformer_PhysicsLoopDeltaApplied[this]=s__Platformer_PhysicsLoopDeltaApplied[this] + applyTimeDelta
			endif
			
            //Handle forces that affect the x and/or y direction and need to be as accurate as possible
            //apply constant forces -- forces applied into newX and newY do not need to factor applyTimeDelta in, since it can be factored in once at the end to cover all individual forces (F = D*f1 + D*f2 ... => F = D*(f1+ f2 +...))
            //apply horizontal key state
            if s__Platformer_HorizontalAxisState[this] != 0 then
                if s__Platformer_OnDiagonal[this] then
                    if s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_Top or s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_Bottom then
                        set newX=s__Platformer_HorizontalAxisState[this] * s__Platformer_MoveSpeed[this]
                    elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_NE or s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_SW then
                        set newX=s__Platformer_HorizontalAxisState[this] * s__Platformer_MoveSpeed[this] * SIN_45
                        set newY=- s__Platformer_HorizontalAxisState[this] * s__Platformer_MoveSpeed[this] * SIN_45
                    elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_NW or s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_SE then
                        set newX=s__Platformer_HorizontalAxisState[this] * s__Platformer_MoveSpeed[this] * SIN_45
                        set newY=s__Platformer_HorizontalAxisState[this] * s__Platformer_MoveSpeed[this] * SIN_45
                    elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_Left or s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_Right then
                        //TODO try it with no effect on position when sticking to a diagonal vertical wall
                        set newX=s__Platformer_HorizontalAxisState[this] * s__Platformer_MoveSpeed[this]
                    endif
                else
                    set newX=s__Platformer_HorizontalAxisState[this] * s__Platformer_MoveSpeed[this]
                endif
            endif
            
            //TODO constant forces need to happen in the main physics loop, which is performance hungry, or can they go to a less performance needy timer?
            //apply constant X forces
            
            //apply constant Y forces
            //update Y velocity for gravity and wall pathing
			if s__Platformer_GravitationalAccel[this] != 0 then
				if s__Platformer_OnDiagonal[this] then
					//check that gravity is in direction of current surface
                    if not s__Platformer_DoesPointEscapeDiagonal(s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] , 0 , s__Platformer_GravitationalAccel[this] , 0.01) then
						//reuse newposition vector and project function for velocity
						//set newPosition = vector2.create(.XVelocity, .YVelocity)
                        set newPosition=s__vector2_create(0 , s__Platformer_GravitationalAccel[this])
						call s__Platformer_ProjectPositionAlongCurrentDiagonal(s__Platformer_DiagonalPathing[this] , newPosition)
						




                        
						//TODO check that magnitude to newPosition does not exceed magnitude of [.TerminalVelocityX, .TerminalVelocityY]
						//get angle either from diagonal, newPosition.x >= 0 or from vector calc
						//reuse distance as angle
						//set distance = newPosition.getAngleHorizontal()
						set s__Platformer_XVelocity[this]=s__Platformer_XVelocity[this] + s__vector2_x[newPosition]
						set s__Platformer_YVelocity[this]=s__Platformer_YVelocity[this] + s__vector2_y[newPosition]
						





                        
						call s__vector2_deallocate((newPosition)) // INLINED!!
					else
						if s__Platformer_GravitationalAccel[this] > 0 then //gravity up
							if s__Platformer_YVelocity[this] > 0 then //also going up
								if s__Platformer_GravitationalAccel[this] + s__Platformer_YVelocity[this] < s__Platformer_TerminalVelocityY[this] then //will adding gravity exceed terminal velocity
									set s__Platformer_YVelocity[this]=s__Platformer_YVelocity[this] + s__Platformer_GravitationalAccel[this] * applyTimeDelta
								endif
							else //gravity going up but velocity down
								set s__Platformer_YVelocity[this]=s__Platformer_YVelocity[this] + s__Platformer_GravitationalAccel[this] * applyTimeDelta
							endif
						else
							if s__Platformer_YVelocity[this] < 0 then //velocity also down
								if s__Platformer_GravitationalAccel[this] + s__Platformer_YVelocity[this] > - s__Platformer_TerminalVelocityY[this] then //will adding gravity exceed terminal velocity
									set s__Platformer_YVelocity[this]=s__Platformer_YVelocity[this] + s__Platformer_GravitationalAccel[this] * applyTimeDelta
								endif
							else
								set s__Platformer_YVelocity[this]=s__Platformer_YVelocity[this] + s__Platformer_GravitationalAccel[this] * applyTimeDelta
							endif
						endif
					endif
				else
					if s__Platformer_GravitationalAccel[this] > 0 then //gravity up
						if s__Platformer_YVelocity[this] > 0 then //also going up
							if s__Platformer_GravitationalAccel[this] + s__Platformer_YVelocity[this] < s__Platformer_TerminalVelocityY[this] then //will adding gravity exceed terminal velocity
								set s__Platformer_YVelocity[this]=s__Platformer_YVelocity[this] + s__Platformer_GravitationalAccel[this] * applyTimeDelta
							endif
						else //gravity going up but velocity down
							set s__Platformer_YVelocity[this]=s__Platformer_YVelocity[this] + s__Platformer_GravitationalAccel[this] * applyTimeDelta
						endif
					elseif s__Platformer_GravitationalAccel[this] < 0 then //gravity down
						if s__Platformer_YVelocity[this] < 0 then //velocity also down
							if s__Platformer_GravitationalAccel[this] + s__Platformer_YVelocity[this] > - s__Platformer_TerminalVelocityY[this] then //will adding gravity exceed terminal velocity
								set s__Platformer_YVelocity[this]=s__Platformer_YVelocity[this] + s__Platformer_GravitationalAccel[this] * applyTimeDelta
							endif
						else
							set s__Platformer_YVelocity[this]=s__Platformer_YVelocity[this] + s__Platformer_GravitationalAccel[this] * applyTimeDelta
						endif
					endif
				endif
			endif
			

            //apply X velocity
            set newX=newX + s__Platformer_XVelocity[this]
                         
            //apply y velocity
            set newY=newY + s__Platformer_YVelocity[this]
			 
			//update newX and newY based on % of current timestep fulfilled
			//this is relevant because apply physics is called after keyboard events, in order to maximize reactivity
			set newX=newX * applyTimeDelta
			set newY=newY * applyTimeDelta
			
            //check new x and/or y position for pathability and apply it dependingly
            if newX != 0 or newY != 0 then
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Change in position")
                if s__Platformer_OnDiagonal[this] then
                    //project newX and newY along the diagonal, sticking or releasing based on fun-syics logic
                    //step 1: check if newX / newY escape the current diagonal
                    //step 2a: if they do, leave the diagonal and switch back to normal path finding
                    //step 2: if they don't escape the diagonal, project newX and newY along the current diagonal
                    //step 3: check if the new location is part of a diagonal
                    //step 4a: if it's not, set on diagonal to false and switch back to normal path finding
                    //step 4b: if it's a different type of diagonal: adjust current physics values to fit new diagonal; push platformer to outside of diagonal; update diagonal
                    //step 4c: if it's the same type of diagonal, continue along it as they were
                    
                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "On diagonal") 
                    
                    //step 1: check if newX / newY escape the current diagonal
                    if s__Platformer_DoesPointEscapeDiagonal(s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] , newX , newY , DIAGONAL_ESCAPEDISTANCE * applyTimeDelta) then
                        //bound newX and newY if they're too big -- this needs to occur AFTER checking if point escapes diagonal, or else the result may be skewed towards any much larger value
						set distance=SquareRoot(newX * newX + newY * newY)
						if distance > PLATFORMING_MAXCHANGE then
							//boundedPercent = PLATFORMING_MAXCHANGE / distance
							
							set newX=newX * PLATFORMING_MAXCHANGE / distance
							set newY=newY * PLATFORMING_MAXCHANGE / distance
						endif
						
						//step 2a: if they do, leave the diagonal and switch back to normal path finding
						//platformer is allowed to escape the diagonal, now need to check if destination is legal
						
                        //this is way more intense then i need here, and i can't even handle any of the cases appropriately as things are setup now
                        //would a CheckAndApplyNewDiagonal(.DiagonalPathing, .XPosition, .YPosition, newX, newY) function make sense?
                        //set pathingResult = ComplexTerrainPathing_GetPathingForPoint(.XPosition + newX, .YPosition + newY)
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Escaping diagonal manually!")



                        
                        //i think this should always be 0 if the rest of the game is functioning properly
                        //NOTE: this would need to use the advanced path finding algorithm to work properly
                        set s__Platformer_OnDiagonal[this]=false
                        call s__ComplexTerrainPathingResult_destroy(s__Platformer_DiagonalPathing[this])
                        set s__Platformer_DiagonalPathing[this]=0
                        
                        set s__Platformer_PushedAgainstVector[this]=0
                        
                        //update unit position
                        //if checking anything, its not enough to check terrain type at destination position, because that assumes terrain will be square. given that starting on a diagonal tile, that definitely isn't the case...
                        //if you don't check complex pathing then you'll likely return the tile that you started on, if the point on diagonal was well inside of it
                        set pathingResult=ComplexTerrainPathing_GetPathingForPoint(s__Platformer_XPosition[this] + newX , s__Platformer_YPosition[this] + newY)
                        
                        //check if hitting empty space or somehow somewhere on the same tile
                        if pathingResult == 0 or ( s__ComplexTerrainPathingResult_TerrainMidpointX[pathingResult] == s__ComplexTerrainPathingResult_TerrainMidpointX[s__Platformer_DiagonalPathing[this]] and s__ComplexTerrainPathingResult_TerrainMidpointY[pathingResult] == s__ComplexTerrainPathingResult_TerrainMidpointY[s__Platformer_DiagonalPathing[this]] ) then



                            
                            set s__Platformer_XTerrainPushedAgainst[this]=0
                            set s__Platformer_XPosition[this]=s__Platformer_XPosition[this] + newX
                            call SetUnitX(s__Platformer_Unit[this], s__Platformer_XPosition[this])
                            
                            set s__Platformer_YTerrainPushedAgainst[this]=0
                            set s__Platformer_YPosition[this]=s__Platformer_YPosition[this] + newY
                            call SetUnitY(s__Platformer_Unit[this], s__Platformer_YPosition[this])
                        elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Left or s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Right then



                            
                            set s__Platformer_XTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]
                            if not TerrainGlobals_IsTerrainSoft(s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]) then



								
								if s__Platformer_XVelocity[this] >= VELOCITY_HARDSTOP_THRESHOLD or s__Platformer_XVelocity[this] <= - VELOCITY_HARDSTOP_THRESHOLD then
									call HardStopEffect(this , s__Platformer_XVelocity[this])
								endif
								
								set s__Platformer_XVelocity[this]=0
                            endif
                            
                            set s__Platformer_YTerrainPushedAgainst[this]=0
                            set s__Platformer_YPosition[this]=s__Platformer_YPosition[this] + newY
                            call SetUnitY(s__Platformer_Unit[this], s__Platformer_YPosition[this])
                        elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Top or s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Bottom then



                            
                            set s__Platformer_XTerrainPushedAgainst[this]=0
                            set s__Platformer_XPosition[this]=s__Platformer_XPosition[this] + newX
                            call SetUnitX(s__Platformer_Unit[this], s__Platformer_XPosition[this])
                            
                            set s__Platformer_YTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]
                            if not TerrainGlobals_IsTerrainSoft(s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]) then



                                
								if s__Platformer_YVelocity[this] >= VELOCITY_HARDSTOP_THRESHOLD or s__Platformer_YVelocity[this] <= - VELOCITY_HARDSTOP_THRESHOLD then
									call HardStopEffect(this , s__Platformer_YVelocity[this])
								endif
								
								set s__Platformer_YVelocity[this]=0
                            endif
                        else //if pathingResult.TerrainPathingForPoint == ComplexTerrainPathing_Square or <other> then                            





                            
                            call s__ComplexTerrainPathingResult_destroy(pathingResult)
                            set pathingResult=0
                        endif
                        //debug else
                        //    debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Warning, unhandled case for escaping a diagonal into an unpathable destination")
                        //endif
                    else
						//bound newX and newY if they're too big -- this needs to occur AFTER checking if point escapes diagonal, or else the result may be skewed towards any much larger value
						set distance=SquareRoot(newX * newX + newY * newY)
						if distance > PLATFORMING_MAXCHANGE then
							//boundedPercent = PLATFORMING_MAXCHANGE / distance
							
							set newX=newX * PLATFORMING_MAXCHANGE / distance
							set newY=newY * PLATFORMING_MAXCHANGE / distance
						endif
						
						//step 2: if they don't escape the diagonal, project newX and newY along the current diagonal
                        //project newX and newY along the current diagonal
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Projecting") 
                        
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Created") 
                        set newPosition=s__vector2_create(newX , newY)
                        call s__Platformer_ProjectPositionAlongCurrentDiagonal(s__Platformer_DiagonalPathing[this] , newPosition)
                        
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Here 1") 
                        
                        //TODO temporary fix until I've implemented raycasting
                        //limit projected position to have a maximum length
                        
						//TODO does this need to be done a 2nd time?
						
						
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Here 2") 
                        
                        //need to make sure projected vector still shows movement
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Updating diagonal position")
                        if s__vector2_x[newPosition] != 0 or s__vector2_y[newPosition] != 0 then
                            //step 3: check if the new location is part of a diagonal
							
							//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Center: " + R2S(.DiagonalPathing.TerrainMidpointX) + "," + R2S(.DiagonalPathing.TerrainMidpointY))
                            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Change: " + R2S(newPosition.x) + "," + R2S(newPosition.y))
                            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Destination: " + R2S(.XPosition + newPosition.x) + "," + R2S(.YPosition + newPosition.y))
                            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Velocity: " + R2S(.XVelocity) + "," + R2S(.YVelocity))
                            
                            set pathingResult=s__Platformer_GetNextDiagonal(s__Platformer_DiagonalPathing[this] , s__Platformer_XPosition[this] , s__Platformer_YPosition[this] , newPosition)
                            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Got next diag") 
                            
                            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Here 3") 
                            if s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] then
                                //if the diagonal remains the same, then its fine to use the projected position as-is















				
                                //the push vector also remains the same
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Diagonal continues")
                                //update unit position
                                set s__Platformer_XTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]
                                set s__Platformer_XPosition[this]=s__Platformer_XPosition[this] + s__vector2_x[newPosition]
                                call SetUnitX(s__Platformer_Unit[this], s__Platformer_XPosition[this])
                                
                                //orthogonal for diagonal didn't change
                                //set .PushedAgainstVector = .PushedAgainstVector
                                
                                set s__Platformer_YTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]
                                set s__Platformer_YPosition[this]=s__Platformer_YPosition[this] + s__vector2_y[newPosition]
                                call SetUnitY(s__Platformer_Unit[this], s__Platformer_YPosition[this])
                                
                                if ( s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Top or s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Bottom ) and not TerrainGlobals_IsTerrainSoft(s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]) then



                                    
									if s__Platformer_YVelocity[this] >= VELOCITY_HARDSTOP_THRESHOLD or s__Platformer_YVelocity[this] <= - VELOCITY_HARDSTOP_THRESHOLD then
										call HardStopEffect(this , s__Platformer_YVelocity[this])
									endif
									
									set s__Platformer_YVelocity[this]=0
                                elseif ( s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Left or s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Right ) and not TerrainGlobals_IsTerrainSoft(s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]) then



									
									if s__Platformer_XVelocity[this] >= VELOCITY_HARDSTOP_THRESHOLD or s__Platformer_XVelocity[this] <= - VELOCITY_HARDSTOP_THRESHOLD then
										call HardStopEffect(this , s__Platformer_XVelocity[this])
									endif
									
                                    set s__Platformer_XVelocity[this]=0
                                endif
                            //check if no next diagonal or if escaped the transition between two different diagonals
                            //elseif pathingResult == 0 then //does not allow platformer to escape between diagonal transitions
                            elseif pathingResult == 0 then
                                //diagonal ends





                                
                                //update unit position
                                set s__Platformer_XTerrainPushedAgainst[this]=0



									set s__Platformer_XPosition[this]=s__Platformer_XPosition[this] + s__vector2_x[newPosition]

                                call SetUnitX(s__Platformer_Unit[this], s__Platformer_XPosition[this])
                                
                                set s__Platformer_YTerrainPushedAgainst[this]=0



									set s__Platformer_YPosition[this]=s__Platformer_YPosition[this] + s__vector2_y[newPosition]

                                call SetUnitY(s__Platformer_Unit[this], s__Platformer_YPosition[this])
								
								set s__Platformer_PushedAgainstVector[this]=0
								set s__Platformer_OnDiagonal[this]=false
                                call s__ComplexTerrainPathingResult_destroy(s__Platformer_DiagonalPathing[this])
                                set s__Platformer_DiagonalPathing[this]=0
                            else
                                //diagonal changed from previous position to new position













                                
                                //if the diagonal has changed, then need to:
                                //project remaining distance along new diagonal (maybe approximate)
                                
                                //build equation for line and then plug in x and get y
                                //slope of line depends on diagonal
                                //intersect of line depends on diagonal and quadrant, and is relative to terrain centerX, Y
                                //project newX,newY onto new diagonal, in the proper direction
                                if s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Square then
                                    //project platformer onto the most relevant surface of the square OR deny movement entirely
                                    
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Encountered a square!")
                                    
                                    //either two cases: side continues as square tile OR side makes a corner with square tile
                                    //legal if changed only 1 of two compass directions (ex NE -> NW, but not NE -> SE)
                                    //check to see if hit a corner
                                    if ( s__ComplexTerrainPathingResult_QuadrantForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_NE and s__ComplexTerrainPathingResult_QuadrantForPoint[pathingResult] == ComplexTerrainPathing_SW ) or ( s__ComplexTerrainPathingResult_QuadrantForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_SE and s__ComplexTerrainPathingResult_QuadrantForPoint[pathingResult] == ComplexTerrainPathing_NW ) or ( s__ComplexTerrainPathingResult_QuadrantForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_SW and s__ComplexTerrainPathingResult_QuadrantForPoint[pathingResult] == ComplexTerrainPathing_NE ) or ( s__ComplexTerrainPathingResult_QuadrantForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_NW and s__ComplexTerrainPathingResult_QuadrantForPoint[pathingResult] == ComplexTerrainPathing_SE ) then
                                        //hit a corner, clear relevant x, y velocity
                                        if s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult] != 0 and not TerrainGlobals_IsTerrainSoft(s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]) then



											
                                            set s__Platformer_XTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]
											
											if s__Platformer_XVelocity[this] >= VELOCITY_HARDSTOP_THRESHOLD or s__Platformer_XVelocity[this] <= - VELOCITY_HARDSTOP_THRESHOLD then
												call HardStopEffect(this , s__Platformer_XVelocity[this])
											endif
											
                                            set s__Platformer_XVelocity[this]=0
                                        endif
                                        
                                        if s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult] != 0 and not TerrainGlobals_IsTerrainSoft(s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]) then



											
                                            set s__Platformer_YTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]
                                           
											if s__Platformer_YVelocity[this] >= VELOCITY_HARDSTOP_THRESHOLD or s__Platformer_YVelocity[this] <= - VELOCITY_HARDSTOP_THRESHOLD then
												call HardStopEffect(this , s__Platformer_YVelocity[this])
											endif
											
											set s__Platformer_YVelocity[this]=0
                                        endif
                                        
                                        //this only works when obstructing wall is square, if obstructing wall is diag then this glitches
                                        //its not very smooth when unit goes from diagonal to wall collision to free falling to diagonal... better to pretend we stayed on the same diagonal
                                        //to do this right we'd need a corner state for all 8 corners
                                        //call pathingResult.destroy()
                                        //set pathingResult = .DiagonalPathing
                                    else
                                        //continued onto square matching previous diagonal surface
                                        if s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_Left then



                                            set newX=s__ComplexTerrainPathingResult_TerrainMidpointX[pathingResult] - TERRAIN_QUADRANT_SIZE - Platformer___wOFFSET
                                            set newY=s__Platformer_YPosition[this] + s__vector2_y[newPosition]
                                        elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_Right then



                                            set newX=s__ComplexTerrainPathingResult_TerrainMidpointX[pathingResult] + TERRAIN_QUADRANT_SIZE + Platformer___wOFFSET
                                            set newY=s__Platformer_YPosition[this] + s__vector2_y[newPosition]
                                        elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_Top then



                                            set newX=s__Platformer_XPosition[this] + s__vector2_x[newPosition]
                                            set newY=s__ComplexTerrainPathingResult_TerrainMidpointY[pathingResult] + TERRAIN_QUADRANT_SIZE + Platformer___wOFFSET
                                        elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_Bottom then



                                            set newX=s__Platformer_XPosition[this] + s__vector2_x[newPosition]
                                            set newY=s__ComplexTerrainPathingResult_TerrainMidpointY[pathingResult] - TERRAIN_QUADRANT_SIZE - Platformer___wOFFSET
                                        endif
                                        
                                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Prev x: " + R2S(.XPosition) + ", " + R2S(newX))
                                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Prev y: " + R2S(.YPosition) + ", " + R2S(newY))
                                        
                                        set ttype=GetTerrainType(newX, s__Platformer_YPosition[this])
                                        if TerrainGlobals_IsTerrainPathable(ttype) then
                                            set s__Platformer_XTerrainPushedAgainst[this]=0
                                            set s__Platformer_XPosition[this]=newX
                                            call SetUnitX(s__Platformer_Unit[this], s__Platformer_XPosition[this])
                                        else
                                            set s__Platformer_XTerrainPushedAgainst[this]=ttype
                                            
                                            if s__vector2_x[newPosition] > 0 then
                                                set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_Left_UnitVector
                                            else
                                                set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_Right_UnitVector
                                            endif
                                            
                                            if not TerrainGlobals_IsTerrainSoft(ttype) then



												
												if s__Platformer_XVelocity[this] >= VELOCITY_HARDSTOP_THRESHOLD or s__Platformer_XVelocity[this] <= - VELOCITY_HARDSTOP_THRESHOLD then
													call HardStopEffect(this , s__Platformer_XVelocity[this])
												endif
												
                                                set s__Platformer_XVelocity[this]=0
                                            endif
                                        endif
                                        
                                        set ttype=GetTerrainType(s__Platformer_XPosition[this], newY)
                                        if TerrainGlobals_IsTerrainPathable(ttype) then
                                            set s__Platformer_YTerrainPushedAgainst[this]=0
                                            set s__Platformer_YPosition[this]=newY
                                            call SetUnitY(s__Platformer_Unit[this], s__Platformer_YPosition[this])
                                        else
                                            set s__Platformer_YTerrainPushedAgainst[this]=ttype
                                            
                                            if s__vector2_y[newPosition] > 0 then
                                                set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_Down_UnitVector
                                            else
                                                set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_Up_UnitVector
                                            endif
                                            
                                            if not TerrainGlobals_IsTerrainSoft(ttype) then




												if s__Platformer_YVelocity[this] >= VELOCITY_HARDSTOP_THRESHOLD or s__Platformer_YVelocity[this] <= - VELOCITY_HARDSTOP_THRESHOLD then
													call HardStopEffect(this , s__Platformer_YVelocity[this])
												endif
												
                                                set s__Platformer_YVelocity[this]=0
                                            endif
                                        endif
                                        
                                        set s__Platformer_OnDiagonal[this]=false
                                        call s__ComplexTerrainPathingResult_destroy(s__Platformer_DiagonalPathing[this])
                                        set s__Platformer_DiagonalPathing[this]=0
                                        



                                    endif
                                //I think this will project newPosition onto the new diagonal's orthogonal and see if it exceeds the sticky constant. If it does, then leave the diagonal
                                elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Left then
                                    //restrict x to boundaries of wall
                                    set s__Platformer_XPosition[this]=s__ComplexTerrainPathingResult_TerrainMidpointX[pathingResult] - IN_DIAGONAL_OFFSET
                                    set s__Platformer_XTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]
                                    call SetUnitX(s__Platformer_Unit[this], s__Platformer_XPosition[this])
                                    
                                    //let y go crazy
                                    set s__Platformer_YTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]
                                    set s__Platformer_YPosition[this]=s__Platformer_YPosition[this] + s__vector2_y[newPosition]
                                    call SetUnitY(s__Platformer_Unit[this], s__Platformer_YPosition[this])
                                    
                                    set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_Left_UnitVector
                                    
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Velocity: " + R2S(.XVelocity) + "," + R2S(.YVelocity))
                                    //if we were coming from a diagonal then apply part of x velocity to y
                                    if s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_SW then
                                        set s__Platformer_YVelocity[this]=s__Platformer_YVelocity[this] - s__Platformer_XVelocity[this] * SIN_45
                                        
                                        if not TerrainGlobals_IsTerrainSoft(s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]) then



											
											set s__Platformer_XVelocity[this]=0
                                        else
                                            set s__Platformer_XVelocity[this]=s__Platformer_XVelocity[this] * SIN_45
                                        endif
                                    elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_NW then
                                        set s__Platformer_YVelocity[this]=s__Platformer_YVelocity[this] + s__Platformer_XVelocity[this] * SIN_45
                                        
                                        if not TerrainGlobals_IsTerrainSoft(s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]) then



											
											set s__Platformer_XVelocity[this]=0
                                        else
                                            set s__Platformer_XVelocity[this]=s__Platformer_XVelocity[this] * SIN_45
                                        endif
                                    elseif s__Platformer_XVelocity[this] != 0 and not TerrainGlobals_IsTerrainSoft(s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]) then



										
										if s__Platformer_XVelocity[this] >= VELOCITY_HARDSTOP_THRESHOLD or s__Platformer_XVelocity[this] <= - VELOCITY_HARDSTOP_THRESHOLD then
											call HardStopEffect(this , s__Platformer_XVelocity[this])
										endif
										
										set s__Platformer_XVelocity[this]=0
                                    endif
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Velocity: " + R2S(.XVelocity) + "," + R2S(.YVelocity))
                                elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Right then
                                    set s__Platformer_XPosition[this]=s__ComplexTerrainPathingResult_TerrainMidpointX[pathingResult] + IN_DIAGONAL_OFFSET
                                    set s__Platformer_XTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]
                                    call SetUnitX(s__Platformer_Unit[this], s__Platformer_XPosition[this])
                                    
                                    set s__Platformer_YTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]
                                    set s__Platformer_YPosition[this]=s__Platformer_YPosition[this] + s__vector2_y[newPosition]
                                    call SetUnitY(s__Platformer_Unit[this], s__Platformer_YPosition[this])
                                    
                                    set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_Right_UnitVector
                                    
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Velocity: " + R2S(.XVelocity) + "," + R2S(.YVelocity))
                                    //if we were coming from a diagonal then apply part of x velocity to y
                                    if s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_SE then
                                        set s__Platformer_YVelocity[this]=s__Platformer_YVelocity[this] + s__Platformer_XVelocity[this] * SIN_45
                                        
                                        if not TerrainGlobals_IsTerrainSoft(s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]) then



											
											set s__Platformer_XVelocity[this]=0
                                        else
                                            set s__Platformer_XVelocity[this]=s__Platformer_XVelocity[this] * SIN_45
                                        endif
                                    elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_NE then
                                        set s__Platformer_YVelocity[this]=s__Platformer_YVelocity[this] - s__Platformer_XVelocity[this] * SIN_45
                                        
                                        if not TerrainGlobals_IsTerrainSoft(s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]) then



											
											set s__Platformer_XVelocity[this]=0
                                        else
                                            set s__Platformer_XVelocity[this]=s__Platformer_XVelocity[this] * SIN_45
                                        endif
                                    elseif s__Platformer_XVelocity[this] != 0 and not TerrainGlobals_IsTerrainSoft(s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]) then



										
										if s__Platformer_XVelocity[this] >= VELOCITY_HARDSTOP_THRESHOLD or s__Platformer_XVelocity[this] <= - VELOCITY_HARDSTOP_THRESHOLD then
											call HardStopEffect(this , s__Platformer_XVelocity[this])
										endif
										
										set s__Platformer_XVelocity[this]=0
                                    endif
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Velocity: " + R2S(.XVelocity) + "," + R2S(.YVelocity))
                                elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Top then
                                    //let x go crazy
                                    set s__Platformer_XTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]
                                    set s__Platformer_XPosition[this]=s__Platformer_XPosition[this] + s__vector2_x[newPosition]
                                    call SetUnitX(s__Platformer_Unit[this], s__Platformer_XPosition[this])
                                    
                                    //restrict y to boundaries of wall
                                    set s__Platformer_YTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]
                                    set s__Platformer_YPosition[this]=s__ComplexTerrainPathingResult_TerrainMidpointY[pathingResult] + IN_DIAGONAL_OFFSET
                                    call SetUnitY(s__Platformer_Unit[this], s__Platformer_YPosition[this])
                                    
                                    set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_Up_UnitVector
                                    
                                    //if we were coming from a diagonal then apply part of x velocity to y
                                    if s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_NE then
                                        set s__Platformer_XVelocity[this]=s__Platformer_XVelocity[this] - s__Platformer_YVelocity[this] * SIN_45
                                        
                                        if not TerrainGlobals_IsTerrainSoft(s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]) then



											
											set s__Platformer_YVelocity[this]=0
                                        else
                                            set s__Platformer_YVelocity[this]=s__Platformer_YVelocity[this] * SIN_45
                                        endif
                                    elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_NW then
                                        set s__Platformer_XVelocity[this]=s__Platformer_XVelocity[this] + s__Platformer_YVelocity[this] * SIN_45
                                        
                                        if not TerrainGlobals_IsTerrainSoft(s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]) then



											
											set s__Platformer_YVelocity[this]=0
                                        else
                                            set s__Platformer_YVelocity[this]=s__Platformer_YVelocity[this] * SIN_45
                                        endif
                                    elseif s__Platformer_YVelocity[this] != 0 and not TerrainGlobals_IsTerrainSoft(s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]) then



										
										if s__Platformer_YVelocity[this] >= VELOCITY_HARDSTOP_THRESHOLD or s__Platformer_YVelocity[this] <= - VELOCITY_HARDSTOP_THRESHOLD then
											call HardStopEffect(this , s__Platformer_YVelocity[this])
										endif
										
										set s__Platformer_YVelocity[this]=0
                                    endif
                                elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Bottom then
                                    set s__Platformer_XTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]
                                    set s__Platformer_XPosition[this]=s__Platformer_XPosition[this] + s__vector2_x[newPosition]
                                    call SetUnitX(s__Platformer_Unit[this], s__Platformer_XPosition[this])
                                    
                                    set s__Platformer_YTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]
                                    set s__Platformer_YPosition[this]=s__ComplexTerrainPathingResult_TerrainMidpointY[pathingResult] - IN_DIAGONAL_OFFSET
                                    call SetUnitY(s__Platformer_Unit[this], s__Platformer_YPosition[this])
                                    
                                    set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_Down_UnitVector
                                    
                                    //if we were coming from a diagonal then apply part of x velocity to y
                                    if s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_SE then
                                        set s__Platformer_XVelocity[this]=s__Platformer_XVelocity[this] + s__Platformer_YVelocity[this] * SIN_45
                                        
                                        if not TerrainGlobals_IsTerrainSoft(s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]) then



											
											set s__Platformer_YVelocity[this]=0
                                        else
                                            set s__Platformer_YVelocity[this]=s__Platformer_YVelocity[this] * SIN_45
                                        endif
                                    elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_SW then
                                        set s__Platformer_XVelocity[this]=s__Platformer_XVelocity[this] - s__Platformer_YVelocity[this] * SIN_45
                                        
                                        if not TerrainGlobals_IsTerrainSoft(s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]) then



											
											set s__Platformer_YVelocity[this]=0
                                        else
                                            set s__Platformer_YVelocity[this]=s__Platformer_YVelocity[this] * SIN_45
                                        endif
                                    elseif s__Platformer_YVelocity[this] != 0 and not TerrainGlobals_IsTerrainSoft(s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]) then



										
										if s__Platformer_YVelocity[this] >= VELOCITY_HARDSTOP_THRESHOLD or s__Platformer_YVelocity[this] <= - VELOCITY_HARDSTOP_THRESHOLD then
											call HardStopEffect(this , s__Platformer_YVelocity[this])
										endif
										
										set s__Platformer_YVelocity[this]=0
                                    endif
                                elseif ( s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_NE and ( s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_SE or s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_NW ) ) or ( s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_SE and ( s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_SW or s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_NE ) ) or ( s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_SW and ( s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_NW or s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_SE ) ) or ( s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_NW and ( s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_SW or s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_NE ) ) then
                                    //hit an inside corner
                                    set s__vector2_x[newPosition]=0
                                    
                                    //TODO get a more appropriate unit vector, orthogonal to a vert or horizontal
                                    //the above will be problematic, because the platformers orthogonal .PushedAgainstVector only updates on diagonal change
                                    //in order for it to work, corners would need their own pathing type, which might be a really good idea for caching reasons anyways
                                    if s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_NE then
                                        set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_NE_UnitVector
                                    elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_SE then
                                        set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_SE_UnitVector
                                    elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_SW then
                                        set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_SW_UnitVector
                                    elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_NW then
                                        set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_NW_UnitVector
                                    endif
                                    
                                    //check if velocity should be zeroed
                                    if not TerrainGlobals_IsTerrainSoft(s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]) then



										
										if s__Platformer_XVelocity[this] >= VELOCITY_HARDSTOP_THRESHOLD or s__Platformer_XVelocity[this] <= - VELOCITY_HARDSTOP_THRESHOLD then
											call HardStopEffect(this , s__Platformer_XVelocity[this])
										endif
										
										set s__Platformer_XVelocity[this]=0
                                    endif
                                    if not TerrainGlobals_IsTerrainSoft(s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]) then



										
										if s__Platformer_YVelocity[this] >= VELOCITY_HARDSTOP_THRESHOLD or s__Platformer_YVelocity[this] <= - VELOCITY_HARDSTOP_THRESHOLD then
											call HardStopEffect(this , s__Platformer_YVelocity[this])
										endif
										
										set s__Platformer_YVelocity[this]=0
                                    endif
                                elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_NE then
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "1 current x: " + R2S(.XPosition) + " x delta: " + R2S(newPosition.x) + " terrain center Y: " + R2S(pathingResult.TerrainMidpointY))
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "NE, current x: " + R2S(.XPosition) + " new x: " + R2S(.XPosition + newPosition.x))                                    
                                    //simplify projection by ignoring the initial y coordinate
                                    set s__Platformer_XPosition[this]=s__Platformer_XPosition[this] + s__vector2_x[newPosition]
                                    set s__Platformer_XTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]
                                    
                                    if s__ComplexTerrainPathingResult_QuadrantForPoint[pathingResult] == ComplexTerrainPathing_SW then
                                        //set .YPosition = -newPosition.x + pathingResult.TerrainMidpointY - IN_DIAGONAL_OFFSET
                                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "NE Y1, current y: " + R2S(.YPosition) + " new y: " + R2S(pathingResult.TerrainMidpointX - .XPosition + pathingResult.TerrainMidpointY - IN_DIAGONAL_OFFSET))
                                        set s__Platformer_YPosition[this]=s__ComplexTerrainPathingResult_TerrainMidpointX[pathingResult] - s__Platformer_XPosition[this] + s__ComplexTerrainPathingResult_TerrainMidpointY[pathingResult] - IN_DIAGONAL_OFFSET
                                    else //all other quadrants use same b
                                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "NE Y2, current y: " + R2S(.YPosition) + " new y: " + R2S(pathingResult.TerrainMidpointX - .XPosition + pathingResult.TerrainMidpointY + IN_DIAGONAL_OFFSET))
                                        set s__Platformer_YPosition[this]=s__ComplexTerrainPathingResult_TerrainMidpointX[pathingResult] - s__Platformer_XPosition[this] + s__ComplexTerrainPathingResult_TerrainMidpointY[pathingResult] + IN_DIAGONAL_OFFSET
                                    endif
                                    set s__Platformer_YTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0],  "1 x: " + R2S(.XPosition) + ", y: " + R2S(.YPosition)) 
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0],  "1 new x: " + R2S(newPosition.x) + ", new y: " + R2S(newPosition.y)) 
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "1 newX: " + R2S(newX) + " newY: " + R2S(pathingResult.TerrainMidpointY + newX - pathingResult.TerrainMidpointX)) 
                                    
                                    call SetUnitX(s__Platformer_Unit[this], s__Platformer_XPosition[this])
                                    call SetUnitY(s__Platformer_Unit[this], s__Platformer_YPosition[this])
                                    
                                    set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_NE_UnitVector
                                    
                                    //if we were coming from top
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Velocity: " + R2S(.XVelocity) + "," + R2S(.YVelocity))
                                    if s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_Top then
                                        set s__Platformer_XVelocity[this]=s__Platformer_XVelocity[this] * SIN_45
                                        set s__Platformer_YVelocity[this]=s__Platformer_YVelocity[this] - s__Platformer_XVelocity[this]
                                    elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_Right then
                                        set s__Platformer_YVelocity[this]=s__Platformer_YVelocity[this] * SIN_45
                                        set s__Platformer_XVelocity[this]=s__Platformer_XVelocity[this] - s__Platformer_YVelocity[this]
                                    endif
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Velocity: " + R2S(.XVelocity) + "," + R2S(.YVelocity))
                                elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_SE then
                                    //simplify projection by ignoring the initial y coordinate
                                    set s__Platformer_XPosition[this]=s__Platformer_XPosition[this] + s__vector2_x[newPosition]
                                    set s__Platformer_XTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]
                                    
                                    if s__ComplexTerrainPathingResult_QuadrantForPoint[pathingResult] == ComplexTerrainPathing_NW then
                                        //set .YPosition = newPosition.x + pathingResult.TerrainMidpointY + IN_DIAGONAL_OFFSET
                                        set s__Platformer_YPosition[this]=s__Platformer_XPosition[this] - s__ComplexTerrainPathingResult_TerrainMidpointX[pathingResult] + s__ComplexTerrainPathingResult_TerrainMidpointY[pathingResult] + IN_DIAGONAL_OFFSET
                                    else //all other quadrants use same b
                                        set s__Platformer_YPosition[this]=s__Platformer_XPosition[this] - s__ComplexTerrainPathingResult_TerrainMidpointX[pathingResult] + s__ComplexTerrainPathingResult_TerrainMidpointY[pathingResult] - IN_DIAGONAL_OFFSET
                                    endif
                                    set s__Platformer_YTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "2 y: " + R2S(.YPosition) + " x: " + R2S(.XPosition)) 
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "2 y: " + R2S(.YPosition) + " x: " + R2S(.XPosition)) 
                                    
                                    call SetUnitX(s__Platformer_Unit[this], s__Platformer_XPosition[this])
                                    call SetUnitY(s__Platformer_Unit[this], s__Platformer_YPosition[this])
                                    
                                    set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_SE_UnitVector
                                    
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Velocity: " + R2S(.XVelocity) + "," + R2S(.YVelocity))
                                    if s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_Bottom then
                                        set s__Platformer_XVelocity[this]=s__Platformer_XVelocity[this] * SIN_45
                                        set s__Platformer_YVelocity[this]=s__Platformer_YVelocity[this] + s__Platformer_XVelocity[this]
                                    elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_Right then
                                        set s__Platformer_YVelocity[this]=s__Platformer_YVelocity[this] * SIN_45
                                        set s__Platformer_XVelocity[this]=s__Platformer_XVelocity[this] + s__Platformer_YVelocity[this]
                                    endif
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Velocity: " + R2S(.XVelocity) + "," + R2S(.YVelocity))
                                elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_SW then
                                    //simplify projection by ignoring the initial y coordinate
                                    set s__Platformer_XPosition[this]=s__Platformer_XPosition[this] + s__vector2_x[newPosition]
                                    set s__Platformer_XTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]
                                    
                                    if s__ComplexTerrainPathingResult_QuadrantForPoint[pathingResult] == ComplexTerrainPathing_NE then
                                        set s__Platformer_YPosition[this]=s__ComplexTerrainPathingResult_TerrainMidpointX[pathingResult] - s__Platformer_XPosition[this] + s__ComplexTerrainPathingResult_TerrainMidpointY[pathingResult] + IN_DIAGONAL_OFFSET
                                    else //all other quadrants use same b
                                        set s__Platformer_YPosition[this]=s__ComplexTerrainPathingResult_TerrainMidpointX[pathingResult] - s__Platformer_XPosition[this] + s__ComplexTerrainPathingResult_TerrainMidpointY[pathingResult] - IN_DIAGONAL_OFFSET
                                    endif
                                    set s__Platformer_YTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "3 y: " + R2S(.YPosition) + " x: " + R2S(.XPosition)) 
                                    
                                    call SetUnitX(s__Platformer_Unit[this], s__Platformer_XPosition[this])
                                    call SetUnitY(s__Platformer_Unit[this], s__Platformer_YPosition[this])
                                    
                                    set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_SW_UnitVector
                                    
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Velocity: " + R2S(.XVelocity) + "," + R2S(.YVelocity))
                                    if s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_Bottom then
                                        set s__Platformer_XVelocity[this]=s__Platformer_XVelocity[this] * SIN_45
                                        set s__Platformer_YVelocity[this]=s__Platformer_YVelocity[this] - s__Platformer_XVelocity[this]
                                    elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_Left then
                                        set s__Platformer_YVelocity[this]=s__Platformer_YVelocity[this] * SIN_45
                                        set s__Platformer_XVelocity[this]=s__Platformer_XVelocity[this] - s__Platformer_YVelocity[this]
                                    endif
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Velocity: " + R2S(.XVelocity) + "," + R2S(.YVelocity))
                                elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_NW then
                                    //simplify projection by ignoring the initial y coordinate
                                    set s__Platformer_XPosition[this]=s__Platformer_XPosition[this] + s__vector2_x[newPosition]
                                    set s__Platformer_XTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]
                                    
                                    if s__ComplexTerrainPathingResult_QuadrantForPoint[pathingResult] == ComplexTerrainPathing_SE then
                                        set s__Platformer_YPosition[this]=s__Platformer_XPosition[this] - s__ComplexTerrainPathingResult_TerrainMidpointX[pathingResult] + s__ComplexTerrainPathingResult_TerrainMidpointY[pathingResult] - IN_DIAGONAL_OFFSET
                                    else //all other quadrants use same b
                                        set s__Platformer_YPosition[this]=s__Platformer_XPosition[this] - s__ComplexTerrainPathingResult_TerrainMidpointX[pathingResult] + s__ComplexTerrainPathingResult_TerrainMidpointY[pathingResult] + IN_DIAGONAL_OFFSET
                                    endif
                                    set s__Platformer_YTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]

                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "4 y: " + R2S(.YPosition) + " x: " + R2S(.XPosition)) 
                                    
                                    call SetUnitX(s__Platformer_Unit[this], s__Platformer_XPosition[this])
                                    call SetUnitY(s__Platformer_Unit[this], s__Platformer_YPosition[this])
                                    
                                    set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_NW_UnitVector
                                    
                                    //if we were coming from top
                                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Velocity: " + R2S(.XVelocity) + "," + R2S(.YVelocity))
                                    if s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_Top then
                                        set s__Platformer_XVelocity[this]=s__Platformer_XVelocity[this] * SIN_45
                                        set s__Platformer_YVelocity[this]=s__Platformer_YVelocity[this] + s__Platformer_XVelocity[this]
                                    elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_Left then
                                        set s__Platformer_YVelocity[this]=s__Platformer_YVelocity[this] * SIN_45
                                        set s__Platformer_XVelocity[this]=s__Platformer_XVelocity[this] + s__Platformer_YVelocity[this]
                                    endif
                                else



                                endif
                            endif
                            
                            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Finished pathing!") 
                            
                            //finally update pathing if its changed
                            if pathingResult != s__Platformer_DiagonalPathing[this] then
                                call s__ComplexTerrainPathingResult_destroy(s__Platformer_DiagonalPathing[this])
                                set s__Platformer_DiagonalPathing[this]=pathingResult
                                
                                if pathingResult == 0 then
                                    set s__Platformer_OnDiagonal[this]=false
                                endif
                            endif
                        else
                            //projected position (along diagonal) couldn't move -- check if we need to zero out velocity in either direction
                            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Projected position couldn't move") 
                            if s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_Top and s__Platformer_YVelocity[this] < 0 and not TerrainGlobals_IsTerrainSoft(s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[s__Platformer_DiagonalPathing[this]]) then



                                
								if s__Platformer_YVelocity[this] >= VELOCITY_HARDSTOP_THRESHOLD or s__Platformer_YVelocity[this] <= - VELOCITY_HARDSTOP_THRESHOLD then
									call HardStopEffect(this , s__Platformer_YVelocity[this])
								endif
								
								set s__Platformer_YVelocity[this]=0
                            elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_Bottom and s__Platformer_YVelocity[this] > 0 and not TerrainGlobals_IsTerrainSoft(s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[s__Platformer_DiagonalPathing[this]]) then



                                
								if s__Platformer_YVelocity[this] >= VELOCITY_HARDSTOP_THRESHOLD or s__Platformer_YVelocity[this] <= - VELOCITY_HARDSTOP_THRESHOLD then
									call HardStopEffect(this , s__Platformer_YVelocity[this])
								endif
								
								set s__Platformer_YVelocity[this]=0
                            elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_Left and s__Platformer_XVelocity[this] > 0 and not TerrainGlobals_IsTerrainSoft(s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[s__Platformer_DiagonalPathing[this]]) then



                                
								if s__Platformer_XVelocity[this] >= VELOCITY_HARDSTOP_THRESHOLD or s__Platformer_XVelocity[this] <= - VELOCITY_HARDSTOP_THRESHOLD then
									call HardStopEffect(this , s__Platformer_XVelocity[this])
								endif
								
								set s__Platformer_XVelocity[this]=0
                            elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_Right and s__Platformer_XVelocity[this] < 0 and not TerrainGlobals_IsTerrainSoft(s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[s__Platformer_DiagonalPathing[this]]) then



                                
								if s__Platformer_XVelocity[this] >= VELOCITY_HARDSTOP_THRESHOLD or s__Platformer_XVelocity[this] <= - VELOCITY_HARDSTOP_THRESHOLD then
									call HardStopEffect(this , s__Platformer_XVelocity[this])
								endif
								
								set s__Platformer_XVelocity[this]=0
                            endif
                        endif
                        
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Destroyed") 
                        call s__vector2_deallocate((newPosition)) // INLINED!!
                    endif
                else //not currently on a diagonal
                    //bound newX and newY if they're too big -- this needs to occur AFTER checking if point escapes diagonal, or else the result may be skewed towards any much larger value
					set distance=SquareRoot(newX * newX + newY * newY)
					if distance > PLATFORMING_MAXCHANGE then
						//boundedPercent = PLATFORMING_MAXCHANGE / distance
						
						set newX=newX * PLATFORMING_MAXCHANGE / distance
						set newY=newY * PLATFORMING_MAXCHANGE / distance
					endif
						
					//TODO implement raycasting to get the first non pathable complex terrain pathing result for newX newY pairs that are big enough to need it to be accurate
                    set newPosition=s__vector2_create(newX , newY)
                    
                    if newX > 0 then
                        set directionX=1
                    elseif newX < 0 then
                        set directionX=- 1
					else
						set directionX=0
                    endif
                    if newY > 0 then
                        set directionY=1
                    elseif newY < 0 then
                        set directionY=- 1
					else
						set directionY=0
                    endif
                    









                        set pathingResult=ComplexTerrainPathing_GetPathingForPoint(s__Platformer_XPosition[this] + s__vector2_x[newPosition] + directionX * Platformer___wOFFSET , s__Platformer_YPosition[this] + s__vector2_y[newPosition] + directionY * Platformer___wOFFSET)
						




                                        
                    if pathingResult == 0 then
                        //check if we are currently pushed against any surfaces, because if we are, we need to check that we're not pathing across an open diagonal between square blocks
                        if s__Platformer_XTerrainPushedAgainst[this] != 0 or s__Platformer_YTerrainPushedAgainst[this] != 0 then
                            //check if x and y terrain are pathable individually
                            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "open space, double check")
                            
                            if s__vector2_x[newPosition] != 0 then
                                set ttype=GetTerrainType(s__Platformer_XPosition[this] + s__vector2_x[newPosition], s__Platformer_YPosition[this])
                                if TerrainGlobals_IsTerrainPathable(ttype) then
                                    set s__Platformer_XTerrainPushedAgainst[this]=0
                                    set s__Platformer_XPosition[this]=s__Platformer_XPosition[this] + s__vector2_x[newPosition]
                                    call SetUnitX(s__Platformer_Unit[this], s__Platformer_XPosition[this])
                                else
                                    set s__Platformer_XTerrainPushedAgainst[this]=ttype
                                    
                                    if s__vector2_x[newPosition] > 0 then
                                        set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_Left_UnitVector
                                    else
                                        set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_Right_UnitVector
                                    endif
                                    
                                    if not TerrainGlobals_IsTerrainSoft(ttype) then



                                        
										if s__Platformer_XVelocity[this] >= VELOCITY_HARDSTOP_THRESHOLD or s__Platformer_XVelocity[this] <= - VELOCITY_HARDSTOP_THRESHOLD then
											call HardStopEffect(this , s__Platformer_XVelocity[this])
										endif
										
                                        set s__Platformer_XVelocity[this]=0
                                    endif
                                endif
                            else
                                set s__Platformer_XTerrainPushedAgainst[this]=0
                            endif
                            
                            if s__vector2_y[newPosition] != 0 then
                                set ttype=GetTerrainType(s__Platformer_XPosition[this], s__Platformer_YPosition[this] + s__vector2_y[newPosition])
                                if TerrainGlobals_IsTerrainPathable(ttype) then
                                    call SetUnitY(s__Platformer_Unit[this], s__Platformer_YPosition[this] + s__vector2_y[newPosition])
                                    set s__Platformer_YPosition[this]=s__Platformer_YPosition[this] + s__vector2_y[newPosition]
                                    
                                    set s__Platformer_YTerrainPushedAgainst[this]=0
                                else
                                    set s__Platformer_YTerrainPushedAgainst[this]=ttype
                                    
                                    if s__vector2_y[newPosition] > 0 then
                                        set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_Down_UnitVector
                                    else
                                        set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_Up_UnitVector
                                    endif
                                    
                                    
                                    if not TerrainGlobals_IsTerrainSoft(ttype) then



                                        
										if s__Platformer_YVelocity[this] >= VELOCITY_HARDSTOP_THRESHOLD or s__Platformer_YVelocity[this] <= - VELOCITY_HARDSTOP_THRESHOLD then
											call HardStopEffect(this , s__Platformer_YVelocity[this])
										endif
										
                                        set s__Platformer_YVelocity[this]=0
                                    endif
                                endif
                            else
                                set s__Platformer_YTerrainPushedAgainst[this]=0
                            endif
                        else
                            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "open space, single check")
                            
                            //open space, not pushed against any unpathable surfaces in the x direction
                            set s__Platformer_XTerrainPushedAgainst[this]=0
                            set s__Platformer_XPosition[this]=s__Platformer_XPosition[this] + s__vector2_x[newPosition]
                            call SetUnitX(s__Platformer_Unit[this], s__Platformer_XPosition[this])
                            
                            set s__Platformer_YTerrainPushedAgainst[this]=0
                            set s__Platformer_YPosition[this]=s__Platformer_YPosition[this] + s__vector2_y[newPosition]
                            call SetUnitY(s__Platformer_Unit[this], s__Platformer_YPosition[this])
                            
                            set s__Platformer_PushedAgainstVector[this]=0
                        endif
                        
                        //finally release the pathing result as there's no point in storing an open pathing result
                        call s__ComplexTerrainPathingResult_destroy(pathingResult)
                                                
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Open Space")
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Moved to open space x, y: " + R2S(.XPosition) + ", " + R2S(.YPosition) + "; new x: " + R2S(newX) + ", new Y: " + R2S(newY))
                    elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Inside then
                        //--T-O-D-O-- consider iterating when we hit an inside point
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Warning, going too fast for pathing and hit inside area of diagonal tiles")
                        call s__ComplexTerrainPathingResult_destroy(pathingResult)
                    elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Square then
                        //need to evaluate x and y separately so that one can be applied even if the other can't
                        //apply x first
                        
                        //TODO if the unit would path into a wall, then don't completely deny their movement, move them up to the wall
                        
                        //too much work to do full complex pathing for this subcase, because then i'd need all the different cases inside
                        //call pathingResult.Release()
                        //set pathingResult = GetPathingForPoint(newX, .CurrentY)
                        if s__vector2_x[newPosition] != 0 then
							//TODO does this all really need to happen or can i just check TerrainGlobals_IsTerrainPathable(GetTerrainType(.XPosition + newPosition.x + directionX*wOFFSET, .YPosition))
                            call s__ComplexTerrainPathingResult_destroy(pathingResult)
                            set pathingResult=ComplexTerrainPathing_GetPathingForPoint(s__Platformer_XPosition[this] + s__vector2_x[newPosition] + directionX * Platformer___wOFFSET , s__Platformer_YPosition[this])
                            
                            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "New x: " + R2S(newPosition.x) + ", velocity x: " + R2S(.XVelocity))
                            
                            if pathingResult == 0 then
                                set s__Platformer_XTerrainPushedAgainst[this]=0
                                set s__Platformer_XPosition[this]=s__Platformer_XPosition[this] + s__vector2_x[newPosition]
                                call SetUnitX(s__Platformer_Unit[this], s__Platformer_XPosition[this])
                            else
                                set s__Platformer_XTerrainPushedAgainst[this]=GetTerrainType(s__ComplexTerrainPathingResult_TerrainMidpointX[pathingResult], s__ComplexTerrainPathingResult_TerrainMidpointY[pathingResult])
                                
                                //needs a more accurate GetTerrainCenter
                                if s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Square or s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Left or s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Right then
                                    if s__vector2_x[newPosition] >= 0 then
                                        set s__Platformer_XPosition[this]=(((s__ComplexTerrainPathingResult_TerrainMidpointX[pathingResult])*1.0) - TERRAIN_QUADRANT_SIZE - TERRAIN_QUADRANT_ROUND) - Platformer___wOFFSET // INLINED!!
                                    else
                                        set s__Platformer_XPosition[this]=(((s__ComplexTerrainPathingResult_TerrainMidpointX[pathingResult])*1.0) + TERRAIN_QUADRANT_SIZE - TERRAIN_QUADRANT_ROUND) + Platformer___wOFFSET // INLINED!!
                                    endif
                                    



									
                                    call SetUnitX(s__Platformer_Unit[this], s__Platformer_XPosition[this])
                                endif
                                
                                if not TerrainGlobals_IsTerrainSoft(s__Platformer_XTerrainPushedAgainst[this]) then



									
									if s__Platformer_XVelocity[this] >= VELOCITY_HARDSTOP_THRESHOLD or s__Platformer_XVelocity[this] <= - VELOCITY_HARDSTOP_THRESHOLD then
										call HardStopEffect(this , s__Platformer_XVelocity[this])
									endif
									
									set s__Platformer_XVelocity[this]=0
                                endif
                            endif
                        else
                            set s__Platformer_XTerrainPushedAgainst[this]=0
                        endif
                        
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "square x, y velocity: " + R2S(.XVelocity) + ", " + R2S(.YVelocity))
                        
                        if s__vector2_y[newPosition] != 0 then
                            call s__ComplexTerrainPathingResult_destroy(pathingResult)
                            set pathingResult=ComplexTerrainPathing_GetPathingForPoint(s__Platformer_XPosition[this] , s__Platformer_YPosition[this] + s__vector2_y[newPosition] + directionY * Platformer___wOFFSET)
                            



							
                            if pathingResult == 0 then
                                set s__Platformer_YTerrainPushedAgainst[this]=0
                                set s__Platformer_YPosition[this]=s__Platformer_YPosition[this] + s__vector2_y[newPosition]
                                call SetUnitY(s__Platformer_Unit[this], s__Platformer_YPosition[this])
                            else
                                set s__Platformer_YTerrainPushedAgainst[this]=GetTerrainType(s__ComplexTerrainPathingResult_TerrainMidpointX[pathingResult], s__ComplexTerrainPathingResult_TerrainMidpointY[pathingResult])
                                
                                //needs a more accurate GetTerrainCenter
								if s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Square or s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Bottom or s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Top then
									if s__vector2_y[newPosition] >= 0 then
										set s__Platformer_YPosition[this]=(((s__ComplexTerrainPathingResult_TerrainMidpointY[pathingResult])*1.0) - TERRAIN_QUADRANT_SIZE - TERRAIN_QUADRANT_ROUND) - Platformer___wOFFSET // INLINED!!
									else
										set s__Platformer_YPosition[this]=(((s__ComplexTerrainPathingResult_TerrainMidpointY[pathingResult])*1.0) + TERRAIN_QUADRANT_SIZE - TERRAIN_QUADRANT_ROUND) + Platformer___wOFFSET // INLINED!!
									endif
									



									
									call SetUnitY(s__Platformer_Unit[this], s__Platformer_YPosition[this])
                                endif
								
                                if not TerrainGlobals_IsTerrainSoft(s__Platformer_YTerrainPushedAgainst[this]) then



                                    
									if s__Platformer_YVelocity[this] >= VELOCITY_HARDSTOP_THRESHOLD or s__Platformer_YVelocity[this] <= - VELOCITY_HARDSTOP_THRESHOLD then
										call HardStopEffect(this , s__Platformer_YVelocity[this])
									endif
									
									set s__Platformer_YVelocity[this]=0
                                endif
                            endif
                        else
                            set s__Platformer_YTerrainPushedAgainst[this]=0
                        endif
                        
                        //set push vector
                        //don't represent both surfaces being pushed against for square tiles, instead just have the Y push trump the X
                        if s__Platformer_YTerrainPushedAgainst[this] != 0 then
                            if s__vector2_y[newPosition] > 0 then
                                set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_Down_UnitVector
                            else
                                set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_Up_UnitVector
                            endif
                        elseif s__Platformer_XTerrainPushedAgainst[this] != 0 then
                            if s__vector2_x[newPosition] > 0 then
                                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "newX: " + R2S(newPosition.x))
                                set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_Left_UnitVector
                            else
                                set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_Right_UnitVector
                            endif
                        endif
                        
                        //not storing square pathing description for now
                        call s__ComplexTerrainPathingResult_destroy(pathingResult)
                        
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "square x, y: " + R2S(.XPosition) + ", " + R2S(.YPosition))
                    else //now on a diagonal tile!
                        set s__Platformer_OnDiagonal[this]=true
                        set s__Platformer_DiagonalPathing[this]=pathingResult
                        






                        
                        //project newX,newY onto new diagonal, in the proper direction
                        if s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Left then
                            set s__Platformer_XTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]
                            set s__Platformer_XPosition[this]=s__ComplexTerrainPathingResult_TerrainMidpointX[pathingResult] - IN_DIAGONAL_OFFSET
                            call SetUnitX(s__Platformer_Unit[this], s__Platformer_XPosition[this])
                            
                            //let y go crazy
                            set s__Platformer_YTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]
                            set s__Platformer_YPosition[this]=s__Platformer_YPosition[this] + s__vector2_y[newPosition]
                            call SetUnitY(s__Platformer_Unit[this], s__Platformer_YPosition[this])
                            
                            set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_Left_UnitVector
                        elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Right then
                            set s__Platformer_XTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]
                            set s__Platformer_XPosition[this]=s__ComplexTerrainPathingResult_TerrainMidpointX[pathingResult] + IN_DIAGONAL_OFFSET
                            call SetUnitX(s__Platformer_Unit[this], s__Platformer_XPosition[this])
                            
                            //let y go crazy
                            set s__Platformer_YTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]
                            set s__Platformer_YPosition[this]=s__Platformer_YPosition[this] + s__vector2_y[newPosition]
                            call SetUnitY(s__Platformer_Unit[this], s__Platformer_YPosition[this])
                            
                            set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_Right_UnitVector
                        elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Top then
                            set s__Platformer_YTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]
                            set s__Platformer_YPosition[this]=s__ComplexTerrainPathingResult_TerrainMidpointY[pathingResult] + IN_DIAGONAL_OFFSET
                            call SetUnitY(s__Platformer_Unit[this], s__Platformer_YPosition[this])
                            
                            //let x go crazy
                            set s__Platformer_XTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]
                            set s__Platformer_XPosition[this]=s__Platformer_XPosition[this] + s__vector2_x[newPosition]
                            call SetUnitX(s__Platformer_Unit[this], s__Platformer_XPosition[this])
                            
                            set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_Up_UnitVector
                        elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Bottom then
                            set s__Platformer_YTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]
                            set s__Platformer_YPosition[this]=s__ComplexTerrainPathingResult_TerrainMidpointY[pathingResult] - IN_DIAGONAL_OFFSET
                            call SetUnitY(s__Platformer_Unit[this], s__Platformer_YPosition[this])
                        
                            //let x go crazy
                            set s__Platformer_XTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]
                            set s__Platformer_XPosition[this]=s__Platformer_XPosition[this] + s__vector2_x[newPosition]
                            call SetUnitX(s__Platformer_Unit[this], s__Platformer_XPosition[this])
                            
                            set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_Down_UnitVector
                        elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_NE then
                            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "1 current x: " + R2S(.XPosition) + " x delta: " + R2S(newPosition.x) + " terrain center Y: " + R2S(pathingResult.TerrainMidpointY))
                            //simplify projection by ignoring the initial y coordinate
                            set s__Platformer_XPosition[this]=s__Platformer_XPosition[this] + s__vector2_x[newPosition]
                            set s__Platformer_XTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]
                            
                            if s__ComplexTerrainPathingResult_QuadrantForPoint[pathingResult] == ComplexTerrainPathing_SW then
                                //set .YPosition = -newPosition.x + pathingResult.TerrainMidpointY - IN_DIAGONAL_OFFSET
                                set s__Platformer_YPosition[this]=s__ComplexTerrainPathingResult_TerrainMidpointX[pathingResult] - s__Platformer_XPosition[this] + s__ComplexTerrainPathingResult_TerrainMidpointY[pathingResult] - IN_DIAGONAL_OFFSET
                            else //all other quadrants use same b
                                set s__Platformer_YPosition[this]=s__ComplexTerrainPathingResult_TerrainMidpointX[pathingResult] - s__Platformer_XPosition[this] + s__ComplexTerrainPathingResult_TerrainMidpointY[pathingResult] + IN_DIAGONAL_OFFSET
                            endif
                            set s__Platformer_YTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]
                            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0],  "1 x: " + R2S(.XPosition) + ", y: " + R2S(.YPosition)) 
                            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0],  "1 new x: " + R2S(newPosition.x) + ", new y: " + R2S(newPosition.y)) 
                            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "1 newX: " + R2S(newX) + " newY: " + R2S(pathingResult.TerrainMidpointY + newX - pathingResult.TerrainMidpointX)) 
                            
                            call SetUnitX(s__Platformer_Unit[this], s__Platformer_XPosition[this])
                            call SetUnitY(s__Platformer_Unit[this], s__Platformer_YPosition[this])
                            
                            set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_NE_UnitVector
                        elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_SE then
                            //simplify projection by ignoring the initial y coordinate
                            set s__Platformer_XPosition[this]=s__Platformer_XPosition[this] + s__vector2_x[newPosition]
                            set s__Platformer_XTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]
                            
                            if s__ComplexTerrainPathingResult_QuadrantForPoint[pathingResult] == ComplexTerrainPathing_NW then
                                //set .YPosition = newPosition.x + pathingResult.TerrainMidpointY + IN_DIAGONAL_OFFSET
                                set s__Platformer_YPosition[this]=s__Platformer_XPosition[this] - s__ComplexTerrainPathingResult_TerrainMidpointX[pathingResult] + s__ComplexTerrainPathingResult_TerrainMidpointY[pathingResult] + IN_DIAGONAL_OFFSET
                            else //all other quadrants use same b
                                set s__Platformer_YPosition[this]=s__Platformer_XPosition[this] - s__ComplexTerrainPathingResult_TerrainMidpointX[pathingResult] + s__ComplexTerrainPathingResult_TerrainMidpointY[pathingResult] - IN_DIAGONAL_OFFSET
                            endif
                            set s__Platformer_YTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]
                            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "2 y: " + R2S(.YPosition) + " x: " + R2S(.XPosition)) 
                            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "2 y: " + R2S(.YPosition) + " x: " + R2S(.XPosition)) 
                            
                            call SetUnitX(s__Platformer_Unit[this], s__Platformer_XPosition[this])
                            call SetUnitY(s__Platformer_Unit[this], s__Platformer_YPosition[this])
                            
                            set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_SE_UnitVector
                        elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_SW then
                            //simplify projection by ignoring the initial y coordinate
                            set s__Platformer_XPosition[this]=s__Platformer_XPosition[this] + s__vector2_x[newPosition]
                            set s__Platformer_XTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]
                            
                            if s__ComplexTerrainPathingResult_QuadrantForPoint[pathingResult] == ComplexTerrainPathing_NE then
                                set s__Platformer_YPosition[this]=s__ComplexTerrainPathingResult_TerrainMidpointX[pathingResult] - s__Platformer_XPosition[this] + s__ComplexTerrainPathingResult_TerrainMidpointY[pathingResult] + IN_DIAGONAL_OFFSET
                            else //all other quadrants use same b
                                set s__Platformer_YPosition[this]=s__ComplexTerrainPathingResult_TerrainMidpointX[pathingResult] - s__Platformer_XPosition[this] + s__ComplexTerrainPathingResult_TerrainMidpointY[pathingResult] - IN_DIAGONAL_OFFSET
                            endif
                            set s__Platformer_YTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]
                            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "3 y: " + R2S(.YPosition) + " x: " + R2S(.XPosition)) 
                            
                            call SetUnitX(s__Platformer_Unit[this], s__Platformer_XPosition[this])
                            call SetUnitY(s__Platformer_Unit[this], s__Platformer_YPosition[this])
                            
                            set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_SW_UnitVector
                        elseif s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_NW then
                            //simplify projection by ignoring the initial y coordinate
                            set s__Platformer_XPosition[this]=s__Platformer_XPosition[this] + s__vector2_x[newPosition]
                            set s__Platformer_XTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]
                            
                            if s__ComplexTerrainPathingResult_QuadrantForPoint[pathingResult] == ComplexTerrainPathing_SE then
                                set s__Platformer_YPosition[this]=s__Platformer_XPosition[this] - s__ComplexTerrainPathingResult_TerrainMidpointX[pathingResult] + s__ComplexTerrainPathingResult_TerrainMidpointY[pathingResult] - IN_DIAGONAL_OFFSET
                            else //all other quadrants use same b
                                set s__Platformer_YPosition[this]=s__Platformer_XPosition[this] - s__ComplexTerrainPathingResult_TerrainMidpointX[pathingResult] + s__ComplexTerrainPathingResult_TerrainMidpointY[pathingResult] + IN_DIAGONAL_OFFSET
                            endif
                            set s__Platformer_YTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]

                            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "4 y: " + R2S(.YPosition) + " x: " + R2S(.XPosition)) 
                            
                            call SetUnitX(s__Platformer_Unit[this], s__Platformer_XPosition[this])
                            call SetUnitY(s__Platformer_Unit[this], s__Platformer_YPosition[this])
                            
                            set s__Platformer_PushedAgainstVector[this]=ComplexTerrainPathing_NW_UnitVector
                        else
                        endif
                        
                        //show effect -- or don't...
                        //Abilities\Spells\Human\ManaFlare\ManaFlareMissile.mdl
                        //set .FX = AddSpecialEffect("Abilities\\Spells\\Human\\ManaFlare\\ManaFlareMissile.mdl", .XPosition, .YPosition)
                        //call DestroyEffect(.FX)
                        //set .FX = null
                        
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "New push vector: " + I2S(.PushedAgainstVector))
                        
                        //check to see if velocity should be zeroed out
                        if s__Platformer_XVelocity[this] != 0 or s__Platformer_YVelocity[this] != 0 then
                            if ( s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Top or s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Bottom ) and not TerrainGlobals_IsTerrainSoft(s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]) then



                                
								if s__Platformer_YVelocity[this] >= VELOCITY_HARDSTOP_THRESHOLD or s__Platformer_YVelocity[this] <= - VELOCITY_HARDSTOP_THRESHOLD then
									call HardStopEffect(this , s__Platformer_YVelocity[this])
								endif
								
								set s__Platformer_YVelocity[this]=0
                            elseif ( s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Left or s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Right ) and not TerrainGlobals_IsTerrainSoft(s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]) then



                                
								if s__Platformer_XVelocity[this] >= VELOCITY_HARDSTOP_THRESHOLD or s__Platformer_XVelocity[this] <= - VELOCITY_HARDSTOP_THRESHOLD then
									call HardStopEffect(this , s__Platformer_XVelocity[this])
								endif
								
								set s__Platformer_XVelocity[this]=0
                            else















                                
                                //transitionAngleChange = newX - newY
                                //percentInDirection = |Cos(transitionAngleChange)|
                                //set newX = RAbsBJ(Cos(newY - newX))
                                
                                //set newPosition.x = .XVelocity * RAbsBJ(Cos(newY - newX)) + .YVelocity * RAbsBJ(Sin(newY - newX))
                                //set newPosition.y = .YVelocity * RAbsBJ(Cos(newY - newX)) + .XVelocity * RAbsBJ(Sin(newY - newX))
                                //set newPosition.x = .XVelocity * Cos(newY - newX) + .YVelocity * Sin(newY - newX)
                                //set newPosition.y = .YVelocity * Cos(newY - newX) + .XVelocity * Sin(newY - newX)
                                
                                set s__vector2_x[newPosition]=s__Platformer_XVelocity[this]
                                set s__vector2_y[newPosition]=s__Platformer_YVelocity[this]
                                call s__Platformer_ProjectPositionAlongCurrentDiagonal(pathingResult , newPosition)

                                set s__Platformer_XVelocity[this]=s__vector2_x[newPosition]
                                set s__Platformer_YVelocity[this]=s__vector2_y[newPosition]
                            endif
                        endif
                        
                        //update terrain pushed against based on new diagonal
                        set s__Platformer_XTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantXTerrainTypeID[pathingResult]
                        set s__Platformer_YTerrainPushedAgainst[this]=s__ComplexTerrainPathingResult_RelevantYTerrainTypeID[pathingResult]
                    endif
                
                    call s__vector2_deallocate((newPosition)) // INLINED!!
                endif
            else //there was no movement in the x or y directions at all, possible or not
                
                
                if s__Platformer_OnDiagonal[this] then
                    //check if we escape the diagonal's stickyness
					//won't ever escape a diagonal by not moving
					
                else
                    //only diagonals need/support stickyness
                    set s__Platformer_YTerrainPushedAgainst[this]=0
                    set s__Platformer_XTerrainPushedAgainst[this]=0
                endif
            endif
            
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Finished pathing!") 
            



			



            
            //TODO does velocity falloff need to happen in the main physics loop, which is performance hungry, or can that happen in a less performance needy timer?
            //decrement all relevant forces on the x-axis
            //X velocity should tend towards 0 if it isn't (an object in motion should tend to rest)
            //TODO change function to somehow be a easing function
            if s__Platformer_XVelocity[this] != 0 then
                //decrement velocity remaining
                //set 0 if approx 0
                
                if s__Platformer_XVelocity[this] > 0 then //velocity going right
                    if s__Platformer_XVelocity[this] < Platformer___xMINVELOCITY then //going super slow
                        set s__Platformer_XVelocity[this]=0
                    //TODO replace with 2nd power easing
                    else //anywhere inbetween
                        set s__Platformer_XVelocity[this]=s__Platformer_XVelocity[this] - s__Platformer_XFalloff[this] * applyTimeDelta
                    endif
                    
                    //TODO this doesn't work with diagonals when you're on an actual diagonal slant
                    if s__Platformer_MoveSpeedVelOffset[this] != 0 and s__Platformer_HorizontalAxisState[this] == - 1 then //left key down in opposite direction as XVelocity -- decrement XVelocity extra
                        set s__Platformer_XVelocity[this]=s__Platformer_XVelocity[this] - s__Platformer_MoveSpeed[this] * s__Platformer_MoveSpeedVelOffset[this] * applyTimeDelta
                    endif
                else //velocity going left
                    if s__Platformer_XVelocity[this] > - Platformer___xMINVELOCITY then
                        set s__Platformer_XVelocity[this]=0
                    else
                        set s__Platformer_XVelocity[this]=s__Platformer_XVelocity[this] + s__Platformer_XFalloff[this] * applyTimeDelta
                    endif
                    
                    //TODO this doesn't work with diagonals when you're on an actual diagonal slant
                     if s__Platformer_MoveSpeedVelOffset[this] != 0 and s__Platformer_HorizontalAxisState[this] == 1 then //right key down in opposite direction as XVelocity -- decrement XVelocity extra
                        set s__Platformer_XVelocity[this]=s__Platformer_XVelocity[this] + s__Platformer_MoveSpeed[this] * s__Platformer_MoveSpeedVelOffset[this] * applyTimeDelta
                    endif
                endif
            endif
            
            //YVelocity going up
            if s__Platformer_YVelocity[this] > 0 then
                //decrement YVelocity if over terminal velocity
				if s__Platformer_YVelocity[this] > s__Platformer_TerminalVelocityY[this] then
                    //todo replace with a smoothing function
                    set s__Platformer_YVelocity[this]=s__Platformer_YVelocity[this] - s__Platformer_YFalloff[this] * applyTimeDelta
                endif
				//set .YVelocity = .YVelocity - .YFalloff
            elseif s__Platformer_YVelocity[this] < 0 then
                //decrement YVelocity if over terminal velocity
				if s__Platformer_YVelocity[this] < - s__Platformer_TerminalVelocityY[this] then
                    //todo replace with a easing function
                    set s__Platformer_YVelocity[this]=s__Platformer_YVelocity[this] + s__Platformer_YFalloff[this] * applyTimeDelta
                endif
				//set .YVelocity = .YVelocity + .YFalloff
            endif
            



            



        endfunction
                
        function s__Platformer_RemoveTerrainEffect takes integer this returns nothing
            if s__Platformer_TerrainDX[this] == OCEAN then
                call s__PlatformerPropertyEquation_removeAdjustment(s__Platformer_MSEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , OCEAN)
                set s__Platformer_MoveSpeed[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_MSEquation[this],s__PlatformerProfile_MoveSpeed[s__Platformer_BaseProfile[this]])
                
                call s__PlatformerPropertyEquation_removeAdjustment(s__Platformer_GravityEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , OCEAN)
                set s__Platformer_GravitationalAccel[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_GravityEquation[this],s__PlatformerProfile_GravitationalAccel[s__Platformer_BaseProfile[this]])
                
                call s__PlatformerPropertyEquation_removeAdjustment(s__Platformer_XFalloffEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , OCEAN)
                set s__Platformer_XFalloff[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_XFalloffEquation[this],s__PlatformerProfile_XFalloff[s__Platformer_BaseProfile[this]])
                
                call s__PlatformerPropertyEquation_removeAdjustment(s__Platformer_YFalloffEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , OCEAN)
                set s__Platformer_YFalloff[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_YFalloffEquation[this],s__PlatformerProfile_YFalloff[s__Platformer_BaseProfile[this]])
                                
                call s__PlatformerPropertyEquation_removeAdjustment(s__Platformer_TVYEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , OCEAN)
                set s__Platformer_TerminalVelocityY[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_TVYEquation[this],s__PlatformerProfile_TerminalVelocityY[s__Platformer_BaseProfile[this]])
                
                //set .GravitationalAccel = .GravitationalAccel / PlatformerOcean_GRAVITYPERCENT
                //set .MoveSpeed = .MoveSpeed / PlatformerOcean_MS
                set s__Platformer_hJumpSpeed[this]=s__Platformer_hJumpSpeed[this] / PlatformerOcean_HJUMP
                set s__Platformer_vJumpSpeed[this]=s__Platformer_vJumpSpeed[this] / PlatformerOcean_VJUMP
                set s__Platformer_v2hJumpRatio[this]=s__Platformer_v2hJumpRatio[this] / PlatformerOcean_V2H
                //set .TerminalVelocityY = .TerminalVelocityY / PlatformerOcean_TVX
                //set .TerminalVelocityX = .TerminalVelocityX / PlatformerOcean_TVY
                //set .XFalloff = .XFalloff / PlatformerOcean_XFALLOFF
                //set .YFalloff = .YFalloff / PlatformerOcean_YFALLOFF
                set s__Platformer_MoveSpeedVelOffset[this]=s__Platformer_MoveSpeedVelOffset[this] / PlatformerOcean_MSOFF
                
                call PlatformerOcean_Remove(this)
            elseif s__Platformer_TerrainDX[this] == VINES then
                call s__PlatformerPropertyEquation_removeAdjustment(s__Platformer_MSEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , VINES)
                set s__Platformer_MoveSpeed[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_MSEquation[this],s__PlatformerProfile_MoveSpeed[s__Platformer_BaseProfile[this]])
				
				call s__PlatformerPropertyEquation_removeAdjustment(s__Platformer_GravityEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , VINES)
                set s__Platformer_GravitationalAccel[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_GravityEquation[this],s__PlatformerProfile_GravitationalAccel[s__Platformer_BaseProfile[this]])
                //set .GravitationalAccel = .GravitationalAccel / VINES_SLOWDOWNPERCENT
                
                call s__PlatformerPropertyEquation_removeAdjustment(s__Platformer_TVYEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , VINES)
                set s__Platformer_TerminalVelocityY[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_TVYEquation[this],s__PlatformerProfile_TerminalVelocityY[s__Platformer_BaseProfile[this]])
				
                //set .TerminalVelocityY = .TerminalVelocityY / VINES_SLOWDOWNPERCENT
                
                //feels better when you don't get speed back after
                //set .YVelocity = .YVelocity / VINES_SLOWDOWNPERCENT
                //set .MoveSpeed = .MoveSpeed / VINES_MOVESPEEDPERCENT
            elseif s__Platformer_TerrainDX[this] == SLIPSTREAM then
                call s__PlatformerPropertyEquation_removeAdjustment(s__Platformer_GravityEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , SLIPSTREAM)
                set s__Platformer_GravitationalAccel[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_GravityEquation[this],s__PlatformerProfile_GravitationalAccel[s__Platformer_BaseProfile[this]])
                
                //call .TVYEquation.removeAdjustment(PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT, SLIPSTREAM)
                //set .TerminalVelocityY = .GravityEquation.calculateAdjustedValue(.BaseProfile.TerminalVelocityY)
                                
                call s__PlatformerPropertyEquation_removeAdjustment(s__Platformer_YFalloffEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , SLIPSTREAM)
                set s__Platformer_YFalloff[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_GravityEquation[this],s__PlatformerProfile_YFalloff[s__Platformer_BaseProfile[this]])
                //set .GravitationalAccel = .GravitationalAccel * 10
                    
                call PlatformerSlipStream_Remove(this)
			elseif s__Platformer_TerrainDX[this] == BOOST then
				call s__PlatformerBounce_Remove(this)
            endif
        endfunction
        
        function s__Platformer_RemoveXSurfaceTerrainEffect takes integer this returns nothing
            //remove any effect from previous pushed against x terrain
            if s__Platformer_XAppliedTerrainPushedAgainst[this] == SAND then
                call s__PlatformerPropertyEquation_removeAdjustment(s__Platformer_YFalloffEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , SAND)
                set s__Platformer_YFalloff[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_YFalloffEquation[this],s__PlatformerProfile_YFalloff[s__Platformer_BaseProfile[this]])
                //set .YFalloff = .YFalloff / SAND_FALLOFF
            elseif s__Platformer_XAppliedTerrainPushedAgainst[this] == DGRASS then
                //set .GravitationalAccel = .GravitationalAccel * 10
            elseif s__Platformer_XAppliedTerrainPushedAgainst[this] == SLOWICE then
                call s__PlatformerPropertyEquation_removeAdjustment(s__Platformer_YFalloffEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , SLOWICE)
                set s__Platformer_YFalloff[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_YFalloffEquation[this],s__PlatformerProfile_YFalloff[s__Platformer_BaseProfile[this]])
                //set .YFalloff = .YFalloff  / PlatformerIce_SLOW_XFALLOFF
                
                //only remove from ice if no part of the platformer is still on ice
                if s__Platformer_YAppliedTerrainPushedAgainst[this] != SLOWICE and s__Platformer_YAppliedTerrainPushedAgainst[this] != FASTICE and s__Platformer_YTerrainPushedAgainst[this] != FASTICE then
                    call PlatformerIce_Remove(this)
                endif
            elseif s__Platformer_XAppliedTerrainPushedAgainst[this] == FASTICE then
                call s__PlatformerPropertyEquation_removeAdjustment(s__Platformer_YFalloffEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , FASTICE)
                set s__Platformer_YFalloff[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_YFalloffEquation[this],s__PlatformerProfile_YFalloff[s__Platformer_BaseProfile[this]])
                //set .YFalloff = .YFalloff / PlatformerIce_FAST_XFALLOFF
                
                //only remove from ice if no part of the platformer is still on ice
                if s__Platformer_YAppliedTerrainPushedAgainst[this] != SLOWICE and s__Platformer_YAppliedTerrainPushedAgainst[this] != FASTICE and s__Platformer_YTerrainPushedAgainst[this] != SLOWICE then
                    call PlatformerIce_Remove(this)
                endif
            endif
        endfunction
        
        function s__Platformer_RemoveYSurfaceTerrainEffect takes integer this returns nothing
            //remove any effect from previous pushed against y terrain
            if s__Platformer_YAppliedTerrainPushedAgainst[this] == SAND then
                call s__PlatformerPropertyEquation_removeAdjustment(s__Platformer_XFalloffEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , SAND)
                set s__Platformer_XFalloff[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_XFalloffEquation[this],s__PlatformerProfile_XFalloff[s__Platformer_BaseProfile[this]])
            elseif s__Platformer_YAppliedTerrainPushedAgainst[this] == GRASS then
				call s__PlatformerPropertyEquation_removeAdjustment(s__Platformer_MSEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , GRASS)
                set s__Platformer_MoveSpeed[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_MSEquation[this],s__PlatformerProfile_MoveSpeed[s__Platformer_BaseProfile[this]])
				
                call s__PlatformerPropertyEquation_removeAdjustment(s__Platformer_TVYEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , GRASS)
                set s__Platformer_TerminalVelocityY[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_TVYEquation[this],s__PlatformerProfile_TerminalVelocityY[s__Platformer_BaseProfile[this]])
			elseif s__Platformer_YAppliedTerrainPushedAgainst[this] == DGRASS then
                call s__PlatformerPropertyEquation_removeAdjustment(s__Platformer_MSEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , DGRASS)
                set s__Platformer_MoveSpeed[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_MSEquation[this],s__PlatformerProfile_MoveSpeed[s__Platformer_BaseProfile[this]])
                //set .MoveSpeed = .MoveSpeed / DGRASS_MS
				
                call s__PlatformerPropertyEquation_removeAdjustment(s__Platformer_TVYEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , DGRASS)
                set s__Platformer_TerminalVelocityY[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_TVYEquation[this],s__PlatformerProfile_TerminalVelocityY[s__Platformer_BaseProfile[this]])
            elseif s__Platformer_YAppliedTerrainPushedAgainst[this] == SLOWICE then
                call s__PlatformerPropertyEquation_removeAdjustment(s__Platformer_XFalloffEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , SLOWICE)
                set s__Platformer_XFalloff[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_XFalloffEquation[this],s__PlatformerProfile_XFalloff[s__Platformer_BaseProfile[this]])
                
                call s__PlatformerPropertyEquation_removeAdjustment(s__Platformer_MSEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , SLOWICE)
                set s__Platformer_MoveSpeed[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_MSEquation[this],s__PlatformerProfile_MoveSpeed[s__Platformer_BaseProfile[this]])
                
                //only remove from ice if no part of the platformer is still on ice and we wouldn't just be putting them back on
                if s__Platformer_XAppliedTerrainPushedAgainst[this] != SLOWICE and s__Platformer_XAppliedTerrainPushedAgainst[this] != FASTICE and s__Platformer_YTerrainPushedAgainst[this] != FASTICE then
                    call PlatformerIce_Remove(this)
                endif
            elseif s__Platformer_YAppliedTerrainPushedAgainst[this] == FASTICE then
                call s__PlatformerPropertyEquation_removeAdjustment(s__Platformer_XFalloffEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , FASTICE)
                set s__Platformer_XFalloff[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_XFalloffEquation[this],s__PlatformerProfile_XFalloff[s__Platformer_BaseProfile[this]])
                
                call s__PlatformerPropertyEquation_removeAdjustment(s__Platformer_MSEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , FASTICE)
                set s__Platformer_MoveSpeed[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_MSEquation[this],s__PlatformerProfile_MoveSpeed[s__Platformer_BaseProfile[this]])
                
                if s__Platformer_XAppliedTerrainPushedAgainst[this] != SLOWICE and s__Platformer_XAppliedTerrainPushedAgainst[this] != FASTICE and s__Platformer_YTerrainPushedAgainst[this] != SLOWICE then
                    call PlatformerIce_Remove(this)
                endif
            endif
        endfunction
                
        function s__Platformer_KillPlatformer takes integer this returns nothing
            call sc__User_SwitchGameModesDefaultLocation((s__Platformer_PID[this]),Teams_GAMEMODE_DYING)
            //call .StopPlatforming()
        endfunction
        
        function s__Platformer_UpdateTerrain takes integer this returns nothing
            local real x= GetUnitX(s__Platformer_Unit[this])
            local real y= GetUnitY(s__Platformer_Unit[this])
                        
            //update terrain at unit's x, y
            local integer ttype
            local integer terrainCenter
            local real offsetZone= TERRAIN_QUADRANT_SIZE - Platformer___tOFFSET
            
            if s__Platformer_OnDiagonal[this] then
                //reuse terrain center. DONT DEALLOCATE UNIT VECTORS
                set terrainCenter=ComplexTerrainPathing_GetUnitVectorForPathing(s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]])
                
                set ttype=GetTerrainType(x + DIAGONAL_TERRAIN_CHECK_OFFSET * s__vector2_x[terrainCenter], y + DIAGONAL_TERRAIN_CHECK_OFFSET * s__vector2_y[terrainCenter])
            else
                set ttype=GetTerrainType(x, y)
            endif
            
            //TODO get dominant terrain type when on DEATH
            if ttype == DEATH then
                //check full sides individually                
                //if GetTerrainType(x + tOFFSET, y) == DEATH and GetTerrainType(x + tOFFSET * .75, y + tOFFSET * .75) == DEATH and GetTerrainType(x + tOFFSET * .75, y - tOFFSET * .75) == DEATH then
                
                //endif
                
                //get centerpoint and check based on that
                set terrainCenter=GetTerrainCenterpoint(x , y)
                set s__vector2_x[terrainCenter]=s__vector2_x[terrainCenter] - x
                set s__vector2_y[terrainCenter]=s__vector2_y[terrainCenter] - y
                
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "offset: " + R2S(offsetZone) + "; x, y: " + R2S(terrainCenter.x) + ", " + R2S(terrainCenter.y))
                
				//check if unit is within a much smaller square centered on this tile
                if s__vector2_x[terrainCenter] < offsetZone and s__vector2_x[terrainCenter] > - offsetZone and s__vector2_y[terrainCenter] < offsetZone and s__vector2_y[terrainCenter] > - offsetZone then




                        call DestroyEffect(AddSpecialEffect(Platformer_TERRAIN_KILL_FX, s__Platformer_XPosition[this], s__Platformer_YPosition[this]))

                    

                        call sc__User_SwitchGameModesDefaultLocation((s__Platformer_PID[(this)]),Teams_GAMEMODE_DYING) // INLINED!!

                    
					call s__vector2_deallocate((terrainCenter)) // INLINED!!
                    return
                else
					//check if unit is within a larger rectangle, formed by multiple squares of adjoining lava or non pathable tiles
                    if s__vector2_x[terrainCenter] <= - offsetZone then
                        //on right side -- either of two corners or the middle
                        set ttype=GetTerrainType(x + Platformer___tOFFSET, y)
                        if ttype == DEATH or not TerrainGlobals_IsTerrainPathable(ttype) then
                            if s__vector2_y[terrainCenter] <= - offsetZone then
                                //top right
                                set ttype=GetTerrainType(x + Platformer___tOFFSET, y + Platformer___tOFFSET)
                                if ttype == DEATH or not TerrainGlobals_IsTerrainPathable(ttype) then
                                    set ttype=GetTerrainType(x, y + Platformer___tOFFSET)
                                    if ttype == DEATH or not TerrainGlobals_IsTerrainPathable(ttype) then




                                            call DestroyEffect(AddSpecialEffect(Platformer_TERRAIN_KILL_FX, s__Platformer_XPosition[this], s__Platformer_YPosition[this]))

                                        

                                            call sc__User_SwitchGameModesDefaultLocation((s__Platformer_PID[(this)]),Teams_GAMEMODE_DYING) // INLINED!!


										call s__vector2_deallocate((terrainCenter)) // INLINED!!
                                        return
                                        //set ttype = DEATH
                                    endif
                                endif
                            elseif s__vector2_y[terrainCenter] >= offsetZone then
                                //bot right
                                set ttype=GetTerrainType(x + Platformer___tOFFSET, y - Platformer___tOFFSET)
                                if ttype == DEATH or not TerrainGlobals_IsTerrainPathable(ttype) then
                                    set ttype=GetTerrainType(x, y - Platformer___tOFFSET)
                                    if ttype == DEATH or not TerrainGlobals_IsTerrainPathable(ttype) then




                                            call DestroyEffect(AddSpecialEffect(Platformer_TERRAIN_KILL_FX, s__Platformer_XPosition[this], s__Platformer_YPosition[this]))

                                        

                                            call sc__User_SwitchGameModesDefaultLocation((s__Platformer_PID[(this)]),Teams_GAMEMODE_DYING) // INLINED!!

                                        
										call s__vector2_deallocate((terrainCenter)) // INLINED!!
                                        return
                                        //set ttype = DEATH
                                    endif
                                endif
                            else
                                //right
                                set ttype=GetTerrainType(x + Platformer___tOFFSET, y - Platformer___tOFFSET)
                                if ttype == DEATH or not TerrainGlobals_IsTerrainPathable(ttype) then
                                    set ttype=GetTerrainType(x + Platformer___tOFFSET, y + Platformer___tOFFSET)
                                    if ttype == DEATH or not TerrainGlobals_IsTerrainPathable(ttype) then




                                            call DestroyEffect(AddSpecialEffect(Platformer_TERRAIN_KILL_FX, s__Platformer_XPosition[this], s__Platformer_YPosition[this]))

                                        

                                            call sc__User_SwitchGameModesDefaultLocation((s__Platformer_PID[(this)]),Teams_GAMEMODE_DYING) // INLINED!!

                                        
										call s__vector2_deallocate((terrainCenter)) // INLINED!!
                                        return
                                        //set ttype = DEATH
                                    endif
                                endif
                            endif
                        endif
                    elseif s__vector2_x[terrainCenter] > offsetZone then
                        //on left side
                        set ttype=GetTerrainType(x - Platformer___tOFFSET, y)
                        if ttype == DEATH or not TerrainGlobals_IsTerrainPathable(ttype) then
                            if s__vector2_y[terrainCenter] <= - offsetZone then
                                //top left
                                set ttype=GetTerrainType(x - Platformer___tOFFSET, y + Platformer___tOFFSET)
                                if ttype == DEATH or not TerrainGlobals_IsTerrainPathable(ttype) then
                                    set ttype=GetTerrainType(x, y + Platformer___tOFFSET)
                                    if ttype == DEATH or not TerrainGlobals_IsTerrainPathable(ttype) then




                                            call DestroyEffect(AddSpecialEffect(Platformer_TERRAIN_KILL_FX, s__Platformer_XPosition[this], s__Platformer_YPosition[this]))

                                        

                                            call sc__User_SwitchGameModesDefaultLocation((s__Platformer_PID[(this)]),Teams_GAMEMODE_DYING) // INLINED!!

                                        
										call s__vector2_deallocate((terrainCenter)) // INLINED!!
                                        return
                                        //set ttype = DEATH
                                    endif
                                endif
                            elseif s__vector2_y[terrainCenter] >= offsetZone then
                                //bot left
                                set ttype=GetTerrainType(x - Platformer___tOFFSET, y - Platformer___tOFFSET)
                                if ttype == DEATH or not TerrainGlobals_IsTerrainPathable(ttype) then
                                    set ttype=GetTerrainType(x, y - Platformer___tOFFSET)
                                    if ttype == DEATH or not TerrainGlobals_IsTerrainPathable(ttype) then




                                            call DestroyEffect(AddSpecialEffect(Platformer_TERRAIN_KILL_FX, s__Platformer_XPosition[this], s__Platformer_YPosition[this]))

                                        

                                            call sc__User_SwitchGameModesDefaultLocation((s__Platformer_PID[(this)]),Teams_GAMEMODE_DYING) // INLINED!!


										call s__vector2_deallocate((terrainCenter)) // INLINED!!
                                        return
                                        //set ttype = DEATH
                                    endif
                                endif
                            else
                                //left
                                set ttype=GetTerrainType(x - Platformer___tOFFSET, y - Platformer___tOFFSET)
                                if ttype == DEATH or not TerrainGlobals_IsTerrainPathable(ttype) then
                                    set ttype=GetTerrainType(x - Platformer___tOFFSET, y + Platformer___tOFFSET)
                                    if ttype == DEATH or not TerrainGlobals_IsTerrainPathable(ttype) then




                                            call DestroyEffect(AddSpecialEffect(Platformer_TERRAIN_KILL_FX, s__Platformer_XPosition[this], s__Platformer_YPosition[this]))

                                        

                                            call sc__User_SwitchGameModesDefaultLocation((s__Platformer_PID[(this)]),Teams_GAMEMODE_DYING) // INLINED!!


										call s__vector2_deallocate((terrainCenter)) // INLINED!!
                                        return
                                        //set ttype = DEATH
                                    endif
                                endif
                            endif
                        endif
                    elseif s__vector2_y[terrainCenter] <= - offsetZone then
                        //top middle side
                        set ttype=GetTerrainType(x, y + Platformer___tOFFSET)
                        if ttype == DEATH or not TerrainGlobals_IsTerrainPathable(ttype) then
                            set ttype=GetTerrainType(x - Platformer___tOFFSET, y + Platformer___tOFFSET)
                            if ttype == DEATH or not TerrainGlobals_IsTerrainPathable(ttype) then
                                set ttype=GetTerrainType(x + Platformer___tOFFSET, y + Platformer___tOFFSET)
                                if ttype == DEATH or not TerrainGlobals_IsTerrainPathable(ttype) then




                                        call DestroyEffect(AddSpecialEffect(Platformer_TERRAIN_KILL_FX, s__Platformer_XPosition[this], s__Platformer_YPosition[this]))

                                    

                                        call sc__User_SwitchGameModesDefaultLocation((s__Platformer_PID[(this)]),Teams_GAMEMODE_DYING) // INLINED!!


									call s__vector2_deallocate((terrainCenter)) // INLINED!!
                                    return
                                    //set ttype = DEATH
                                endif
                            endif
                        endif
                    elseif s__vector2_y[terrainCenter] >= offsetZone then
                        //bottom middle side
                        set ttype=GetTerrainType(x, y - Platformer___tOFFSET)
                        if ttype == DEATH or not TerrainGlobals_IsTerrainPathable(ttype) then
                            set ttype=GetTerrainType(x - Platformer___tOFFSET, y - Platformer___tOFFSET)
                            if ttype == DEATH or not TerrainGlobals_IsTerrainPathable(ttype) then
                                set ttype=GetTerrainType(x + Platformer___tOFFSET, y - Platformer___tOFFSET)
                                if ttype == DEATH or not TerrainGlobals_IsTerrainPathable(ttype) then




                                        call DestroyEffect(AddSpecialEffect(Platformer_TERRAIN_KILL_FX, s__Platformer_XPosition[this], s__Platformer_YPosition[this]))

                                    

                                        call sc__User_SwitchGameModesDefaultLocation((s__Platformer_PID[(this)]),Teams_GAMEMODE_DYING) // INLINED!!


									call s__vector2_deallocate((terrainCenter)) // INLINED!!
                                    return
                                    //set ttype = DEATH
                                endif
                            endif
                        endif
                    endif
                endif
                
                call s__vector2_deallocate((terrainCenter)) // INLINED!!
            endif
            
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "On terrain " + I2S(.TerrainDX) + ", new on terrain: " + I2S(ttype))
            
            //TODO change so that platformer dies if there are 3 adjacent points in the 8 points around them that are all lava
            //  * * X
            //  * O X
            //  X X X
            //
            // Safe
            //
            //  X * X
            //  * O X
            //  X X X
            //
            // Dead
            
            //check n
            //if true -> check n + 1 and then n - 1
            //if false -> check n + 2
            
            
            //start with death check
            
            
            if ttype == DEATH then
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Dead")
                //handled in stop platforming
                //call .RemoveTerrainEffect()
                //call .RemoveXSurfaceTerrainEffect()
                //call .RemoveYSurfaceTerrainEffect()
                
                //call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Other\\Incinerate\\FireLordDeathExplode.mdl", .XPosition, .YPosition))
                //call .KillPlatformer()
                
                return
            endif
            
            //apply any differences in terrain that platformer is being pushed against
            //effects from terrain the platformer is pushed against should be multiplicative so that they're compatible with the main terrain effects, and anything else that effects physic variables
            if s__Platformer_XTerrainPushedAgainst[this] != s__Platformer_XAppliedTerrainPushedAgainst[this] then



                
                call s__Platformer_RemoveXSurfaceTerrainEffect(this)
                
                //apply any new effects from current pushed against x terrain
                if s__Platformer_XTerrainPushedAgainst[this] == SAND then
                    call s__PlatformerPropertyEquation_addAdjustment(s__Platformer_YFalloffEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , SAND , SAND_FALLOFF)
                    set s__Platformer_YFalloff[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_YFalloffEquation[this],s__PlatformerProfile_YFalloff[s__Platformer_BaseProfile[this]])
                    //set .YFalloff = .YFalloff * SAND_FALLOFF
                elseif s__Platformer_XTerrainPushedAgainst[this] == DGRASS then
                    //set .GravitationalAccel = .GravitationalAccel * .1
                elseif s__Platformer_XTerrainPushedAgainst[this] == SLOWICE then
                    call s__PlatformerPropertyEquation_addAdjustment(s__Platformer_YFalloffEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , SLOWICE , PlatformerIce_SLOW_YFALLOFF)
					set s__Platformer_YFalloff[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_YFalloffEquation[this],s__PlatformerProfile_YFalloff[s__Platformer_BaseProfile[this]])
                    
                    call PlatformerIce_Add(this)
                elseif s__Platformer_XTerrainPushedAgainst[this] == FASTICE then
                    call s__PlatformerPropertyEquation_addAdjustment(s__Platformer_YFalloffEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , FASTICE , PlatformerIce_FAST_YFALLOFF)
                    set s__Platformer_YFalloff[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_YFalloffEquation[this],s__PlatformerProfile_YFalloff[s__Platformer_BaseProfile[this]])
                    
                    call PlatformerIce_Add(this)
                endif
                
                //update currently applied x terrain
                set s__Platformer_XAppliedTerrainPushedAgainst[this]=s__Platformer_XTerrainPushedAgainst[this]
            endif
            
            if s__Platformer_YTerrainPushedAgainst[this] != s__Platformer_YAppliedTerrainPushedAgainst[this] then



                
                call s__Platformer_RemoveYSurfaceTerrainEffect(this)
                
                //apply any new effects from current pushed against y terrain
                if s__Platformer_YTerrainPushedAgainst[this] == SAND then
                    call s__PlatformerPropertyEquation_addAdjustment(s__Platformer_XFalloffEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , SAND , SAND_FALLOFF)
                    set s__Platformer_XFalloff[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_XFalloffEquation[this],s__PlatformerProfile_XFalloff[s__Platformer_BaseProfile[this]])
                    //set .XFalloff = .XFalloff * SAND_FALLOFF
				elseif s__Platformer_YTerrainPushedAgainst[this] == GRASS then
					call s__PlatformerPropertyEquation_addAdjustment(s__Platformer_MSEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , GRASS , GRASS_MS)
                    set s__Platformer_MoveSpeed[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_MSEquation[this],s__PlatformerProfile_MoveSpeed[s__Platformer_BaseProfile[this]])
					
                    if ( s__Platformer_GravitationalAccel[this] > 0 and ( s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_Bottom or s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_SE or s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_SW ) ) or ( s__Platformer_GravitationalAccel[this] < 0 and ( s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_Top or s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_NE or s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_NW ) ) then
						call s__PlatformerPropertyEquation_addAdjustment(s__Platformer_TVYEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , GRASS , GRASS_TVY)
                        set s__Platformer_TerminalVelocityY[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_TVYEquation[this],s__PlatformerProfile_TerminalVelocityY[s__Platformer_BaseProfile[this]])
						



                    endif
                elseif s__Platformer_YTerrainPushedAgainst[this] == DGRASS then
                    call s__PlatformerPropertyEquation_addAdjustment(s__Platformer_MSEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , DGRASS , DGRASS_MS)
                    set s__Platformer_MoveSpeed[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_MSEquation[this],s__PlatformerProfile_MoveSpeed[s__Platformer_BaseProfile[this]])
					//set .MoveSpeed = .MoveSpeed * DGRASS_MS
					
                    if ( s__Platformer_GravitationalAccel[this] > 0 and ( s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_Bottom or s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_SE or s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_SW ) ) or ( s__Platformer_GravitationalAccel[this] < 0 and ( s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_Top or s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_NE or s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[this]] == ComplexTerrainPathing_NW ) ) then
                        call s__PlatformerPropertyEquation_addAdjustment(s__Platformer_TVYEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , DGRASS , DGRASS_TVY)
                        set s__Platformer_TerminalVelocityY[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_TVYEquation[this],s__PlatformerProfile_TerminalVelocityY[s__Platformer_BaseProfile[this]])
						



                    endif
                elseif s__Platformer_YTerrainPushedAgainst[this] == SLOWICE then
                    call s__PlatformerPropertyEquation_addAdjustment(s__Platformer_XFalloffEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , SLOWICE , PlatformerIce_SLOW_XFALLOFF)
                    set s__Platformer_XFalloff[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_XFalloffEquation[this],s__PlatformerProfile_XFalloff[s__Platformer_BaseProfile[this]])
                    
                    call s__PlatformerPropertyEquation_addAdjustment(s__Platformer_MSEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , SLOWICE , PlatformerIce_SLOW_MS)
                    set s__Platformer_MoveSpeed[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_MSEquation[this],s__PlatformerProfile_MoveSpeed[s__Platformer_BaseProfile[this]])
                    
                    call PlatformerIce_Add(this)
                elseif s__Platformer_YTerrainPushedAgainst[this] == FASTICE then
                    call s__PlatformerPropertyEquation_addAdjustment(s__Platformer_XFalloffEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , FASTICE , PlatformerIce_FAST_XFALLOFF)
                    set s__Platformer_XFalloff[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_XFalloffEquation[this],s__PlatformerProfile_XFalloff[s__Platformer_BaseProfile[this]])
                    
                    call s__PlatformerPropertyEquation_addAdjustment(s__Platformer_MSEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , FASTICE , PlatformerIce_FAST_MS)
                    set s__Platformer_MoveSpeed[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_MSEquation[this],s__PlatformerProfile_MoveSpeed[s__Platformer_BaseProfile[this]])
                    
                    call PlatformerIce_Add(this)
                endif
                
                //update currently applied y terrain
                set s__Platformer_YAppliedTerrainPushedAgainst[this]=s__Platformer_YTerrainPushedAgainst[this]
            endif
            
            if ttype == DEATH or TerrainGlobals_IsTerrainDiagonal(ttype) then
                //don't update regular .TerrainDX when on either death or a diagonal (those use .XAppliedTerrainPushedAgainst and .YAppliedTerrainPushedAgainst)
                return
            elseif ttype != s__Platformer_TerrainDX[this] then




                
                //remove old effect
                call s__Platformer_RemoveTerrainEffect(this)
				
				set s__Platformer_TerrainDX[this]=ttype
                
                //add new effect
                if ttype == OCEAN then
                    //apply starting velocity depending on previous properties, mostly aesthetic
                    if s__Platformer_XVelocity[this] == 0 then
                        //convert a small amount of old movespeed in current key direction to new x velocity
                        set s__Platformer_XVelocity[this]=s__Platformer_XVelocity[this] + s__Platformer_MoveSpeed[this] * .25 * s__Platformer_HorizontalAxisState[this]
                    else
                        //reduce current velocity by around half
                        set s__Platformer_XVelocity[this]=s__Platformer_XVelocity[this] * PlatformerOcean_ENTRANCE_VEL
                    endif
                    
                    set s__Platformer_YVelocity[this]=s__Platformer_YVelocity[this] * PlatformerOcean_ENTRANCE_VEL
                    
                    //set .GravitationalAccel = .GravitationalAccel * PlatformerOcean_GRAVITYPERCENT
                    //set .MoveSpeed = .MoveSpeed * PlatformerOcean_MS
                    set s__Platformer_hJumpSpeed[this]=s__Platformer_hJumpSpeed[this] * PlatformerOcean_HJUMP
                    set s__Platformer_vJumpSpeed[this]=s__Platformer_vJumpSpeed[this] * PlatformerOcean_VJUMP
                    set s__Platformer_v2hJumpRatio[this]=s__Platformer_v2hJumpRatio[this] * PlatformerOcean_V2H
                    //set .TerminalVelocityY = .TerminalVelocityY * PlatformerOcean_TVX
                    //set .TerminalVelocityX = .TerminalVelocityX * PlatformerOcean_TVY
                    //set .XFalloff = .XFalloff * PlatformerOcean_XFALLOFF
                    //set .YFalloff = .YFalloff * PlatformerOcean_YFALLOFF
                    set s__Platformer_MoveSpeedVelOffset[this]=s__Platformer_MoveSpeedVelOffset[this] * PlatformerOcean_MSOFF
                    
                    call s__PlatformerPropertyEquation_addAdjustment(s__Platformer_MSEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , OCEAN , PlatformerOcean_MS)
                    set s__Platformer_MoveSpeed[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_MSEquation[this],s__PlatformerProfile_MoveSpeed[s__Platformer_BaseProfile[this]])
                    
                    call s__PlatformerPropertyEquation_addAdjustment(s__Platformer_GravityEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , OCEAN , PlatformerOcean_GRAVITYPERCENT)
                    set s__Platformer_GravitationalAccel[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_GravityEquation[this],s__PlatformerProfile_GravitationalAccel[s__Platformer_BaseProfile[this]])
                    
                    call s__PlatformerPropertyEquation_addAdjustment(s__Platformer_XFalloffEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , OCEAN , PlatformerOcean_XFALLOFF)
                    set s__Platformer_XFalloff[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_XFalloffEquation[this],s__PlatformerProfile_XFalloff[s__Platformer_BaseProfile[this]])
                    
                    call s__PlatformerPropertyEquation_addAdjustment(s__Platformer_YFalloffEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , OCEAN , PlatformerOcean_YFALLOFF)
                    set s__Platformer_YFalloff[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_YFalloffEquation[this],s__PlatformerProfile_YFalloff[s__Platformer_BaseProfile[this]])
                                        
                    call s__PlatformerPropertyEquation_addAdjustment(s__Platformer_TVYEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , OCEAN , PlatformerOcean_TVY)
                    set s__Platformer_TerminalVelocityY[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_TVYEquation[this],s__PlatformerProfile_TerminalVelocityY[s__Platformer_BaseProfile[this]])
                    
                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Ocean base gravity: " + R2S(.BaseProfile.GravitationalAccel) + ", new gravity: " + R2S(.GravitationalAccel))
                    
                    //set .FX = AddSpecialEffect(OCEAN_JUMP_FX, x, y)
                    //call DestroyEffect(.FX)
					//set .FX = null
					call DestroyEffect(AddSpecialEffect(Platformer_OCEAN_JUMP_FX, x, y))
                    
                    call PlatformerOcean_Add(this)
                elseif ttype == VINES then
                    //set .GravitationalAccel = VINES_SLOWDOWNPERCENT * .GravitationalAccel
                    //set .TerminalVelocityY = VINES_SLOWDOWNPERCENT * .TerminalVelocityY
                    //set .MoveSpeed = VINES_MOVESPEEDPERCENT * .MoveSpeed
                    set s__Platformer_XVelocity[this]=VINES_SLOWDOWNPERCENT * s__Platformer_XVelocity[this]
                    set s__Platformer_YVelocity[this]=VINES_SLOWDOWNPERCENT * s__Platformer_YVelocity[this]
                    
                    call s__PlatformerPropertyEquation_addAdjustment(s__Platformer_MSEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , VINES , VINES_MOVESPEEDPERCENT)
                    set s__Platformer_MoveSpeed[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_MSEquation[this],s__PlatformerProfile_MoveSpeed[s__Platformer_BaseProfile[this]])
                    
                    call s__PlatformerPropertyEquation_addAdjustment(s__Platformer_GravityEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , VINES , VINES_SLOWDOWNPERCENT)
                    set s__Platformer_GravitationalAccel[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_GravityEquation[this],s__PlatformerProfile_GravitationalAccel[s__Platformer_BaseProfile[this]])
                    
                    call s__PlatformerPropertyEquation_addAdjustment(s__Platformer_TVYEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , VINES , VINES_SLOWDOWNPERCENT)
                    set s__Platformer_TerminalVelocityY[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_TVYEquation[this],s__PlatformerProfile_TerminalVelocityY[s__Platformer_BaseProfile[this]])
                    
					call DestroyEffect(AddSpecialEffect(Platformer_TERRAIN_VINES_FX, x, y))
                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "On vines, grav is: " + R2S(.GravitationalAccel))
                elseif ttype == BOOST then
					//this is too inconsistent inside this loop, will need to move it out to its own timer after all...
                    if s__Platformer_GravitationalAccel[this] > 0 then
                        set s__Platformer_YVelocity[this]=- BOOST_SPEED
                    elseif s__Platformer_GravitationalAccel[this] < 0 then
                        set s__Platformer_YVelocity[this]=BOOST_SPEED
                    endif
					
					call s__PlatformerBounce_Add(this)
                elseif ttype == SLIPSTREAM then
                    call s__PlatformerPropertyEquation_addAdjustment(s__Platformer_GravityEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , SLIPSTREAM , 0)
                    set s__Platformer_GravitationalAccel[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_GravityEquation[this],s__PlatformerProfile_GravitationalAccel[s__Platformer_BaseProfile[this]])
                    
                    //call .TVYEquation.addAdjustment(PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT, SLIPSTREAM, 10)
                    //set .TerminalVelocityY = .GravityEquation.calculateAdjustedValue(.BaseProfile.TerminalVelocityY)
                    
                    call s__PlatformerPropertyEquation_addAdjustment(s__Platformer_YFalloffEquation[this],PlatformerPropertyEquation_MULTIPLY_ADJUSTMENT , SLIPSTREAM , .1)
                    set s__Platformer_YFalloff[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_GravityEquation[this],s__PlatformerProfile_YFalloff[s__Platformer_BaseProfile[this]])
                    //set .GravitationalAccel = .GravitationalAccel * .1
                    
                    call PlatformerSlipStream_Add(this)
                elseif ttype == PLATFORMING then
					set terrainCenter=GetTerrainCenterpoint(x , y)
					
					if s__vector2_x[terrainCenter] > x then
						set x=x + Platformer___wOFFSET
					else
						set x=x - Platformer___wOFFSET
					endif
					if s__vector2_y[terrainCenter] > y then
						set y=y + Platformer___wOFFSET
					else
						set y=y - Platformer___wOFFSET
					endif
					
					call s__vector2_deallocate((terrainCenter)) // INLINED!!
					
					call sc__User_SwitchGameModes((s__Platformer_PID[this]),Teams_GAMEMODE_STANDARD , x , y)
					call sc__User_ApplyDefaultCameras((s__Platformer_PID[this]),1.)
                    // call SetDefaultCameraForPlayer(.PID, .5)
					set s__PreviousTerrainTypedx[s__Platformer_PID[this]]= PLATFORMING
					call DestroyEffect(AddSpecialEffect(Platformer_TERRAIN_STANDARD_FX, x, y))
					
                    return
                endif
			elseif s__Platformer_TerrainDX[this] == BOOST then
				//this is too inconsistent inside this loop, will need to move it out to its own timer after all...
				if s__Platformer_GravitationalAccel[this] > 0 then
					set s__Platformer_YVelocity[this]=- BOOST_SPEED
				elseif s__Platformer_GravitationalAccel[this] < 0 then
					set s__Platformer_YVelocity[this]=BOOST_SPEED
				endif
            endif
            
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Finished updating terrain")
        endfunction
        
        function s__Platformer_GameloopListIteration takes nothing returns nothing
            local integer p= s__SimpleList_List_first[s__Platformer_ActivePlatformers]
            
            loop
            exitwhen p == 0
                call s__Platformer_ApplyPhysics((s__SimpleList_ListNode_value[p]))
                set p=s__SimpleList_ListNode_next[p]
            endloop
        endfunction
        
        function s__Platformer_TerrainloopListIteration takes nothing returns nothing
   local integer p= s__SimpleList_List_first[s__Platformer_ActivePlatformers]
            
            loop
            exitwhen p == 0
                call s__Platformer_UpdateTerrain((s__SimpleList_ListNode_value[p]))
                set p=s__SimpleList_ListNode_next[p]
            endloop
        endfunction
        
        function s__Platformer_SetPhysicsToProfile takes integer this returns nothing
            //.BaseProfile refers to the default values (without any effects) for the platformer, on the current "world"
            set s__Platformer_GravitationalAccel[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_GravityEquation[this],s__PlatformerProfile_GravitationalAccel[s__Platformer_BaseProfile[this]])
            set s__Platformer_MoveSpeed[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_MSEquation[this],s__PlatformerProfile_MoveSpeed[s__Platformer_BaseProfile[this]])
            set s__Platformer_XFalloff[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_XFalloffEquation[this],s__PlatformerProfile_XFalloff[s__Platformer_BaseProfile[this]])
            set s__Platformer_YFalloff[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_YFalloffEquation[this],s__PlatformerProfile_YFalloff[s__Platformer_BaseProfile[this]])
            set s__Platformer_TerminalVelocityY[this]=s__PlatformerPropertyEquation_calculateAdjustedValue(s__Platformer_TVYEquation[this],s__PlatformerProfile_TerminalVelocityY[s__Platformer_BaseProfile[this]])
            
            //set .GravitationalAccel = .BaseProfile.GravitationalAccel
            set s__Platformer_vJumpSpeed[this]=s__PlatformerProfile_vJumpSpeed[s__Platformer_BaseProfile[this]]
            set s__Platformer_hJumpSpeed[this]=s__PlatformerProfile_hJumpSpeed[s__Platformer_BaseProfile[this]]
            //set .MoveSpeed = .BaseProfile.MoveSpeed
            //set .TerminalVelocityX = .BaseProfile.TerminalVelocityX
            //set .TerminalVelocityY = .BaseProfile.TerminalVelocityY
            //set .XFalloff = .BaseProfile.XFalloff
            //set .YFalloff = .BaseProfile.YFalloff
            
            set s__Platformer_MoveSpeedVelOffset[this]=s__PlatformerProfile_MoveSpeedVelOffset[s__Platformer_BaseProfile[this]]
            set s__Platformer_v2hJumpRatio[this]=s__PlatformerProfile_v2hJumpRatio[s__Platformer_BaseProfile[this]]
        endfunction
        
        function s__Platformer_ApplyCamera takes integer this returns nothing
			if GetLocalPlayer() == Player(s__Platformer_PID[this]) and GetCameraField(CAMERA_FIELD_ANGLE_OF_ATTACK) != 270 then
                call CameraSetupApply(s__Platformer_PlatformingCamera, true, true) //orients the camera to face down from above
				call SetCameraTargetController(s__Platformer_Unit[this], 0, 0, false) //fixes the camera to platforming unit
				
				if s__User_IsAFK[(s__Platformer_PID[this])] then
					set s__vector2_x[s__User_LocalCameraTargetPosition]=GetUnitX(s__Platformer_Unit[this])
					set s__vector2_y[s__User_LocalCameraTargetPosition]=GetUnitY(s__Platformer_Unit[this])
				endif
            endif
        endfunction
  function s__Platformer_ApplyAllCameras takes nothing returns nothing
   local integer p= s__SimpleList_List_first[s__Platformer_ActivePlatformers]
            
            loop
            exitwhen p == 0
                call s__Platformer_ApplyCamera((s__SimpleList_ListNode_value[p]))
			set p=s__SimpleList_ListNode_next[p]
            endloop
  endfunction
        
        function s__Platformer_StartPlatforming takes integer this,real x,real y returns nothing
            if not s__Platformer_IsPlatforming[this] then
                set s__Platformer_IsPlatforming[this]=true
                set s__Platformer_TerrainDX[this]=PLATFORMING
                
                set s__Platformer_OnDiagonal[this]=false
                if s__Platformer_DiagonalPathing[this] != 0 then
                    call s__ComplexTerrainPathingResult_destroy(s__Platformer_DiagonalPathing[this])
                    set s__Platformer_DiagonalPathing[this]=0
                endif
                
                set s__Platformer_XPosition[this]=x
                set s__Platformer_YPosition[this]=y
                set s__Platformer_YVelocity[this]=0
                set s__Platformer_XVelocity[this]=0
				
				set s__Platformer_PhysicsLoopDeltaApplied[this]=0.
                
                call s__Platformer_SetPhysicsToProfile(this)
                
                if s__SimpleList_List_count[s__Platformer_ActivePlatformers] == 0 then
                    call TimerStart(s__Platformer_GameloopTimer, PlatformerGlobals_GAMELOOP_TIMESTEP, true, function s__Platformer_GameloopListIteration)
                    call TimerStart(s__Platformer_TerrainloopTimer, PlatformerGlobals_TERRAINLOOP_TIMESTEP, true, function s__Platformer_TerrainloopListIteration)
                    call TimerStart(s__Platformer_CameraTimer, Platformer___CAMERA_APPLY_TIMESTEP, true, function s__Platformer_ApplyAllCameras)
                endif
                
                call SetUnitPosition(s__Platformer_Unit[this], x, y)
                call ShowUnit(s__Platformer_Unit[this], true)

                call s__SimpleList_List_add(s__Platformer_ActivePlatformers,this)
                





				
                call s__Platformer_ApplyCamera(this)
                





				



            endif
        endfunction
        
        function s__Platformer_StopPlatforming takes integer this returns nothing
            if s__Platformer_IsPlatforming[this] then
                call s__Platformer_RemoveTerrainEffect(this)
                call s__Platformer_RemoveXSurfaceTerrainEffect(this)
                call s__Platformer_RemoveYSurfaceTerrainEffect(this)
                
                set s__Platformer_IsPlatforming[this]=false
                set s__Platformer_HorizontalAxisState[this]=0
                set s__Platformer_LeftKey[this]=false
                set s__Platformer_RightKey[this]=false
                call s__SimpleList_List_remove(s__Platformer_ActivePlatformers,this)
                
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Start clearing adjustments")
                call s__PlatformerPropertyEquation_clearAdjustments(s__Platformer_MSEquation[this])
                call s__PlatformerPropertyEquation_clearAdjustments(s__Platformer_GravityEquation[this])
                call s__PlatformerPropertyEquation_clearAdjustments(s__Platformer_XFalloffEquation[this])
                call s__PlatformerPropertyEquation_clearAdjustments(s__Platformer_YFalloffEquation[this])
                call s__PlatformerPropertyEquation_clearAdjustments(s__Platformer_TVYEquation[this])
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "End clearing adjustments")
                
                if s__SimpleList_List_count[s__Platformer_ActivePlatformers] == 0 then
                    call PauseTimer(s__Platformer_GameloopTimer)
                    call PauseTimer(s__Platformer_TerrainloopTimer)
					call PauseTimer(s__Platformer_CameraTimer)
                endif
                





				
				call sc__User_ResetDefaultCamera((s__Platformer_PID[this]),0.)
				
				call ShowUnit(s__Platformer_Unit[this], false)
				//call SetUnitPosition(.Unit, PlatformerGlobals_SAFE_X, PlatformerGlobals_SAFE_Y)
				





                



            endif
        endfunction
        
        
//textmacro instance: horizontal_toggles("PRESSED")
        function s__Platformer_Left_PRESSED takes nothing returns boolean
            local integer pID= GetPlayerId(GetTriggerPlayer())
            local integer p= s__User_Platformer[(pID)]
            local integer ttype
            local real newX
            
            set s__Platformer_LeftKey[p]=Platformer___PRESSED
            
            if s__Platformer_IsPlatforming[p] then

                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Left key pressed")
                    if not s__Platformer_RightKey[p] then //and right key not down
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "And right not down")
                        set s__Platformer_HorizontalAxisState[p]=- 1
                        set s__Platformer_LastHorizontalKey[p]=- 1
                        
						call s__Platformer_ApplyPhysics(p)
						
						
                    endif

















            endif
            
            return false
        endfunction
        
        function s__Platformer_Right_PRESSED takes nothing returns boolean
            local integer pID= GetPlayerId(GetTriggerPlayer())
            local integer p= s__User_Platformer[(pID)]
            local integer ttype
            local real newX
            
            set s__Platformer_RightKey[p]=Platformer___PRESSED
            
            if s__Platformer_IsPlatforming[p] then

                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Right key pressed")
                    if not s__Platformer_LeftKey[p] then //and left key down
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "And left not down")
                        set s__Platformer_HorizontalAxisState[p]=1
                        set s__Platformer_LastHorizontalKey[p]=1
                        
						call s__Platformer_ApplyPhysics(p)
						
						
                    endif

















            endif
            
            return false
        endfunction
//end of: horizontal_toggles("PRESSED")
//textmacro instance: horizontal_toggles("RELEASED")
        function s__Platformer_Left_RELEASED takes nothing returns boolean
            local integer pID= GetPlayerId(GetTriggerPlayer())
            local integer p= s__User_Platformer[(pID)]
            local integer ttype
            local real newX
            
            set s__Platformer_LeftKey[p]=Platformer___RELEASED
            
            if s__Platformer_IsPlatforming[p] then












                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Left key released")
                    if s__Platformer_RightKey[p] then
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "And right down")
                        //set axis state towards right and move unit a bit
                        set s__Platformer_HorizontalAxisState[p]=1
                        set s__Platformer_LastHorizontalKey[p]=1
                        
						call s__Platformer_ApplyPhysics(p)
						
						
                    else
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "And right not down")
                        //set axis state to neutral
                        set s__Platformer_HorizontalAxisState[p]=0
                    endif

            endif
            
            return false
        endfunction
        
        function s__Platformer_Right_RELEASED takes nothing returns boolean
            local integer pID= GetPlayerId(GetTriggerPlayer())
            local integer p= s__User_Platformer[(pID)]
            local integer ttype
            local real newX
            
            set s__Platformer_RightKey[p]=Platformer___RELEASED
            
            if s__Platformer_IsPlatforming[p] then












                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Right key released")
                    if s__Platformer_LeftKey[p] then
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "And left down")
                        //set axis state towards left and move unit a bit
                        set s__Platformer_HorizontalAxisState[p]=- 1
                        set s__Platformer_LastHorizontalKey[p]=- 1
						
						call s__Platformer_ApplyPhysics(p)
						
						
                    else
                        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "And left not down")
                        //set axis state to neutral
                        set s__Platformer_HorizontalAxisState[p]=0
                    endif

            endif
            
            return false
        endfunction
//end of: horizontal_toggles("RELEASED")
        
        function s__Platformer_OceanJumpCB takes nothing returns nothing
            local timer t= GetExpiredTimer()
            local integer p= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
            
            set s__Platformer_CanOceanJump[p]=true
            
            call ReleaseTimer(t)
            set t=null
        endfunction
        
        function s__Platformer_Up_PRESSED takes nothing returns boolean
            local integer pID= GetPlayerId(GetTriggerPlayer())
            local integer p= s__User_Platformer[(pID)]
   local integer pathingResult
			//ComplexTerrainPathing_GetPathingForPoint(.XPosition + newX, .YPosition + newY)
            local real l
            



            
            //only apply logic if player is platforming
            if s__Platformer_IsPlatforming[p] then





                
                if s__Platformer_OnDiagonal[p] or s__Platformer_PushedAgainstVector[p] != 0 then
                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Diagonal jump!")
                    
                    if s__Platformer_PushedAgainstVector[p] == ComplexTerrainPathing_NE_UnitVector then
                        set l=s__Platformer_hJumpSpeed[p] * s__vector2_x[s__Platformer_PushedAgainstVector[p]] + s__Platformer_vJumpSpeed[p] * s__vector2_y[s__Platformer_PushedAgainstVector[p]]
                        
                        set s__Platformer_XVelocity[p]=s__Platformer_XVelocity[p] + l * s__vector2_x[s__Platformer_PushedAgainstVector[p]]
                        set s__Platformer_YVelocity[p]=s__Platformer_YVelocity[p] + l * s__vector2_y[s__Platformer_PushedAgainstVector[p]]
                        
                        
                        call DestroyEffect(AddSpecialEffect(Platformer_NON_VERTICAL_JUMP_FX, s__Platformer_XPosition[p], s__Platformer_YPosition[p]))
						
						call s__Platformer_ApplyPhysics(p)
						
                        return false
                    elseif s__Platformer_PushedAgainstVector[p] == ComplexTerrainPathing_SW_UnitVector then
                        set l=- s__Platformer_hJumpSpeed[p] * s__vector2_x[s__Platformer_PushedAgainstVector[p]] + - s__Platformer_vJumpSpeed[p] * s__vector2_y[s__Platformer_PushedAgainstVector[p]]
                        
                        set s__Platformer_XVelocity[p]=s__Platformer_XVelocity[p] + l * s__vector2_x[s__Platformer_PushedAgainstVector[p]]
                        set s__Platformer_YVelocity[p]=s__Platformer_YVelocity[p] + l * s__vector2_y[s__Platformer_PushedAgainstVector[p]]
                        
                        call DestroyEffect(AddSpecialEffect(Platformer_NON_VERTICAL_JUMP_FX, s__Platformer_XPosition[p], s__Platformer_YPosition[p]))
						
						call s__Platformer_ApplyPhysics(p)
						
						return false
                    elseif s__Platformer_PushedAgainstVector[p] == ComplexTerrainPathing_SE_UnitVector then
                        set l=s__Platformer_hJumpSpeed[p] * s__vector2_x[s__Platformer_PushedAgainstVector[p]] + - s__Platformer_vJumpSpeed[p] * s__vector2_y[s__Platformer_PushedAgainstVector[p]]
                        
                        set s__Platformer_XVelocity[p]=s__Platformer_XVelocity[p] + l * s__vector2_x[s__Platformer_PushedAgainstVector[p]]
                        set s__Platformer_YVelocity[p]=s__Platformer_YVelocity[p] + l * s__vector2_y[s__Platformer_PushedAgainstVector[p]]
                        
                        call DestroyEffect(AddSpecialEffect(Platformer_NON_VERTICAL_JUMP_FX, s__Platformer_XPosition[p], s__Platformer_YPosition[p]))
                        
						call s__Platformer_ApplyPhysics(p)
						
                        return false
                    elseif s__Platformer_PushedAgainstVector[p] == ComplexTerrainPathing_NW_UnitVector then
                        set l=- s__Platformer_hJumpSpeed[p] * s__vector2_x[s__Platformer_PushedAgainstVector[p]] + s__Platformer_vJumpSpeed[p] * s__vector2_y[s__Platformer_PushedAgainstVector[p]]
                        
                        set s__Platformer_XVelocity[p]=s__Platformer_XVelocity[p] + l * s__vector2_x[s__Platformer_PushedAgainstVector[p]]
                        set s__Platformer_YVelocity[p]=s__Platformer_YVelocity[p] + l * s__vector2_y[s__Platformer_PushedAgainstVector[p]]
                        
                        call DestroyEffect(AddSpecialEffect(Platformer_NON_VERTICAL_JUMP_FX, s__Platformer_XPosition[p], s__Platformer_YPosition[p]))
                        
						call s__Platformer_ApplyPhysics(p)
						



                        
                        return false
                    elseif s__Platformer_PushedAgainstVector[p] == ComplexTerrainPathing_Up_UnitVector or s__Platformer_PushedAgainstVector[p] == ComplexTerrainPathing_Down_UnitVector and (TerrainGlobals_IsTerrainUnpathable((s__Platformer_YTerrainPushedAgainst[p]))) then // INLINED!!
                        set s__Platformer_YVelocity[p]=s__Platformer_vJumpSpeed[p] * s__vector2_y[s__Platformer_PushedAgainstVector[p]]
                        
                        //experimental
                        //set p.XVelocity = 0
                        
                        call DestroyEffect(AddSpecialEffect(Platformer_VERTICAL_JUMP_FX, s__Platformer_XPosition[p], s__Platformer_YPosition[p]))
						



						
						call s__Platformer_ApplyPhysics(p)
                        
                        return false
                    elseif s__Platformer_PushedAgainstVector[p] == ComplexTerrainPathing_Left_UnitVector or s__Platformer_PushedAgainstVector[p] == ComplexTerrainPathing_Right_UnitVector and TerrainGlobals_IsTerrainWallJumpable(s__Platformer_XTerrainPushedAgainst[p]) then
                        set s__Platformer_XVelocity[p]=s__Platformer_hJumpSpeed[p] * s__vector2_x[s__Platformer_PushedAgainstVector[p]]
                        
						if TerrainGlobals_IsTerrainGoodFooting(s__Platformer_XTerrainPushedAgainst[p]) then
							if s__Platformer_GravitationalAccel[p] < 0 then
								set s__Platformer_YVelocity[p]=s__Platformer_vJumpSpeed[p] * s__Platformer_v2hJumpRatio[p]
							elseif s__Platformer_GravitationalAccel[p] > 0 then
								set s__Platformer_YVelocity[p]=- s__Platformer_vJumpSpeed[p] * s__Platformer_v2hJumpRatio[p]
							endif
						else
							if s__Platformer_GravitationalAccel[p] < 0 then
								set s__Platformer_YVelocity[p]=s__Platformer_YVelocity[p] + s__Platformer_vJumpSpeed[p] * s__Platformer_v2hJumpRatio[p]
							elseif s__Platformer_GravitationalAccel[p] > 0 then
								set s__Platformer_YVelocity[p]=s__Platformer_YVelocity[p] + - s__Platformer_vJumpSpeed[p] * s__Platformer_v2hJumpRatio[p]
							endif
						endif
						



                        
                        call DestroyEffect(AddSpecialEffect(Platformer_NON_VERTICAL_JUMP_FX, s__Platformer_XPosition[p], s__Platformer_YPosition[p]))
                        
						call s__Platformer_ApplyPhysics(p)
						
                        return false
                    endif
                else
                    //double check that there's nothing close by for the sake of playability -- this only applies when not on a diagonal
                    //physics loop lags behind key event too much
                    
                    //check below or above y, assuming 
                    //p.YPosition



					
                    if ( s__Platformer_YVelocity[p] == 0 and s__Platformer_GravitationalAccel[p] > 0 ) or s__Platformer_YVelocity[p] > 0 then
                        set pathingResult=ComplexTerrainPathing_GetPathingForPoint(s__Platformer_XPosition[p] , s__Platformer_YPosition[p] + Platformer___vjBUFFER)
						
						if ( s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Square or s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Bottom ) and (TerrainGlobals_IsTerrainUnpathable((s__ComplexTerrainPathingResult_GetYTerrainType(pathingResult)))) then // INLINED!!
							set s__Platformer_YVelocity[p]=- s__Platformer_vJumpSpeed[p]
                            
                            //Objects\Spawnmodels\Other\ToonBoom\ToonBoom.mdl
                            call DestroyEffect(AddSpecialEffect(Platformer_VERTICAL_JUMP_FX, s__Platformer_XPosition[p], s__Platformer_YPosition[p]))
                            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Vert jump " + R2S(p.YVelocity))
                            



							
							call s__ComplexTerrainPathingResult_destroy(pathingResult)
							return false
						endif
						
						call s__ComplexTerrainPathingResult_destroy(pathingResult)
						
						// if TerrainGlobals_IsTerrainJumpable(GetTerrainType(p.XPosition, p.YPosition + vjBUFFER)) then
                            // set p.YVelocity = -p.vJumpSpeed
                            
                            // //Objects\Spawnmodels\Other\ToonBoom\ToonBoom.mdl
                            // call DestroyEffect(AddSpecialEffect(VERTICAL_JUMP_FX, p.XPosition, p.YPosition))
                            // //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Vert jump " + R2S(p.YVelocity))
                            
							// static if DEBUG_JUMPING then
								// call DisplayTextToForce(bj_FORCE_PLAYER[0], "Found vertical opposition above")
							// endif
							
                            // return false
                        // endif
                    elseif ( s__Platformer_YVelocity[p] == 0 and s__Platformer_GravitationalAccel[p] < 0 ) or s__Platformer_YVelocity[p] < 0 then
                        set pathingResult=ComplexTerrainPathing_GetPathingForPoint(s__Platformer_XPosition[p] , s__Platformer_YPosition[p] - Platformer___vjBUFFER)
						// call DisplayTextToForce(bj_FORCE_PLAYER[0], "Pathing below: " + I2S(pathingResult.TerrainPathingForPoint))
						
						if ( s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Square or s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Top ) and (TerrainGlobals_IsTerrainUnpathable((s__ComplexTerrainPathingResult_GetYTerrainType(pathingResult)))) then // INLINED!!
							set s__Platformer_YVelocity[p]=s__Platformer_vJumpSpeed[p]
                            
                            //Objects\Spawnmodels\Other\ToonBoom\ToonBoom.mdl
                            call DestroyEffect(AddSpecialEffect(Platformer_VERTICAL_JUMP_FX, s__Platformer_XPosition[p], s__Platformer_YPosition[p]))
                            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Vert jump " + R2S(p.YVelocity))
                            



							
							call s__ComplexTerrainPathingResult_destroy(pathingResult)
							return false
						endif
						
						call s__ComplexTerrainPathingResult_destroy(pathingResult)
						
						// if TerrainGlobals_IsTerrainJumpable(GetTerrainType(p.XPosition, p.YPosition - vjBUFFER)) then                    
                            // set p.YVelocity = p.vJumpSpeed
                        
                            // call DestroyEffect(AddSpecialEffect(VERTICAL_JUMP_FX, p.XPosition, p.YPosition))
                            // //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Vert jump " + R2S(p.YVelocity))
                            
							// static if DEBUG_JUMPING then
								// call DisplayTextToForce(bj_FORCE_PLAYER[0], "Found vertical opposition below")
							// endif
							
                            // return false
                        // endif
                    endif
                    
                    //check left of x
					set pathingResult=ComplexTerrainPathing_GetPathingForPoint(s__Platformer_XPosition[p] - Platformer___hjBUFFER , s__Platformer_YPosition[p])
						
					if ( s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Square or s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Right ) and TerrainGlobals_IsTerrainWallJumpable(s__ComplexTerrainPathingResult_GetXTerrainType(pathingResult)) then
						//apply a percentage, given by v2hJumpRatio, of vJumpSpeed as immediate YVelocity
                        if TerrainGlobals_IsTerrainGoodFooting(s__ComplexTerrainPathingResult_GetXTerrainType(pathingResult)) then
							if s__Platformer_GravitationalAccel[p] < 0 then
								set s__Platformer_YVelocity[p]=s__Platformer_vJumpSpeed[p] * s__Platformer_v2hJumpRatio[p]
							elseif s__Platformer_GravitationalAccel[p] > 0 then
								set s__Platformer_YVelocity[p]=- s__Platformer_vJumpSpeed[p] * s__Platformer_v2hJumpRatio[p]
							endif
						else
							if s__Platformer_GravitationalAccel[p] < 0 then
								set s__Platformer_YVelocity[p]=s__Platformer_YVelocity[p] + s__Platformer_vJumpSpeed[p] * s__Platformer_v2hJumpRatio[p]
							elseif s__Platformer_GravitationalAccel[p] > 0 then
								set s__Platformer_YVelocity[p]=s__Platformer_YVelocity[p] + - s__Platformer_vJumpSpeed[p] * s__Platformer_v2hJumpRatio[p]
							endif
						endif
                        



						
                        //apply full horizontal jump speed (this is the only use for it)
                        set s__Platformer_XVelocity[p]=s__Platformer_hJumpSpeed[p]
                        
                        call DestroyEffect(AddSpecialEffect(Platformer_NON_VERTICAL_JUMP_FX, s__Platformer_XPosition[p], s__Platformer_YPosition[p]))
						
						call s__ComplexTerrainPathingResult_destroy(pathingResult)
						return false
					endif
					
					call s__ComplexTerrainPathingResult_destroy(pathingResult)
					
					//check right of x
					set pathingResult=ComplexTerrainPathing_GetPathingForPoint(s__Platformer_XPosition[p] + Platformer___hjBUFFER , s__Platformer_YPosition[p])
						
					if ( s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Square or s__ComplexTerrainPathingResult_TerrainPathingForPoint[pathingResult] == ComplexTerrainPathing_Left ) and TerrainGlobals_IsTerrainWallJumpable(s__ComplexTerrainPathingResult_GetXTerrainType(pathingResult)) then
						//apply a percentage, given by v2hJumpRatio, of vJumpSpeed as immediate YVelocity
						if TerrainGlobals_IsTerrainGoodFooting(s__ComplexTerrainPathingResult_GetXTerrainType(pathingResult)) then
							if s__Platformer_GravitationalAccel[p] < 0 then
								set s__Platformer_YVelocity[p]=s__Platformer_vJumpSpeed[p] * s__Platformer_v2hJumpRatio[p]
							elseif s__Platformer_GravitationalAccel[p] > 0 then
								set s__Platformer_YVelocity[p]=- s__Platformer_vJumpSpeed[p] * s__Platformer_v2hJumpRatio[p]
							endif
						else
							if s__Platformer_GravitationalAccel[p] < 0 then
								set s__Platformer_YVelocity[p]=s__Platformer_YVelocity[p] + s__Platformer_vJumpSpeed[p] * s__Platformer_v2hJumpRatio[p]
							elseif s__Platformer_GravitationalAccel[p] > 0 then
								set s__Platformer_YVelocity[p]=s__Platformer_YVelocity[p] + - s__Platformer_vJumpSpeed[p] * s__Platformer_v2hJumpRatio[p]
							endif
						endif
                        



						
                        //apply full horizontal jump speed (this is the only use for it)
                        set s__Platformer_XVelocity[p]=- s__Platformer_hJumpSpeed[p]
                        
                        call DestroyEffect(AddSpecialEffect(Platformer_NON_VERTICAL_JUMP_FX, s__Platformer_XPosition[p], s__Platformer_YPosition[p]))
						
						call s__ComplexTerrainPathingResult_destroy(pathingResult)
						return false
					endif
					
					call s__ComplexTerrainPathingResult_destroy(pathingResult)
										
                    // if TerrainGlobals_IsTerrainWallJumpable(GetTerrainType(p.XPosition - hjBUFFER, p.YPosition)) and TerrainGlobals_IsTerrainSquare(GetTerrainType(p.XPosition - hjBUFFER, p.YPosition)) then
                        // //apply a percentage, given by v2hJumpRatio, of vJumpSpeed as immediate YVelocity
                        // if TerrainGlobals_IsTerrainGoodFooting(GetTerrainType(p.XPosition - hjBUFFER, p.YPosition)) then
							// if p.GravitationalAccel < 0 then
								// set p.YVelocity = p.vJumpSpeed * p.v2hJumpRatio
							// elseif p.GravitationalAccel > 0 then
								// set p.YVelocity = -p.vJumpSpeed * p.v2hJumpRatio
							// endif
						// else
							// if p.GravitationalAccel < 0 then
								// set p.YVelocity = p.YVelocity + p.vJumpSpeed * p.v2hJumpRatio
							// elseif p.GravitationalAccel > 0 then
								// set p.YVelocity = p.YVelocity + -p.vJumpSpeed * p.v2hJumpRatio
							// endif
						// endif
                        
						// static if DEBUG_JUMPING then
							// call DisplayTextToForce(bj_FORCE_PLAYER[0], "Found horizontal opposition left")
						// endif
						
                        // //apply full horizontal jump speed (this is the only use for it)
                        // set p.XVelocity = p.hJumpSpeed
                        
                        // call DestroyEffect(AddSpecialEffect(NON_VERTICAL_JUMP_FX, p.XPosition, p.YPosition))
                        // //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Left wall jump " + R2S(p.YVelocity) + ", " + R2S(p.XVelocity))
                        
                        // return false
                    // endif
                    
                    //otherwise check if can right wall jump
                    // if TerrainGlobals_IsTerrainWallJumpable(GetTerrainType(p.XPosition + hjBUFFER, p.YPosition)) and TerrainGlobals_IsTerrainSquare(GetTerrainType(p.XPosition + hjBUFFER, p.YPosition)) then
                        // //apply a percentage, given by v2hJumpRatio, of vJumpSpeed as immediate YVelocity
						// if TerrainGlobals_IsTerrainGoodFooting(GetTerrainType(p.XPosition + hjBUFFER, p.YPosition)) then
							// if p.GravitationalAccel < 0 then
								// set p.YVelocity = p.vJumpSpeed * p.v2hJumpRatio
							// elseif p.GravitationalAccel > 0 then
								// set p.YVelocity = -p.vJumpSpeed * p.v2hJumpRatio
							// endif
						// else
							// if p.GravitationalAccel < 0 then
								// set p.YVelocity = p.YVelocity + p.vJumpSpeed * p.v2hJumpRatio
							// elseif p.GravitationalAccel > 0 then
								// set p.YVelocity = p.YVelocity + -p.vJumpSpeed * p.v2hJumpRatio
							// endif
						// endif
                        
						// static if DEBUG_JUMPING then
							// call DisplayTextToForce(bj_FORCE_PLAYER[0], "Found horizontal opposition right")
						// endif
						
                        // //apply full horizontal jump speed (this is the only use for it)
                        // set p.XVelocity = -p.hJumpSpeed
                        
                        // call DestroyEffect(AddSpecialEffect(NON_VERTICAL_JUMP_FX, p.XPosition, p.YPosition))
                        // //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Right wall jump " + R2S(p.YVelocity) + ", " + R2S(p.XVelocity))
                        
                        // return false
                    // endif
                endif
                
                if s__Platformer_TerrainDX[p] == OCEAN and s__Platformer_CanOceanJump[p] then
                    set s__Platformer_CanOceanJump[p]=false
                    call TimerStart(NewTimerEx(p), OCEAN_JUMP_COOLDOWN, false, function s__Platformer_OceanJumpCB)
                    //TODO give platformer unit an abil to show jump CD
                    
                    if s__Platformer_GravitationalAccel[p] < 0 then
                        set s__Platformer_YVelocity[p]=JUMPHEIGHTINOCEAN
                    elseif s__Platformer_GravitationalAccel[p] > 0 then
                        set s__Platformer_YVelocity[p]=- JUMPHEIGHTINOCEAN
                    endif
                    
                    //remove some of the x velocity
                    set s__Platformer_XVelocity[p]=s__Platformer_XVelocity[p] * PlatformerOcean_XVELOCITYONJUMP
                    
                    //set e = AddSpecialEffect("Doodads\\Icecrown\\Water\\BubbleGeyserSteam\\BubbleGeyserSteam.mdl", x, y)
                    call DestroyEffect(AddSpecialEffect(Platformer_OCEAN_JUMP_FX, s__Platformer_XPosition[p], s__Platformer_YPosition[p]))
                    //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Vert jump " + R2S(p.YVelocity))
                    
                    return false
                endif
            endif
            
            return false
        endfunction
        
        
        function s__Platformer_create takes integer pID returns integer
            local integer new= s__Platformer_allocate()
			



            
            set s__Platformer_PID[new]=pID
            
            set s__Platformer_LeftKey[new]=false
            set s__Platformer_RightKey[new]=false
            set s__Platformer_LastHorizontalKey[new]=0 //none since last death
            set s__Platformer_HorizontalAxisState[new]=0 //none
            
            set s__Platformer_CanOceanJump[new]=true
            
            set s__Platformer_BaseProfile[new]=PlatformerProfile_DefaultProfileID
            
            set s__Platformer_MSEquation[new]=s__PlatformerPropertyEquation_create()
            set s__Platformer_GravityEquation[new]=s__PlatformerPropertyEquation_create()
            set s__Platformer_XFalloffEquation[new]=s__PlatformerPropertyEquation_create()
            set s__Platformer_YFalloffEquation[new]=s__PlatformerPropertyEquation_create()
            set s__Platformer_TVYEquation[new]=s__PlatformerPropertyEquation_create()
            
            set s__Platformer_Unit[new]=CreateUnit(Player(pID), PLATFORMERWISP, PlatformerGlobals_SAFE_X, PlatformerGlobals_SAFE_Y, 0)
            call UnitAddAbility(s__Platformer_Unit[new], 'Aloc')
            call ShowUnit(s__Platformer_Unit[new], false)
			call UnitRemoveAbility(s__Platformer_Unit[new], 'Aloc')
            //sets the directions the unit is allowed to turn in, 0 means it move in no direction
            call SetUnitPropWindow(s__Platformer_Unit[new], 0)
            
            set s__Platformer_IsPlatforming[new]=false
            
                        
            call TriggerRegisterPlayerEvent(s__s__Platformer_ArrowKeyTriggers[0], Player(pID), EVENT_PLAYER_ARROW_LEFT_DOWN)
            call TriggerRegisterPlayerEvent(s__s__Platformer_ArrowKeyTriggers[1], Player(pID), EVENT_PLAYER_ARROW_LEFT_UP)
            call TriggerRegisterPlayerEvent(s__s__Platformer_ArrowKeyTriggers[2], Player(pID), EVENT_PLAYER_ARROW_RIGHT_DOWN)
            call TriggerRegisterPlayerEvent(s__s__Platformer_ArrowKeyTriggers[3], Player(pID), EVENT_PLAYER_ARROW_RIGHT_UP)
            call TriggerRegisterPlayerEvent(s__s__Platformer_ArrowKeyTriggers[4], Player(pID), EVENT_PLAYER_ARROW_UP_DOWN)
                                    



                        
            return new
        endfunction
        
  function s__Platformer_OnUnitDamaged takes nothing returns boolean
   local unit source= GetEventDamageSource()
   local unit target= GetTriggerUnit()
			
			// call DisplayTextToForce(bj_FORCE_PLAYER[0], "damage taken somewhere!")
			
			if GetUnitTypeId(source) == SMLMORT and GetUnitTypeId(target) == PLATFORMERWISP then
				call sc__User_SwitchGameModesDefaultLocation((s__Platformer_PID[(s__User_Platformer[(GetPlayerId(GetOwningPlayer(target)))])]),Teams_GAMEMODE_DYING) // INLINED!!
			endif
			
			set source=null
			set target=null
			return false
  endfunction
        function s__Platformer_onInit takes nothing returns nothing
            local integer i= 0
            local integer p
   local trigger damageEvent= CreateTrigger()
            
			set s__Platformer_PlatformingCamera=CreateCameraSetup()
            call CameraSetupSetField(s__Platformer_PlatformingCamera, CAMERA_FIELD_ANGLE_OF_ATTACK, 270, 0)
            call CameraSetupSetField(s__Platformer_PlatformingCamera, CAMERA_FIELD_TARGET_DISTANCE, 2200, 0)
			
			set s__s__Platformer_ArrowKeyTriggers[0]= CreateTrigger()
            set s__s__Platformer_ArrowKeyTriggers[1]= CreateTrigger()
            set s__s__Platformer_ArrowKeyTriggers[2]= CreateTrigger()
            set s__s__Platformer_ArrowKeyTriggers[3]= CreateTrigger()
            set s__s__Platformer_ArrowKeyTriggers[4]= CreateTrigger()
			
			call TriggerAddCondition(s__s__Platformer_ArrowKeyTriggers[0], Condition(function s__Platformer_Left_PRESSED))
            call TriggerAddCondition(s__s__Platformer_ArrowKeyTriggers[1], Condition(function s__Platformer_Left_RELEASED))
            call TriggerAddCondition(s__s__Platformer_ArrowKeyTriggers[2], Condition(function s__Platformer_Right_PRESSED))
            call TriggerAddCondition(s__s__Platformer_ArrowKeyTriggers[3], Condition(function s__Platformer_Right_RELEASED))
            call TriggerAddCondition(s__s__Platformer_ArrowKeyTriggers[4], Condition(function s__Platformer_Up_PRESSED))
			
			set s__Platformer_ActivePlatformers=s__SimpleList_List_create()
			
            set s__Platformer_GameloopTimer=CreateTimer()
            set s__Platformer_TerrainloopTimer=CreateTimer()
			set s__Platformer_CameraTimer=CreateTimer()
			
			//TODO, depending on the number of damage events that are fired during gameplay, it might be more performant to declare a global trigger for plat damage and register each individual wisp with a damaged event
			//Currently, there are very few damage events resolving
			call TriggerRegisterAnyUnitEventBJ(damageEvent, EVENT_PLAYER_UNIT_DAMAGED)
			call TriggerAddCondition(damageEvent, Condition(function s__Platformer_OnUnitDamaged))
			set damageEvent=null
        endfunction

//library Platformer ends
//library EDWVFXPreload:
 function EDWVFXPreload___init takes nothing returns nothing
		//gamemode changes
		call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\NightElf\\EntanglingRoots\\EntanglingRootsTarget.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect(StandardGameLoop_PLATFORMING_FX, 0, 0))
		call DestroyEffect(AddSpecialEffect(Platformer_TERRAIN_STANDARD_FX, 0, 0))
		call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Human\\Resurrect\\ResurrectCaster.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Items\\AIso\\AIsoTarget.mdl", 0, 0))
		
		//collision effects
		call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Human\\Flare\\FlareTarget.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("Abilities\\Weapons\\Bolt\\BoltImpact.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Other\\HowlOfTerror\\HowlTarget.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Human\\Thunderclap\\ThunderClapCaster.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Other\\Doom\\DoomTarget.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Demon\\DarkPortal\\DarkPortalTarget.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Human\\Feedback\\SpellBreakerAttack.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Other\\BreathOfFire\\BreathOfFireMissile.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Undead\\FrostArmor\\FrostArmorTarget.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("Abilities\\Weapons\\FrostWyrmMissile\\FrostWyrmMissile.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Undead\\AnimateDead\\AnimateDeadTarget.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Undead\\DeathCoil\\DeathCoilSpecialArt.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Human\\DispelMagic\\DispelMagicTarget.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Undead\\ReplenishHealth\\ReplenishHealthCasterOverhead.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Human\\ControlMagic\\ControlMagicTarget.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Human\\SunderingBlades\\SunderingBlades.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Items\\SpellShieldAmulet\\SpellShieldCaster.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Other\\BlackArrow\\BlackArrowMissile.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("Abilities\\Weapons\\DemolisherFireMissile\\DemolisherFireMissile.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTarget.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Other\\Charm\\CharmTarget.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\NightElf\\Tranquility\\Tranquility.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Human\\Resurrect\\ResurrectTarget.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Items\\ResourceItems\\ResourceEffectTarget.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("UI\\Feedback\\GoldCredit\\GoldCredit.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Other\\Transmute\\PileofGold.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Other\\Doom\\DoomDeath.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Other\\StrongDrink\\BrewmasterMissile.mdl", 0, 0))
		
		//standard mazing terrain effects
		call DestroyEffect(AddSpecialEffect(StandardGameLoop_LAVA_MOVEMENT_FX, 0, 0))
		call DestroyEffect(AddSpecialEffect(StandardGameLoop_VINES_MOVEMENT_FX, 0, 0))
		call DestroyEffect(AddSpecialEffect(SAND_MOVEMENT_FX, 0, 0))
	
		//platforming terrain effects
		call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Undead\\FrostArmor\\FrostArmorDamage.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect("Doodads\\Icecrown\\Water\\BubbleGeyserSteam\\BubbleGeyserSteam.mdl", 0, 0))
		call DestroyEffect(AddSpecialEffect(Platformer_TERRAIN_VINES_FX, 0, 0))
		call DestroyEffect(AddSpecialEffect(PlatformerBounce_TERRAIN_SUPERBOUNCE_FX, 0, 0))
		call DestroyEffect(AddSpecialEffect(Platformer_VERTICAL_JUMP_FX, 0, 0))
		call DestroyEffect(AddSpecialEffect(Platformer_NON_VERTICAL_JUMP_FX, 0, 0))
		call DestroyEffect(AddSpecialEffect(Platformer_OCEAN_JUMP_FX, 0, 0))
		call DestroyEffect(AddSpecialEffect(Platformer_TERRAIN_KILL_FX, 0, 0))
		
	endfunction

//library EDWVFXPreload ends
//library InGameCommands:
 function ExportPlatformingVariables takes integer p returns nothing
		//display all variables on screen
		//call DisplayTextToForce(bj_FORCE_PLAYER[p.PID], "[tvx] Terminal Velocity X: " + R2S(p.TerminalVelocityX / PlatformerGlobals_GAMELOOP_TIMESTEP))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[tvy] Terminal Velocity Y: " + R2S(s__Platformer_TerminalVelocityY[p] / PlatformerGlobals_GAMELOOP_TIMESTEP))
		//call DisplayTextToForce(bj_FORCE_PLAYER[p.PID], "[tvf] Terminal Velocity Falloff: " + R2S(p.TerminalFalloff))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[xf] Horizontal Falloff: " + R2S(s__Platformer_XFalloff[p] / PlatformerGlobals_GAMELOOP_TIMESTEP))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[yf] Vertical Falloff: " + R2S(s__Platformer_YFalloff[p] / PlatformerGlobals_GAMELOOP_TIMESTEP))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[ms] Move Speed: " + R2S(s__Platformer_MoveSpeed[p] / PlatformerGlobals_GAMELOOP_TIMESTEP))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[msoff] Move Speed's Offset Effect against cur Velocity: " + R2S(s__Platformer_MoveSpeedVelOffset[p]))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[ga] Gravitational Acceleration: " + R2S(s__Platformer_GravitationalAccel[p] / PlatformerGlobals_GAMELOOP_TIMESTEP))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[vj] Vertical Jump: " + R2S(s__Platformer_vJumpSpeed[p] / PlatformerGlobals_GAMELOOP_TIMESTEP))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[v2h] Vertical 2 Horizontal Jump: " + R2S(s__Platformer_v2hJumpRatio[p]))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[hj] Horizontal Jump: " + R2S(s__Platformer_hJumpSpeed[p] / PlatformerGlobals_GAMELOOP_TIMESTEP))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[om] Ocean Motion: " + R2S(PlatformerOcean_OCEAN_MOTION / PlatformerOcean_TIMESTEP))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[ovj] Ocean Jump Height: " + R2S(JUMPHEIGHTINOCEAN / PlatformerGlobals_GAMELOOP_TIMESTEP))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[iss] Ice Slow Speed: " + R2S(PlatformerIce_SLOW_VELOCITY / PlatformerIce_TIMESTEP))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[ifs] Ice Fast Speed: " + R2S(PlatformerIce_FAST_VELOCITY / PlatformerIce_TIMESTEP))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "--------------------")
	endfunction

 function PrintPlatformingVariables takes integer p returns nothing
		//display all variables on screen
		//call DisplayTextToForce(bj_FORCE_PLAYER[p.PID], "[tvx] Terminal Velocity X: " + R2S(p.TerminalVelocityX))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[tvy] Terminal Velocity Y: " + R2S(s__Platformer_TerminalVelocityY[p]))
		//call DisplayTextToForce(bj_FORCE_PLAYER[p.PID], "[tvf] Terminal Velocity Falloff: " + R2S(p.TerminalFalloff))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[xf] Horizontal Falloff: " + R2S(s__Platformer_XFalloff[p]))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[yf] Vertical Falloff: " + R2S(s__Platformer_YFalloff[p]))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[ms] Move Speed: " + R2S(s__Platformer_MoveSpeed[p]))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[msoff] Move Speed's Offset Effect against cur Velocity: " + R2S(s__Platformer_MoveSpeedVelOffset[p]))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[ga] Gravitational Acceleration: " + R2S(s__Platformer_GravitationalAccel[p]))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[vj] Vertical Jump: " + R2S(s__Platformer_vJumpSpeed[p]))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[v2h] Vertical 2 Horizontal Jump: " + R2S(s__Platformer_v2hJumpRatio[p]))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[hj] Horizontal Jump: " + R2S(s__Platformer_hJumpSpeed[p]))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[om] Ocean Motion: " + R2S(PlatformerOcean_OCEAN_MOTION))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[ovj] Ocean Jump Height: " + R2S(JUMPHEIGHTINOCEAN))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[iss] Ice Slow Speed: " + R2S(PlatformerIce_SLOW_VELOCITY))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[ifs] Ice Fast Speed: " + R2S(PlatformerIce_FAST_VELOCITY))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "--------------------")
	endfunction

 function PrintPlatformingCurrentValues takes integer p returns nothing
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "Velocity X: " + R2S(s__Platformer_XVelocity[p]))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "Velocity Y: " + R2S(s__Platformer_YVelocity[p]))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "Movespeed: " + R2S(s__Platformer_MoveSpeed[p]))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "Grav Accel: " + R2S(s__Platformer_GravitationalAccel[p]))
		
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "Diagonal Path: " + I2S(s__ComplexTerrainPathingResult_TerrainPathingForPoint[s__Platformer_DiagonalPathing[p]]))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "Current Terrain: " + I2S(s__Platformer_TerrainDX[p]))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "Current Terrain X: " + I2S(s__Platformer_XTerrainPushedAgainst[p]) + ", " + I2S(s__Platformer_XAppliedTerrainPushedAgainst[p]))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "Current Terrain Y: " + I2S(s__Platformer_YTerrainPushedAgainst[p]) + ", " + I2S(s__Platformer_YAppliedTerrainPushedAgainst[p]))
	endfunction

 function PrintPlatformingProfileVariables takes integer p returns nothing
		//display all variables on screen
		//call DisplayTextToForce(bj_FORCE_PLAYER[p.PID], "[tvx] Terminal Velocity X: " + R2S(p.BaseProfile.TerminalVelocityX))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[tvy] Terminal Velocity Y: " + R2S(s__PlatformerProfile_TerminalVelocityY[s__Platformer_BaseProfile[p]]))
		//call DisplayTextToForce(bj_FORCE_PLAYER[p.PID], "[tvf] Terminal Velocity Falloff: " + R2S(p.TerminalFalloff))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[xf] Horizontal Falloff: " + R2S(s__PlatformerProfile_XFalloff[s__Platformer_BaseProfile[p]]))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[yf] Vertical Falloff: " + R2S(s__PlatformerProfile_YFalloff[s__Platformer_BaseProfile[p]]))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[ms] Move Speed: " + R2S(s__PlatformerProfile_MoveSpeed[s__Platformer_BaseProfile[p]]))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[msoff] Move Speed's Offset Effect against cur Velocity: " + R2S(s__PlatformerProfile_MoveSpeedVelOffset[s__Platformer_BaseProfile[p]]))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[ga] Gravitational Acceleration: " + R2S(s__PlatformerProfile_GravitationalAccel[s__Platformer_BaseProfile[p]]))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[vj] Vertical Jump: " + R2S(s__PlatformerProfile_vJumpSpeed[s__Platformer_BaseProfile[p]]))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[v2h] Vertical 2 Horizontal Jump: " + R2S(s__PlatformerProfile_v2hJumpRatio[s__Platformer_BaseProfile[p]]))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "[hj] Horizontal Jump: " + R2S(s__PlatformerProfile_hJumpSpeed[s__Platformer_BaseProfile[p]]))
		call DisplayTextToForce(bj_FORCE_PLAYER[s__Platformer_PID[p]], "--------------------")
	endfunction

 function PrintMemoryAnalysis takes integer pID returns nothing
		call DisplayTextToForce(bj_FORCE_PLAYER[pID], "Memory Analysis:")
	endfunction

 function RelayCallback takes nothing returns nothing
  local unit selectedUnit= GetEnumUnit()
  local integer pID= GetPlayerId(GetTriggerPlayer())
  local integer turnUnitInfo= s__RelayGenerator_UnitIDToRelayUnitID[GetUnitUserData(selectedUnit)]
		
		call DisplayTextToForce(bj_FORCE_PLAYER[pID], "Lane: " + I2S(s__RelayUnit_LaneNumber[turnUnitInfo]))
		call DisplayTextToForce(bj_FORCE_PLAYER[pID], "Turn center: " + s__vector2_toString(s__RelayTurn_Center[(s__SimpleList_ListNode_value[s__RelayUnit_CurrentTurn[turnUnitInfo]])]))
		call DisplayTextToForce(bj_FORCE_PLAYER[pID], "-----")
	endfunction

 function DistanceCallback takes nothing returns nothing
  local unit selectedUnit= GetEnumUnit()
  local integer pID= GetPlayerId(GetTriggerPlayer())
  local unit playerUnit= s__User_ActiveUnit[(pID)]
  local real x= GetUnitX(selectedUnit) - GetUnitX(playerUnit)
  local real y= GetUnitY(selectedUnit) - GetUnitY(playerUnit)
		
		call DisplayTextToForce(bj_FORCE_PLAYER[pID], "Distance: " + R2S(SquareRoot(x * x + y * y)))
		
		set selectedUnit=null
		set playerUnit=null
	endfunction
	
	// function Vector2AssertEquals takes vector2 v1, vector2 v2 returns nothing
		// if v1.x == v2.x then
			// call BJDebugMsg("vectors equal for x")
		// elseif v1.x != v2.x then
			// call BJDebugMsg("vectors not equal for v1.x: " + R2S(v1.x) + ", v2.x: " + R2S(v2.x) + ", diff: " + R2S(v1.x - v2.x))
		// endif
		
		// if v1.y == v2.y then
			// call BJDebugMsg("vectors equal for y")
		// elseif v1.y != v2.y then
			// call BJDebugMsg("vectors not equal for v1.y: " + R2S(v1.y) + ", v2.y: " + R2S(v2.y) + ", diff: " + R2S(v1.y - v2.y))
		// endif
	// endfunction
	// function Vector2UnitTest takes nothing returns nothing
		// local vector2 vector = vector2.create(-1.1, -123.456)
		// local string strVector = vector.toString()
		// local vector2 parsedVector = vector2.fromString(strVector)
		
		// call Vector2AssertEquals(vector, parsedVector)
		// call vector.deallocate()
		
		// set vector = vector2.create(-123.456, -1.1)
		// set strVector = vector.toString()
		// set parsedVector = vector2.fromString(strVector)
		
		// call Vector2AssertEquals(vector, parsedVector)
		// call vector.deallocate()
		
		// set vector = vector2.create(-1, -1)
		// set strVector = vector.toString()
		// set parsedVector = vector2.fromString(strVector)
		
		// call Vector2AssertEquals(vector, parsedVector)
		// call vector.deallocate()
	// endfunction

 function DebugRelay takes integer pID returns nothing
  local integer platformerLevel= s__Teams_MazingTeam_OnLevel[s__User_Team[(pID)]]
  local integer curNode= s__SimpleList_List_first[s__Levels_Level_Startables[platformerLevel]]
  local integer curIndex
  local integer relay= 0
		
		loop
		exitwhen curNode == 0 or relay != 0
			if si__IStartable_type[(s__SimpleList_ListNode_value[curNode])] == si__RelayGenerator then
				set relay=s__SimpleList_ListNode_value[curNode]
			endif
		set curNode=s__SimpleList_ListNode_next[curNode]
		endloop
		
		call DisplayTextToForce(bj_FORCE_PLAYER[pID], "Relay ID: " + I2S(relay))
		
		if relay != 0 then













		endif
	endfunction

 function OverclockRelays takes integer pID,real overclock returns nothing
  local integer level= s__Teams_MazingTeam_OnLevel[s__User_Team[(pID)]]
  local integer curNode= s__SimpleList_List_first[s__Levels_Level_Startables[level]]
  local integer curIndex
  local integer relay= 0
		
		loop
		exitwhen curNode == 0
			if si__IStartable_type[(s__SimpleList_ListNode_value[curNode])] == si__RelayGenerator then
				set relay=s__SimpleList_ListNode_value[curNode]
				call DisplayTextToForce(bj_FORCE_PLAYER[pID], "Overclocking relay: " + I2S(relay))
				
				call s__RelayGenerator_SetOverclockFactor(relay,overclock)
			endif
		set curNode=s__SimpleList_ListNode_next[curNode]
		endloop
	endfunction
	
	// function OnAllCameraSync takes integer result, Deferred all returns integer
		// // call DisplayTextToForce(bj_FORCE_PLAYER[0], "On all camera sync")
		
		// local SimpleList_ListNode curTeamNode = Teams_MazingTeam.AllTeams.first
		// local SimpleList_ListNode curUserNode
		
		// local boolean anyNonAFK
		
		// loop
		// exitwhen curTeamNode == 0
			// set curUserNode = Teams_MazingTeam(curTeamNode.value).Users.first
			// set anyNonAFK = false
			
			// loop
			// exitwhen curUserNode == 0 or anyNonAFK
				// // call DisplayTextToPlayer(Player(0), 0, 0, "User: " + I2S(curUserNode.value))
				
				// if not User(curUserNode.value).IsAFK and not User(curUserNode.value).IsAFKSync() and User(curUserNode.value).IsAlive then
					// set anyNonAFK = true
				// endif
			// set curUserNode = curUserNode.next
			// endloop
			
			// if not anyNonAFK then
				// set curUserNode = Teams_MazingTeam(curTeamNode.value).Users.first
				
				// loop
				// exitwhen curUserNode == 0
					// if not User(curUserNode.value).IsAFK and User(curUserNode.value).IsAFKSync() then
						// call User(curUserNode.value).ToggleAFK()
					// endif
				// set curUserNode = curUserNode.next
				// endloop
			// endif
		// set curTeamNode = curTeamNode.next
		// endloop
		
		// call all.destroy()
		
		// return 0
	// endfunction

 function ParseCommand takes nothing returns nothing
  local string msg= GetEventPlayerChatString()
  local integer pID= GetPlayerId(GetTriggerPlayer())
  local integer i= 0
  local integer strLength= StringLength(msg)
  local string cmd
  local real val
  local integer intVal
  local integer u= (pID)
  local integer p= s__User_Platformer[u]
  local integer team= s__User_Team[(pID)]
  local group unitgroup
  local unit gunit
		
  local integer async
		
		//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "msg: " + msg)
		
		//set i equal to the position of first space in message
		loop
		exitwhen i >= strLength or SubString(msg, i, i + 1) == " "
			set i=i + 1
		endloop
		
		set cmd=SubString(msg, 1, i)
		
		//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "msg: " + msg + " cmd: " + cmd)
		
		//check if string contains a value
		if strLength >= i + 1 then
			set val=S2R(SubString(msg, i + 1, strLength))
			set intVal=R2I(val)
		endif
		
		// if cmd == "afk" then
			// set async = User.SyncLocalCameraIdleTime()
			// call async.Then(OnAllCameraSync, 0, async)
		// endif
		
		if CONFIGURATION_PROFILE != RELEASE then
			//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "msg: " + msg + " cmd: " + cmd + " val: " + R2S(val))
			if cmd == "tvy" then
				set s__Platformer_TerminalVelocityY[p]=val
			//elseif cmd == "tvf" then
				//set p.TerminalFalloff = val
			elseif cmd == "xf" then
				set s__Platformer_XFalloff[p]=val
			elseif cmd == "yf" then
				set s__Platformer_YFalloff[p]=val
			elseif cmd == "ms" then
				set s__Platformer_MoveSpeed[p]=val
			elseif cmd == "msoff" then
				set s__Platformer_MoveSpeedVelOffset[p]=val
			elseif cmd == "ga" then
				set s__Platformer_GravitationalAccel[p]=val
			elseif cmd == "vj" then
				set s__Platformer_vJumpSpeed[p]=val
			elseif cmd == "hj" then
				set s__Platformer_hJumpSpeed[p]=val
			elseif cmd == "v2h" then
				set s__Platformer_v2hJumpRatio[p]=val
			elseif cmd == "om" then
				set PlatformerOcean_OCEAN_MOTION=val
			elseif cmd == "ovj" then
				set JUMPHEIGHTINOCEAN=val
			elseif cmd == "iss" then
				set PlatformerIce_SLOW_VELOCITY=val
			elseif cmd == "ifs" then
				set PlatformerIce_FAST_VELOCITY=val
			elseif cmd == "size" or cmd == "s" then
				call DisplayTextToForce(bj_FORCE_PLAYER[pID], "Size: " + R2S(GetUnitCollision(FirstOfGroup(GetUnitsSelectedAll(Player(pID))))))
			elseif cmd == "unitmovespeed" or cmd == "ums" then
				call SetUnitMoveSpeed(FirstOfGroup(GetUnitsSelectedAll(Player(pID))), val)
			elseif cmd == "distance" or cmd == "dist" or cmd == "d" then
				set unitgroup=CreateGroup()
				call GroupEnumUnitsSelected(unitgroup, Player(pID), null)
				call ForGroup(unitgroup, function DistanceCallback)
				call DestroyGroup(unitgroup)
				set unitgroup=null
			elseif cmd == "level" or cmd == "lvl" then
				if (intVal) != 0 then
					call sc__Levels_Level_SwitchLevels((s__Teams_MazingTeam_OnLevel[team]),team , (intVal) , u , false)
				endif
			elseif cmd == "checkpoint" or cmd == "cp" then
				call sc__Levels_Level_SetCheckpointForTeam((s__Teams_MazingTeam_OnLevel[team]),team , intVal)
			elseif cmd == "help" or cmd == "h" then
				call PrintPlatformingVariables(p)
			elseif cmd == "status" or cmd == "s" then
				call PrintPlatformingCurrentValues(p)
			elseif msg == "-prof" or cmd == "prof" then
				call PrintPlatformingProfileVariables(p)
			elseif msg == "-export" or cmd == "export" then
				call ExportPlatformingVariables(p)
			elseif msg == "-mem" or cmd == "mem" then
				call DisplayTextToForce(bj_FORCE_PLAYER[(s__Platformer_PID[p])], "Memory Analysis:") // INLINED!!
			elseif msg == "-debugrelay" then
				call DebugRelay(pID)
			elseif msg == "-overclock" or cmd == "overclock" or cmd == "clock" then
				call DisplayTextToForce(bj_FORCE_PLAYER[pID], "Overclocking relay for player: " + I2S(pID) + ", val: " + R2S(val))
				call OverclockRelays(pID , val)
			elseif cmd == "rotate" or cmd == "rot" then
				set unitgroup=CreateGroup()
				call GroupEnumUnitsSelected(unitgroup, Player(pID), null)
				call SetUnitFacing(FirstOfGroup(unitgroup), val)
			elseif cmd == "testpocean" or cmd == "tpo" then
				call sc__Teams_MazingTeam_MoveRevive(team,gg_rct_Region_380)
				set s__Teams_MazingTeam_DefaultGameMode[team]=Teams_GAMEMODE_PLATFORMING
				call sc__Teams_MazingTeam_RespawnTeamAtRect(team,gg_rct_Region_380 , true)
				
			elseif cmd == "testpice" or cmd == "tpi" then
				call sc__Teams_MazingTeam_MoveRevive(team,gg_rct_SboxIceR)
				set s__Teams_MazingTeam_DefaultGameMode[team]=Teams_GAMEMODE_PLATFORMING
				call sc__Teams_MazingTeam_RespawnTeamAtRect(team,gg_rct_SboxIceR , true)
				
			elseif cmd == "pause" or cmd == "p" then
				if s__User_GameMode[u] == Teams_GAMEMODE_STANDARD or s__User_GameMode[u] == Teams_GAMEMODE_PLATFORMING then
					call sc__User_Pause(u,true)
				elseif s__User_GameMode[u] == Teams_GAMEMODE_STANDARD_PAUSED or s__User_GameMode[u] == Teams_GAMEMODE_PLATFORMING_PAUSED then
					call sc__User_Pause(u,false)
				endif
			elseif cmd == "a" or cmd == "animate" then
				set unitgroup=CreateGroup()
				call GroupEnumUnitsSelected(unitgroup, Player(pID), null)
				set gunit=FirstOfGroup(unitgroup)
				
				loop
				exitwhen gunit == null
					call SetUnitAnimationByIndex(gunit, R2I(val))
				call GroupRemoveUnit(unitgroup, gunit)
				set gunit=FirstOfGroup(unitgroup)
				endloop
				
				call DestroyGroup(unitgroup)
				set unitgroup=null
				set gunit=null
			elseif cmd == "share" then
				call SetPlayerAllianceBJ(Player(intVal), ALLIANCE_SHARED_CONTROL, true, Player(pID))
			// elseif cmd == "afk" then
				// set async = User.SyncLocalCameraIdleTime()
				// call async.Then(OnAllCameraSync, 0, async)
			// endif
			endif
		endif
	endfunction
	

	//===========================================================================
 function InGameCommands__init takes nothing returns nothing
  local integer i= 0
  local trigger t
		
		if CONFIGURATION_PROFILE != RELEASE then
			set t=CreateTrigger()
			
			loop
				call TriggerRegisterPlayerChatEvent(t, Player(i), "-", false)
				//call TriggerRegisterPlayerChatEvent( t, Player(i), "!", false )
			set i=i + 1
			exitwhen i >= 8
			endloop
			
			call TriggerAddAction(t, function ParseCommand)
			
			set t=null
		endif
	endfunction

//library InGameCommands ends
//library User:


	   
	// public real CameraIdleTime //only as accurate as the last sync
	
	
	// private static trigger AFKLocalCameraTimeSyncEvent
	// private static SimpleList_List AFKSyncLocalCameraTimePromises
	
	// public static trigger AFKMouseEvent
	// public static vector2 LocalUserMousePosition
	
		    
    //MOST IMPORTANT that "this" returns the exact player ID without having to remember to add / subtract 1
    //also no need to recycle users, let's just keep a basic count
    
 function s__User_SetActiveEffect takes integer this,string strEffect,string attachPoint returns nothing
		if s__User_ActiveEffect[this] != null then



			
			call DestroyEffect(s__User_ActiveEffect[this])
			set s__User_ActiveEffect[this]=null
		endif
		
		if strEffect != null then
			set s__User_ActiveEffect[this]=AddSpecialEffectTarget(strEffect, s__User_ActiveUnit[this], attachPoint)
			



		endif
 endfunction
 function s__User_SetActiveEffectEx takes integer this,effect fx returns nothing
		if s__User_ActiveEffect[this] != null then



			
			call DestroyEffect(s__User_ActiveEffect[this])
		endif
		
		set s__User_ActiveEffect[this]=fx
		







 endfunction
 function s__User_ClearActiveEffect takes integer this returns nothing
		call s__User_SetActiveEffect(this,null , null)
 endfunction
	
 function s__User_CreateUserTimedEffect takes integer this,string fxFileLocation,string attachPointName,real duration returns nothing
		call s__UserActiveTimedEffect_create(fxFileLocation , attachPointName , this , duration)
 endfunction

	
    function s__User_DisplayMessageAll takes string message returns nothing
        local integer i= 0
        
        loop
        exitwhen i > s__User_count
            call sc__User_DisplayMessage((i),message , 0)
        set i=i + 1
        endloop
    endfunction
    
    function s__User_OnCinemaEndCB takes nothing returns boolean
        set s__User_CinematicPlaying[EventUser]=0
        call sc__User_CheckCinematicQueue(EventUser)
		
        return false
    endfunction
 function s__User_ShortcutCinematicQueue takes integer this,integer cine returns nothing
		call s__SimpleList_List_add(s__User_CinematicQueue[this],cine)
		
		//remove currently playing cinematic
		if s__User_CinematicPlaying[this] != 0 then
			call s__CinemaCallbackModel_EndCallbackStack(s__User_CinematicPlaying[this])
		else
			call sc__User_CheckCinematicQueue(this)
		endif
 endfunction
    function s__User_AddCinematicToQueue takes integer this,integer cine returns nothing
        local integer priorityIndex= 0
  local integer curCinematicNode= s__SimpleList_List_first[s__User_CinematicQueue[this]]
		
		if s__User_CinematicPlaying[this] == 0 then
			call s__SimpleList_List_add(s__User_CinematicQueue[this],cine)
			call sc__User_CheckCinematicQueue(this)
		else
			// call DisplayTextToPlayer(Player(0), 0, 0, "Cinematic priority difference: " + I2S(cine.Priority - .CinematicPlaying.Cinematic.Priority))
			
			if s__Cinematic_Priority[cine] - s__Cinematic_Priority[s__CinemaCallbackModel_Cinematic[s__User_CinematicPlaying[this]]] >= 2 then
				call s__User_ShortcutCinematicQueue(this,cine)
			else
				//iterate list until we find the position in user's queue to place the cinema (comparing priorities)
				loop
				exitwhen curCinematicNode == 0 or s__Cinematic_Priority[(s__SimpleList_ListNode_value[curCinematicNode])] < s__Cinematic_Priority[cine]
				
				set curCinematicNode=s__SimpleList_ListNode_next[curCinematicNode]
				set priorityIndex=priorityIndex + 1
				endloop
				
				//add the new cinema at the priority sorted index. no need to check queue as already established its non null
				call s__SimpleList_List_insert(s__User_CinematicQueue[this],cine , priorityIndex)
			endif
		endif
    endfunction
    function s__User_CheckCinematicQueue takes integer this returns nothing
        //call DisplayTextToForce(bj_FORCE_PLAYER[0], "Checking cinema queue for user:" + I2S(this))
        //debug call .CinematicQueue.print(this)
        
        if s__User_CinematicPlaying[this] == 0 and s__SimpleList_List_count[s__User_CinematicQueue[this]] > 0 then
            //call DisplayTextToForce(bj_FORCE_PLAYER[0], "popping next cinematic for user: " + I2S(this))
            
            set s__User_CinematicPlaying[this]=s__Cinematic_Activate((s__SimpleList_ListNode_value[s__SimpleList_List_pop(s__User_CinematicQueue[this])]),this)
            // call .CinematicPlaying.Activate(this)
        endif
    endfunction
    
    function s__User_DisplayMessage takes integer this,string message,real duration returns nothing
        if s__User_IsPlaying[this] then
            if duration == 0 then
                call DisplayTextToPlayer(Player(this), 0, 0, message)
            else
                call DisplayTimedTextToPlayer(Player(this), 0, 0, duration, message)
            endif
        endif
    endfunction
    
    function s__User_OnLeave takes integer this returns nothing
        call sc__User_SwitchGameModesDefaultLocation(this,Teams_GAMEMODE_STANDARD)
        
        set s__User_IsPlaying[this]=false
		
		call sc__User_SwitchGameModesDefaultLocation(this,Teams_GAMEMODE_DYING)

        //TODO cleanup any structs
        
        //call thistype.DisplayMessageAll(GetPlayerName(Player(this)) + " has left the game!")
        call s__User_DisplayMessageAll(sc__User_GetStylizedPlayerName(this) + " has left the game!")
        
        set s__User_ActiveUnit[this]=null
        
        set s__User_ActivePlayers=s__User_ActivePlayers - 1
    endfunction
    
    
    function s__User_ReviveActiveHero takes integer this,real x,real y returns nothing
        if s__User_GameMode[this] == Teams_GAMEMODE_STANDARD then
            call ReviveHero(s__MazersArray[this], x, y, true)
            call PauseUnit(s__MazersArray[this], true)
			call PauseUnit(s__MazersArray[this], false)
            call SetUnitX(s__MazersArray[this], x)
            call SetUnitY(s__MazersArray[this], y)
        elseif s__User_GameMode[this] == Teams_GAMEMODE_PLATFORMING then
            call s__Platformer_StartPlatforming(s__User_Platformer[this],x , y)
        endif
    endfunction
    
 function s__User_ToggleDefaultTracking takes integer this returns nothing
        set s__DefaultCameraTracking[this]= not s__DefaultCameraTracking[this]
		
		if s__User_GameMode[this] == Teams_GAMEMODE_STANDARD or s__User_GameMode[this] == Teams_GAMEMODE_STANDARD_PAUSED then
			if GetLocalPlayer() == Player(this) then
				if s__DefaultCameraTracking[this] then
					//enable
					call SetCameraTargetController(s__MazersArray[this], 0, 0, false)
					
					// if .CinematicPlaying.Cinematic != thistype.ToggleCameraTrackingTutorial or thistype.ToggleCameraTrackingTutorial == 0 then
						// call .DisplayMessage("Camera tracking: " + ColorMessage("ON", TOGGLE_ON_COLOR), 1.)
					// endif
					call s__User_DisplayMessage(this,"Camera tracking: " + ColorMessage("ON" , TOGGLE_ON_COLOR) , 1.)
				else
					//disable
					call ResetToGameCamera(0)
					call CameraSetupApply(s__DefaultCamera[this], false, false)
					
					// if .CinematicPlaying.Cinematic != thistype.ToggleCameraTrackingTutorial or thistype.ToggleCameraTrackingTutorial == 0 then
						// call .DisplayMessage("Camera tracking: " + ColorMessage("OFF", TOGGLE_OFF_COLOR), 1.)
					// endif
					call s__User_DisplayMessage(this,"Camera tracking: " + ColorMessage("OFF" , TOGGLE_OFF_COLOR) , 1.)
				endif
			endif
			
			if s__User_ToggleCameraTrackingTutorial != 0 then
				if s__DefaultCameraTracking[this] and not s__Cinematic_HasUserViewed(s__User_ToggleCameraTrackingTutorial,this) then
					call s__User_ShortcutCinematicQueue(this,s__User_ToggleCameraTrackingTutorial)
				endif
			endif
		endif
    endfunction
    function s__User_ApplyDefaultCameras takes integer this,real time returns nothing





		
		if s__User_GameMode[this] == Teams_GAMEMODE_PLATFORMING or s__User_GameMode[this] == Teams_GAMEMODE_PLATFORMING_PAUSED then
            call s__Platformer_ApplyCamera(s__User_Platformer[this])
        elseif s__User_GameMode[this] == Teams_GAMEMODE_STANDARD or s__User_GameMode[this] == Teams_GAMEMODE_STANDARD_PAUSED then
            if GetLocalPlayer() == Player(this) then
                call CameraSetupApply(s__DefaultCamera[this], false, false)
                if s__User_IsAFK[this] then
					call SetCameraPosition(GetUnitX(s__User_ActiveUnit[this]), GetUnitY(s__User_ActiveUnit[this]))
					
					//these don't return the updated value until a timeout of 0 for some reason
					// set thistype.LocalCameraTargetPosition.x = GetCameraTargetPositionX()
					// set thistype.LocalCameraTargetPosition.y = GetCameraTargetPositionY()
					set s__vector2_x[s__User_LocalCameraTargetPosition]=GetUnitX(s__User_ActiveUnit[this])
					set s__vector2_y[s__User_LocalCameraTargetPosition]=GetUnitY(s__User_ActiveUnit[this])
				else
					call PanCameraToTimed(GetUnitX(s__User_ActiveUnit[this]), GetUnitY(s__User_ActiveUnit[this]), time)
				endif
				
                if s__DefaultCameraTracking[this] then
                    call SetCameraTargetController(s__User_ActiveUnit[this], 0, 0, false)
                endif
            endif
        endif
		





    endfunction
 function s__User_ResetDefaultCamera takes integer this,real duration returns nothing





		
		if ( GetLocalPlayer() == Player(this) ) then
            call ResetToGameCamera(duration)
			if duration > 0 then
				call CameraSetupApply(s__DefaultCamera[this], false, false)
			else
				call CameraSetupApply(s__DefaultCamera[this], false, false)
			endif
        endif
		





    endfunction
	
 function s__User_ApplyDefaultSelections takes integer this returns nothing
		if s__User_GameMode[this] != Teams_GAMEMODE_PLATFORMING and s__User_GameMode[this] != Teams_GAMEMODE_PLATFORMING_PAUSED then
            if GetLocalPlayer() == Player(this) then
                call ClearSelection()
                if s__User_ActiveUnit[this] != null then
                    call SelectUnit(s__User_ActiveUnit[this], true)
                endif
            endif
        endif
 endfunction
    
    function s__User_Pause takes integer this,boolean flag returns nothing
        if s__User_IsPlaying[this] and s__User_IsAlive[this] then
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "unpausing " + I2S(u))
            //call PauseUnit(.ActiveUnit, flag)
            if flag then
                if s__User_GameMode[this] == Teams_GAMEMODE_STANDARD then
					call PauseUnit(s__MazersArray[this], true)
					call PauseUnit(s__MazersArray[this], false)
					call IssueImmediateOrder(s__User_ActiveUnit[this], "stop")
					
                    call sc__User_SwitchGameModesDefaultLocation(this,Teams_GAMEMODE_STANDARD_PAUSED)
                elseif s__User_GameMode[this] == Teams_GAMEMODE_PLATFORMING then
                    call sc__User_SwitchGameModesDefaultLocation(this,Teams_GAMEMODE_PLATFORMING_PAUSED)
                endif
            else
                if s__User_GameMode[this] == Teams_GAMEMODE_STANDARD_PAUSED then
                    call sc__User_SwitchGameModesDefaultLocation(this,Teams_GAMEMODE_STANDARD)
                elseif s__User_GameMode[this] == Teams_GAMEMODE_PLATFORMING_PAUSED then
                    call sc__User_SwitchGameModesDefaultLocation(this,Teams_GAMEMODE_PLATFORMING)
                endif
            endif
        endif
    endfunction
    
 function s__User_CancelAutoUnpause takes integer this returns nothing
		if s__User_UnpauseTimer[this] != null then
			call ReleaseTimer(s__User_UnpauseTimer[this])
			set s__User_UnpauseTimer[this]=null
		endif
 endfunction
    function s__User_UnpauseUserCB takes nothing returns nothing
        local timer t= GetExpiredTimer()
        local integer u= ((LoadInteger(TimerUtils___ht, 0, GetHandleId((t))))) // INLINED!!
        		
        if s__User_IsPlaying[u] then
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "unpausing " + I2S(u))
            //call PauseUnit(u.ActiveUnit, false)
            //call IssueImmediateOrder(u.ActiveUnit, "stop")
            
            call s__User_Pause(u,false)
        endif
		





        
        call ReleaseTimer(t)
        set t=null
		set s__User_UnpauseTimer[u]=null
    endfunction
 function s__User_RegisterAutoUnpause takes integer this,real timeout returns nothing
		call s__User_CancelAutoUnpause(this)
		set s__User_UnpauseTimer[this]=NewTimerEx(this)
		call TimerStart(s__User_UnpauseTimer[this], timeout, false, function s__User_UnpauseUserCB)
 endfunction
 function s__User_GetAutoUnpauseRemainingTime takes integer this returns real
		if s__User_UnpauseTimer[this] != null then
			return TimerGetRemaining(s__User_UnpauseTimer[this])
		else
			return - 1.
		endif
 endfunction
	
    function s__User_RespawnAtRect takes integer this,rect r,boolean moveliving returns nothing
        local real x= GetRectMinX(r)
        local real y= GetRectMinY(r)
        local integer ttype
		
		//call DisplayTextToForce(bj_FORCE_PLAYER[0], "respawn start for player " + I2S(this))
		// if this == 1 then
			// call DisplayTextToForce(bj_FORCE_PLAYER[0], "respawn start for player " + I2S(this))
			// //call DisplayTextToForce(bj_FORCE_PLAYER[0], "Active Unit name before " + GetUnitName(.ActiveUnit))
		// endif
		
        if s__User_IsPlaying[this] and ( moveliving or not s__User_IsAlive[this] ) then
            loop
                set x=GetRandomReal(GetRectMinX(r), GetRectMaxX(r))
                set y=GetRandomReal(GetRectMinY(r), GetRectMaxY(r))
                //check these values to see if they're on abyss, redo if so
                set ttype=GetTerrainType(x, y)
                if s__Teams_MazingTeam_DefaultGameMode[s__User_Team[this]] == Teams_GAMEMODE_STANDARD then
                    exitwhen ( ttype != ABYSS and ttype != LAVA )
                elseif s__Teams_MazingTeam_DefaultGameMode[s__User_Team[this]] == Teams_GAMEMODE_PLATFORMING then
                    exitwhen ( ttype != LAVA and ttype != LRGBRICKS and TerrainGlobals_IsTerrainPathable(ttype) )
                endif
            endloop
			
			//call DisplayTextToForce(bj_FORCE_PLAYER[0], "reviving at x: " + R2S(x) + ", y: " + R2S(y))
			// if this == 1 then
				// call DisplayTextToForce(bj_FORCE_PLAYER[0], "reviving at x: " + R2S(x) + ", y: " + R2S(y))
			// endif
			
            if s__Teams_MazingTeam_DefaultGameMode[s__User_Team[this]] == Teams_GAMEMODE_STANDARD or s__Teams_MazingTeam_DefaultGameMode[s__User_Team[this]] == Teams_GAMEMODE_STANDARD_PAUSED then
				call sc__User_SwitchGameModes(this,Teams_GAMEMODE_STANDARD_PAUSED , x , y)
                
				call s__User_RegisterAutoUnpause(this,RespawnPauseTime)
			elseif s__Teams_MazingTeam_DefaultGameMode[s__User_Team[this]] == Teams_GAMEMODE_PLATFORMING_PAUSED then
				call sc__User_SwitchGameModes(this,Teams_GAMEMODE_PLATFORMING_PAUSED , x , y)
				
				call s__User_RegisterAutoUnpause(this,RespawnPauseTime)
            
            else
                call sc__User_SwitchGameModes(this,s__Teams_MazingTeam_DefaultGameMode[s__User_Team[this]] , x , y)
            endif
        endif
        
		//it's least jarring to call apply default cameras only when it's extremely important
        call s__User_ApplyDefaultCameras(this,0.0)
		
		//call DisplayTextToForce(bj_FORCE_PLAYER[0], "respawn end for player " + I2S(this))
		// if this == 1 then
			// //call DisplayTextToForce(bj_FORCE_PLAYER[0], "Active Unit name after " + GetUnitName(.ActiveUnit))
			// call DisplayTextToForce(bj_FORCE_PLAYER[0], "Respawn check active x: " + R2S(GetUnitX(.ActiveUnit)) + ", y: " + R2S(GetUnitY(.ActiveUnit)))
			// call DisplayTextToForce(bj_FORCE_PLAYER[0], "respawn end for player " + I2S(this))
		// endif
		
        //set .LastTransferTime = GameElapsedTime()
    endfunction
	
 function s__User_SetKeyColor takes integer this,integer keyColor returns nothing
		if s__MazerColor[this] != keyColor then
			set s__MazerColor[this]= keyColor
			
			if keyColor == KEY_RED then
				call SetUnitVertexColor(s__MazersArray[this], 255, 0, 0, 255)
			elseif keyColor == KEY_BLUE then
				call SetUnitVertexColor(s__MazersArray[this], 0, 0, 255, 255)
			elseif keyColor == KEY_GREEN then
				call SetUnitVertexColor(s__MazersArray[this], 0, 255, 0, 255)
			elseif keyColor == KEY_NONE then
				call SetUnitVertexColor(s__MazersArray[this], 255, 255, 255, 255)
			endif
		endif
 endfunction
	
 function s__User_GetPlayerColorHex takes integer this returns string
  local string hex
        
        if this == 0 then
            set hex="FF0303"
        elseif this == 1 then
            set hex="0042ff"
        elseif this == 2 then
            set hex="1ce6b9"
        elseif this == 3 then
            set hex="540081"
        elseif this == 4 then
            set hex="fffc01"
        elseif this == 5 then
            set hex="feba0e"
        elseif this == 6 then
            set hex="20c000"
        elseif this == 7 then
            set hex="e55bb0"
        else
            set hex=""
        endif
		
		return hex
 endfunction
 function s__User_GetStylizedPlayerName takes integer this returns string
        local string hex= s__User_GetPlayerColorHex(this)
        
        if GetPlayerSlotState(Player(this)) == PLAYER_SLOT_STATE_PLAYING then
			if s__User_IsAFK[this] then
				return ColorMessage("(AFK) " , DISABLED_COLOR) + ColorMessage(GetPlayerName(Player(this)) , hex)
			else
				return ColorMessage(GetPlayerName(Player(this)) , hex)
			endif
        else
			return ColorMessage("(Left) " + GetPlayerName(Player(this)) , hex)
        endif
    endfunction
    
    function s__User_PartialUpdateMultiboard takes integer this returns nothing
        if GetPlayerSlotState(Player(this)) == PLAYER_SLOT_STATE_PLAYING then
            call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, this + 1, 0), sc__Teams_MazingTeam_GetStylizedPlayerName(s__User_Team[this],this))
			call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, this + 1, 2), I2S((s__Teams_MazingTeam_Score[(s__User_Team[this])]))) // INLINED!!
            call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, this + 1, 3), I2S((s__Teams_MazingTeam_ContinueCount[(s__User_Team[this])]))) // INLINED!!
            
            call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, this + 1, 0))
			call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, this + 1, 2))
            call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, this + 1, 3))
            
			if RewardMode == GameModesGlobals_HARD then
				call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, this + 1, 4), I2S(s__User_Deaths[this]))
				call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, this + 1, 4))
            endif
        elseif GetPlayerSlotState(Player(this)) == PLAYER_SLOT_STATE_LEFT then
            call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, this + 1, 0), "Left the game")
            call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, this + 1, 1), "Gone")
            call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, this + 1, 2), "Negative")
            call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, this + 1, 3), "Zilch")
            
            call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, this + 1, 0))
            call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, this + 1, 1))
            call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, this + 1, 2))
            call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, this + 1, 3))
            
			if RewardMode == GameModesGlobals_HARD then
				call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, this + 1, 4), "Too many")
				call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, this + 1, 4))
			endif
        else
            call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, this + 1, 0), "Not playing")
            call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, this + 1, 0))
        endif
    endfunction
    
    //set game mode should take all players, dead or alive, and make it so the next time they are respawned (naturally or forced) it will be as the correct unit type with all the correct mechanisms enabled
    
    //initial x, y coordinate will either resume from previous location in last gamemode or from revive
    function s__User_SwitchGameModesDefaultLocation takes integer this,integer newGameMode returns nothing
        local real x
        local real y
        
        local integer ttype
        
        if s__User_GameMode[this] == Teams_GAMEMODE_DEAD then
            loop
                set x=GetRandomReal(GetRectMinX(s__Teams_MazingTeam_Revive[s__User_Team[this]]), GetRectMaxX(s__Teams_MazingTeam_Revive[s__User_Team[this]]))
                set y=GetRandomReal(GetRectMinY(s__Teams_MazingTeam_Revive[s__User_Team[this]]), GetRectMaxY(s__Teams_MazingTeam_Revive[s__User_Team[this]]))
                //check these values to see if they're on abyss, redo if so
                set ttype=GetTerrainType(x, y)
                
                if newGameMode == Teams_GAMEMODE_STANDARD or newGameMode == Teams_GAMEMODE_STANDARD_PAUSED then
                    exitwhen ( ttype != ABYSS and ttype != LAVA and ttype != LRGBRICKS )
                elseif newGameMode == Teams_GAMEMODE_PLATFORMING or newGameMode == Teams_GAMEMODE_PLATFORMING_PAUSED then
                    exitwhen ( ttype != LAVA and ttype != LRGBRICKS and TerrainGlobals_IsTerrainPathable(ttype) )
                else
                endif
            endloop
        elseif s__User_ActiveUnit[this] != null then
            set x=GetUnitX(s__User_ActiveUnit[this])
            set y=GetUnitY(s__User_ActiveUnit[this])
		else
			set x=0
			set y=0
        endif
        
        call sc__User_SwitchGameModes(this,newGameMode , x , y)
    endfunction
    
    function s__User_ApplyDeathMode takes integer this,real x,real y,real facing,integer oldGameMode returns nothing
        local integer respawnPoint
                
        //disable camera tracking if that player has it enabled
        call s__User_ResetDefaultCamera(this,1.)
        
        //check if respawn circles should be used
        if not RespawnASAPMode and s__User_IsPlaying[this] then
            //figure out the coordinates for respawn point given the previous game mode and other info
            set respawnPoint=TerrainHelpers_TryGetLastValidLocation(x , y , facing , oldGameMode)
            
            //move respawn circle to point
            call SetUnitPosition(s__PlayerReviveCircles[this], s__vector2_x[respawnPoint], s__vector2_y[respawnPoint])
            call ShowUnit(s__PlayerReviveCircles[this], true)
            
            call s__vector2_deallocate((respawnPoint)) // INLINED!!
        endif
    endfunction
    
    function s__User_ApplyRootsCB takes nothing returns nothing
        local timer t= GetExpiredTimer()
        local integer user= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
        
        //call DummyCaster['A003'].castTarget(Player(10), 1, OrderId("entanglingroots"), user.ActiveUnit)
        call s__DummyCaster_castTarget(('A003'),Player(user) , 1 , OrderId("entanglingroots") , s__User_ActiveUnit[user])
        
        call ReleaseTimer(t)
        set t=null
    endfunction
    
    function s__User_SwitchGameModes takes integer this,integer newGameMode,real x,real y returns nothing
        local integer curGameMode= s__User_GameMode[this]
        local real facing
        
        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Removing " + I2S(oldGameMode) + ", Adding " + I2S(newGameMode))
        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Adding " + I2S(newGameMode))
        
        if newGameMode != curGameMode then



			
			//if the new gamemode is death then we might need to keep a few things in memory
            if newGameMode == Teams_GAMEMODE_DEAD then
                if not RespawnASAPMode then
                    set facing=GetUnitFacing(s__User_ActiveUnit[this])
                endif
			elseif newGameMode == Teams_GAMEMODE_HIDDEN then
				call s__User_ResetDefaultCamera(this,0.)
            endif
			
			// if this == 1 then
				// call DisplayTextToForce(bj_FORCE_PLAYER[0], "Changing gamemode from: " + I2S(curGameMode) + ", to: " + R2S(newGameMode))
			// endif
            
            //remove the old game mode
            if curGameMode == Teams_GAMEMODE_STANDARD then
                call ShowUnit(s__MazersArray[this], false)
				
				//remove the current terrain effect
                if s__PreviousTerrainTypedx[this] != NOEFFECT then
					call GameLoopRemoveTerrainAction(s__MazersArray[this] , this , s__PreviousTerrainTypedx[this] , NOEFFECT)
					set s__PreviousTerrainTypedx[this]= NOEFFECT
				endif
								
				//moves the mazing unit
                call SetUnitPosition(s__MazersArray[this], MazerGlobals_SAFE_X, MazerGlobals_SAFE_Y)
                //removes the reg unit from the reg game loop. thereby enabling regular terrain effects
				call s__SimpleList_List_remove(StandardMazingUsers,this)
                
                //updates the number of units platforming/regular mazing
                set NumberMazing=NumberMazing - 1
            elseif curGameMode == Teams_GAMEMODE_PLATFORMING then
                call s__Platformer_StopPlatforming(s__User_Platformer[this])
            elseif curGameMode == Teams_GAMEMODE_STANDARD_PAUSED then
                // //restore default movespeed regardless
                //call SetUnitMoveSpeed(MazersArray[this], DefaultMoveSpeed)
                
                //remove entangling roots on the paused mazer
				call s__User_SetActiveEffect((this),null , null) // INLINED!!
				
                //call UnitRemoveBuffs(.ActiveUnit, true, true)
                call s__DummyCaster_castTarget(('A004'),Player(10) , 1 , OrderId("dispel") , s__User_ActiveUnit[this])
				call SetUnitPropWindow(s__User_ActiveUnit[this], GetUnitDefaultPropWindow(s__User_ActiveUnit[this]) * bj_DEGTORAD)
                
                //if the new gamemode isnt to unpause the unit then we need to undo the pause effect
                if newGameMode != Teams_GAMEMODE_STANDARD then
					call ShowUnit(s__MazersArray[this], false)
					call SetUnitPosition(s__MazersArray[this], MazerGlobals_SAFE_X, MazerGlobals_SAFE_Y)
                endif
            elseif curGameMode == Teams_GAMEMODE_PLATFORMING_PAUSED then
                //if the new gamemode isnt to unpause the unit then we need to undo the pause effect
                if newGameMode != Teams_GAMEMODE_PLATFORMING then
                    call ShowUnit(s__Platformer_Unit[s__User_Platformer[this]], false)
					call SetUnitPosition(s__Platformer_Unit[s__User_Platformer[this]], PlatformerGlobals_SAFE_X, PlatformerGlobals_SAFE_Y)
                endif
            elseif curGameMode == Teams_GAMEMODE_DYING then
				//no actions removing dying gamemode
            elseif curGameMode == Teams_GAMEMODE_DEAD then
                //revive the mazing unit
                call ReviveHero(s__MazersArray[this], MazerGlobals_SAFE_X, MazerGlobals_SAFE_Y, false)
                call ShowUnit(s__MazersArray[this], false)
                call IssueImmediateOrder(s__MazersArray[this], "stop")
                //call PauseUnit(MazersArray[this], true)
                //call PauseUnit(MazersArray[this], false)
                
                //move the respawn circle
                call SetUnitPosition(s__PlayerReviveCircles[this], MazerGlobals_REVIVE_CIRCLE_SAFE_X, MazerGlobals_REVIVE_CIRCLE_SAFE_Y)
                call ShowUnit(s__PlayerReviveCircles[this], false)
            endif
            
            //set the new game mode
            //note this does not do anything (include store the gamemode) if new game mode is same as old
            call sc__User_SetCurrentGameMode(this,newGameMode)
            
            //apply the new game mode
            if newGameMode == Teams_GAMEMODE_STANDARD then
                //moves the mazing unit
				call SetUnitPosition(s__MazersArray[this], x, y)
				//adds the reg unit from the reg game loop. thereby enabling regular terrain effects
				call s__SimpleList_List_addEnd(StandardMazingUsers,this)
                //updates the number of units platforming/regular mazing
                set NumberMazing=NumberMazing + 1
                
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Number mazing applying standard: " + I2S(NumberMazing))
                
                //unhides the wisp and hides the DH
                call ShowUnit(s__MazersArray[this], true)
                //pause/unpause the unit to clear order stack
                call PauseUnit(s__MazersArray[this], true)
                call PauseUnit(s__MazersArray[this], false)
				
				//always select the mazing unit when switching to STANDARD mode
				call s__User_ApplyDefaultSelections(this)
            elseif newGameMode == Teams_GAMEMODE_PLATFORMING then
                call s__Platformer_StartPlatforming(s__User_Platformer[this],x , y)
				
				// if GetLocalPlayer() == Player(this) then
					// set .PlatformerStartStable = false
				// endif
				set s__User_PlatformerStartStable[this]=false
				
				if s__User_IsAFK[this] then
					call sc__User_ApplyAFKPlatformer(this)
				endif
            elseif newGameMode == Teams_GAMEMODE_STANDARD_PAUSED then
                call SetUnitPosition(s__MazersArray[this], x, y)
                //set movespeed 0 instead of pausing unit so player can pivot to face a better direction
                //call SetUnitMoveSpeed(MazersArray[this], 0)
                call ShowUnit(s__MazersArray[this], true)
				
                //apply entangling roots to the paused mazer
				//using the actual spell on a flying unit is very inconsistent so just script its effect
                //call DummyCaster['A003'].castTarget(Player(10), 1, OrderId("entanglingroots"), .ActiveUnit)			
				//call DummyCaster['A007'].castTarget(Player(10), 1, OrderId("slow"), .ActiveUnit)
				call s__User_SetActiveEffect(this,"Abilities\\Spells\\NightElf\\EntanglingRoots\\EntanglingRootsTarget.mdl" , "origin")
				call SetUnitPropWindow(s__User_ActiveUnit[this], 0)
				
				//always select the mazing unit when switching to STANDARD_PAUSED mode
				call s__User_ApplyDefaultSelections(this)
                //call UnitApplyTimedLife(.ActiveUnit, 'BEer', 10.)
				
                //resets the game camera and selects the mazing unit
                //call SetDefaultCameraForPlayer(this, .5)
            elseif newGameMode == Teams_GAMEMODE_PLATFORMING_PAUSED then
                set s__Platformer_XPosition[s__User_Platformer[this]]=x
                set s__Platformer_YPosition[s__User_Platformer[this]]=y
                call SetUnitPosition(s__Platformer_Unit[s__User_Platformer[this]], x, y)
                call ShowUnit(s__Platformer_Unit[s__User_Platformer[this]], true)
                
                call s__Platformer_ApplyCamera(s__User_Platformer[this])
            elseif newGameMode == Teams_GAMEMODE_DYING then
                //kill their standard mazer in front of their eyes
                //DO THIS LAST SO IT HURTS MORE. jk, its BC IT IMMEDIATELY SETS OFF ON DEATH EVENT AND PRE-EMPTS THE REST OF THIS FUNC
				call SetUnitPosition(s__MazersArray[this], x, y)
                call ShowUnit(s__MazersArray[this], true)
                call KillUnit(s__MazersArray[this])
            elseif newGameMode == Teams_GAMEMODE_DEAD then
                call s__User_ApplyDeathMode(this,x , y , facing , s__User_PreviousGameMode[this])
            endif
        else
            //same gamemode, but may still need to move unit
            if newGameMode == Teams_GAMEMODE_STANDARD or newGameMode == Teams_GAMEMODE_STANDARD_PAUSED then
                //moves the mazing unit
                call SetUnitPosition(s__MazersArray[this], x, y)
            elseif newGameMode == Teams_GAMEMODE_PLATFORMING or newGameMode == Teams_GAMEMODE_PLATFORMING_PAUSED then
                call s__Platformer_StopPlatforming(s__User_Platformer[this])
                call s__Platformer_StartPlatforming(s__User_Platformer[this],x , y)
            endif
        endif
		
		// if this == 1 then
			// call DisplayTextToForce(bj_FORCE_PLAYER[0], "Moved to x: " + R2S(x) + ", y: " + R2S(y))
			// call DisplayTextToForce(bj_FORCE_PLAYER[0], "Check active x: " + R2S(GetUnitX(.ActiveUnit)) + ", y: " + R2S(GetUnitY(.ActiveUnit)))
		// endif
    endfunction
    
    function s__User_SetCurrentGameMode takes integer this,integer newGameMode returns nothing
        if newGameMode != s__User_GameMode[this] then
            if s__User_GameMode[this] >= 0 then
                set s__User_PreviousGameMode[this]=s__User_GameMode[this]
            endif
            
            set s__User_GameMode[this]=newGameMode
            
			if newGameMode != Teams_GAMEMODE_DEAD and newGameMode != Teams_GAMEMODE_DYING then
				set s__User_IsAlive[this]=true
			endif
			
            if newGameMode == Teams_GAMEMODE_STANDARD or newGameMode == Teams_GAMEMODE_STANDARD_PAUSED or newGameMode == Teams_GAMEMODE_DYING then
                set s__User_ActiveUnit[this]=s__MazersArray[this]
				set s__User_ActiveUnitRadius[this]=GetUnitDefaultRadius(GetUnitTypeId(s__User_ActiveUnit[this]))
            elseif newGameMode == Teams_GAMEMODE_PLATFORMING or newGameMode == Teams_GAMEMODE_PLATFORMING_PAUSED then
                set s__User_ActiveUnit[this]=s__Platformer_Unit[s__User_Platformer[this]]
				set s__User_ActiveUnitRadius[this]=GetUnitDefaultRadius(GetUnitTypeId(s__User_ActiveUnit[this]))
            elseif newGameMode == Teams_GAMEMODE_DEAD then
                //this may be problematic
                if RespawnASAPMode then
                    set s__User_ActiveUnit[this]=null
					set s__User_ActiveUnitRadius[this]=0.
                else
                    set s__User_ActiveUnit[this]=s__PlayerReviveCircles[this]
					set s__User_ActiveUnitRadius[this]=GetUnitDefaultRadius(GetUnitTypeId(s__User_ActiveUnit[this]))
                endif
			elseif newGameMode == Teams_GAMEMODE_HIDDEN then
				set s__User_ActiveUnit[this]=null
            endif
        endif
    endfunction
    
    function s__User_IsActiveUnitInRect takes integer this,rect r returns boolean
        return GetUnitX(s__User_ActiveUnit[this]) >= GetRectMinX(r) and GetUnitX(s__User_ActiveUnit[this]) <= GetRectMaxX(r) and GetUnitY(s__User_ActiveUnit[this]) >= GetRectMinY(r) and GetUnitY(s__User_ActiveUnit[this]) <= GetRectMaxY(r)
    endfunction
    function s__User_IsActiveUnitInArea takes integer this,integer topLeft,integer botRight returns boolean
        return GetUnitX(s__User_ActiveUnit[this]) >= s__vector2_x[topLeft] and GetUnitX(s__User_ActiveUnit[this]) <= s__vector2_x[botRight] and GetUnitY(s__User_ActiveUnit[this]) >= s__vector2_y[botRight] and GetUnitY(s__User_ActiveUnit[this]) <= s__vector2_y[topLeft]
    endfunction
	
 function s__User_UnpauseAFKCB takes nothing returns nothing
  local timer t= GetExpiredTimer()
  local integer u= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
  local texttag text
		
		if s__User_AFKPlatformerDeathClock[u] == User___AFK_UNPAUSE_BUFFER then
			set text=CreateTextTag()
			call SetTextTagText(text, ColorMessage("Unpausing" , s__User_GetPlayerColorHex(u)) + " in ", User___SMALL_FONT_SIZE)
			call SetTextTagPos(text, GetUnitX(s__User_ActiveUnit[u]) - 13 * 5.5, GetUnitY(s__User_ActiveUnit[u]), 16.0)
			call SetTextTagVisibility(text, true)
			call SetTextTagFadepoint(text, User___AFK_UNPAUSE_BUFFER)
			call SetTextTagLifespan(text, User___AFK_UNPAUSE_BUFFER + 1.)
			call SetTextTagPermanent(text, false)
			set text=null
		endif
		
		if s__User_AFKPlatformerDeathClock[u] > 0 then
			if s__User_AFKPlatformerDeathClock[u] - R2I(s__User_AFKPlatformerDeathClock[u]) == 0. then
				set text=CreateTextTag()
				call SetTextTagText(text, I2S(R2I(s__User_AFKPlatformerDeathClock[u])), User___SMALL_FONT_SIZE)
				
				//more funk
				call SetTextTagPos(text, GetUnitX(s__User_ActiveUnit[u]) + 22 * 5.5 + 4 * 5.5, GetUnitY(s__User_ActiveUnit[u]) - 16 * 2.5, 16.0)
				call SetTextTagVelocity(text, 0.0, 0.04)
				// //less funk
				// call SetTextTagPos(text, u.Platformer.XPosition + 16 * 5.5 + 4 * 5.5, u.Platformer.YPosition, 16.0)
				// call SetTextTagVelocity(text, 0.0, 0.02)
				
				call SetTextTagVisibility(text, true)
				call SetTextTagFadepoint(text, .75)
				call SetTextTagLifespan(text, 1.)
				call SetTextTagPermanent(text, false)
				
				if s__User_AFKPlatformerDeathClock[u] == 1. then
					call SetTextTagColor(text, 255, 0, 0, 255)
				endif
				
				set text=null
			endif
			
			set s__User_AFKPlatformerDeathClock[u]=s__User_AFKPlatformerDeathClock[u] - 1.
		else
			call s__User_Pause(u,false)
			
			call ReleaseTimer(t)
		endif
		
		set t=null
 endfunction
 function s__User_PanAFKCameraCB takes nothing returns nothing
		call TimerStart(GetExpiredTimer(), 1., true, function s__User_UnpauseAFKCB)
 endfunction
	
 function s__User_ApplyAFKPlatformerCB takes nothing returns nothing
  local timer t= GetExpiredTimer()
  local integer u= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
  local texttag text
		
		if s__User_IsAFK[u] then
			if s__User_PlatformerStartStable[u] then
				if s__User_AFKPlatformerDeathClock[u] == User___AFK_PLATFORMER_DEATH_CLOCK_START then
					set text=CreateTextTag()
					call SetTextTagText(text, ColorMessage("Dead" , s__User_GetPlayerColorHex(u)) + " in ", User___SMALL_FONT_SIZE)
					call SetTextTagPos(text, s__Platformer_XPosition[s__User_Platformer[u]] - 8 * 5.5, s__Platformer_YPosition[s__User_Platformer[u]], 16.0)
					call SetTextTagVisibility(text, true)
					call SetTextTagFadepoint(text, User___AFK_PLATFORMER_DEATH_CLOCK_START)
					call SetTextTagLifespan(text, User___AFK_PLATFORMER_DEATH_CLOCK_START + 1.)
					call SetTextTagPermanent(text, false)
					set text=null
				endif
				
				if s__User_AFKPlatformerDeathClock[u] > 0 then
					if s__User_AFKPlatformerDeathClock[u] - R2I(s__User_AFKPlatformerDeathClock[u]) == 0. then
						set text=CreateTextTag()
						call SetTextTagText(text, I2S(R2I(s__User_AFKPlatformerDeathClock[u])), User___SMALL_FONT_SIZE)
						
						//more funk
						call SetTextTagPos(text, s__Platformer_XPosition[s__User_Platformer[u]] + 16 * 5.5 + 4 * 5.5, s__Platformer_YPosition[s__User_Platformer[u]] - 16 * 2.5, 16.0)
						call SetTextTagVelocity(text, 0.0, 0.04)
						// //less funk
						// call SetTextTagPos(text, u.Platformer.XPosition + 16 * 5.5 + 4 * 5.5, u.Platformer.YPosition, 16.0)
						// call SetTextTagVelocity(text, 0.0, 0.02)
						
						call SetTextTagVisibility(text, true)
						call SetTextTagFadepoint(text, .75)
						call SetTextTagLifespan(text, 1.)
						call SetTextTagPermanent(text, false)
						
						if s__User_AFKPlatformerDeathClock[u] <= 3 then
							call SetTextTagColor(text, 255, 0, 0, 255)
						endif
						
						set text=null
					endif
					
					set s__User_AFKPlatformerDeathClock[u]=s__User_AFKPlatformerDeathClock[u] - User___AFK_PLATFORMER_CLOCK
				else
					call s__User_SwitchGameModesDefaultLocation(u,Teams_GAMEMODE_DYING)
					
					call ReleaseTimer(t)
				endif
			endif
		else
			//no longer AFK, immediately desist
			call ReleaseTimer(t)
		endif
		
		set t=null
 endfunction
 function s__User_ApplyAFKPlatformer takes integer this returns nothing
		//no way to support sharing control via keyboard actions
		//show texttag countdown before killing
		set s__User_AFKPlatformerDeathClock[this]=User___AFK_PLATFORMER_DEATH_CLOCK_START
		call TimerStart(NewTimerEx(this), User___AFK_PLATFORMER_CLOCK, true, function s__User_ApplyAFKPlatformerCB)
 endfunction
	
 function s__User_OnUnapplyAFKStandard takes integer request,integer user returns integer
		// local boolean needsPause = S2B(request.RequestData)
		
		if S2B(s__SyncRequest_RequestData[request]) then
			set s__User_AFKPlatformerDeathClock[user]=User___AFK_UNPAUSE_BUFFER
			call s__User_Pause(user,true)
			call s__User_ApplyDefaultCameras(user,User___AFK_PAN_CAMERA_DURATION)
			call s__User_ApplyDefaultSelections(user)
			
			call TimerStart(NewTimerEx(user), User___AFK_PAN_CAMERA_DURATION, false, function s__User_PanAFKCameraCB)
		endif
		
		call s__SyncRequest_destroy(request)
		
		return 0
 endfunction
	
	//User AFK synced event callback and async logic for checking/tracking idle state
 function s__User_ToggleAFK takes integer this returns nothing
  local integer request
		
		//this hurts, but its advantageous to have GetStylizedPlayerName include the AFK prefix in every other situation but this
		if not s__User_IsAFK[this] then
			if User___DEBUG_AFK or s__SimpleList_List_count[s__Teams_MazingTeam_Users[s__User_Team[this]]] > 1 then
				call sc__Teams_MazingTeam_PrintMessage(s__User_Team[this],s__User_GetStylizedPlayerName(this) + " is now AFK!")
			endif
		endif
		
		set s__User_IsAFK[this]=not s__User_IsAFK[this]
		
		if s__User_IsAFK[this] then
			if User___DEBUG_AFK or s__SimpleList_List_count[s__Teams_MazingTeam_Users[s__User_Team[this]]] > 1 then
				// call .Team.PrintMessage(.GetStylizedPlayerName() + " is now AFK!")
				
				if s__User_GameMode[this] == Teams_GAMEMODE_STANDARD or s__User_GameMode[this] == Teams_GAMEMODE_STANDARD_PAUSED then
					call sc__Teams_MazingTeam_SetSharedControlForTeam(s__User_Team[this],this , true)
				elseif s__User_GameMode[this] == Teams_GAMEMODE_PLATFORMING or s__User_GameMode[this] == Teams_GAMEMODE_PLATFORMING_PAUSED then
					call s__User_ApplyAFKPlatformer(this)
				endif
				
				//disable default camera tracking so as to not interact with shared control
				if s__DefaultCameraTracking[this] then
					call s__User_ToggleDefaultTracking(this)
				endif
				
				if GetLocalPlayer() == Player(this) and User___AFK_CAMERA_DELTA_TIMEOUT * s__User_LocalAFKThreshold >= User___AFK_CAMERA_MIN_TIMEOUT then
					set s__User_LocalAFKThreshold=User___AFK_CAMERA_DELTA_TIMEOUT * s__User_LocalAFKThreshold
					
					//TODO sync callback for user's threshold
					//if first threshold then warn player about exiling
					//if second threshold then inform team about exiling
				endif
			endif
		else
			if User___DEBUG_AFK or s__SimpleList_List_count[s__Teams_MazingTeam_Users[s__User_Team[this]]] > 1 then
				call sc__Teams_MazingTeam_PrintMessage(s__User_Team[this],s__User_GetStylizedPlayerName(this) + " is no longer AFK")
				call sc__Teams_MazingTeam_SetSharedControlForTeam(s__User_Team[this],this , false)
				
				if s__User_GameMode[this] == Teams_GAMEMODE_STANDARD then
					//check that unit is not near owner's camera bounds as well
					set request=s__SyncRequest_create((5) , this)
					// set request = SyncRequest.create()
					// call request.Then(OnUnapplyAFKStandard, 0, this)
					
					if GetLocalPlayer() == Player(this) then
						call BlzSendSyncData("SyncRequest___" + SyncRequest___EVENT_PREFIX, I2S((request)) + SyncRequest___DATA_DELIMITER + (B2S(RAbsBJ(GetCameraTargetPositionX() - GetUnitX(s__User_ActiveUnit[this])) >= User___CAMERA_TARGET_POSITION_PAUSE_X_FLEX or ( GetCameraTargetPositionY() >= GetUnitY(s__User_ActiveUnit[this]) and GetCameraTargetPositionY() - GetUnitY(s__User_ActiveUnit[this]) >= User___CAMERA_TARGET_POSITION_PAUSE_Y_BOTTOM_FLEX ) or ( GetCameraTargetPositionY() < GetUnitY(s__User_ActiveUnit[this]) and GetUnitY(s__User_ActiveUnit[this]) - GetCameraTargetPositionY() >= User___CAMERA_TARGET_POSITION_PAUSE_Y_TOP_FLEX )))) // INLINED!!
						
						// call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "Unpause AFK, pt 1: " + B2S(RAbsBJ(GetCameraTargetPositionX() - GetUnitX(.ActiveUnit)) >= CAMERA_TARGET_POSITION_PAUSE_X_FLEX) + ", pt 2: " + B2S(GetCameraTargetPositionY() >= GetUnitY(.ActiveUnit) and GetCameraTargetPositionY() - GetUnitY(.ActiveUnit) >= CAMERA_TARGET_POSITION_PAUSE_Y_BOTTOM_FLEX) + ", pt 3: " + B2S(GetCameraTargetPositionY() < GetUnitY(.ActiveUnit) and GetUnitY(.ActiveUnit) - GetCameraTargetPositionY()  >= CAMERA_TARGET_POSITION_PAUSE_Y_TOP_FLEX))
					endif
				endif
				
				
			endif
		endif
		
		//either prepend or reset player's name in multiboard
		call s__User_PartialUpdateMultiboard(this)
 endfunction
 function s__User_ToggleAFKCallback takes nothing returns boolean
		call s__User_ToggleAFK((S2I(BlzGetTriggerSyncData())))
		
		return false
 endfunction
		
 function s__User_CheckAFKPlayer takes integer this,real timeElapsed returns nothing
		//call sync AFK checks, sync wrappers around async data
		if s__User_GameMode[this] == Teams_GAMEMODE_PLATFORMING and not s__User_PlatformerStartStable[this] and ( ( s__Platformer_PushedAgainstVector[s__User_Platformer[this]] != 0 and s__Platformer_YVelocity[s__User_Platformer[this]] == 0. ) or s__Platformer_HorizontalAxisState[s__User_Platformer[this]] != 0 ) then
			set s__User_PlatformerStartStable[this]=true
			
			if GetLocalPlayer() == Player(this) and s__Platformer_HorizontalAxisState[s__User_Platformer[this]] == 0 then
				set s__vector2_x[s__User_LocalCameraTargetPosition]=GetCameraTargetPositionX()
				set s__vector2_y[s__User_LocalCameraTargetPosition]=GetCameraTargetPositionY()
			endif
		endif
		
		//call async AFK checks
		if GetLocalPlayer() == Player(this) then
			if s__User_GameMode[this] == Teams_GAMEMODE_PLATFORMING or s__User_GameMode[this] == Teams_GAMEMODE_PLATFORMING_PAUSED then
				if s__Platformer_HorizontalAxisState[s__User_Platformer[this]] != 0 or ( s__User_PlatformerStartStable[this] and ( GetCameraTargetPositionX() != s__vector2_x[s__User_LocalCameraTargetPosition] or GetCameraTargetPositionY() != s__vector2_y[s__User_LocalCameraTargetPosition] ) ) then
					set s__User_LocalCameraIdleTime=0
					
					set s__vector2_x[s__User_LocalCameraTargetPosition]=GetCameraTargetPositionX()
					set s__vector2_y[s__User_LocalCameraTargetPosition]=GetCameraTargetPositionY()
				else
					set s__User_LocalCameraIdleTime=s__User_LocalCameraIdleTime + timeElapsed
				endif
			else
				if RAbsBJ(GetCameraTargetPositionX() - s__vector2_x[s__User_LocalCameraTargetPosition]) > User___CAMERA_TARGET_POSITION_FLEX or RAbsBJ(GetCameraTargetPositionY() - s__vector2_y[s__User_LocalCameraTargetPosition]) > User___CAMERA_TARGET_POSITION_FLEX then
					// call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "Difference for camera destination x: " + R2S(RAbsBJ(GetCameraTargetPositionX() - LocalCameraTargetPosition.x)) + ", y: " + R2S(RAbsBJ(GetCameraTargetPositionY() - LocalCameraTargetPosition.y)))
					
					set s__User_LocalCameraIdleTime=0
					
					set s__vector2_x[s__User_LocalCameraTargetPosition]=GetCameraTargetPositionX()
					set s__vector2_y[s__User_LocalCameraTargetPosition]=GetCameraTargetPositionY()
				else
					// if .IsAFK then
						// call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "(No) Difference for camera destination x: " + R2S(RAbsBJ(GetCameraTargetPositionX() - LocalCameraTargetPosition.x)) + ", y: " + R2S(RAbsBJ(GetCameraTargetPositionY() - LocalCameraTargetPosition.y)))
						// call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "Full boolean: " + B2S(RAbsBJ(GetCameraTargetPositionX() - LocalCameraTargetPosition.x) > CAMERA_TARGET_POSITION_FLEX or RAbsBJ(GetCameraTargetPositionY() - LocalCameraTargetPosition.y) > CAMERA_TARGET_POSITION_FLEX) + ", pt 1: " + B2S(RAbsBJ(GetCameraTargetPositionX() - LocalCameraTargetPosition.x) > CAMERA_TARGET_POSITION_FLEX) + ", pt 2: " + B2S(RAbsBJ(GetCameraTargetPositionY() - LocalCameraTargetPosition.y) > CAMERA_TARGET_POSITION_FLEX))
					// endif

					set s__User_LocalCameraIdleTime=s__User_LocalCameraIdleTime + timeElapsed
				endif
			endif
			
			//if (this.IsAFK and thistype.LocalCameraIdleTime < AFK_CAMERA_MAX_TIMEOUT) or /*
			//	*/(not this.IsAFK and /*
			//	*/((thistype.LocalCameraIdleTime >= AFK_CAMERA_MAX_TIMEOUT) or /*
			//	*/(thistype.LocalCameraIdleTime >= AFK_MANUAL_CHECK_FACTOR * AFK_CAMERA_MAX_TIMEOUT)) then
			//
			if ( s__User_IsAFK[this] and s__User_LocalCameraIdleTime < s__User_LocalAFKThreshold ) or ( not s__User_IsAFK[this] and s__User_LocalCameraIdleTime >= s__User_LocalAFKThreshold ) then
				// call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "On sync event, idle time: " + R2S(thistype.LocalCameraIdleTime))
				call BlzSendSyncData(User___AFK_SYNC_EVENT_PREFIX, I2S(this))
			endif
		endif
 endfunction
 function s__User_CheckAFKPlayers takes nothing returns nothing
  local integer curUserNode= PlayerUtils_FirstPlayer
  local real timeElapsed= TimerGetElapsed(GetExpiredTimer())
		
		loop
		exitwhen curUserNode == 0
			call s__User_CheckAFKPlayer((s__SimpleList_ListNode_value[curUserNode]),timeElapsed)
		set curUserNode=s__SimpleList_ListNode_next[curUserNode]
		endloop
 endfunction
	
	// private static method ClearSyncLocalCameraPromises takes nothing returns nothing
		// local SimpleList_ListNode curCameraPromiseNode
		
		// loop
		// set curCameraPromiseNode = AFKSyncLocalCameraTimePromises.pop()
		// exitwhen curCameraPromiseNode == 0
			// call Deferred(curCameraPromiseNode.value).destroy()
			
			// call curCameraPromiseNode.deallocate()
		// endloop
	// endmethod
	// private static method OnSyncAll takes integer result, All allCameraTimeSynced returns integer
		// local SimpleList_ListNode curUserNode = PlayerUtils_FirstPlayer
		
		// call DisplayTextToPlayer(Player(0), 0, 0, "All camera idle times synced (all: " + I2S(allCameraTimeSynced) + ")")
		
		// loop
		// exitwhen curUserNode == 0
			// call DisplayTextToPlayer(Player(0), 0, 0, "Idle time: " + R2S(User(curUserNode.value).CameraIdleTime))
		// set curUserNode = curUserNode.next
		// endloop
		
		// // call allCameraTimeSynced.destroy()
		
		// return 0
	// endmethod
	// private static method OnSyncLocal takes nothing returns boolean
		// local string data = BlzGetTriggerSyncData()
		// local integer uIndex = S2I(SubString(data, 0, 1))
		// local User u = PlayerUtils_PlayerList.get(uIndex).value
		// // local real time = S2R(SubString(data, 1, StringLength(data)))
		
		// // // call DisplayTextToPlayer(Player(0), 0, 0, "user index: " + I2S(uIndex) + ", user: " + I2S(u) + ", time: " + R2S(time))
		
		// // set u.CameraIdleTime = time
		
		// // call DisplayTextToPlayer(Player(0), 0, 0, "user index: " + I2S(uIndex) + ", user: " + I2S(u) + ", time: " + R2S(S2R(SubString(data, 1, StringLength(data)))))
		
		// set u.CameraIdleTime = S2R(SubString(data, 1, StringLength(data)))
		// call Deferred(thistype.AFKSyncLocalCameraTimePromises.get(uIndex).value).Resolve(u)
		
		// return false
	// endmethod
	
	// public method IsAFKSync takes nothing returns boolean
		// // call DisplayTextToPlayer(Player(0), 0, 0, "User: " + I2S(this) + ", idle time: " + R2S(.CameraIdleTime) + ", threshold: " + R2S(AFK_MANUAL_CHECK_FACTOR * AFK_CAMERA_MAX_TIMEOUT))
		
		// return .CameraIdleTime >=  AFK_MANUAL_CHECK_FACTOR * AFK_CAMERA_MAX_TIMEOUT
	// endmethod
	// public static method SyncLocalCameraIdleTime takes nothing returns Deferred
		// local SimpleList_ListNode curUserNode = PlayerUtils_FirstPlayer
		// local integer i = 0
		// // local Deferred allCameraTimeSynced
		
		// call ClearSyncLocalCameraPromises()
		
		// loop
		// exitwhen curUserNode == 0
			// call AFKSyncLocalCameraTimePromises.addEnd(Deferred.create())
			
			// if GetLocalPlayer() == Player(curUserNode.value) then
				// //TODO encode to base-whatever to support max possible players
				// call BlzSendSyncData(LOCAL_CAMERA_IDLE_TIME_EVENT_PREFIX, I2S(i) + R2S(thistype.LocalCameraIdleTime))
			// endif
		// set curUserNode = curUserNode.next
		// set i = i + 1
		// endloop
		
		// // set allCameraTimeSynced = All(AFKSyncLocalCameraTimePromises)
		// // //TODO move this to the caller
		// // // call allCameraTimeSynced.Then(thistype.OnSyncAll, 0, allCameraTimeSynced)
		
		// // return allCameraTimeSynced
		
		// return All(AFKSyncLocalCameraTimePromises)
	// endmethod
	        
    function s__User_allocate takes nothing returns integer
        set s__User_count=s__User_count + 1
        return s__User_count
    endfunction
        
    function s__User_create takes nothing returns integer
        local integer new
        
        set new=s__User_allocate()
        
        //debug call DisplayTextToPlayer(Player(0), 0, 0, "Creating User: " + I2S(new))
        
        //set new.PlayerID = new
        set s__User_Team[new]=0
        set s__User_Deaths[new]=0
        set s__User_IsAlive[new]=true
		
		set s__User_IsAFK[new]=false
		call BlzTriggerRegisterPlayerSyncEvent(s__User_AFKSyncEvent, Player(new), User___AFK_SYNC_EVENT_PREFIX, false)
		
		// set new.CameraIdleTime = 0.
		// call BlzTriggerRegisterPlayerSyncEvent(thistype.AFKLocalCameraTimeSyncEvent, Player(new), LOCAL_CAMERA_IDLE_TIME_EVENT_PREFIX, false)
		// call TriggerRegisterPlayerStateEvent(thistype.AFKMouseEvent, Player(new), PLAYER_STATE_OBSERVER_ON_DEATH, GREATER_THAN_OR_EQUAL, 0)
        
        set s__User_CinematicPlaying[new]=0
        set s__User_CinematicQueue[new]=s__SimpleList_List_create()
        
        set s__User_GameMode[new]=Teams_GAMEMODE_STANDARD //regular mazing
        //FOR SOME REASON THIS IS RETURNING NULL, SO WE NEED TO SET ACTIVE UNIT AFTER MAP INIT
        //set new.ActiveUnit = MazersArray[new]
        
        //set new.Platformer = Platformer.AllPlatformers[new]
        set s__User_Platformer[new]=s__Platformer_create(new)
		
        return new
    endfunction
	
 function s__User_ToggleCameraTrackingCinematicCleanup takes nothing returns boolean
		if EventCinematic == s__User_ToggleCameraTrackingTutorial then
			set s__User_ToggleCameraTrackingTutorial=0
		endif
		
		return false
 endfunction
	//currently assumes that the human players are all the first n players
    function s__User_onInit takes nothing returns nothing
        local integer n= 0
        set s__User_ActivePlayers=0
        



			set s__User_LocalAFKThreshold=User___AFK_CAMERA_MAX_TIMEOUT

		
		// set User.AFKLocalCameraTimeSyncEvent = CreateTrigger()
		// set User.AFKSyncLocalCameraTimePromises = SimpleList_List.create()
		// call TriggerAddCondition(User.AFKLocalCameraTimeSyncEvent, Condition(function thistype.OnSyncLocal))
		
		set s__User_AFKSyncEvent=CreateTrigger()
		call TriggerAddCondition(s__User_AFKSyncEvent, Condition(function s__User_ToggleAFKCallback))
		set s__User_LocalCameraIdleTime=0.
		set s__User_LocalCameraTargetPosition=s__vector2_create(0. , 0.)
		
		// set User.AFKMouseEvent = CreateTrigger()
		// call TriggerAddCondition(thistype.AFKMouseEvent, Condition(function thistype.CheckAFKMouseEventCallback))
		// set User.LocalUserMousePosition = vector2.create(0., 0.)
		
		call TimerStart(CreateTimer(), User___AFK_CAMERA_CHECK_TIMEOUT, true, function s__User_CheckAFKPlayers)
		
        loop
        exitwhen n >= NumberPlayers
            //debug call DisplayTextToPlayer(Player(0), 0, 0, "Creating User: " + I2S(n))
            
            //if GetPlayerSlotState(Player(n))==PLAYER_SLOT_STATE_PLAYING then
                if GetPlayerController(Player(n)) == MAP_CONTROL_USER then
                    call s__User_create()
                endif
            //endif
        set n=n + 1
        endloop
        
        //register user cinematic CB
        //call DisplayTextToPlayer(Player(0), 0, 0, "Trying to register user cinematic CB")
        //call Cinematic.OnCinemaEnd.register(Condition(function thistype.OnCinemaEndCB))
        //call DisplayTextToPlayer(Player(0), 0, 0, "Registered user cinematic CB")
		
		//register camera tracking cinematic
		set s__User_ToggleCameraTrackingTutorial=s__Cinematic_create(null , false , false , s__CinemaMessage_create(null , GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Nice, you've enabled camera tracking!" , DEFAULT_TEXT_COLOR) , DEFAULT_SHORT_TEXT_SPEED))
		call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(s__User_ToggleCameraTrackingTutorial)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Turn tracking on and off by pressing the escape key" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_LONG_TEXT_SPEED)*1.0))) // INLINED!!
		call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(s__User_ToggleCameraTrackingTutorial)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Each mode has different advantages and disadvantages" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_MEDIUM_TEXT_SPEED)*1.0))) // INLINED!!
		call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(s__User_ToggleCameraTrackingTutorial)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Try getting good at both!" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
		
		call TriggerAddCondition(s__Event_e[(s__Cinematic_OnCinemaEnd)], (Condition(function s__User_ToggleCameraTrackingCinematicCleanup))) // INLINED!!
    endfunction


//library User ends
//library Blackhole:
    
    
		
                
        function s__Blackhole_GetActiveBlackholeFromUnit takes unit b returns integer
            local integer e= s__SimpleList_List_first[s__Blackhole_ActiveBlackholes]
            
            loop
            exitwhen e == 0
                if s__Blackhole_BlackholeUnit[(s__SimpleList_ListNode_value[e])] == b then
                    return s__SimpleList_ListNode_value[e]
                endif
            set e=s__SimpleList_ListNode_next[e]
            endloop
            
            return 0
        endfunction
        
		//this relationship doesn't make any sense
        function s__Blackhole_GetMaxStrength takes integer ttype,real dist,integer gameMode returns real
            if gameMode == Teams_GAMEMODE_STANDARD then
                if ttype == SNOW or ttype == RSNOW or ttype == SAND then
                    //takes effect in terms of velocity
                    return 10. * Blackhole___PULL_TIMESTEP
                elseif ttype == FASTICE or ttype == MEDIUMICE or ttype == SLOWICE then
                    return 8. * Blackhole___PULL_TIMESTEP
                else
                    //takes effect in terms of position
					return 100. * Blackhole___PULL_TIMESTEP
                endif
            elseif gameMode == Teams_GAMEMODE_PLATFORMING then
                if ttype == ABYSS or ttype == LAVA then
                    return 100. * Blackhole___PULL_TIMESTEP
                else
                    return 100. * Blackhole___PULL_TIMESTEP
                endif
            else
                return 50. * Blackhole___PULL_TIMESTEP
            endif
        endfunction
		
  function s__Blackhole_CheckUsers takes nothing returns nothing
   local integer curBlackhole= s__SimpleList_List_first[s__Blackhole_ActiveBlackholes]
			
   local integer curTeam
   local integer curUser
   local real x
   local real y
   local real distance
			
			loop
			exitwhen curBlackhole == 0



				
				set curTeam=s__SimpleList_List_first[s__Levels_Level_ActiveTeams[s__IStartable_ParentLevel[(s__SimpleList_ListNode_value[curBlackhole])]]]

				loop
				exitwhen curTeam == 0



					
					set curUser=s__Teams_MazingTeam_FirstUser[(s__SimpleList_ListNode_value[curTeam])]
					
					loop
					exitwhen curUser == 0



						
						if not s__SimpleList_List_contains(s__Blackhole_PlayersInRange[(s__SimpleList_ListNode_value[curBlackhole])],s__SimpleList_ListNode_value[curUser]) then
							set x=GetUnitX(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUser])]) - GetUnitX(s__Blackhole_BlackholeUnit[(s__SimpleList_ListNode_value[curBlackhole])])
							set y=GetUnitY(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUser])]) - GetUnitY(s__Blackhole_BlackholeUnit[(s__SimpleList_ListNode_value[curBlackhole])])
							set distance=SquareRoot(x * x + y * y)
							



							
							if distance <= Blackhole___BLACKHOLE_MAXRADIUS then
								call sc__Blackhole_WatchPlayer((s__SimpleList_ListNode_value[curBlackhole]),s__SimpleList_ListNode_value[curUser])
							endif
						endif
						
					set curUser=s__SimpleList_ListNode_next[curUser]
					endloop
					
				set curTeam=s__SimpleList_ListNode_next[curTeam]
				endloop
				
			set curBlackhole=s__SimpleList_ListNode_next[curBlackhole]
			endloop
  endfunction
        
        function s__Blackhole_PullNearbyUnits takes nothing returns nothing
            local integer curBlackholeNode= s__SimpleList_List_first[s__Blackhole_ActiveBlackholes]
   local integer curUserNode
            local integer nearbyUser
            local real nearbyX
            local real nearbyY
            
            local real dx
            local real dy
            local real dist
            
            local real angle
            
            local integer ttype
            
			loop
			exitwhen curBlackholeNode == 0
				set curUserNode=s__SimpleList_List_first[s__Blackhole_PlayersInRange[(s__SimpleList_ListNode_value[curBlackholeNode])]]
				
				loop
				exitwhen curUserNode == 0
					set nearbyUser=(s__SimpleList_ListNode_value[curUserNode])
					set nearbyX=GetUnitX(s__User_ActiveUnit[nearbyUser])
					set nearbyY=GetUnitY(s__User_ActiveUnit[nearbyUser])
					
					set dx=GetUnitX(s__Blackhole_BlackholeUnit[(s__SimpleList_ListNode_value[curBlackholeNode])]) - nearbyX
					set dy=GetUnitY(s__Blackhole_BlackholeUnit[(s__SimpleList_ListNode_value[curBlackholeNode])]) - nearbyY
									
					set dist=SquareRoot(dx * dx + dy * dy)
					if dist < Blackhole_BLACKHOLE_EVENT_HORIZON then
						call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Other\\Doom\\DoomDeath.mdl", nearbyX, nearbyY))
						//call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Other\\Doom\\DoomTarget.mdl", nearbyX, nearbyY))
						//call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Demon\\DarkPortal\\DarkPortalTarget.mdl", nearbyX, nearbyY))
						
						if s__User_GameMode[nearbyUser] != Teams_GAMEMODE_DEAD then
							call s__User_SwitchGameModesDefaultLocation(nearbyUser,Teams_GAMEMODE_DYING)
						else



							//call SetUnitX(nearbyUser.ActiveUnit, MazerGlobals_SAFE_X)
							//call SetUnitY(nearbyUser.ActiveUnit, MazerGlobals_SAFE_Y)
							call SetUnitPosition(s__User_ActiveUnit[nearbyUser], MazerGlobals_SAFE_X, MazerGlobals_SAFE_Y)
							call ShowUnit(s__User_ActiveUnit[nearbyUser], false)
						endif
					elseif dist >= Blackhole___BLACKHOLE_MAXRADIUS then
						//escaped blackhole, stop watching unit... for now...



						call s__SimpleList_List_remove(s__Blackhole_PlayersInRange[(s__SimpleList_ListNode_value[curBlackholeNode])],nearbyUser)
					else
						//returns angle in radians
						set angle=Atan2(dy, dx)
						//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "angle " + R2S(angle))
						//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "angle deg " + R2S(angle * 180 / bj_PI))
						//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "angle rad " + R2S(angle / 180 * bj_PI))

						//repurpose dx to measure strength
						
						set ttype=GetTerrainType(nearbyX, nearbyY)
						set dx=( Blackhole___BLACKHOLE_MAXRADIUS - dist ) / Blackhole___BLACKHOLE_MAXRADIUS * s__Blackhole_GetMaxStrength(ttype , dist , s__User_GameMode[nearbyUser])
						if s__User_GameMode[nearbyUser] == Teams_GAMEMODE_STANDARD then



							
							if ttype == SNOW or ttype == RSNOW or ttype == SAND then
								set s__VelocityX[nearbyUser]= s__VelocityX[nearbyUser] + Cos(angle) * dx
								set s__VelocityY[nearbyUser]= s__VelocityY[nearbyUser] + Sin(angle) * dx
							else
								call SetUnitX(s__User_ActiveUnit[nearbyUser], nearbyX + Cos(angle) * dx)
								call SetUnitY(s__User_ActiveUnit[nearbyUser], nearbyY + Sin(angle) * dx)
							endif
						elseif s__User_GameMode[nearbyUser] == Teams_GAMEMODE_PLATFORMING then



													
							//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Before Velocity: " + R2S(nearbyUser.Platformer.XVelocity) + "," + R2S(nearbyUser.Platformer.YVelocity))
							
							set s__Platformer_XVelocity[s__User_Platformer[nearbyUser]]=s__Platformer_XVelocity[s__User_Platformer[nearbyUser]] + Cos(angle) * dx
							set s__Platformer_YVelocity[s__User_Platformer[nearbyUser]]=s__Platformer_YVelocity[s__User_Platformer[nearbyUser]] + Sin(angle) * dx
							
							//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "After Velocity: " + R2S(nearbyUser.Platformer.XVelocity) + "," + R2S(nearbyUser.Platformer.YVelocity))
						elseif s__User_GameMode[nearbyUser] == Teams_GAMEMODE_DEAD and s__User_ActiveUnit[nearbyUser] != null then




							
							call SetUnitX(s__User_ActiveUnit[nearbyUser], nearbyX + Cos(angle) * dx)
							call SetUnitY(s__User_ActiveUnit[nearbyUser], nearbyY + Sin(angle) * dx)
						endif
					endif
				set curUserNode=s__SimpleList_ListNode_next[curUserNode]
				endloop
			set curBlackholeNode=s__SimpleList_ListNode_next[curBlackholeNode]
			endloop
        endfunction
                
        function s__Blackhole_UnwatchPlayer takes integer this,integer pID returns nothing
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "No longer watching: " + I2S(pID))
            call s__SimpleList_List_remove(s__Blackhole_PlayersInRange[this],pID)
        endfunction
        
        function s__Blackhole_WatchPlayer takes integer this,integer pID returns nothing
            if not s__SimpleList_List_contains(s__Blackhole_PlayersInRange[this],pID) then
                //debug call .PlayersInRange.print(0)



				
                call s__SimpleList_List_add(s__Blackhole_PlayersInRange[this],pID)
            endif
        endfunction
        
        function s__Blackhole_Start takes integer this returns nothing
            if s__SimpleList_List_count[s__Blackhole_ActiveBlackholes] == 0 then
                set Blackhole___PullTimer=(NewTimerEx(0)) // INLINED!!
				call TimerStart(Blackhole___PullTimer, Blackhole___PULL_TIMESTEP, true, function s__Blackhole_PullNearbyUnits)
				
				set Blackhole___CheckTimer=(NewTimerEx(0)) // INLINED!!
				call TimerStart(Blackhole___CheckTimer, Blackhole___CHECK_TIMESTEP, true, function s__Blackhole_CheckUsers)
            endif
			
            call s__SimpleList_List_add(s__Blackhole_ActiveBlackholes,this)
        endfunction
        
        function s__Blackhole_Stop takes integer this returns nothing
            call IssueImmediateOrder(s__Blackhole_BlackholeUnit[this], "stop")
            call s__SimpleList_List_clear(s__Blackhole_PlayersInRange[this])
            
            call s__SimpleList_List_remove(s__Blackhole_ActiveBlackholes,this)
			if s__SimpleList_List_count[s__Blackhole_ActiveBlackholes] == 0 then
				//call PauseTimer(PullTimer)
				call ReleaseTimer(Blackhole___PullTimer)
				
				//call PauseTimer(CheckTimer)
				call ReleaseTimer(Blackhole___CheckTimer)
			endif
        endfunction

        function s__Blackhole_destroy takes integer this returns nothing
			if s__SimpleList_List_contains(s__Blackhole_ActiveBlackholes,this) then
				call s__Blackhole_Stop(this)
			endif
			
            //call Recycle_ReleaseUnit(.BlackholeUnit)
            call s__SimpleList_List_destroy(s__Blackhole_PlayersInRange[this])
            
            set s__Blackhole_BlackholeUnit[this]=null
			
			call sc__IStartable_deallocate(this)
        endfunction
    
        function s__Blackhole_create takes real x,real y,boolean persist returns integer
            local integer new= s__Blackhole__allocate()
            
			//TODO add persist param
			if persist then
				set s__Blackhole_BlackholeUnit[new]=CreateUnit(BLACKHOLE_PLAYER, BLACKHOLE, x, y, 0)
			else
				set s__Blackhole_BlackholeUnit[new]=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((BLACKHOLE )))),(( x )*1.0) , (( y)*1.0))) // INLINED!!
			endif
            call AddUnitLocust(s__Blackhole_BlackholeUnit[new])
            set s__Blackhole_PlayersInRange[new]=s__SimpleList_List_create()
            
            return new
        endfunction
		
  function s__Blackhole_onInit takes nothing returns nothing
			set s__Blackhole_ActiveBlackholes=s__SimpleList_List_create()
  endfunction

//library Blackhole ends
//library CameraTrackingEvents:
	
 function RegisterCameraToggleEvents takes integer user returns nothing
		call TriggerRegisterPlayerEventEndCinematic(CameraTrackingEvents___EscapeKeyEvent, Player(user))
	endfunction
	
 function CameraTrackingEvents___OnEscapePress takes nothing returns nothing
		// local User source = User(GetPlayerId(GetTriggerPlayer()))
		call s__User_ToggleDefaultTracking((GetPlayerId(GetTriggerPlayer())))
	endfunction
 function CameraTrackingEvents___Init takes nothing returns nothing
		// set EscapeKeyEvent = Event.create()
		// call EscapeKeyEvent.register(Condition(function OnEscapePress))
		set CameraTrackingEvents___EscapeKeyEvent=CreateTrigger()
		call TriggerAddAction(CameraTrackingEvents___EscapeKeyEvent, function CameraTrackingEvents___OnEscapePress)
	endfunction

//library CameraTrackingEvents ends
//library EDWCollectibleResolveHandlers:
	
 function EDWCollectibleResolveHandlers___AdvanceLevelSwitchLevel takes nothing returns nothing
  local timer t= GetExpiredTimer()
  local integer team= s__User_Team[((LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))))] // INLINED!!
  local integer nextLevel
		
		//call DisplayTextToPlayer(Player(0), 0, 0, "Default advance level resolved by active team " + I2S(team))
		
		if s__Levels_Level_NextLevel[s__Teams_MazingTeam_OnLevel[team]] == 0 then
			set nextLevel=(DOORS_LEVEL_ID)
		else
			set nextLevel=s__Levels_Level_NextLevel[s__Teams_MazingTeam_OnLevel[team]]
		endif
		
		call sc__Levels_Level_SwitchLevelsAnimated(s__Teams_MazingTeam_OnLevel[team],team , nextLevel , true)
		
		call ReleaseTimer(t)
		set t=null
	endfunction
 function EDWCollectibleResolveHandlers___AdvanceLevelPlaySFX takes nothing returns nothing
  local timer t= GetExpiredTimer()
  local integer user= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
			
		//play frogger sfx
		call AttachSoundToUnit(gg_snd_FroggerPS1Victory_EDW, s__User_ActiveUnit[user])
		//call StartSound(gg_snd_FroggerPS1Victory_EDW)
		call sc__Teams_MazingTeam_PlaySoundForTeam(s__User_Team[user],gg_snd_FroggerPS1Victory_EDW)
		
		if s__SimpleList_List_count[s__Teams_MazingTeam_Users[s__User_Team[user]]] > 1 then
			set s__Teams_MazingTeam_LastEventUser[s__User_Team[user]]=- 1
			call sc__Teams_MazingTeam_PrintMessage(s__User_Team[user],"Your team has cleared the level!")
		else
			set s__Teams_MazingTeam_LastEventUser[s__User_Team[user]]=user
		endif
		
		call TimerStart(t, EDWCollectibleResolveHandlers___ADVANCE_LEVEL_FROGGER_SFX_DURATION, false, function EDWCollectibleResolveHandlers___AdvanceLevelSwitchLevel)
		set t=null
	endfunction
	
 function EDWCollectibleResolveHandlers_AdvanceLevel takes integer user,integer activeTeam returns integer
		//pause team
		call sc__Teams_MazingTeam_PauseTeam(s__CollectibleTeam_Team[activeTeam],true)
		
		//pan team's cameras to last collected
		call sc__Teams_MazingTeam_PanCameraForTeam(s__CollectibleTeam_Team[activeTeam],GetUnitX(s__User_ActiveUnit[user]) , GetUnitY(s__User_ActiveUnit[user]) , EDWCollectibleResolveHandlers___ADVANCE_LEVEL_PAN_CAMERA_DURATION)
		
		call TimerStart(NewTimerEx(user), EDWCollectibleResolveHandlers___ADVANCE_LEVEL_PAN_CAMERA_DURATION, false, function EDWCollectibleResolveHandlers___AdvanceLevelPlaySFX)
		
		return 0
	endfunction
 function EDWCollectibleResolveHandlers_AdvanceCheckpoint takes integer result,integer activeTeam returns integer
		//call DisplayTextToPlayer(Player(0), 0, 0, "Default advance checkpoint resolved by active team " + I2S(activeTeam))
		
		if s__Teams_MazingTeam_OnCheckpoint[s__CollectibleTeam_Team[activeTeam]] >= s__SimpleList_List_count[s__Levels_Level_Checkpoints[s__Teams_MazingTeam_OnLevel[s__CollectibleTeam_Team[activeTeam]]]] then
			call EDWCollectibleResolveHandlers_AdvanceLevel(result , activeTeam)
		else
			call sc__Levels_Level_AnimatedSetCheckpointForTeam(s__Teams_MazingTeam_OnLevel[s__CollectibleTeam_Team[activeTeam]],s__CollectibleTeam_Team[activeTeam] , s__Teams_MazingTeam_OnCheckpoint[s__CollectibleTeam_Team[activeTeam]] + 1)
		endif
		
		return 0
	endfunction

//library EDWCollectibleResolveHandlers ends
//library Teams:

//ASSUMPTIONS: !!IMPORTANT!!
//when creating a new MazingTeam, the game assumes that MazersArray[PlayerId(i)] = that player's starting demonhunter
//it also assumes that the platforming unit is fit to match (mistakes were made) and that all the relevant gameloops are ready to go / have been recycled properly
//this should only be relevant when first starting the game (for which it's hardcoded in already...) or if attempting to implement -restart lol

	
	
 function s__WorldProgress_create takes integer furthestLevel returns integer
  local integer new= s__WorldProgress_c
		set s__WorldProgress_c=s__WorldProgress_c + 1
		
		set s__WorldProgress_WorldID[new]=sc__Levels_Level_GetWorldID(furthestLevel)
		set s__WorldProgress_FurthestLevel[new]=furthestLevel
		
		return new
 endfunction

    
    // public boolean RecentlyTransferred
    // public real LastTransferTime
	// public boolean IsRemainingTeamAFK
    
    //public integer DefaultGameMode
    
    
	
    
//Implemented from module Alloc:
		
		

			

		
		
  function s__Teams_MazingTeam_allocate takes nothing returns integer
   local integer this= s__Teams_MazingTeam_Alloc___recycler[0]
			


			
			if ( s__Teams_MazingTeam_Alloc___recycler[this] == 0 ) then
				set s__Teams_MazingTeam_Alloc___recycler[0]=this + 1
			else
				set s__Teams_MazingTeam_Alloc___recycler[0]=s__Teams_MazingTeam_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__Teams_MazingTeam_deallocate takes integer this returns nothing


			


			
			set s__Teams_MazingTeam_Alloc___recycler[this]=s__Teams_MazingTeam_Alloc___recycler[0]
			set s__Teams_MazingTeam_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__Teams_MazingTeam_Alloc___onInit takes nothing returns nothing
			set s__Teams_MazingTeam_Alloc___recycler[0]=1
  endfunction
	
    function s__Teams_MazingTeam_MoveRevive takes integer this,rect newlocation returns nothing
        call MoveRectTo(s__Teams_MazingTeam_Revive[this], GetRectCenterX(newlocation), GetRectCenterY(newlocation))
    endfunction
    
    function s__Teams_MazingTeam_MoveReviveToDoors takes integer this returns nothing
        call MoveRectTo(s__Teams_MazingTeam_Revive[this], GetRectCenterX(gg_rct_HubWorld_R), GetRectCenterY(gg_rct_HubWorld_R))
    endfunction
    
    function s__Teams_MazingTeam_CreateMenu takes integer this,real time,string optionCB returns nothing
        local real x= Teams___VOTE_TOP_LEFT_X + R2I(( this + 1 ) / 4)
        local real y= Teams___VOTE_TOP_LEFT_Y + R2I(( this + 1 ) / 2)
        local integer cur= s__Teams_MazingTeam_FirstUser[this]
                
        set s__Teams_MazingTeam_VoteMenu[this]=s__VisualVote_voteMenu_create(x , y , time , optionCB)
        
        //register team to menu
        loop
        exitwhen cur == 0
            //pause their active unit
            if s__User_GameMode[(s__SimpleList_ListNode_value[cur])] == Teams_GAMEMODE_STANDARD then
                call s__User_SwitchGameModesDefaultLocation((s__SimpleList_ListNode_value[cur]),Teams_GAMEMODE_STANDARD_PAUSED)
            elseif s__User_GameMode[(s__SimpleList_ListNode_value[cur])] == Teams_GAMEMODE_PLATFORMING then
                call s__User_SwitchGameModesDefaultLocation((s__SimpleList_ListNode_value[cur]),Teams_GAMEMODE_PLATFORMING_PAUSED)
            endif
            
            call s__SimpleList_List_addEnd(s__VisualVote_voteMenu_forPlayers[s__Teams_MazingTeam_VoteMenu[this]],s__SimpleList_ListNode_value[cur])
        set cur=s__SimpleList_ListNode_next[cur]
        endloop
    endfunction
    
    function s__Teams_MazingTeam_IsTeamDead takes integer this returns boolean
        local integer fp= s__Teams_MazingTeam_FirstUser[this]
        local integer count= 0
        
        if s__Teams_MazingTeam_IsTeamPlaying[this] then
            loop
            exitwhen fp == 0
                if not s__User_IsPlaying[(s__SimpleList_ListNode_value[fp])] or s__User_GameMode[(s__SimpleList_ListNode_value[fp])] == Teams_GAMEMODE_DEAD then
                    set count=count + 1
                endif
                
            set fp=s__SimpleList_ListNode_next[fp]
            endloop
            //call DisplayTextToForce(bj_FORCE_PLAYER[0], "count " + I2S(count) + " of " + I2S(.Users.count))
            return count == s__SimpleList_List_count[s__Teams_MazingTeam_Users[this]]
        else
            //call DisplayTextToForce(bj_FORCE_PLAYER[0], "team is dead, returning true")
            return true
        endif
    endfunction
	
 function s__Teams_MazingTeam_ClearCinematicQueue takes integer this returns nothing
  local integer fp= s__Teams_MazingTeam_FirstUser[this]
		
		loop
		exitwhen fp == 0
			call s__SimpleList_List_clear(s__User_CinematicQueue[(s__SimpleList_ListNode_value[fp])])
		set fp=s__SimpleList_ListNode_next[fp]
		endloop
 endfunction
 function s__Teams_MazingTeam_ClearAllCinematicsForTeam takes integer this returns nothing
  local integer fp= s__Teams_MazingTeam_FirstUser[this]
		
		loop
		exitwhen fp == 0
			call s__SimpleList_List_clear(s__User_CinematicQueue[(s__SimpleList_ListNode_value[fp])])
			
			if s__User_CinematicPlaying[(s__SimpleList_ListNode_value[fp])] != 0 then
				call s__CinemaCallbackModel_EndCallbackStack(s__User_CinematicPlaying[(s__SimpleList_ListNode_value[fp])])
			endif
		set fp=s__SimpleList_ListNode_next[fp]
		endloop
 endfunction
    
//    public method SetDefaultTeamGameMode takes integer gameMode returns nothing
//        local SimpleList_ListNode u = .FirstUser
//        
//        set .DefaultGameMode = gameMode
//        
//        loop
//        exitwhen u == 0
//            call User(u.value).SetCurrentGameMode(gameMode)
//        set u = u.next
//        endloop
//    endmethod
    
    function s__Teams_MazingTeam_SwitchGameModeContinuous takes integer this,integer newGameMode returns nothing
        local integer u= s__Teams_MazingTeam_FirstUser[this]
                
        loop
        exitwhen u == 0
            call s__User_SwitchGameModesDefaultLocation((s__SimpleList_ListNode_value[u]),newGameMode)
        set u=s__SimpleList_ListNode_next[u]
        endloop
    endfunction
    
    function s__Teams_MazingTeam_SwitchTeamGameMode takes integer this,integer newGameMode,real x,real y returns nothing
        local integer u= s__Teams_MazingTeam_FirstUser[this]
                
        loop
        exitwhen u == 0
            call s__User_SwitchGameModes((s__SimpleList_ListNode_value[u]),newGameMode , x , y)
        set u=s__SimpleList_ListNode_next[u]
        endloop
    endfunction
    
    function s__Teams_MazingTeam_AddTeamVision takes integer this,rect newvision returns nothing
        local integer fp= s__Teams_MazingTeam_FirstUser[this]
        local integer u
        
        if s__Teams_MazingTeam_IsTeamPlaying[this] then
            loop
            exitwhen fp == 0
                set u=s__SimpleList_ListNode_value[fp]
                if s__User_IsPlaying[u] then
                    call FogModifierStart(CreateFogModifierRect(Player(u), FOG_OF_WAR_VISIBLE, newvision, false, true))
					
					//call DisplayTextToForce(bj_FORCE_PLAYER[0], "added vision for user " + I2S(u))
                endif
                
            set fp=s__SimpleList_ListNode_next[fp]
            endloop
        endif
    endfunction
    
    function s__Teams_MazingTeam_ApplyTeamDefaultCameras takes integer this returns nothing
        local integer fp= s__Teams_MazingTeam_FirstUser[this]
        local integer u
        
        if s__Teams_MazingTeam_IsTeamPlaying[this] then
            loop
            exitwhen fp == 0
                set u=s__SimpleList_ListNode_value[fp]
                
                call s__User_ApplyDefaultCameras((s__SimpleList_ListNode_value[fp]),0.)
                
            set fp=s__SimpleList_ListNode_next[fp]
            endloop
        endif
    endfunction
    
 function s__Teams_MazingTeam_ReviveTeam takes integer this returns nothing
		call sc__Teams_MazingTeam_RespawnTeamAtRect(this,s__Teams_MazingTeam_Revive[this] , true)
 endfunction
    function s__Teams_MazingTeam_RespawnTeamAtRect takes integer this,rect newlocation,boolean moveliving returns nothing
        local real x
        local real y
        local integer ttype
        local integer fp= s__Teams_MazingTeam_FirstUser[this]
        local integer u
        local timer t
        
        //call DisplayTextToForce(bj_FORCE_PLAYER[0], "Respawn start for team " + I2S(this))
        
        if s__Teams_MazingTeam_IsTeamPlaying[this] then
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Team respawn")
            
            loop
            exitwhen fp == 0
                set u=s__SimpleList_ListNode_value[fp]
                
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "respawning " + I2S(u))
                //call DisplayTextToForce(bj_FORCE_PLAYER[0], "cur " + I2S(fp) + ", next " + I2S(fp.next))
                
                call s__User_RespawnAtRect(u,newlocation , moveliving)
            set fp=s__SimpleList_ListNode_next[fp]
            endloop
            
			//call DisplayTextToForce(bj_FORCE_PLAYER[0], "Respawn end for team " + I2S(this))
            set t=null
        endif
    endfunction
    
    function s__Teams_MazingTeam_SetPlatformerProfile takes integer this,integer profile returns nothing
        local integer fp= s__Teams_MazingTeam_FirstUser[this]
        local integer u
        
        if s__Teams_MazingTeam_IsTeamPlaying[this] then
            loop
            exitwhen fp == 0
                set u=s__SimpleList_ListNode_value[fp]
                if s__User_IsPlaying[u] then
                    set s__Platformer_BaseProfile[s__User_Platformer[u]]=profile
                endif
                
            set fp=s__SimpleList_ListNode_next[fp]
            endloop
        endif
    endfunction
    
    function s__Teams_MazingTeam_ApplyKeyToTeam takes integer this,integer keyID returns nothing
        local integer fp= s__Teams_MazingTeam_FirstUser[this]
        local integer u
        
        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "applying key " + I2S(keyID))
        if s__Teams_MazingTeam_IsTeamPlaying[this] then
            loop
            exitwhen fp == 0
                set u=s__SimpleList_ListNode_value[fp]
                if s__User_IsPlaying[u] then
                    call s__User_SetKeyColor(u,keyID)
                endif
                
            set fp=s__SimpleList_ListNode_next[fp]
            endloop
        endif
    endfunction
    
    function s__Teams_MazingTeam_AddTeamCinema takes integer this,integer cinema,integer activatingUser returns nothing
        local integer u= s__Teams_MazingTeam_FirstUser[this]
                
        loop
        exitwhen u == 0
            call s__User_AddCinematicToQueue((s__SimpleList_ListNode_value[u]),cinema)
        set u=s__SimpleList_ListNode_next[u]
        endloop
    endfunction
    
    function s__Teams_MazingTeam_PrintMessage takes integer this,string message returns nothing
        local integer fp= s__Teams_MazingTeam_FirstUser[this]
        
        loop
        exitwhen fp == 0
            if GetLocalPlayer() == Player(s__SimpleList_ListNode_value[fp]) then
                call DisplayTextToPlayer(Player(s__SimpleList_ListNode_value[fp]), 0, 0, message)
            endif
        set fp=s__SimpleList_ListNode_next[fp]
        endloop
    endfunction
 function s__Teams_MazingTeam_PrintMessageAll takes string message,integer filterTeam returns nothing
  local integer curTeamNode= s__SimpleList_List_first[s__Teams_MazingTeam_AllTeams]
        
        loop
        exitwhen curTeamNode == 0
            if filterTeam == 0 or s__SimpleList_ListNode_value[curTeamNode] != filterTeam then
				call s__Teams_MazingTeam_PrintMessage((s__SimpleList_ListNode_value[curTeamNode]),message)
			endif
			
            set curTeamNode=s__SimpleList_ListNode_next[curTeamNode]
        endloop
 endfunction
    
    //returns -1 if could not find that player in this.plist
    function s__Teams_MazingTeam_ConvertPlayerID takes integer this,integer pID returns integer
        local integer fp= s__Teams_MazingTeam_FirstUser[this]
        
        if s__Teams_MazingTeam_IsTeamPlaying[this] then
            loop
            exitwhen fp == 0
                if (s__SimpleList_ListNode_value[fp]) == pID then
                    return s__SimpleList_ListNode_value[fp]
                endif
                
            set fp=s__SimpleList_ListNode_next[fp]
            endloop
        endif
        
        return 0
    endfunction
        
    function s__Teams_MazingTeam_GetInitialContinues takes integer this returns integer
        local real weighted= STARTING_CONTINUES
        
        if RewardMode == 0 then
            set weighted=weighted * 2 * s__Teams_MazingTeam_Weight[this]
        elseif RewardMode == 1 then
            set weighted=weighted * s__Teams_MazingTeam_Weight[this]
        elseif RewardMode == 2 then
            set weighted=0
        endif
        
        if this != 0 and RespawnASAPMode then
            set weighted=weighted * s__SimpleList_List_count[s__Teams_MazingTeam_Users[this]]
        //else weighted = weighted, no point
        endif
        
        //TODO: Uneven teams handicap bonus
        
        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "initial continues: " + R2S(weighted))
        
        return R2I(weighted)
    endfunction
        
    function s__Teams_MazingTeam_GetWeightedReward takes integer this,integer unweighted returns integer
        local real weighted= unweighted
        
        if RewardMode == 0 then
            set weighted=weighted * 2 * s__Teams_MazingTeam_Weight[this]
        elseif RewardMode == 1 then
            set weighted=weighted * s__Teams_MazingTeam_Weight[this]
        elseif RewardMode == 2 then
            set weighted=0
        endif
        
        if this != 0 and RespawnASAPMode then
            set weighted=weighted * s__SimpleList_List_count[s__Teams_MazingTeam_Users[this]]
        //else weighted = weighted, no point
        endif
        
        //TODO: Uneven teams handicap bonus
        
        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "level reward continues: " + R2S(weighted))
        
        return R2I(weighted)
    endfunction
        
    function s__Teams_MazingTeam_GetCountOnLevel takes integer levelID returns integer
        local integer curTeamNode= s__SimpleList_List_first[s__Teams_MazingTeam_AllTeams]
        local integer count= 0
        
        loop
        exitwhen curTeamNode == 0
            // call DisplayTextToForce(bj_FORCE_PLAYER[0], "Team " + I2S(MazingTeam(curTeamNode.value)) + " on level: " + I2S(MazingTeam(curTeamNode.value).OnLevel))
            // call DisplayTextToForce(bj_FORCE_PLAYER[0], "Checking " + I2S(levelID))
            if s__Teams_MazingTeam_OnLevel[(s__SimpleList_ListNode_value[curTeamNode])] == levelID then
                set count=count + s__SimpleList_List_count[s__Teams_MazingTeam_Users[(s__SimpleList_ListNode_value[curTeamNode])]]
            endif
			
		set curTeamNode=s__SimpleList_ListNode_next[curTeamNode]
        endloop
        
        // call DisplayTextToForce(bj_FORCE_PLAYER[0], "Count on level " + I2S(count))
        
        return count
    endfunction
    
    function s__Teams_MazingTeam_IsLevelEmpty takes integer levelID returns boolean
        local integer curTeamNode= s__SimpleList_List_first[s__Teams_MazingTeam_AllTeams]
        
        loop
        exitwhen curTeamNode == 0
            //call DisplayTextToForce(bj_FORCE_PLAYER[0], "Team " + I2S(AllTeams[i].TeamID) + " on level: " + I2S(.AllTeams[i].OnLevel))
            //call DisplayTextToForce(bj_FORCE_PLAYER[0], "Checking " + I2S(levelID))
            if s__Teams_MazingTeam_OnLevel[(s__SimpleList_ListNode_value[curTeamNode])] == levelID then
                return false
            endif
			
		set curTeamNode=s__SimpleList_ListNode_next[curTeamNode]
        endloop
				
        //call DisplayTextToForce(bj_FORCE_PLAYER[0], "Count on level " + I2S(count))
        
        return true
    endfunction
	
 function s__Teams_MazingTeam_GetWorldProgress takes integer this,integer worldID returns integer
  local integer curWorld= s__SimpleList_List_first[s__Teams_MazingTeam_AllWorldProgress[this]]
				
		loop
		exitwhen curWorld == 0
			if s__WorldProgress_WorldID[(s__SimpleList_ListNode_value[curWorld])] == worldID then
				return (s__SimpleList_ListNode_value[curWorld])
			endif
		set curWorld=s__SimpleList_ListNode_next[curWorld]
		endloop
		
		return 0
 endfunction
 function s__Teams_MazingTeam_UpdateWorldProgress takes integer this,integer level returns nothing
  local integer worldID= sc__Levels_Level_GetWorldID(level)
  local integer currentProgress
				
		if worldID != 0 then
			set currentProgress=s__Teams_MazingTeam_GetWorldProgress(this,worldID)
						
			if currentProgress == 0 then
				set currentProgress=s__WorldProgress_create(level)
				call s__SimpleList_List_add(s__Teams_MazingTeam_AllWorldProgress[this],currentProgress)
			elseif s__WorldProgress_FurthestLevel[currentProgress] + 0 < level + 0 then
				set s__WorldProgress_FurthestLevel[currentProgress]=level
			endif
		endif
 endfunction
    
    function s__Teams_MazingTeam_PlayerLeaves takes nothing returns nothing
        local player p= GetTriggerPlayer()
        local integer pID= GetPlayerId(p)
        local integer u= (pID)
        local integer mt= s__User_Team[u]
		
  local integer curUserNode= s__SimpleList_List_first[s__Teams_MazingTeam_Users[mt]]
  local boolean anyActive= false
        
        //call mt.Users.remove(u)
        call s__User_OnLeave(u)
        
        //update team comparison weights and give the team that just lost a player ~1 more continue
        call TriggerEvaluate(st__Teams_MazingTeam_ComputeTeamWeights) // INLINED!!
        set s__Teams_MazingTeam_ContinueCount[mt]=s__Teams_MazingTeam_ContinueCount[mt] + R2I(1 * s__Teams_MazingTeam_Weight[mt] + .5)
        
        call sc__Teams_MazingTeam_UpdateMultiboard(mt)
		
		loop
        exitwhen curUserNode == 0 or anyActive
			if s__User_IsPlaying[(s__SimpleList_ListNode_value[curUserNode])] then
				set anyActive=s__User_IsPlaying[(s__SimpleList_ListNode_value[curUserNode])]
			endif
		set curUserNode=s__SimpleList_ListNode_next[curUserNode]
		endloop
		
		if not anyActive then
			set s__Teams_MazingTeam_IsTeamPlaying[mt]=false
		endif
        //set MazersArray[pID] = null
    endfunction
    
    function s__Teams_MazingTeam_AddPlayer takes integer this,integer pID returns nothing





















                
        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Adding user: " + I2S(User(pID)) + " to team: " + I2S(this))
        
        call s__SimpleList_List_addEnd(s__Teams_MazingTeam_Users[this],(pID))
        set s__User_Team[(pID)]=this
        set s__User_IsPlaying[(pID)]=true
        
        //check if this was the first player added to the team
        if s__SimpleList_List_count[s__Teams_MazingTeam_Users[this]] == 1 then
            set s__Teams_MazingTeam_FirstUser[this]=s__SimpleList_List_first[s__Teams_MazingTeam_Users[this]]
            
            set s__Teams_MazingTeam_IsTeamPlaying[this]=true
        endif
        
        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Player count of team " + I2S(this) + ", is now: " + I2S(.PlayerCount))
    endfunction
    
    function s__Teams_MazingTeam_UpdateMultiboard takes integer this returns nothing
        local integer pID
        
        local integer fp= s__Teams_MazingTeam_FirstUser[this]
        local integer u
        
        //PLAYER_SLOT_STATE_LEFT
        
        loop
        exitwhen fp == 0
            set u=(s__SimpleList_ListNode_value[fp])
            set pID=u
            
            if GetPlayerSlotState(Player(pID)) == PLAYER_SLOT_STATE_PLAYING then
				call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 0), sc__Teams_MazingTeam_GetStylizedPlayerName(this,pID))
                call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 1), s__Levels_Level_Name[s__Teams_MazingTeam_OnLevel[this]])
                call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 2), I2S(s__Teams_MazingTeam_Score[this]))
                call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 3), I2S(s__Teams_MazingTeam_ContinueCount[this]))
                
                
                call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 0))
                call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 1))
                call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 2))
                call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 3))
                
				
				if RewardMode == GameModesGlobals_HARD then
					call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 4), I2S(s__User_Deaths[u]))
					call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 4))
				endif
			elseif GetPlayerSlotState(Player(pID)) == PLAYER_SLOT_STATE_LEFT then
                call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 0), "Left the game")
                call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 1), "Gone")
                call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 2), "Negative")
                call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 3), "Zilch")
                
                
                call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 0))
                call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 1))
                call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 2))
                call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 3))
                
				
				if RewardMode == GameModesGlobals_HARD then
					call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 4), "Too many")
					call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 4))
				endif
            else
                call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 0), "Not playing")
                call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 0))
            endif
            
        set fp=s__SimpleList_ListNode_next[fp]
        endloop
    endfunction
    
 function s__Teams_MazingTeam_GetTeamColor takes integer this returns string
  local string hex
        
        if this == 1 then
            set hex="FF0000"
        elseif this == 2 then
            set hex="0000FF"
        elseif this == 3 then
            set hex="00FFCC"
        elseif this == 4 then
            set hex="FF66CC"
        elseif this == 5 then
            set hex="FFFF66"
        elseif this == 6 then
            set hex="FF9933"
        elseif this == 7 then
            set hex="00CC00"
        elseif this == 8 then
            set hex="FF66CC"
        else
            set hex=""
        endif
		
		return hex
 endfunction
 function s__Teams_MazingTeam_GetDefaultTeamName takes integer this returns string
  local string name
		
		if this == 1 then
			set name="Red"
		elseif this == 2 then
			set name="Blue"
		elseif this == 3 then
			set name="Teal"
		elseif this == 4 then
			set name="Purple"
		elseif this == 5 then
			set name="Yellow"
		elseif this == 6 then
			set name="Orange"
		elseif this == 7 then
			set name="Green"
		elseif this == 8 then
			set name="Pink"
		else
			set name=""
		endif
		
		return ColorMessage(name , s__Teams_MazingTeam_GetTeamColor(this))
 endfunction
    function s__Teams_MazingTeam_GetStylizedPlayerName takes integer this,integer pID returns string
        if GetPlayerSlotState(Player(pID)) == PLAYER_SLOT_STATE_PLAYING then
			if s__User_IsAFK[(pID)] then
				return ColorMessage("(AFK) " , DISABLED_COLOR) + ColorMessage(GetPlayerName(Player(pID)) , s__Teams_MazingTeam_GetTeamColor(this))
			else
				return ColorMessage(GetPlayerName(Player(pID)) , s__Teams_MazingTeam_GetTeamColor(this))
			endif
			
        else
			return ColorMessage("Gone" , s__Teams_MazingTeam_GetTeamColor(this))
        endif
    endfunction
    
    function s__Teams_MazingTeam_ComputeTeamWeights takes nothing returns nothing
        local integer curTeamNode= s__SimpleList_List_first[s__Teams_MazingTeam_AllTeams]
        local real avgSize= 0
        
        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "computing team weights")
        
        //compute average team size
        loop
        exitwhen curTeamNode == 0
            set avgSize=avgSize + s__SimpleList_List_count[s__Teams_MazingTeam_Users[(s__SimpleList_ListNode_value[curTeamNode])]]
            
		set curTeamNode=s__SimpleList_ListNode_next[curTeamNode]
        endloop
        set avgSize=avgSize / s__Teams_MazingTeam_NumberTeams
        
        //TODO also include individual player scores in weight
        
        set curTeamNode=s__SimpleList_List_first[s__Teams_MazingTeam_AllTeams]
        loop
        exitwhen curTeamNode == 0
            if s__SimpleList_List_count[s__Teams_MazingTeam_Users[(s__SimpleList_ListNode_value[curTeamNode])]] > avgSize then
                set s__Teams_MazingTeam_Weight[(s__SimpleList_ListNode_value[curTeamNode])]=1.0 / ( s__SimpleList_List_count[s__Teams_MazingTeam_Users[(s__SimpleList_ListNode_value[curTeamNode])]] - avgSize )
            elseif s__SimpleList_List_count[s__Teams_MazingTeam_Users[(s__SimpleList_ListNode_value[curTeamNode])]] < avgSize then
                set s__Teams_MazingTeam_Weight[(s__SimpleList_ListNode_value[curTeamNode])]=1.0 * ( avgSize - s__SimpleList_List_count[s__Teams_MazingTeam_Users[(s__SimpleList_ListNode_value[curTeamNode])]] )
            else // team size == avg size
                set s__Teams_MazingTeam_Weight[(s__SimpleList_ListNode_value[curTeamNode])]=1.
            endif
            
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "team: " + I2S(i) + ", weight: " + R2S(.AllTeams[i].Weight))
            
		set curTeamNode=s__SimpleList_ListNode_next[curTeamNode]
        endloop
    endfunction
	
 function s__Teams_MazingTeam_GetRandomTeam takes integer filter returns integer
  local integer rand= GetRandomInt(0, s__Teams_MazingTeam_NumberTeams - 1)
		
		if s__Teams_MazingTeam_NumberTeams != 1 or filter == 0 then
			if filter != 0 then
				loop
				exitwhen rand != filter
				set rand=GetRandomInt(0, s__Teams_MazingTeam_NumberTeams - 1)
				endloop
			endif
			
			return s__SimpleList_ListNode_value[s__SimpleList_List_get(s__Teams_MazingTeam_AllTeams,rand)]
		else
			return 0
		endif
 endfunction
    	
	//returning the 1st place winner is fine for now, but eventually i'll want to run through all team ranks
	//TODO replace with a sort by score function that returns a simple list
 function s__Teams_MazingTeam_GetLeadingScore takes nothing returns integer
  local integer leader= 0
  local integer leadScore= - 1
  local boolean tie= false
		
  local integer curTeamNode= s__SimpleList_List_first[s__Teams_MazingTeam_AllTeams]
		
		loop
        exitwhen curTeamNode == 0
            if s__Teams_MazingTeam_Score[(s__SimpleList_ListNode_value[curTeamNode])] > leadScore then
				set tie=false
				set leader=(s__SimpleList_ListNode_value[curTeamNode])
				set leadScore=s__Teams_MazingTeam_Score[leader]
			elseif s__Teams_MazingTeam_Score[(s__SimpleList_ListNode_value[curTeamNode])] == leadScore then
				set tie=true
			endif
			
            set curTeamNode=s__SimpleList_ListNode_next[curTeamNode]
        endloop
				
		return leader
 endfunction
	
 function s__Teams_MazingTeam_GetContinueCount takes integer this returns integer
		return s__Teams_MazingTeam_ContinueCount[this]
 endfunction
 function s__Teams_MazingTeam_SetContinueCount takes integer this,integer continueCount returns nothing





		
		set s__Teams_MazingTeam_ContinueCount[this]=continueCount
		
		call s__Teams_MazingTeam_UpdateMultiboard(this)
 endfunction
 function s__Teams_MazingTeam_ChangeContinueCount takes integer this,integer continueOffset returns nothing
		if continueOffset != 0 then
			if s__Teams_MazingTeam_ContinueCount[this] + continueOffset < 0 then
				call s__Teams_MazingTeam_PrintMessage(this,"Your team ran out of lives!")
				call sc__Levels_Level_SwitchLevels(s__Teams_MazingTeam_OnLevel[this],this , (DOORS_LEVEL_ID) , 0 , false)
				
				//if not in 99 and none mode, reset continues
				if RewardMode == 0 or RewardMode == 1 then //standard mode or challenge mode
					set s__Teams_MazingTeam_ContinueCount[this]=0
					//call mt.RespawnTeamAtRect(mt.Revive, true)
				elseif RewardMode == 2 then
					//call RemoveUnit()
					//**************************************
					//no more continues in 99 and none mode -- team has lost!
					//**************************************
				endif
			else
				set s__Teams_MazingTeam_ContinueCount[this]=s__Teams_MazingTeam_ContinueCount[this] + continueOffset
			endif
			
			call s__Teams_MazingTeam_UpdateMultiboard(this)
		endif
 endfunction
	
 function s__Teams_MazingTeam_GetScore takes integer this returns integer
		return s__Teams_MazingTeam_Score[this]
 endfunction
 function s__Teams_MazingTeam_ChangeScore takes integer this,integer scoreOffset returns nothing
  local integer ogScore= VictoryScore - s__Teams_MazingTeam_Score[this]
		
		if scoreOffset != 0 then
			set s__Teams_MazingTeam_Score[this]=s__Teams_MazingTeam_Score[this] + scoreOffset
			
			//TODO update multiboard leader positions
			
			//check for victory conditions
			if VictoryScore != 0 then
				if VictoryScore - s__Teams_MazingTeam_Score[this] <= 0 then
					call sc__Teams_MazingTeam_ApplyEndGameAll(this)
				elseif ( VictoryScore - s__Teams_MazingTeam_Score[this] <= 10 and ogScore > 10 ) or ( VictoryScore - s__Teams_MazingTeam_Score[this] <= 5 and ogScore > 5 ) then
					call s__Teams_MazingTeam_PrintMessageAll("Team " + s__Teams_MazingTeam_TeamName[this] + " needs " + (ColorMessage((I2S(VictoryScore - s__Teams_MazingTeam_Score[this])) , SPEAKER_COLOR)) + " more points to win" , 0) // INLINED!!
				elseif VictoryScore - s__Teams_MazingTeam_Score[this] <= 3 and ogScore > 3 then
					if VictoryScore - s__Teams_MazingTeam_Score[this] == 1 then
						call s__Teams_MazingTeam_PrintMessageAll("Team " + s__Teams_MazingTeam_TeamName[this] + " only needs " + (ColorMessage((I2S(VictoryScore - s__Teams_MazingTeam_Score[this])) , SPEAKER_COLOR)) + " more point to win!" , 0) // INLINED!!
					else
						call s__Teams_MazingTeam_PrintMessageAll("Team " + s__Teams_MazingTeam_TeamName[this] + " only needs " + (ColorMessage((I2S(VictoryScore - s__Teams_MazingTeam_Score[this])) , SPEAKER_COLOR)) + " more points to win!" , 0) // INLINED!!
					endif
				endif
			endif
			
			call s__Teams_MazingTeam_UpdateMultiboard(this)
		endif
 endfunction
    
 function s__Teams_MazingTeam_MultiboardHideCallback takes nothing returns nothing
        local timer t= GetExpiredTimer()
        
        call MultiboardMinimize(s__Teams_MazingTeam_PlayerStats, true)
        
        call ReleaseTimer(t)
        set t=null
    endfunction

    //intended to be run after initial team setup
    function s__Teams_MazingTeam_MultiboardSetupInit takes nothing returns nothing
        local integer i= 0
        local integer u
        local integer mt
        local timer t= (NewTimerEx(0)) // INLINED!!
        
        set s__Teams_MazingTeam_PlayerStats=CreateMultiboard()
        set bj_lastCreatedMultiboard=s__Teams_MazingTeam_PlayerStats
        
        call MultiboardSetRowCount(s__Teams_MazingTeam_PlayerStats, NumberPlayers + 1)
        call MultiboardSetTitleText(s__Teams_MazingTeam_PlayerStats, "Player Stats")
        call MultiboardDisplay(s__Teams_MazingTeam_PlayerStats, true)
        call MultiboardSetItemsWidth(s__Teams_MazingTeam_PlayerStats, .1)
		
		if RewardMode == GameModesGlobals_HARD then
			call MultiboardSetColumnCount(s__Teams_MazingTeam_PlayerStats, 5)
		else
			call MultiboardSetColumnCount(s__Teams_MazingTeam_PlayerStats, 4)
        endif
        
        //multiboard column titles
        call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, 0, 0), "Player Name")
        call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, 0, 1), "On Level")
        call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, 0, 2), "Score")
        call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, 0, 3), "Continues")
        
        call MultiboardSetItemIcon(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, 0, 0), "ReplaceableTextures\\CommandButtons\\BTNPeasant.blp")
        call MultiboardSetItemIcon(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, 0, 1), "ReplaceableTextures\\CommandButtons\\BTNDemonGate.blp")
        call MultiboardSetItemIcon(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, 0, 2), "ReplaceableTextures\\CommandButtons\\BTNGlyph.blp")
        call MultiboardSetItemIcon(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, 0, 3), "ReplaceableTextures\\CommandButtons\\BTNSkillz.tga")
        
        call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, 0, 0))
        call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, 0, 1))
        call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, 0, 2))
        call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, 0, 3))
        
		if RewardMode == GameModesGlobals_HARD then
			call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, 0, 4), "Deaths")
			call MultiboardSetItemIcon(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, 0, 4), "ReplaceableTextures\\CommandButtons\\BTNAnkh.blp")
			call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, 0, 4))
		endif
		
        loop
        exitwhen i >= NumberPlayers
            call MultiboardSetItemIcon(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, i + 1, 0), "ReplaceableTextures\\CommandButtons\\BTNPeasant.blp")
            call MultiboardSetItemIcon(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, i + 1, 1), "ReplaceableTextures\\CommandButtons\\BTNDemonGate.blp")
            call MultiboardSetItemIcon(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, i + 1, 2), "ReplaceableTextures\\CommandButtons\\BTNGlyph.blp")
            call MultiboardSetItemIcon(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, i + 1, 3), "ReplaceableTextures\\CommandButtons\\BTNSkillz.tga")
            
			if RewardMode == GameModesGlobals_HARD then
				call MultiboardSetItemIcon(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, i + 1, 4), "ReplaceableTextures\\CommandButtons\\BTNAnkh.blp")
            endif
			
            if GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING then
                set u=(i)
                set mt=s__User_Team[u]
                
                call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, i + 1, 0), s__Teams_MazingTeam_GetStylizedPlayerName(mt,i))
                call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, i + 1, 1), s__Levels_Level_Name[s__Teams_MazingTeam_OnLevel[mt]])
                call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, i + 1, 2), I2S(s__Teams_MazingTeam_Score[mt]))
                call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, i + 1, 3), I2S(s__Teams_MazingTeam_ContinueCount[mt]))
                
                
                call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, i + 1, 0))
                call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, i + 1, 1))
                call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, i + 1, 2))
                call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, i + 1, 3))
                
				
				if RewardMode == GameModesGlobals_HARD then
					call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, i + 1, 4), I2S(s__User_Deaths[u]))
					call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, i + 1, 4))
				endif
            else
                call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, i + 1, 0), "Not Playing")
                call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, i + 1, 0))
            endif
            
            set i=i + 1
        endloop
        call MultiboardDisplay(s__Teams_MazingTeam_PlayerStats, false)
        call MultiboardDisplay(s__Teams_MazingTeam_PlayerStats, true)
        call MultiboardMinimize(s__Teams_MazingTeam_PlayerStats, true)
        call MultiboardMinimize(s__Teams_MazingTeam_PlayerStats, false)
        
        //call TimerStart(t, MULTIBOARD_HIDE_DELAY, false, function MazingTeam.MultiboardHideCallback)
        
        set t=null
    endfunction
	
 function s__Teams_MazingTeam_ApplyEndGame takes integer this,boolean victory returns nothing
  local integer curPlayer= s__Teams_MazingTeam_FirstUser[this]
		
		loop
		exitwhen curPlayer == 0
			if victory then
				call CustomVictoryBJ(Player(s__SimpleList_ListNode_value[curPlayer]), true, false)
			else
				call CustomDefeatDialogBJ(Player(s__SimpleList_ListNode_value[curPlayer]), "Here to play. Forever stay.")
			endif
		set curPlayer=s__SimpleList_ListNode_next[curPlayer]
		endloop
 endfunction
 function s__Teams_MazingTeam_ApplyEndGameAll takes integer victor returns nothing
  local integer curTeamNode= s__SimpleList_List_first[s__Teams_MazingTeam_AllTeams]
		
		loop
        exitwhen curTeamNode == 0
            if (s__SimpleList_ListNode_value[curTeamNode]) == victor then
				call s__Teams_MazingTeam_ApplyEndGame((s__SimpleList_ListNode_value[curTeamNode]),true)
			else
				call s__Teams_MazingTeam_ApplyEndGame((s__SimpleList_ListNode_value[curTeamNode]),false)
			endif
			
            set curTeamNode=s__SimpleList_ListNode_next[curTeamNode]
        endloop
 endfunction
	
 function s__Teams_MazingTeam_PauseTeam takes integer this,boolean flag returns nothing
  local integer curPlayerNode= s__Teams_MazingTeam_FirstUser[this]
		
		loop
		exitwhen curPlayerNode == 0
			call s__User_Pause((s__SimpleList_ListNode_value[curPlayerNode]),flag)
		set curPlayerNode=s__SimpleList_ListNode_next[curPlayerNode]
		endloop
 endfunction
 function s__Teams_MazingTeam_CancelAutoUnpauseForTeam takes integer this returns nothing
  local integer curPlayerNode= s__Teams_MazingTeam_FirstUser[this]
		
		loop
		exitwhen curPlayerNode == 0
			call s__User_CancelAutoUnpause((s__SimpleList_ListNode_value[curPlayerNode]))
		set curPlayerNode=s__SimpleList_ListNode_next[curPlayerNode]
		endloop
 endfunction
 function s__Teams_MazingTeam_RegisterAutoUnpauseForTeam takes integer this,real timeout returns nothing
  local integer curPlayerNode= s__Teams_MazingTeam_FirstUser[this]
		
		loop
		exitwhen curPlayerNode == 0
			call s__User_RegisterAutoUnpause((s__SimpleList_ListNode_value[curPlayerNode]),timeout)
		set curPlayerNode=s__SimpleList_ListNode_next[curPlayerNode]
		endloop
 endfunction
 function s__Teams_MazingTeam_GetAutoUnpauseLeastRemainingTime takes integer this returns real
  local integer curPlayerNode= s__Teams_MazingTeam_FirstUser[this]
  local real leastTime= - 1.
  local real curPlayerTime
		
		loop
		exitwhen curPlayerNode == 0
		set curPlayerTime=s__User_GetAutoUnpauseRemainingTime((s__SimpleList_ListNode_value[curPlayerNode]))
			if leastTime == - 1. or ( curPlayerTime != - 1. and curPlayerTime < leastTime ) then
				set leastTime=curPlayerTime
			endif
		set curPlayerNode=s__SimpleList_ListNode_next[curPlayerNode]
		endloop
				
		return leastTime
 endfunction
	
 function s__Teams_MazingTeam_SetUnitLocalVisibilityForTeam takes integer this,unit u,boolean visible returns nothing
  local integer curPlayerNode= s__Teams_MazingTeam_FirstUser[this]
		
		loop
		exitwhen curPlayerNode == 0
			call SetUnitLocalVisibility(u , s__SimpleList_ListNode_value[curPlayerNode] , visible)
		set curPlayerNode=s__SimpleList_ListNode_next[curPlayerNode]
		endloop
 endfunction
 function s__Teams_MazingTeam_SetUnitLocalOpacityForTeam takes integer this,unit u,integer opacity returns nothing
  local integer curPlayerNode= s__Teams_MazingTeam_FirstUser[this]
		
		loop
		exitwhen curPlayerNode == 0
			call SetUnitLocalOpacity(u , s__SimpleList_ListNode_value[curPlayerNode] , opacity)
		set curPlayerNode=s__SimpleList_ListNode_next[curPlayerNode]
		endloop
 endfunction
		
 function s__Teams_MazingTeam_PlaySoundForTeam takes integer this,sound sfx returns nothing
  local integer curPlayerNode= s__Teams_MazingTeam_FirstUser[this]
		
		loop
		exitwhen curPlayerNode == 0
			if GetLocalPlayer() == Player(s__SimpleList_ListNode_value[curPlayerNode]) then
				call StartSound(sfx)
			endif
		set curPlayerNode=s__SimpleList_ListNode_next[curPlayerNode]
		endloop
 endfunction
	
 function s__Teams_MazingTeam_PanCameraForTeam takes integer this,real x,real y,real duration returns nothing
  local integer curPlayerNode= s__Teams_MazingTeam_FirstUser[this]
		
		loop
		exitwhen curPlayerNode == 0
			if GetLocalPlayer() == Player(s__SimpleList_ListNode_value[curPlayerNode]) then
				if s__User_IsAFK[(s__SimpleList_ListNode_value[curPlayerNode])] then
					call SetCameraPosition(x, y)
					
					//these don't return the updated value until a timeout of 0 for some reason
					// set User.LocalCameraTargetPosition.x = GetCameraTargetPositionX()
					// set User.LocalCameraTargetPosition.y = GetCameraTargetPositionY()
					set s__vector2_x[s__User_LocalCameraTargetPosition]=x
					set s__vector2_y[s__User_LocalCameraTargetPosition]=y
				else
					call PanCameraToTimed(x, y, duration)
				endif
			endif
		set curPlayerNode=s__SimpleList_ListNode_next[curPlayerNode]
		endloop
 endfunction
	
 function s__Teams_MazingTeam_FadeInForTeamCB takes nothing returns nothing
  local timer t= GetExpiredTimer()
  local integer mt= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
  local integer curPlayerNode= s__Teams_MazingTeam_FirstUser[mt]
		
		loop
		exitwhen curPlayerNode == 0
			if GetLocalPlayer() == Player(s__SimpleList_ListNode_value[curPlayerNode]) then
				call DisplayCineFilter(false)
				call EnableUserUI(true)
			endif
		set curPlayerNode=s__SimpleList_ListNode_next[curPlayerNode]
		endloop
		
		call ReleaseTimer(t)
		set t=null
 endfunction
 function s__Teams_MazingTeam_FadeInForTeam takes integer this,real duration returns nothing
  local string filterTexture= "ReplaceableTextures\\CameraMasks\\Black_mask.blp"
  local integer curPlayerNode= s__Teams_MazingTeam_FirstUser[this]
		
		loop
		exitwhen curPlayerNode == 0
			if GetLocalPlayer() == Player(s__SimpleList_ListNode_value[curPlayerNode]) then
				call EnableUserUI(false)
				
				call SetCineFilterTexture(filterTexture)
				call SetCineFilterBlendMode(BLEND_MODE_BLEND)
				call SetCineFilterTexMapFlags(TEXMAP_FLAG_NONE)
				call SetCineFilterStartUV(0, 0, 1, 1)
				call SetCineFilterEndUV(0, 0, 1, 1)
				call SetCineFilterStartColor(PercentTo255(100), PercentTo255(100), PercentTo255(100), PercentTo255(100))
				call SetCineFilterEndColor(PercentTo255(100), PercentTo255(100), PercentTo255(100), PercentTo255(0))
				call SetCineFilterDuration(duration)
				
				call DisplayCineFilter(true)
			endif
		set curPlayerNode=s__SimpleList_ListNode_next[curPlayerNode]
		endloop
		
		call TimerStart(NewTimerEx(this), duration, false, function s__Teams_MazingTeam_FadeInForTeamCB)
 endfunction
 function s__Teams_MazingTeam_FadeOutForTeam takes integer this,real duration returns nothing
  local string filterTexture= "ReplaceableTextures\\CameraMasks\\Black_mask.blp"
  local integer curPlayerNode= s__Teams_MazingTeam_FirstUser[this]
		
		loop
		exitwhen curPlayerNode == 0
			if GetLocalPlayer() == Player(s__SimpleList_ListNode_value[curPlayerNode]) then
				call EnableUserUI(false)
				
				call SetCineFilterTexture(filterTexture)
				call SetCineFilterBlendMode(BLEND_MODE_BLEND)
				call SetCineFilterTexMapFlags(TEXMAP_FLAG_NONE)
				call SetCineFilterStartUV(0, 0, 1, 1)
				call SetCineFilterEndUV(0, 0, 1, 1)
				call SetCineFilterStartColor(PercentTo255(100), PercentTo255(100), PercentTo255(100), PercentTo255(0))
				call SetCineFilterEndColor(PercentTo255(100), PercentTo255(100), PercentTo255(100), PercentTo255(100))
				call SetCineFilterDuration(duration)
				
				call DisplayCineFilter(true)
			endif
		set curPlayerNode=s__SimpleList_ListNode_next[curPlayerNode]
		endloop
 endfunction
	
 function s__Teams_MazingTeam_SetSharedControlForTeam takes integer this,integer user,boolean flag returns nothing
  local integer curPlayerNode= s__Teams_MazingTeam_FirstUser[this]
		
		loop
		exitwhen curPlayerNode == 0
			if s__SimpleList_ListNode_value[curPlayerNode] != user then
				call SetPlayerAlliance(Player(user), Player(s__SimpleList_ListNode_value[curPlayerNode]), ALLIANCE_SHARED_CONTROL, flag)
			endif
		set curPlayerNode=s__SimpleList_ListNode_next[curPlayerNode]
		endloop
 endfunction
	
 function s__Teams_MazingTeam_ResetHealthForTeam takes integer this returns nothing
  local integer curPlayerNode= s__Teams_MazingTeam_FirstUser[this]
		
		loop
		exitwhen curPlayerNode == 0
			if s__User_IsAlive[(s__SimpleList_ListNode_value[curPlayerNode])] then
				call SetUnitState(s__MazersArray[s__SimpleList_ListNode_value[curPlayerNode]], UNIT_STATE_LIFE, GetUnitState(s__MazersArray[s__SimpleList_ListNode_value[curPlayerNode]], UNIT_STATE_MAX_LIFE))
			endif
		set curPlayerNode=s__SimpleList_ListNode_next[curPlayerNode]
		endloop
 endfunction
	
 function s__Teams_MazingTeam_CreateInstantEffectForTeam takes integer this,string fxFileLocation,integer filter returns nothing
  local integer curPlayerNode= s__Teams_MazingTeam_FirstUser[this]
		
		loop
		exitwhen curPlayerNode == 0
			if ( filter == - 1 or s__SimpleList_ListNode_value[curPlayerNode] != filter ) and s__User_ActiveUnit[(s__SimpleList_ListNode_value[curPlayerNode])] != null then
				call CreateInstantSpecialEffect(fxFileLocation , GetUnitX(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curPlayerNode])]) , GetUnitY(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curPlayerNode])]) , Player(s__SimpleList_ListNode_value[curPlayerNode]))
			endif
		set curPlayerNode=s__SimpleList_ListNode_next[curPlayerNode]
		endloop
 endfunction
		
    function s__Teams_MazingTeam_create takes nothing returns integer
        local integer mt= s__Teams_MazingTeam_allocate()
		
        if not s__SimpleList_List_contains(s__Teams_MazingTeam_AllTeams,mt) then
            set s__Teams_MazingTeam_TeamName[mt]=s__Teams_MazingTeam_GetDefaultTeamName(mt) //set later
            // set mt.RecentlyTransferred = false //used to make sure triggers aren't run multiple times / no interrupts
            // set mt.LastTransferTime = -50 //has never transferred
            set s__Teams_MazingTeam_OnLevel[mt]=TEMP_LEVEL_ID
            set s__Teams_MazingTeam_OnCheckpoint[mt]=- 1
            set s__Teams_MazingTeam_Revive[mt]=Rect(0, 0, 200, 200)
            // call mt.MoveRevive(gg_rct_IntroWorld_R1)
            set s__Teams_MazingTeam_Score[mt]=0
            set s__Teams_MazingTeam_DefaultGameMode[mt]=Teams___GAMEMODE_INIT
			set s__Teams_MazingTeam_LastEventUser[mt]=- 1
            
			set s__Teams_MazingTeam_Users[mt]=s__SimpleList_List_create()
            set s__Teams_MazingTeam_AllWorldProgress[mt]=s__SimpleList_List_create()
			
            call s__SimpleList_List_addEnd(s__Teams_MazingTeam_AllTeams,mt)
            //set .NumberTeams = .NumberTeams + 1
            set s__Teams_MazingTeam_NumberTeams=s__Teams_MazingTeam_NumberTeams + 1
        else
            call DisplayTextToForce(bj_FORCE_PLAYER[0], "Overlapping team ID: " + I2S(mt) + " -- invalid game state")
            return 0 //team already exists
        endif
        return mt
    endfunction
	
 function s__Teams_MazingTeam_onInit takes nothing returns nothing
		set s__Teams_MazingTeam_AllTeams=s__SimpleList_List_create()
 endfunction

function Teams_Init takes nothing returns nothing
    local trigger t= CreateTrigger()
    local integer i= 0
    
    loop
        if GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING then
            call TriggerRegisterPlayerEvent(t, Player(i), EVENT_PLAYER_DEFEAT)
            call TriggerRegisterPlayerEvent(t, Player(i), EVENT_PLAYER_LEAVE)
        endif

	set i=i + 1
	exitwhen i >= NumberPlayers
    endloop
    
    call TriggerAddAction(t, function s__Teams_MazingTeam_PlayerLeaves)
endfunction


//library Teams ends
//library EDWGameTime:
    
    function GetElapsedGameTime takes nothing returns real
        return TimerGetElapsed(EDWGameTime___t) + EDWGameTime___currentTime
    endfunction
	
 function EDWGameTime___CB takes nothing returns nothing
  local real remainingTime
		set EDWGameTime___currentTime=EDWGameTime___currentTime + EDWGameTime___TIMEOUT
		
		//check if theres a time related victory condition
		if VictoryTime != 0 then
			set remainingTime=( VictoryTime - EDWGameTime___currentTime ) / 60
			if remainingTime == 0 then
				//end the game
				call s__Teams_MazingTeam_ApplyEndGameAll(s__Teams_MazingTeam_GetLeadingScore())
			elseif remainingTime >= 10 and remainingTime <= 30 then
				if ModuloInteger(R2I(EDWGameTime___currentTime), 600) == 0 then
					//post elapsed time every 10 minutes
					call s__Teams_MazingTeam_PrintMessageAll((ColorMessage((I2S(R2I(remainingTime))) , SPEAKER_COLOR)) + " minutes remaining" , 0) // INLINED!!
				endif
			elseif remainingTime == 5 then
				//5min warning
				call s__Teams_MazingTeam_PrintMessageAll((ColorMessage((I2S(R2I(remainingTime))) , SPEAKER_COLOR)) + " minutes remaining" , 0) // INLINED!!
			elseif remainingTime <= 3 then
				//post warnings every minute
				if remainingTime != 1 then
					call s__Teams_MazingTeam_PrintMessageAll("Only " + (ColorMessage((I2S(R2I(remainingTime))) , SPEAKER_COLOR)) + " minutes remaining!" , 0) // INLINED!!
				else
					call s__Teams_MazingTeam_PrintMessageAll("Only " + (ColorMessage((I2S(R2I(remainingTime))) , SPEAKER_COLOR)) + " minute remaining!" , 0) // INLINED!!
				endif
			endif
		endif
	endfunction
	
 function ToggleGameTime takes boolean flag returns nothing
		if EDWGameTime___t != null then
			if flag then
				call ResumeTimer(EDWGameTime___t)
			else
				call PauseTimer(EDWGameTime___t)
			endif
		endif
	endfunction
    
    function TrackGameTime takes nothing returns nothing
		if EDWGameTime___t == null then
			set EDWGameTime___t=CreateTimer()
			call TimerStart(EDWGameTime___t, EDWGameTime___TIMEOUT, true, function EDWGameTime___CB)
			
			if VictoryTime != 0 then
				call s__Teams_MazingTeam_PrintMessageAll((ColorMessage((I2S(R2I(VictoryTime / 60))) , SPEAKER_COLOR)) + " minutes remaining" , 0) // INLINED!!
			endif
		endif
    endfunction
	
 function IsGameTimeTracked takes nothing returns boolean
		return EDWGameTime___t != null
	endfunction

//library EDWGameTime ends
//library EDWPlayerSlots:
 function EDWPlayerSlotsInit takes nothing returns nothing
  local integer i= 0
		// local trigger playerLeaves = CreateTrigger()
		// local trigger visualVoteSelected = CreateTrigger()
        
		//TODO remove -- functionality deprecated / replaced by User
		//initialize player utility collection
		call PlayerUtils_Init()
		
		//initialize visual vote selection events
		call VisualVote_Init()
		
		//initialize teams
		call Teams_Init()
		
        //loop which adds playing mazing units to a group and removes the units which are not playing from the game
        loop
        exitwhen i >= NumberPlayers
            if GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING then
				set s__User_IsPlaying[(i)]=true
				set s__User_ActivePlayers=s__User_ActivePlayers + 1
				
				set s__User_ActiveUnit[(i)]=s__MazersArray[i]
				
				set s__PlayerReviveCircles[i]= CreateUnit(Player(i), TEAM_REVIVE_UNIT_ID, MazerGlobals_REVIVE_CIRCLE_SAFE_X, MazerGlobals_REVIVE_CIRCLE_SAFE_Y, 0)
                call AddUnitLocust(s__PlayerReviveCircles[i])
				call s__IndexedUnit_create(s__PlayerReviveCircles[i])
				call ShowUnit(s__PlayerReviveCircles[i], false)
                
                //(integer camOwner, unit camUnit, boolean altDir, boolean rotASAP, boolean PauseResets, real minSpd, real maxSpd, integer minTck, integer maxTck)
                set s__DefaultCamera[i]= CreateCameraSetup()
                
                call CameraSetupSetField(s__DefaultCamera[i], CAMERA_FIELD_TARGET_DISTANCE, 1800, 0)
                call CameraSetupSetField(s__DefaultCamera[i], CAMERA_FIELD_FARZ, 5000, 0)
                call CameraSetupSetField(s__DefaultCamera[i], CAMERA_FIELD_ANGLE_OF_ATTACK, 304, 0)
                call CameraSetupSetField(s__DefaultCamera[i], CAMERA_FIELD_FIELD_OF_VIEW, 70, 0)
                call CameraSetupSetField(s__DefaultCamera[i], CAMERA_FIELD_ROLL, 0, 0)
                call CameraSetupSetField(s__DefaultCamera[i], CAMERA_FIELD_ROTATION, 90, 0)
                
                //assumes all units will start in standard gamemode
                set NumberMazing=NumberMazing + 1
				
				//register click events used for standard mazing
				call s__IsMoving_RegisterMazingClickEvents(i)
				
				//register camera toggle events
				set s__DefaultCameraTracking[i]= false
				call TriggerRegisterPlayerEventEndCinematic(CameraTrackingEvents___EscapeKeyEvent, Player((i))) // INLINED!!
			else
				set s__User_IsPlaying[(i)]=false
				
				call RemoveUnit(s__MazersArray[i])
                set s__MazersArray[i]= null
			endif
		set i=i + 1
		endloop
	endfunction

//library EDWPlayerSlots ends
//library Levels:
    
        //struct does not support recycling
		
        
  function s__Checkpoint_create takes rect gate,rect center returns integer
   local integer new= s__Checkpoint_c + 1
			set s__Checkpoint_c=new
			
			set s__Checkpoint_Gate[new]=gate
			set s__Checkpoint_ReviveCenter[new]=center
			
			//defaults
			set s__Checkpoint_DefaultColor[new]=KEY_NONE
			set s__Checkpoint_DefaultGameMode[new]=Teams_GAMEMODE_STANDARD
			set s__Checkpoint_RequiresSameGameMode[new]=false
			
			return new
  endfunction
		
  function s__Checkpoint_InitGate takes integer this,real angle,real scale returns destructable
			return CreateDestructable('B006', GetRectCenterX(s__Checkpoint_Gate[this]), GetRectCenterY(s__Checkpoint_Gate[this]), angle, scale, 1)
  endfunction
	
	
		
//Implemented from module Alloc:
		
		

			

		
		
  function s__Levels___AnimatedLevelTransferData_allocate takes nothing returns integer
   local integer this= s__Levels___AnimatedLevelTransferData_Alloc___recycler[0]
			


			
			if ( s__Levels___AnimatedLevelTransferData_Alloc___recycler[this] == 0 ) then
				set s__Levels___AnimatedLevelTransferData_Alloc___recycler[0]=this + 1
			else
				set s__Levels___AnimatedLevelTransferData_Alloc___recycler[0]=s__Levels___AnimatedLevelTransferData_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__Levels___AnimatedLevelTransferData_deallocate takes integer this returns nothing


			


			
			set s__Levels___AnimatedLevelTransferData_Alloc___recycler[this]=s__Levels___AnimatedLevelTransferData_Alloc___recycler[0]
			set s__Levels___AnimatedLevelTransferData_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__Levels___AnimatedLevelTransferData_Alloc___onInit takes nothing returns nothing
			set s__Levels___AnimatedLevelTransferData_Alloc___recycler[0]=1
  endfunction
    
        
                
        
		
		
		
        
		
		
		
		//private static Event OnLevelChange
		//private static Event OnCheckpointChange
                        
        function s__Levels_Level_Start takes integer this returns nothing
            local integer startableNode
			



			
            if s__Teams_MazingTeam_GetCountOnLevel(this) == 0 then
                call s__SimpleList_List_add(s__Levels_Level_ActiveLevels,this)
                
                if s__Levels_Level_StartFunction[this] != null then
					call ExecuteFunc(s__Levels_Level_StartFunction[this])
				endif
					
				if s__Levels_Level_Startables[this] != 0 then
					//debug call .Startables.print(0)
					set startableNode=s__SimpleList_List_first[s__Levels_Level_Startables[this]]
					
					loop
					exitwhen startableNode == 0
						call sc__IStartable_Start((s__SimpleList_ListNode_value[startableNode]))
					set startableNode=s__SimpleList_ListNode_next[startableNode]
					endloop
				endif
				
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Started level " + I2S(this))
            endif
        endfunction
        
        //stops this level unless someone else is on it
        function s__Levels_Level_Stop takes integer this returns nothing
            local integer countprev= s__Teams_MazingTeam_GetCountOnLevel(this)
            local integer startableNode
			



			
            if countprev == 0 then
                call s__SimpleList_List_remove(s__Levels_Level_ActiveLevels,this)
                
                if s__Levels_Level_StopFunction[this] != null then
					call ExecuteFunc(s__Levels_Level_StopFunction[this])
				endif
				
				if s__Levels_Level_Startables[this] != 0 then
					//debug call .Startables.print(0)
					set startableNode=s__SimpleList_List_first[s__Levels_Level_Startables[this]]
					
					loop
					exitwhen startableNode == 0
						call sc__IStartable_Stop((s__SimpleList_ListNode_value[startableNode]))
					set startableNode=s__SimpleList_ListNode_next[startableNode]
					endloop
				endif
				
				//cleans up unregistered content
				//MUST fire after IStartable.Stop to make sure IStartables are cleaned up correctly
                call sc__Levels_Level_RemoveGreenFromLevel(this)
                
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Stopped level " + I2S(this))
            endif
        endfunction
		
		//placeholder, TODO implement based on random integers already gotten for the level *and* the level's intended difficulty
  function s__Levels_Level_GetWeightedRandomInt takes integer this,integer lowBound,integer highBound returns integer
			return GetRandomInt(lowBound, highBound)
  endfunction
  function s__Levels_Level_GetWeightedRandomReal takes integer this,real lowBound,real highBound returns real
			return GetRandomReal(lowBound, highBound)
  endfunction
        
        function s__Levels_Level_GetWorldID takes integer this returns integer
            //World levels follow this format
			if this >= 3 then //last level ID
                return ModuloInteger(this - 3, 7) + 1
			else
				return - this
            endif
        endfunction
  function s__Levels_Level_GetWorldColor takes integer this returns string
   local integer onWorld= s__Levels_Level_GetWorldID(this)
            
            if onWorld == - 1 then
                return INTRO_TEXT_COLOR
			elseif onWorld == - 2 then
				return DOORS_TEXT_COLOR
            elseif onWorld == 1 then
                return HARD_ICE_WORLD_COLOR
            elseif onWorld == 2 then
                return EASY_ICE_WORLD_COLOR
            elseif onWorld == 3 then
                return LAND_WORLD_COLOR
            elseif onWorld == 4 then
                return ""
            elseif onWorld == 5 then
                return ""
            elseif onWorld == 6 then
                return FOUR_SEASONS_WORLD_COLOR
            else //if onWorld == 7
                return PLATFORMING_WORLD_COLOR
            endif
  endfunction
        function s__Levels_Level_GetWorldString takes integer this returns string
            local integer onWorld= s__Levels_Level_GetWorldID(this)
   local string worldName= ""
            
            if onWorld == - 1 then
                set worldName="???"
			elseif onWorld == - 2 then
				set worldName="Doors"
            elseif onWorld == 1 then
                set worldName="Black Ice"
            elseif onWorld == 2 then
                set worldName="Icetown"
            elseif onWorld == 3 then
                set worldName="Landlubber"
            elseif onWorld == 4 then
                set worldName="Greed"
            elseif onWorld == 5 then
                set worldName="Sloth"
            elseif onWorld == 6 then
                set worldName="Four Seasons"
            else //if onWorld == 7
                set worldName="2.5 Dimensions"
            endif
			
			return ColorMessage(worldName , s__Levels_Level_GetWorldColor(this))
        endfunction
		
        function s__Levels_Level_ToString takes integer this returns string
            local string name
            
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Level ID: " + I2S(this))
            
            if this == INTRO_LEVEL_ID then
                return "Entrance"
            elseif this == DOORS_LEVEL_ID then
                return "Doors"
            else
                set name=s__Levels_Level_GetWorldString(this)

                return name + " " + I2S(R2I(( this - 3 ) / 7) + 1)
            endif
        endfunction
                        
        function s__Levels_Level_RemoveGreenFromLevel takes integer this returns nothing
            local unit u
   local integer i= 0
            local rect r
			
			loop
			exitwhen i >= s__RectList__get_size(s__Levels_Level_Boundaries[this])
			set r=s__RectList__getindex(s__Levels_Level_Boundaries[this],i)
				//call BJDebugMsg("Removing green from boundary ID: " + I2S(i))
				
				call GroupEnumUnitsInRect(TempGroup, r, null)
				
				loop
				set u=FirstOfGroup(TempGroup)
				exitwhen u == null
					if GetPlayerId(GetOwningPlayer(u)) == 10 then
						//reset unit to default stats based on what can currently change... at some point find a better way to unload modified units (and only them)
						call SetUnitVertexColor(u, 255, 255, 255, 255)
						call SetUnitMoveSpeed(u, GetUnitDefaultMoveSpeed(u))
						call Recycle_ReleaseUnit(u)
					endif
				call GroupRemoveUnit(TempGroup, u)
				endloop
			set i=i + 1
            endloop
			
			set r=null
        endfunction
		
        function s__Levels_Level_SetCheckpointForTeam takes integer this,integer mt,integer cpID returns nothing
            local integer cp= (s__SimpleList_ListNode_value[s__SimpleList_List_get(s__Levels_Level_Checkpoints[this],cpID)])
			
			//call DisplayTextToForce(bj_FORCE_PLAYER[0], "Started setting CP for team " + I2S(mt) + ", index " + I2S(cpID) + ", cp " + I2S(cp))
			
			if cp != 0 then
				set EventCheckpoint=cp
				set EventCurrentLevel=this
				set s__Levels_Level_CBTeam=mt
				
				set s__Teams_MazingTeam_OnCheckpoint[mt]=cpID
                
                set s__Teams_MazingTeam_DefaultGameMode[mt]=s__Checkpoint_DefaultGameMode[cp]
                
                call s__Teams_MazingTeam_MoveRevive(mt,s__Checkpoint_ReviveCenter[cp])
                call s__Teams_MazingTeam_RespawnTeamAtRect(mt,s__Checkpoint_ReviveCenter[cp] , true)
                call s__Teams_MazingTeam_ApplyKeyToTeam(mt,s__Checkpoint_DefaultColor[cp])
				call s__Teams_MazingTeam_ResetHealthForTeam(mt)
                
                call s__Teams_MazingTeam_UpdateMultiboard(mt)
				
				if s__Levels_Level_OnCheckpointChange[this] != 0 then
					//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Firing checkpoint event for: " + I2S(this.OnCheckpointChange))
					call s__Event_fire(s__Levels_Level_OnCheckpointChange[this])
				endif
				//call DisplayTextToForce(bj_FORCE_PLAYER[0], "Finished setting CP for team " + I2S(mt))				
            endif
            
            //TODO add team wide CP effect instead of CP effect on first user in team
            //call CPEffect(mt.FirstUser.value)
        endfunction
		
  function s__Levels_Level_OnCheckpointChangeFX_Respawn takes nothing returns nothing
   local timer t= GetExpiredTimer()
   local integer mt= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
			
			call s__Levels_Level_SetCheckpointForTeam(s__Teams_MazingTeam_OnLevel[mt],mt , s__Teams_MazingTeam_OnCheckpoint[mt])
			
			call ReleaseTimer(t)
			set t=null
  endfunction
  function s__Levels_Level_OnCheckpointChangeFX_Pan takes nothing returns nothing
   local timer t= GetExpiredTimer()
   local integer mt= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
			
			call s__Teams_MazingTeam_PanCameraForTeam(mt,GetUnitX(s__User_ActiveUnit[s__Teams_MazingTeam_LastEventUser[mt]]) , GetUnitY(s__User_ActiveUnit[s__Teams_MazingTeam_LastEventUser[mt]]) , 1.0)
			
			call TimerStart(t, 1.0 + 0.5, false, function s__Levels_Level_OnCheckpointChangeFX_Respawn)
  endfunction
  function s__Levels_Level_OnCheckpointChangeFX_Hide takes nothing returns nothing
   local timer t= GetExpiredTimer()
   local integer mt= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
   local integer u= s__Teams_MazingTeam_FirstUser[mt]
			
			loop
			exitwhen u == 0
				if s__SimpleList_ListNode_value[u] != s__Teams_MazingTeam_LastEventUser[mt] then
					call s__User_SwitchGameModes((s__SimpleList_ListNode_value[u]),Teams_GAMEMODE_HIDDEN , GetUnitX(s__User_ActiveUnit[s__Teams_MazingTeam_LastEventUser[mt]]) , GetUnitY(s__User_ActiveUnit[s__Teams_MazingTeam_LastEventUser[mt]]))
				endif
			set u=s__SimpleList_ListNode_next[u]
			endloop
			
			call TimerStart(t, .5, false, function s__Levels_Level_OnCheckpointChangeFX_Pan)
  endfunction
  function s__Levels_Level_OnCheckpointChangeFX_HideAndPan takes nothing returns nothing
   local timer t= GetExpiredTimer()
   local integer mt= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
   local integer u= s__Teams_MazingTeam_FirstUser[mt]
			
			loop
			exitwhen u == 0
				if s__SimpleList_ListNode_value[u] != s__Teams_MazingTeam_LastEventUser[mt] then
					call s__User_SwitchGameModes((s__SimpleList_ListNode_value[u]),Teams_GAMEMODE_HIDDEN , GetUnitX(s__User_ActiveUnit[s__Teams_MazingTeam_LastEventUser[mt]]) , GetUnitY(s__User_ActiveUnit[s__Teams_MazingTeam_LastEventUser[mt]]))
				endif
			set u=s__SimpleList_ListNode_next[u]
			endloop
			
			call s__Teams_MazingTeam_PanCameraForTeam(mt,GetUnitX(s__User_ActiveUnit[s__Teams_MazingTeam_LastEventUser[mt]]) , GetUnitY(s__User_ActiveUnit[s__Teams_MazingTeam_LastEventUser[mt]]) , 1.0)
			
			call TimerStart(t, 1.0 + 0.75, false, function s__Levels_Level_OnCheckpointChangeFX_Respawn)
  endfunction
  function s__Levels_Level_OnCheckpointChangeFX_DisappearingVFX takes nothing returns nothing
   local timer t= GetExpiredTimer()
   local integer mt= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
   local integer u= s__Teams_MazingTeam_FirstUser[mt]
   local effect fx
			
			// call mt.CreateInstantEffectForTeam("Abilities\\Spells\\Items\\AIso\\AIsoTarget.mdl", mt.LastEventUser)
			// call mt.CreateInstantEffectForTeam("Abilities\\Spells\\Items\\TomeOfRetraining\\TomeOfRetrainingCaster.mdl", mt.LastEventUser)
			
			loop
			exitwhen u == 0
				if s__SimpleList_ListNode_value[u] != s__Teams_MazingTeam_LastEventUser[mt] and s__User_ActiveUnit[(s__SimpleList_ListNode_value[u])] != null then
					set fx=CreateSpecialEffect("Abilities\\Spells\\Items\\AIso\\AIsoTarget.mdl" , GetUnitX(s__User_ActiveUnit[(s__SimpleList_ListNode_value[u])]) , GetUnitY(s__User_ActiveUnit[(s__SimpleList_ListNode_value[u])]) , null)
					call BlzSetSpecialEffectScale(fx, 1.5)
					call BlzSetSpecialEffectTime(fx, 1.)
					call BlzSetSpecialEffectTimeScale(fx, 1.75)
					call DestroyEffect(fx)
					// call CreateInstantSpecialEffect("Abilities\\Spells\\Items\\AIso\\AIsoTarget.mdl", GetUnitX(User(u.value).ActiveUnit), GetUnitY(User(u.value).ActiveUnit), null)
				endif
			set u=s__SimpleList_ListNode_next[u]
			endloop
			
			call TimerStart(t, 1.15, false, function s__Levels_Level_OnCheckpointChangeFX_HideAndPan)
  endfunction
  function s__Levels_Level_AnimatedSetCheckpointForTeam takes integer this,integer mt,integer cpID returns nothing
   local integer cp= (s__SimpleList_ListNode_value[s__SimpleList_List_get(s__Levels_Level_Checkpoints[this],cpID)])
			
			//call DisplayTextToForce(bj_FORCE_PLAYER[0], "Started setting CP for team " + I2S(mt) + ", index " + I2S(cpID) + ", cp " + I2S(cp))
			if s__SimpleList_List_count[s__Teams_MazingTeam_Users[mt]] > 1 then
				if cp != 0 then
					call s__Teams_MazingTeam_PauseTeam(mt,true)
					if s__Teams_MazingTeam_LastEventUser[mt] != - 1 then
						call s__Teams_MazingTeam_PrintMessage(mt,s__User_GetStylizedPlayerName(s__Teams_MazingTeam_LastEventUser[mt]) + " has reached a checkpoint!")
					endif
					
					//just for safety
					set s__Teams_MazingTeam_OnCheckpoint[mt]=cpID
					set s__Teams_MazingTeam_DefaultGameMode[mt]=s__Checkpoint_DefaultGameMode[cp]
					call s__Teams_MazingTeam_MoveRevive(mt,s__Checkpoint_ReviveCenter[cp])
									
					call TimerStart(NewTimerEx(mt), .25, false, function s__Levels_Level_OnCheckpointChangeFX_DisappearingVFX)
				endif
			else
				call s__Levels_Level_SetCheckpointForTeam(this,mt , cpID)
			endif
  endfunction
                        
        function s__Levels_Level_AddCheckpoint takes integer this,rect gate,rect center returns integer
            local integer cp= s__Checkpoint_create(gate , center)
			call s__SimpleList_List_addEnd(s__Levels_Level_Checkpoints[this],cp)
			
			return cp
        endfunction
  function s__Levels_Level_InsertCheckpoint takes integer this,rect gate,rect center,integer position returns integer
   local integer cp= s__Checkpoint_create(gate , center)
			
			if position < s__SimpleList_List_count[s__Levels_Level_Checkpoints[this]] then
				call s__SimpleList_List_insert(s__Levels_Level_Checkpoints[this],cp , position)
			else
				call s__SimpleList_List_addEnd(s__Levels_Level_Checkpoints[this],cp)
			endif
			
			return cp
  endfunction
        
  function s__Levels_Level_GetWeightedScore takes integer this returns integer
   local integer score
					
			if RewardMode == GameModesGlobals_EASY or RewardMode == GameModesGlobals_CHEAT then
				set score=R2I(s__Levels_Level_RawScore[this] * Levels_EASY_SCORE_MODIFIER + .5)
			elseif RewardMode == GameModesGlobals_HARD then
				set score=R2I(s__Levels_Level_RawScore[this] * Levels_HARD_SCORE_MODIFIER + .5)
			else
				set score=s__Levels_Level_RawScore[this]
			endif
			
			return score
  endfunction
  function s__Levels_Level_ApplyLevelRewards takes integer this,integer u,integer mt,integer nextLevel returns nothing
   local integer score= s__Levels_Level_GetWeightedScore(this)
   local integer originalContinues= (s__Teams_MazingTeam_ContinueCount[(mt)]) // INLINED!!
   local integer rolloverContinues= 0
   local integer nextLevelContinues= 0
			
			//update score
			call s__Teams_MazingTeam_ChangeScore(mt,score)
			
			//update continues
			if (CONFIGURATION_PROFILE == RELEASE or FORCE_SETTING_MENU) and RewardMode != GameModesGlobals_CHEAT then // INLINED!!
				if RewardMode == GameModesGlobals_EASY then
					if (s__Teams_MazingTeam_ContinueCount[(mt)]) > Levels_EASY_MAX_CONTINUE_ROLLOVER then // INLINED!!
						set rolloverContinues=Levels_EASY_MAX_CONTINUE_ROLLOVER
					else
						set rolloverContinues=(s__Teams_MazingTeam_ContinueCount[(mt)]) // INLINED!!
					endif
					
					set nextLevelContinues=R2I(s__Levels_Level_RawContinues[nextLevel] * Levels_EASY_CONTINUE_MODIFIER + .5)
				elseif RewardMode == GameModesGlobals_HARD then
					if (s__Teams_MazingTeam_ContinueCount[(mt)]) > Levels_HARD_MAX_CONTINUE_ROLLOVER then // INLINED!!
						set rolloverContinues=Levels_HARD_MAX_CONTINUE_ROLLOVER
					else
						set rolloverContinues=(s__Teams_MazingTeam_ContinueCount[(mt)]) // INLINED!!
					endif
					
					set nextLevelContinues=R2I(s__Levels_Level_RawContinues[nextLevel] * Levels_HARD_CONTINUE_MODIFIER + .5)
				endif
				
				if this == DOORS_LEVEL_ID then
					set rolloverContinues=0
				endif
				
				if originalContinues != rolloverContinues + nextLevelContinues then
					call s__Teams_MazingTeam_SetContinueCount(mt,rolloverContinues + nextLevelContinues)
				endif
			endif
			
			// if this == DOORS_LEVEL_ID then
				// //call mt.PrintMessage("Starting level " + ColorMessage(nextLevel.Name, SPEAKER_COLOR) + "!")
				// // if not ShouldShowSettingVoteMenu() or RewardMode == GameModesGlobals_CHEAT then
					// // call mt.PrintMessage("Starting " + nextLevel.GetWorldString())
				// // else
					// // call mt.PrintMessage("Starting " + nextLevel.GetWorldString() + " with " + ColorMessage(I2S(mt.GetContinueCount()), SPEAKER_COLOR) + " continues")
				// // endif
			// else
				// if ShouldShowSettingVoteMenu() and RewardMode != GameModesGlobals_CHEAT then
					// if originalContinues == 1 and rolloverContinues == 1 then
						// call mt.PrintMessage("You kept your " + ColorMessage(I2S(1), SPEAKER_COLOR) + " continue, and gained " + ColorMessage(I2S(nextLevelContinues), SPEAKER_COLOR) + " extra continues to boot")
					// elseif originalContinues > 0 and originalContinues != rolloverContinues + nextLevelContinues then
						// call mt.PrintMessage("You kept " + ColorMessage(I2S(rolloverContinues), SPEAKER_COLOR) + " of your " + ColorMessage(I2S(originalContinues), SPEAKER_COLOR) + " continues, and gained " + ColorMessage(I2S(nextLevelContinues), SPEAKER_COLOR) + " extra continues to boot")
					// else
						// call mt.PrintMessage("You have " + ColorMessage(I2S(rolloverContinues + nextLevelContinues), SPEAKER_COLOR) + " continues")
					// endif
				// endif
			// endif
  endfunction
		
  function s__Levels_Level_StopLevelForTeam takes integer this,integer mt returns nothing
			set EventPreviousLevel=this
			set s__Levels_Level_CBTeam=mt
			
			call s__Teams_MazingTeam_ClearAllCinematicsForTeam(mt)
            call s__SimpleList_List_remove(s__Levels_Level_ActiveTeams[this],mt)
			
			set s__Teams_MazingTeam_OnLevel[mt]=TEMP_LEVEL_ID
            call s__Levels_Level_Stop(this) //only stops the level if no ones on it
			if s__Levels_Level_OnLevelStop[this] != 0 then
				call s__Event_fire(s__Levels_Level_OnLevelStop[this])
			endif
  endfunction
  function s__Levels_Level_StartLevelForTeam takes integer this,integer mt returns nothing
   local integer i= 0
            local rect r
			
			set EventCurrentLevel=this
            set s__Levels_Level_CBTeam=mt
			
			call s__Levels_Level_Start(this) //only starts the next level if there is one
			if s__Levels_Level_OnLevelStart[this] != 0 then
				call s__Event_fire(s__Levels_Level_OnLevelStart[this])
			endif
			
            set s__Teams_MazingTeam_OnLevel[mt]=this
            call s__SimpleList_List_add(s__Levels_Level_ActiveTeams[this],mt)
            
			loop
			exitwhen i >= s__RectList__get_size(s__Levels_Level_Boundaries[this])
			set r=s__RectList__getindex(s__Levels_Level_Boundaries[this],i)
				call s__Teams_MazingTeam_AddTeamVision(mt,r)
			set i=i + 1
			endloop
			set r=null
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Started")
            //team tele, respawn update, vision, pause + unpause
            call s__Levels_Level_SetCheckpointForTeam(this,mt , 0)
  endfunction
		
        //update level continuously or discontinuously from one to the next. IE lvl 1 -> 2 -> 3 -> 4 OR 1 -> 4 -> 2 etc
        function s__Levels_Level_SwitchLevels takes integer this,integer mt,integer nextLevel,integer activatingUser,boolean updateProgress returns nothing



			
			if updateProgress then



				
				//add continues and score
				call s__Levels_Level_ApplyLevelRewards(this,activatingUser , mt , nextLevel)

				call s__Teams_MazingTeam_UpdateWorldProgress(mt,this)
			endif
			
			//stop current level before starting next level. some of the current level may be able to immediately recycle, and itll be easier on the CPU
			call s__Levels_Level_StopLevelForTeam(this,mt)
			
			call s__Levels_Level_StartLevelForTeam(nextLevel,mt)
        endfunction
		
		// private static method SwitchLevels_FadeIn takes nothing returns nothing
			// local timer t = GetExpiredTimer()
			// local AnimatedLevelTransferData transferData = GetTimerData(t)
			
			// // call transferData.Team.PrintMessage(transferData.NextLevel.Name)
			// call transferData.Team.FadeInForTeam(LEVEL_TRANSFER_FADE_DURATION)
			
			// call transferData.deallocate()
			// call ReleaseTimer(t)
			// set t = null
		// endmethod
  function s__Levels_Level_SwitchLevels_Message3 takes nothing returns nothing
   local timer t= GetExpiredTimer()
   local integer transferData= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
						
			call s__Teams_MazingTeam_PrintMessage(s__Levels___AnimatedLevelTransferData_Team[transferData],"Now starting: " + s__Levels_Level_Name[s__Levels___AnimatedLevelTransferData_NextLevel[transferData]])
			call s__Teams_MazingTeam_FadeInForTeam(s__Levels___AnimatedLevelTransferData_Team[transferData],Levels___LEVEL_TRANSFER_FADE_DURATION)
			
			if s__Teams_MazingTeam_DefaultGameMode[s__Levels___AnimatedLevelTransferData_Team[transferData]] == Teams_GAMEMODE_PLATFORMING then
				call s__Teams_MazingTeam_PauseTeam(s__Levels___AnimatedLevelTransferData_Team[transferData],false)
			else
				call s__Teams_MazingTeam_RegisterAutoUnpauseForTeam(s__Levels___AnimatedLevelTransferData_Team[transferData],Levels___LEVEL_TRANSFER_FADE_DURATION + Levels___LEVEL_TRANSFER_UNPAUSE_DELAY)
			endif
			
			call s__Levels___AnimatedLevelTransferData_deallocate(transferData)
			call ReleaseTimer(t)
			set t=null
			// call TimerStart(t, LEVEL_TRANSFER_MESSAGE_DELAY, false, function thistype.SwitchLevels_FadeIn)
  endfunction
  function s__Levels_Level_SwitchLevels_Message2 takes nothing returns nothing
   local timer t= GetExpiredTimer()
   local integer transferData= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
			
			call s__Teams_MazingTeam_PrintMessage(s__Levels___AnimatedLevelTransferData_Team[transferData],"You have " + (ColorMessage((I2S((s__Teams_MazingTeam_ContinueCount[(s__Levels___AnimatedLevelTransferData_Team[transferData])]))) , SPEAKER_COLOR)) + " continues left") // INLINED!!
			
			call TimerStart(t, Levels___LEVEL_TRANSFER_MESSAGE_DELAY, false, function s__Levels_Level_SwitchLevels_Message3)
  endfunction
  function s__Levels_Level_SwitchLevels_Message1 takes nothing returns nothing
   local timer t= GetExpiredTimer()
   local integer transferData= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
			
			if s__Levels_Level_GetWeightedScore(s__Teams_MazingTeam_OnLevel[s__Levels___AnimatedLevelTransferData_Team[transferData]]) > 0 then
				if (s__Teams_MazingTeam_Score[(s__Levels___AnimatedLevelTransferData_Team[transferData])]) > 0 then // INLINED!!
					call s__Teams_MazingTeam_PrintMessage(s__Levels___AnimatedLevelTransferData_Team[transferData],"You gained " + (ColorMessage((I2S(s__Levels_Level_GetWeightedScore(s__Teams_MazingTeam_OnLevel[s__Levels___AnimatedLevelTransferData_Team[transferData]]))) , SPEAKER_COLOR)) + " points (" + (ColorMessage((I2S((s__Teams_MazingTeam_Score[(s__Levels___AnimatedLevelTransferData_Team[transferData])]) + s__Levels_Level_GetWeightedScore(s__Teams_MazingTeam_OnLevel[s__Levels___AnimatedLevelTransferData_Team[transferData]]))) , SPEAKER_COLOR)) + " total)") // INLINED!!
				else
					call s__Teams_MazingTeam_PrintMessage(s__Levels___AnimatedLevelTransferData_Team[transferData],"You gained " + (ColorMessage((I2S(s__Levels_Level_GetWeightedScore(s__Teams_MazingTeam_OnLevel[s__Levels___AnimatedLevelTransferData_Team[transferData]]))) , SPEAKER_COLOR)) + " points") // INLINED!!
				endif
			endif
			
			call s__Levels_Level_SwitchLevels(s__Teams_MazingTeam_OnLevel[s__Levels___AnimatedLevelTransferData_Team[transferData]],s__Levels___AnimatedLevelTransferData_Team[transferData] , s__Levels___AnimatedLevelTransferData_NextLevel[transferData] , s__Teams_MazingTeam_LastEventUser[s__Levels___AnimatedLevelTransferData_Team[transferData]] , true)
			call s__Teams_MazingTeam_CancelAutoUnpauseForTeam(s__Levels___AnimatedLevelTransferData_Team[transferData])
			call s__Teams_MazingTeam_PauseTeam(s__Levels___AnimatedLevelTransferData_Team[transferData],true)
			
			if (CONFIGURATION_PROFILE == RELEASE or FORCE_SETTING_MENU) and RewardMode != GameModesGlobals_CHEAT and s__Teams_MazingTeam_OnLevel[s__Levels___AnimatedLevelTransferData_Team[transferData]] != DOORS_LEVEL_ID then // INLINED!!
				call TimerStart(t, Levels___LEVEL_TRANSFER_MESSAGE_DELAY, false, function s__Levels_Level_SwitchLevels_Message2)
			else
				call TimerStart(t, Levels___LEVEL_TRANSFER_MESSAGE_DELAY, false, function s__Levels_Level_SwitchLevels_Message3)
			endif
  endfunction
		// private static method SwitchLevels_Message takes nothing returns nothing
			// local timer t = GetExpiredTimer()
			// local AnimatedLevelTransferData transferData = GetTimerData(t)
			
			// if transferData.Team.GetScore() > 0 then
				// call transferData.Team.PrintMessage("You gained " + ColorValue(I2S(transferData.Team.OnLevel.GetWeightedScore())) + " points (" + ColorValue(I2S(transferData.Team.GetScore() + transferData.Team.OnLevel.GetWeightedScore())) + " total)")
			// else
				// call transferData.Team.PrintMessage("You gained " + ColorValue(I2S(transferData.Team.OnLevel.GetWeightedScore())) + " points")
			// endif
			// call transferData.Team.OnLevel.SwitchLevels(transferData.Team, transferData.NextLevel, transferData.Team.LastEventUser, true)
			
			// if ShouldShowSettingVoteMenu() and RewardMode != GameModesGlobals_CHEAT then
				// call transferData.Team.PrintMessage("You have " + ColorValue(I2S(transferData.Team.GetContinueCount())) + " continues left")
			// endif
			// // call transferData.Team.PrintMessage("Now starting: " + transferData.NextLevel.Name)
			
			// call transferData.Team.PrintMessage("Now starting:")
			
			// call TimerStart(t, 1., false, function thistype.SwitchLevels_FadeIn)
		// endmethod
  function s__Levels_Level_SwitchLevels_GameMode takes nothing returns nothing
   local timer t= GetExpiredTimer()
   local integer transferData= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
						
			call s__Teams_MazingTeam_SwitchTeamGameMode(s__Levels___AnimatedLevelTransferData_Team[transferData],Teams_GAMEMODE_HIDDEN , GetUnitX(s__User_ActiveUnit[s__Teams_MazingTeam_LastEventUser[s__Levels___AnimatedLevelTransferData_Team[transferData]]]) , GetUnitY(s__User_ActiveUnit[s__Teams_MazingTeam_LastEventUser[s__Levels___AnimatedLevelTransferData_Team[transferData]]]))
			
			if s__Teams_MazingTeam_OnLevel[s__Levels___AnimatedLevelTransferData_Team[transferData]] != DOORS_LEVEL_ID then
				call TimerStart(t, Levels___LEVEL_TRANSFER_FADE_DURATION, false, function s__Levels_Level_SwitchLevels_Message1)
			else
				// call TimerStart(t, 0., false, function thistype.SwitchLevels_Message1)
				call s__Levels_Level_SwitchLevels_Message1()
			endif
  endfunction
  function s__Levels_Level_SwitchLevels_FadeOut takes nothing returns nothing
   local timer t= GetExpiredTimer()
   local integer transferData= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
			
			call s__Teams_MazingTeam_ClearAllCinematicsForTeam(s__Levels___AnimatedLevelTransferData_Team[transferData])
			// call transferData.Team.SwitchTeamGameMode(Teams_GAMEMODE_HIDDEN, GetUnitX(transferData.Team.LastEventUser.ActiveUnit), GetUnitY(transferData.Team.LastEventUser.ActiveUnit))
			call s__Teams_MazingTeam_FadeOutForTeam(s__Levels___AnimatedLevelTransferData_Team[transferData],Levels___LEVEL_TRANSFER_FADE_DURATION)
			
			call TimerStart(t, Levels___LEVEL_TRANSFER_FADE_DURATION, false, function s__Levels_Level_SwitchLevels_GameMode)
  endfunction
		// private static method SwitchLevels_FadeOut takes nothing returns nothing
			// local timer t = GetExpiredTimer()
			// local AnimatedLevelTransferData transferData = GetTimerData(t)
						
			// call transferData.Team.SwitchTeamGameMode(Teams_GAMEMODE_HIDDEN, GetUnitX(transferData.Team.LastEventUser.ActiveUnit), GetUnitY(transferData.Team.LastEventUser.ActiveUnit))
			// call transferData.Team.FadeOutForTeam(LEVEL_TRANSFER_FADE_DURATION)
			
			// if transferData.Team.OnLevel != DOORS_LEVEL_ID then
				// call TimerStart(t, 2. * LEVEL_TRANSFER_FADE_DURATION, false, function thistype.SwitchLevels_Message1)
			// else
				// call TimerStart(t, LEVEL_TRANSFER_FADE_DURATION, false, function thistype.SwitchLevels_Message1)
			// endif
		// endmethod
  function s__Levels_Level_SwitchLevels_DisappearingVFX takes nothing returns nothing
   local timer t= GetExpiredTimer()
   local integer transferData= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
   local integer u= s__Teams_MazingTeam_FirstUser[s__Levels___AnimatedLevelTransferData_Team[transferData]]
   local effect fx
						
			loop
			exitwhen u == 0
				if s__User_ActiveUnit[(s__SimpleList_ListNode_value[u])] != null then
					// set fx = CreateSpecialEffect("Abilities\\Spells\\Items\\AIso\\AIsoTarget.mdl", GetUnitX(User(u.value).ActiveUnit), GetUnitY(User(u.value).ActiveUnit), null)
					// call BlzSetSpecialEffectScale(fx, 1.5)
					// call BlzSetSpecialEffectTime(fx, 1.)
					// call BlzSetSpecialEffectTimeScale(fx, 1.75)
					// call DestroyEffect(fx)
					call CreateInstantSpecialEffect("Abilities\\Spells\\Human\\Resurrect\\ResurrectCaster.mdl" , GetUnitX(s__User_ActiveUnit[(s__SimpleList_ListNode_value[u])]) , GetUnitY(s__User_ActiveUnit[(s__SimpleList_ListNode_value[u])]) , null)
				endif
			set u=s__SimpleList_ListNode_next[u]
			endloop
			
			call TimerStart(t, 1.15, false, function s__Levels_Level_SwitchLevels_FadeOut)
  endfunction
  function s__Levels_Level_SwitchLevelsAnimated takes integer this,integer mt,integer nextLevel,boolean updateProgress returns nothing
   local integer transferData= s__Levels___AnimatedLevelTransferData_allocate()
			set s__Levels___AnimatedLevelTransferData_Team[transferData]=mt
			set s__Levels___AnimatedLevelTransferData_NextLevel[transferData]=nextLevel
			set s__Levels___AnimatedLevelTransferData_UpdateProgress[transferData]=updateProgress
			
			call s__Teams_MazingTeam_PauseTeam(mt,true)
			if this != DOORS_LEVEL_ID then
				if s__Teams_MazingTeam_LastEventUser[mt] != - 1 then
					call s__Teams_MazingTeam_PrintMessage(mt,s__User_GetStylizedPlayerName(s__Teams_MazingTeam_LastEventUser[mt]) + " has cleared the level!")
				endif
			else
				//TODO remove when there's a less intrusive and more relevant way to convey what team is where via the Doors level
				call s__Teams_MazingTeam_PrintMessageAll(s__Teams_MazingTeam_TeamName[mt] + " team has just started " + s__Levels_Level_GetWorldString(nextLevel) , mt)
				call s__Teams_MazingTeam_PrintMessage(mt,"Entering new world: " + s__Levels_Level_GetWorldString(nextLevel))
			endif
			
			call TimerStart(NewTimerEx(transferData), .5, false, function s__Levels_Level_SwitchLevels_DisappearingVFX)
  endfunction
        		
  function s__Levels_Level_CheckTransfers takes nothing returns nothing
            local integer curLevel= s__SimpleList_List_first[s__Levels_Level_ActiveLevels]
            local integer curTeam
            local integer curUser
			
   local integer curCheckpoint
            
   local integer i
   local real x
   local real y
			
            local integer nextLevel
   local integer nextCheckpointID
			
   local integer worldProgress
			
            loop
            exitwhen curLevel == 0
				set curTeam=s__SimpleList_List_first[s__Levels_Level_ActiveTeams[(s__SimpleList_ListNode_value[curLevel])]]
				
				loop
				exitwhen curTeam == 0
					//call DisplayTextToForce(bj_FORCE_PLAYER[0], "Checking team " + I2S(curTeam.value))
					set nextLevel=0
					set nextCheckpointID=- 1
					set curUser=s__SimpleList_List_first[s__Teams_MazingTeam_Users[(s__SimpleList_ListNode_value[curTeam])]]
											
					loop
					exitwhen curUser == 0 or nextLevel != 0
						//call DisplayTextToForce(bj_FORCE_PLAYER[0], "Checking player " + I2S(curUser.value))
						if s__User_GameMode[(s__SimpleList_ListNode_value[curUser])] == Teams_GAMEMODE_STANDARD or s__User_GameMode[(s__SimpleList_ListNode_value[curUser])] == Teams_GAMEMODE_PLATFORMING then
							set x=GetUnitX(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUser])])
							set y=GetUnitY(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curUser])])
							
							//check level transfer(s)
							if (s__SimpleList_ListNode_value[curLevel]) == DOORS_LEVEL_ID then
								set i=0
								loop
								exitwhen i == WorldCount or nextLevel != 0
									if s__Levels___DoorRects[i] != null and RectContainsCoords(s__Levels___DoorRects[i], x, y) then
										set nextLevel=(i + DOORS_LEVEL_ID + 1) //levels take standard structure after the DOORS level
										
										//check if the team has already made progress into that world
										set worldProgress=s__Teams_MazingTeam_GetWorldProgress((s__SimpleList_ListNode_value[curTeam]),s__Levels_Level_GetWorldID(nextLevel))
										//call DisplayTextToForce(bj_FORCE_PLAYER[0], "World ID " + I2S(nextLevel.GetWorldID()))
										//call DisplayTextToForce(bj_FORCE_PLAYER[0], "World Progress " + I2S(worldProgress))
										if worldProgress != 0 then
											if s__Levels_Level_NextLevel[s__WorldProgress_FurthestLevel[worldProgress]] == 0 then
												//team has already beaten this world!
												call DisplayTextToForce(bj_FORCE_PLAYER[0], "You've already beaten that world!")
												set nextLevel=0
												call s__User_RespawnAtRect((s__SimpleList_ListNode_value[curUser]),s__Teams_MazingTeam_Revive[(s__SimpleList_ListNode_value[curTeam])] , true)
											else
												set s__Teams_MazingTeam_LastEventUser[(s__SimpleList_ListNode_value[curTeam])]=s__SimpleList_ListNode_value[curUser]
												
												set nextLevel=s__Levels_Level_NextLevel[s__WorldProgress_FurthestLevel[worldProgress]]
											endif
										endif
									endif
								set i=i + 1
								endloop
							else
								if s__Levels_Level_LevelEnd[(s__SimpleList_ListNode_value[curLevel])] != null and RectContainsCoords(s__Levels_Level_LevelEnd[(s__SimpleList_ListNode_value[curLevel])], x, y) then
									set s__Teams_MazingTeam_LastEventUser[(s__SimpleList_ListNode_value[curTeam])]=s__SimpleList_ListNode_value[curUser]
									
									//check if there's a sequential level after the current one
									if s__Levels_Level_NextLevel[(s__SimpleList_ListNode_value[curLevel])] != 0 then
										set nextLevel=s__Levels_Level_NextLevel[(s__SimpleList_ListNode_value[curLevel])]
									else
										//finished all available levels in world, returning to Doors
										set nextLevel=(DOORS_LEVEL_ID)
									endif
								endif
							endif
							
							///check for any checkpoints if nothing has been found yet
							if nextLevel == 0 and nextCheckpointID == - 1 then
								set i=0
								set curCheckpoint=s__SimpleList_List_first[s__Levels_Level_Checkpoints[(s__SimpleList_ListNode_value[curLevel])]]
								loop
								exitwhen curCheckpoint == 0 or nextCheckpointID >= 0
									if i > s__Teams_MazingTeam_OnCheckpoint[(s__SimpleList_ListNode_value[curTeam])] and ( not s__Checkpoint_RequiresSameGameMode[(s__SimpleList_ListNode_value[curCheckpoint])] or s__User_GameMode[(s__SimpleList_ListNode_value[curUser])] == s__Checkpoint_DefaultGameMode[(s__SimpleList_ListNode_value[curCheckpoint])] ) and s__Checkpoint_Gate[(s__SimpleList_ListNode_value[curCheckpoint])] != null and RectContainsCoords(s__Checkpoint_Gate[(s__SimpleList_ListNode_value[curCheckpoint])], x, y) then
										set s__Teams_MazingTeam_LastEventUser[(s__SimpleList_ListNode_value[curTeam])]=s__SimpleList_ListNode_value[curUser]
										
										set nextCheckpointID=i
									endif
								set i=i + 1
								set curCheckpoint=s__SimpleList_ListNode_next[curCheckpoint]
								endloop
							endif
						endif
					set curUser=s__SimpleList_ListNode_next[curUser]
					endloop
					
					//apply either the next level or the next checkpoint or neither to the current team (never apply both)
					if nextLevel != 0 then



						
						call s__Levels_Level_SwitchLevelsAnimated((s__SimpleList_ListNode_value[curLevel]),(s__SimpleList_ListNode_value[curTeam]) , nextLevel , true)
					elseif nextCheckpointID >= 0 then




						
						//call Level(curLevel.value).SetCheckpointForTeam(Teams_MazingTeam(curTeam.value), nextCheckpointID)
						call s__Levels_Level_AnimatedSetCheckpointForTeam((s__SimpleList_ListNode_value[curLevel]),(s__SimpleList_ListNode_value[curTeam]) , nextCheckpointID)
					endif
					
				set curTeam=s__SimpleList_ListNode_next[curTeam]
				endloop
                
            set curLevel=s__SimpleList_ListNode_next[curLevel]
            endloop
        endfunction        
        
  function s__Levels_Level_AddStartable takes integer this,integer startable returns nothing
			if s__IStartable_ParentLevel[startable] != 0 and s__Levels_Level_Startables[s__IStartable_ParentLevel[startable]] != 0 then
				call s__SimpleList_List_remove(s__Levels_Level_Startables[s__IStartable_ParentLevel[startable]],startable)
			endif
			
			set s__IStartable_ParentLevel[startable]=this
			
			if s__Levels_Level_Startables[this] == 0 then
				set s__Levels_Level_Startables[this]=s__SimpleList_List_create()
			endif
			call s__SimpleList_List_addEnd(s__Levels_Level_Startables[this],startable)
  endfunction
        
        function s__Levels_Level_AddCinematic takes integer this,integer cinema returns nothing
            call s__SimpleList_List_addEnd(s__Levels_Level_Cinematics[this],cinema)
            set s__Cinematic_ParentLevel[cinema]=this
        endfunction
        function s__Levels_Level_CheckCinematics takes nothing returns nothing
            local integer curLevel= s__SimpleList_List_first[s__Levels_Level_ActiveLevels]
            local integer curCinematic
            local integer curTeam
            local integer curUser
            
            local integer user
            
            loop
            exitwhen curLevel == 0
                set curCinematic=s__SimpleList_List_first[s__Levels_Level_Cinematics[(s__SimpleList_ListNode_value[curLevel])]]
                
                loop
                exitwhen curCinematic == 0
                    //call DisplayTextToForce(bj_FORCE_PLAYER[0], "Checking cinematic " + I2S(curCinematic.value) + ", total count: " + I2S(thistype(curLevel.value).Cinematics.count))
                    
					set curTeam=s__SimpleList_List_first[s__Levels_Level_ActiveTeams[(s__SimpleList_ListNode_value[curLevel])]]
                    
                    loop
                    exitwhen curTeam == 0
                        //call DisplayTextToForce(bj_FORCE_PLAYER[0], "Checking team " + I2S(curTeam.value))
                        set curUser=s__SimpleList_List_first[s__Teams_MazingTeam_Users[(s__SimpleList_ListNode_value[curTeam])]]
                                                
                        loop
                        exitwhen curUser == 0
                            set user=(s__SimpleList_ListNode_value[curUser])
                            //call DisplayTextToForce(bj_FORCE_PLAYER[0], "Checking player " + I2S(curUser.value))
                            
                            if s__Cinematic_CanUserActivate((s__SimpleList_ListNode_value[curCinematic]),(s__SimpleList_ListNode_value[curUser])) then
                                //call Cinematic(curCinematic.value).Activate(curUser.value)
                                if s__Cinematic_Individual[(s__SimpleList_ListNode_value[curCinematic])] then
                                    //call DisplayTextToForce(bj_FORCE_PLAYER[0], "User " + I2S(user) + " activating cine " + I2S(curCinematic.value) + " for self")
                                    call s__User_AddCinematicToQueue(user,s__SimpleList_ListNode_value[curCinematic])
                                else
                                    //call DisplayTextToForce(bj_FORCE_PLAYER[0], "User " + I2S(user) + " activating cine " + I2S(curCinematic.value) + " for team")
                                    call s__Teams_MazingTeam_AddTeamCinema((s__SimpleList_ListNode_value[curTeam]),s__SimpleList_ListNode_value[curCinematic] , user)
                                endif
                            endif
                        set curUser=s__SimpleList_ListNode_next[curUser]
                        endloop
                        
                    set curTeam=s__SimpleList_ListNode_next[curTeam]
                    endloop
                    
                set curCinematic=s__SimpleList_ListNode_next[curCinematic]
                endloop
                
            set curLevel=s__SimpleList_ListNode_next[curLevel]
            endloop
        endfunction
		
		//creates the level struct / region triggers for the doors area
        function s__Levels_Level_CreateDoors takes integer intro,string startFunction,string stopFunction,rect startspawn,rect vision returns integer
            local integer new= DOORS_LEVEL_ID
            
            set s__Levels_Level_Name[new]="Doors"
            set s__Levels_Level_RawContinues[new]=0
            set s__Levels_Level_RawScore[new]=0

			set s__Levels_Level_StartFunction[new]=startFunction
			set s__Levels_Level_StopFunction[new]=stopFunction
			set s__Levels_Level_Startables[new]=0
			
			set s__Levels_Level_Checkpoints[new]=s__SimpleList_List_create()
            call s__Levels_Level_AddCheckpoint(new,null , startspawn)
            //set new.CPToHere = tothislevel //these might change
            //set new.StartRect = startspawn
            set s__Levels_Level_Boundaries[new]=s__RectList_create()
			call s__RectList_addEnd(s__Levels_Level_Boundaries[new],vision)
                        
            set s__Levels_Level_PrevLevel[new]=intro
            set s__Levels_Level_NextLevel[intro]=new
			
			set s__Levels_Level_Cinematics[new]=s__SimpleList_List_create()
            set s__Levels_Level_ActiveTeams[new]=s__SimpleList_List_create()
			
			set s__Levels___DoorRects[0]= gg_rct_IW_Entrance
			set s__Levels___DoorRects[1]= gg_rct_EIW_Entrance
			set s__Levels___DoorRects[2]= gg_rct_LW_Entrance
			set s__Levels___DoorRects[5]= gg_rct_FS_Entrance
			set s__Levels___DoorRects[6]= gg_rct_PW_Entrance
			
			
			set s__Levels_Level_MaxCollisionSize[new]=Levels___DEFAULT_MAX_COLLISION_SIZE
            //call DisplayTextToForce(bj_FORCE_PLAYER[0], "Created doors")
            
            return new
        endfunction
        
  function s__Levels_Level_AddLevelStartCB takes integer this,conditionfunc cb returns nothing
			if s__Levels_Level_OnLevelStart[this] == 0 then
				set s__Levels_Level_OnLevelStart[this]=s__Event_create()
			endif
			
			call TriggerAddCondition(s__Event_e[(s__Levels_Level_OnLevelStart[this])], (cb)) // INLINED!!
  endfunction
  function s__Levels_Level_AddLevelStopCB takes integer this,conditionfunc cb returns nothing
			if s__Levels_Level_OnLevelStop[this] == 0 then
				set s__Levels_Level_OnLevelStop[this]=s__Event_create()
			endif
			
			call TriggerAddCondition(s__Event_e[(s__Levels_Level_OnLevelStop[this])], (cb)) // INLINED!!
  endfunction
  function s__Levels_Level_AddCheckpointChangeCB takes integer this,conditionfunc cb returns nothing
			if s__Levels_Level_OnCheckpointChange[this] == 0 then
				set s__Levels_Level_OnCheckpointChange[this]=s__Event_create()
			endif
			
			call TriggerAddCondition(s__Event_e[(s__Levels_Level_OnCheckpointChange[this])], (cb)) // INLINED!!
  endfunction
		
		
        //creates a level struct
        function s__Levels_Level_create takes integer LevelID,string name,integer rawContinues,integer rawScore,string startFunction,string stopFunction,rect startspawn,rect vision,rect levelEnd,integer previouslevel returns integer
            local integer new= LevelID
            
            //infer this is a partial level
            //set new.Name = new.ToString()
            set s__Levels_Level_Name[new]=name
            set s__Levels_Level_RawContinues[new]=rawContinues
            set s__Levels_Level_RawScore[new]=rawScore
            //set new.Difficulty = diff
            
            
			set s__Levels_Level_StartFunction[new]=startFunction
			set s__Levels_Level_StopFunction[new]=stopFunction
			set s__Levels_Level_Startables[new]=0
            //set new.CPToHere = tothislevel
            //set new.StartRect = startspawn
			set s__Levels_Level_Boundaries[new]=s__RectList_create()
			call s__RectList_addEnd(s__Levels_Level_Boundaries[new],vision)
                                    
            set s__Levels_Level_Cinematics[new]=s__SimpleList_List_create()
            set s__Levels_Level_ActiveTeams[new]=s__SimpleList_List_create()
            
            if ( previouslevel != 0 ) then
                //don't point backwards to partial levels
                set s__Levels_Level_PrevLevel[new]=previouslevel
                set s__Levels_Level_NextLevel[s__Levels_Level_PrevLevel[new]]=new
            endif
            
			set s__Levels_Level_LevelEnd[new]=levelEnd
            
			set s__Levels_Level_Checkpoints[new]=s__SimpleList_List_create()
            //use the checkpoint schema for the first checkpoint. region enter event is handled separately, so use null for the region
            call s__Levels_Level_AddCheckpoint(new,null , startspawn)
            
			set s__Levels_Level_MaxCollisionSize[new]=Levels___DEFAULT_MAX_COLLISION_SIZE
			set s__Levels_Level_OnLevelStart[new]=0
			set s__Levels_Level_OnLevelStop[new]=0
			set s__Levels_Level_OnCheckpointChange[new]=0
			
            return new
        endfunction
		
  function s__Levels_Level_onInit takes nothing returns nothing
			//set OnLevelChange = Event.create()
			//set OnCheckpointChange = Event.create()
			
			set s__Levels_Level_ActiveLevels=s__SimpleList_List_create()
			
			call TimerStart(CreateTimer(), Levels_TRANSFER_TIMER_TIMEOUT, true, function s__Levels_Level_CheckTransfers)
			call TimerStart(CreateTimer(), Levels_CINEMATIC_TIMER_TIMEOUT, true, function s__Levels_Level_CheckCinematics)
  endfunction

//library Levels ends
//library BossLevel:

//processed: 	function interface BossBehavior takes BossLevel bossLevel returns nothing
	
		
		//use unit object for all possible properties
		
//Implemented from module Alloc:
		
		

			

		
		
  function s__Boss_allocate takes nothing returns integer
   local integer this= s__Boss_Alloc___recycler[0]
			


			
			if ( s__Boss_Alloc___recycler[this] == 0 ) then
				set s__Boss_Alloc___recycler[0]=this + 1
			else
				set s__Boss_Alloc___recycler[0]=s__Boss_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__Boss_deallocate takes integer this returns nothing


			


			
			set s__Boss_Alloc___recycler[this]=s__Boss_Alloc___recycler[0]
			set s__Boss_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__Boss_Alloc___onInit takes nothing returns nothing
			set s__Boss_Alloc___recycler[0]=1
  endfunction
		
  function s__Boss_destroy takes integer this returns nothing
			call RemoveUnit(s__Boss_Unit[this])
			set s__Boss_Unit[this]=null
			
			set s__Boss_Behavior[this]=0
			
			call s__Boss_deallocate(this)
  endfunction
		
		//public SimpleList_List TeamQueue
		
		
		
  function s__BossLevel_ResetTargets takes integer this returns nothing
   local integer curTeam= s__SimpleList_List_first[s__Levels_Level_ActiveTeams[(this)]]
   local integer curUser
			
			loop
			exitwhen curTeam == 0
				if s__Teams_MazingTeam_OnCheckpoint[(s__SimpleList_ListNode_value[curTeam])] == s__BossLevel_OnCheckpoint[this] then
					set curUser=s__Teams_MazingTeam_FirstUser[(s__SimpleList_ListNode_value[curTeam])]
				
					loop
					exitwhen curUser == 0
						call s__SimpleList_List_addEnd(s__BossLevel_CurrentTargets[this],s__SimpleList_ListNode_value[curUser])
					set curUser=s__SimpleList_ListNode_next[curUser]
					endloop
				endif
			set curTeam=s__SimpleList_ListNode_next[curTeam]
			endloop
  endfunction
  function s__BossLevel_ResetBoss takes integer this returns nothing
			
  endfunction
				
		//give a user who just died a temporary reprieve
  function s__BossLevel_OnPlayerDeath takes integer this returns nothing
			//.remove only does anything to the first match
			//if .CurrentTargets.contains(TriggerUser) then
				call s__SimpleList_List_remove(s__BossLevel_CurrentTargets[this],TriggerUser)
			//endif
  endfunction
  function s__BossLevel_OnLevelChange takes integer this returns nothing
			
  endfunction
  function s__BossLevel_OnCheckpointChange takes integer this returns nothing
			
  endfunction
		
  function s__BossLevel_RunBossBehavior takes nothing returns nothing
   local integer curBossLevel= s__SimpleList_List_first[s__BossLevel_ActiveBosses]
   local integer bossLevel
			
			loop
			exitwhen curBossLevel == 0
				set bossLevel=(s__SimpleList_ListNode_value[curBossLevel])
				
				
			set curBossLevel=s__SimpleList_ListNode_next[curBossLevel]
			endloop
  endfunction
				
  function s__BossLevel_Start takes integer this returns nothing
			if not s__SimpleList_List_contains(s__BossLevel_ActiveBosses,this) then
				call s__SimpleList_List_addEnd(s__BossLevel_ActiveBosses,this)
				
				if s__SimpleList_List_count[s__BossLevel_ActiveBosses] == 1 then
					call TimerStart(s__BossLevel_BehaviorTimer, BossLevel___BOSS_BEHAVIOR_TIMEOUT, true, function s__BossLevel_RunBossBehavior)
				endif
			endif
  endfunction
  function s__BossLevel_Stop takes integer this returns nothing
			
  endfunction
		
  function s__BossLevel_create takes integer bossLevelID,string bossName,integer rawContinues,integer rawScore,string startFunction,string stopFunction,rect startspawn,rect vision,integer previousLevel returns integer
   local integer new= s__Levels_Level_create(bossLevelID , bossName , rawContinues , rawScore , startFunction , stopFunction , startspawn , vision , null , previousLevel)
			
			return new
  endfunction
		
  function s__BossLevel_onInit takes nothing returns nothing
			//listen to LevelChange, CheckpointChange, and PlayerDeath events
  endfunction


//library BossLevel ends
//library Collectible:
	
	//has two units in the same location
	//has functionality for displaying one unit while hiding the other PER TEAM
	//needs to use a unit so i can easily change visibility locally
		
//Implemented from module PermanentAlloc:
		
  function s__Collectible_allocate takes nothing returns integer
   local integer new= s__Collectible_PermanentAlloc___c
			
			set s__Collectible_PermanentAlloc___c=s__Collectible_PermanentAlloc___c + 1
			
			return new
  endfunction
		//no deallocate for this module, use vanilla Alloc if you need that functionality
		
  function s__Collectible_create takes integer uncollectedUnitID,real x,real y,real facing returns integer
   local integer new= s__Collectible_allocate()
   local integer uInfo
						
			set s__Collectible_UncollectedUnit[new]=CreateUnit(Collectible___COLLECTIBLE_PLAYER, uncollectedUnitID, x, y, facing)
			set uInfo=s__IndexedUnit_create(s__Collectible_UncollectedUnit[new])
			set s__IndexedUnit_Collideable[uInfo]=false
			call s__IndexedUnit_InitializeVertexColor(uInfo)
			call AddUnitLocust(s__Collectible_UncollectedUnit[new])
			set s__Collectible_UncollectedUnitRadius[new]=GetUnitDefaultRadius(uncollectedUnitID)
			
			//hide the collected version of the unit on init or on level start
			
			//defaults
			set s__Collectible_ReturnToCheckpoint[new]=false
						
			return new
  endfunction
  function s__Collectible_createFromPoint takes integer uncollectedUnitID,rect loc,real facing returns integer
			return s__Collectible_create(uncollectedUnitID , GetRectCenterX(loc) , GetRectCenterY(loc) , facing)
  endfunction
	
	//consists of:
	//either a doodad or a unit that can be shown to some players but not others. this object will be visually shown based on its properties, the user, and their team's having collected it
	//IStartable Start/Stop
	//a periodic check of the region around that unit for active player units
	//a callback for the first time a team activates a collectibe
	//a callback for when a team activates all collectibles on a level
		
		
//Implemented from module Alloc:
		
		

			

		
		
  function s__CollectibleTeam_allocate takes nothing returns integer
   local integer this= s__CollectibleTeam_Alloc___recycler[0]
			


			
			if ( s__CollectibleTeam_Alloc___recycler[this] == 0 ) then
				set s__CollectibleTeam_Alloc___recycler[0]=this + 1
			else
				set s__CollectibleTeam_Alloc___recycler[0]=s__CollectibleTeam_Alloc___recycler[this]
			endif
			


			


			
			return this
  endfunction
		
  function s__CollectibleTeam_deallocate takes integer this returns nothing


			


			
			set s__CollectibleTeam_Alloc___recycler[this]=s__CollectibleTeam_Alloc___recycler[0]
			set s__CollectibleTeam_Alloc___recycler[0]=this
  endfunction
		

			
			
			


























































































































		
		


		
		
  function s__CollectibleTeam_Alloc___onInit takes nothing returns nothing
			set s__CollectibleTeam_Alloc___recycler[0]=1
  endfunction
		
		// private static method OnAllCollected takes integer result, integer callbackData returns integer
			// call DisplayTextToPlayer(Player(0), 0, 0, "All collectibles found! Active Team ID: " + I2S(callbackData))
			
			// return 0
		// endmethod
				
  function s__CollectibleTeam_create takes integer parent,integer mt returns integer
   local integer new= s__CollectibleTeam_allocate()
   local integer curCollectibleNode= s__SimpleList_List_first[s__CollectibleSet_Collectibles[parent]]
						
			set s__CollectibleTeam_Team[new]=mt
			
			//create one deferred per collectible, match order so that it can be used as the ID
			set s__CollectibleTeam_CollectibleDeferreds[new]=s__SimpleList_List_create()
			loop
			exitwhen curCollectibleNode == 0
				//show uncollected unit for local team only
				call s__Teams_MazingTeam_SetUnitLocalVisibilityForTeam(mt,s__Collectible_UncollectedUnit[(s__SimpleList_ListNode_value[curCollectibleNode])] , true)
								
				//create a deferred to track collection state
				call s__SimpleList_List_addEnd(s__CollectibleTeam_CollectibleDeferreds[new],s__Deferred_create())
			set curCollectibleNode=s__SimpleList_ListNode_next[curCollectibleNode]
			endloop
			
			set s__CollectibleTeam_AllCollected[new]=All(s__CollectibleTeam_CollectibleDeferreds[new])
			//call new.AllCollected.Then(thistype.OnAllCollected, 0, new)
			call s__Deferred_Then(s__CollectibleTeam_AllCollected[new],s__CollectibleSet_OnAllCollected[parent] , 0 , new)
						
			return new
  endfunction
  function s__CollectibleTeam_destroy takes integer this returns nothing
   local integer curDeferredNode
			
			call s__Deferred_destroy(s__CollectibleTeam_AllCollected[this])
			
			loop
			set curDeferredNode=s__SimpleList_List_pop(s__CollectibleTeam_CollectibleDeferreds[this])
			exitwhen curDeferredNode == 0
				call s__Deferred_destroy((s__SimpleList_ListNode_value[curDeferredNode]))
			endloop
			
			call s__SimpleList_List_destroy(s__CollectibleTeam_CollectibleDeferreds[this])
			
			call s__CollectibleTeam_deallocate(this)
			
			//call DisplayTextToPlayer(Player(0), 0, 0, "Deallocated active team - " + I2S(this))
  endfunction
	
		
		
		
  function s__CollectibleSet_AddCollectible takes integer this,integer collectible returns nothing
			call s__SimpleList_List_addEnd(s__CollectibleSet_Collectibles[this],collectible)
  endfunction
		
  function s__CollectibleSet_InitializeTeam takes nothing returns nothing
   local integer curStartableNode= s__SimpleList_List_first[s__Levels_Level_Startables[EventCurrentLevel]]
			
			loop
			exitwhen curStartableNode == 0
				if si__IStartable_type[(s__SimpleList_ListNode_value[curStartableNode])] == si__CollectibleSet then
					call s__SimpleList_List_addEnd(s__CollectibleSet_ActiveTeams[(s__SimpleList_ListNode_value[curStartableNode])],s__CollectibleTeam_create((s__SimpleList_ListNode_value[curStartableNode]) , s__Levels_Level_CBTeam))
				endif
			set curStartableNode=s__SimpleList_ListNode_next[curStartableNode]
			endloop
  endfunction
  function s__CollectibleSet_DeinitializeTeam takes nothing returns nothing
   local integer curStartableNode= s__SimpleList_List_first[s__Levels_Level_Startables[EventPreviousLevel]]
   local integer curActiveTeamNode
   local integer removedTeam
			
			//call DisplayTextToPlayer(Player(0), 0, 0, "Deinitializing start for level: " + I2S(EventPreviousLevel))
			
			loop
			exitwhen curStartableNode == 0
				if si__IStartable_type[(s__SimpleList_ListNode_value[curStartableNode])] == si__CollectibleSet then
					set curActiveTeamNode=s__SimpleList_List_first[s__CollectibleSet_ActiveTeams[(s__SimpleList_ListNode_value[curStartableNode])]]
					
					//call DisplayTextToPlayer(Player(0), 0, 0, "Deinitializing active team: " + I2S(curActiveTeamNode.value))
					
					loop
					exitwhen curActiveTeamNode == 0
						if s__CollectibleTeam_Team[(s__SimpleList_ListNode_value[curActiveTeamNode])] == s__Levels_Level_CBTeam then
							call s__CollectibleTeam_destroy((s__SimpleList_ListNode_value[curActiveTeamNode]))
							call s__SimpleList_List_removeNode(s__CollectibleSet_ActiveTeams[(s__SimpleList_ListNode_value[curStartableNode])],curActiveTeamNode)
						endif
					set curActiveTeamNode=s__SimpleList_ListNode_next[curActiveTeamNode]
					endloop
				endif
			set curStartableNode=s__SimpleList_ListNode_next[curStartableNode]
			endloop
  endfunction
		
  function s__CollectibleSet_CheckActiveCollectibles takes nothing returns nothing
   local integer curCollectibleSetNode= s__SimpleList_List_first[s__CollectibleSet_ActiveCollectibles]
   local integer curTeamNode
   local integer curPlayerNode
   local integer curCollectibleNode
   local integer curCollectibleIndex
   local integer curCollectibleDeferred
			
   local real deltaX
   local real deltaY
			//local real distance
			
			loop
			exitwhen curCollectibleSetNode == 0
				set curTeamNode=s__SimpleList_List_first[s__CollectibleSet_ActiveTeams[(s__SimpleList_ListNode_value[curCollectibleSetNode])]]
				
				loop
				exitwhen curTeamNode == 0
					set curPlayerNode=s__Teams_MazingTeam_FirstUser[s__CollectibleTeam_Team[(s__SimpleList_ListNode_value[curTeamNode])]]
					
					loop
					exitwhen curPlayerNode == 0
						set curCollectibleNode=s__SimpleList_List_first[s__CollectibleSet_Collectibles[(s__SimpleList_ListNode_value[curCollectibleSetNode])]]
						set curCollectibleIndex=0
						
						loop
						exitwhen curCollectibleNode == 0
							set curCollectibleDeferred=(s__SimpleList_ListNode_value[s__SimpleList_List_get(s__CollectibleTeam_CollectibleDeferreds[(s__SimpleList_ListNode_value[curTeamNode])],curCollectibleIndex)])
							set deltaX=GetUnitX(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curPlayerNode])]) - GetUnitX(s__Collectible_UncollectedUnit[(s__SimpleList_ListNode_value[curCollectibleNode])])
							set deltaY=GetUnitY(s__User_ActiveUnit[(s__SimpleList_ListNode_value[curPlayerNode])]) - GetUnitY(s__Collectible_UncollectedUnit[(s__SimpleList_ListNode_value[curCollectibleNode])])
							//set distance = SquareRoot(deltaX*deltaX + deltaY*deltaY)
							
							if SquareRoot(deltaX * deltaX + deltaY * deltaY) <= s__Collectible_UncollectedUnitRadius[(s__SimpleList_ListNode_value[curCollectibleNode])] + s__User_ActiveUnitRadius[(s__SimpleList_ListNode_value[curPlayerNode])] then
								if not s__Deferred_Resolved[curCollectibleDeferred] then
									call CollectibleAcquireEffect(s__SimpleList_ListNode_value[curCollectibleNode] , s__SimpleList_ListNode_value[curPlayerNode])
									call s__Teams_MazingTeam_SetUnitLocalOpacityForTeam(s__CollectibleTeam_Team[(s__SimpleList_ListNode_value[curTeamNode])],s__Collectible_UncollectedUnit[(s__SimpleList_ListNode_value[curCollectibleNode])] , INACTIVE_UNIT_OPACITY)
									
									call s__Deferred_Resolve(curCollectibleDeferred,s__SimpleList_ListNode_value[curPlayerNode])
								endif
								
								if s__Collectible_ReturnToCheckpoint[(s__SimpleList_ListNode_value[curCollectibleNode])] then
									call TeleportEffect(s__Collectible_UncollectedUnit[(s__SimpleList_ListNode_value[curCollectibleNode])] , s__SimpleList_ListNode_value[curPlayerNode])
									
									call s__User_RespawnAtRect((s__SimpleList_ListNode_value[curPlayerNode]),s__Teams_MazingTeam_Revive[s__CollectibleTeam_Team[(s__SimpleList_ListNode_value[curTeamNode])]] , true)
								endif
							endif
						
						set curCollectibleNode=s__SimpleList_ListNode_next[curCollectibleNode]
						set curCollectibleIndex=curCollectibleIndex + 1
						endloop
					set curPlayerNode=s__SimpleList_ListNode_next[curPlayerNode]
					endloop
				set curTeamNode=s__SimpleList_ListNode_next[curTeamNode]
				endloop
			set curCollectibleSetNode=s__SimpleList_ListNode_next[curCollectibleSetNode]
			endloop
  endfunction
		
		//called when either the first team starts a level or the last team stops a level
  function s__CollectibleSet_Start takes integer this returns nothing
			if s__SimpleList_List_count[s__CollectibleSet_ActiveCollectibles] == 0 then
				set s__CollectibleSet_Timer=(NewTimerEx(0)) // INLINED!!
				call TimerStart(s__CollectibleSet_Timer, Collectible___COLLECTIBLE_COLLISION_TIMEOUT, true, function s__CollectibleSet_CheckActiveCollectibles)
			endif
			
			call s__SimpleList_List_addEnd(s__CollectibleSet_ActiveCollectibles,this)
  endfunction
  function s__CollectibleSet_Stop takes integer this returns nothing
			call s__SimpleList_List_remove(s__CollectibleSet_ActiveCollectibles,this)
			
			if s__SimpleList_List_count[s__CollectibleSet_ActiveCollectibles] == 0 then
				call ReleaseTimer(s__CollectibleSet_Timer)
				set s__CollectibleSet_Timer=null
			endif
  endfunction
		
  function s__CollectibleSet_create takes integer parentLevel,integer onAllCollected returns integer
   local integer tcsCountOnLevel= 0
   local integer curStartableNode
   local integer new= s__CollectibleSet__allocate()
						
			set s__CollectibleSet_OnAllCollected[new]=onAllCollected
			
			set s__CollectibleSet_ActiveTeams[new]=s__SimpleList_List_create()
			set s__CollectibleSet_Collectibles[new]=s__SimpleList_List_create()
						
			if parentLevel != 0 and s__Levels_Level_Startables[parentLevel] != 0 then
				set curStartableNode=s__SimpleList_List_first[s__Levels_Level_Startables[parentLevel]]
				loop
				exitwhen curStartableNode == 0 or tcsCountOnLevel != 0
					if si__IStartable_type[(s__SimpleList_ListNode_value[curStartableNode])] == si__CollectibleSet then
						set tcsCountOnLevel=tcsCountOnLevel + 1
					endif
				set curStartableNode=s__SimpleList_ListNode_next[curStartableNode]
				endloop
			endif
						
			if tcsCountOnLevel == 0 then
				call s__Levels_Level_AddLevelStartCB(parentLevel,Condition(function s__CollectibleSet_InitializeTeam))
				call s__Levels_Level_AddLevelStopCB(parentLevel,Condition(function s__CollectibleSet_DeinitializeTeam))
			endif
			
			call s__Levels_Level_AddStartable(parentLevel,new)
						
			return new
  endfunction
		
  function s__CollectibleSet_onInit takes nothing returns nothing
			set s__CollectibleSet_ActiveCollectibles=s__SimpleList_List_create()
  endfunction

//library Collectible ends
//library Continues:

function Continues_onPlayerUnitDiedCB takes nothing returns nothing
    local timer t= GetExpiredTimer()
    local integer pID= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
    local integer user= (pID)
	
    local integer mt= s__User_Team[user]
    local integer level= s__Teams_MazingTeam_OnLevel[mt]
	
	//check that the user is still dying -- they might have been revived in the mean-time
	if s__User_IsAlive[user] then
		//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "pID " + I2S(pID) + " died on level " + level.Name + ", on team: " + I2S(mt))
		//specifically refers to the PlayerUnitDied CB having executed
		set s__User_IsAlive[user]=false
		
		//switch from any game mode to dead
		//unit should be dead at this point
		call s__User_SwitchGameModesDefaultLocation(user,Teams_GAMEMODE_DEAD)
		
		//can't lose continues in starting worlds
		if ( level == INTRO_LEVEL_ID or level == DOORS_LEVEL_ID ) then
			//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "no continues lost")
			//respawn players immediately if on intro or doors levels, regardless of other settings
			
			call s__User_RespawnAtRect(user,s__Teams_MazingTeam_Revive[mt] , false)
			
			//lets not keep track of deaths till everyone has a chance to learn from the first few levels
			return
		endif
		
		set s__User_Deaths[user]=s__User_Deaths[user] + 1
			
		//check if the team has any more continues AND needs to use one
		
		//should death cause a continue to be used
		if RespawnASAPMode or s__Teams_MazingTeam_IsTeamDead(mt) then
			//can a continue be used
			if (s__Teams_MazingTeam_ContinueCount[(mt)]) > 0 then // INLINED!!
				//how should that continue be used
				if RespawnASAPMode then
					//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Continues ASAP respawn")
					call s__User_RespawnAtRect(user,s__Teams_MazingTeam_Revive[mt] , false)
				else //mt.IsTeamDead()
					//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Continues Team respawn")
					call s__Teams_MazingTeam_RespawnTeamAtRect(mt,s__Teams_MazingTeam_Revive[mt] , false)
				endif
			endif
			
			call s__Teams_MazingTeam_ChangeContinueCount(mt,- 1)
		endif
		
		call s__Teams_MazingTeam_UpdateMultiboard(mt)
	endif
	    
    call ReleaseTimer(t)
    set t=null
endfunction

function Continues_onPlayerUnitDied takes nothing returns nothing
    //call Continues_PlayerUnitDied(GetPlayerId(GetTriggerPlayer()))
    call TimerStart(NewTimerEx(GetPlayerId(GetTriggerPlayer())), REVIVE_WAIT_AFTER_DEATH, false, function Continues_onPlayerUnitDiedCB)
endfunction

function Continues___Init takes nothing returns nothing
    local integer i= 0
    local trigger t= CreateTrigger()
    
    loop
    exitwhen i >= NumberPlayers
        call TriggerRegisterPlayerUnitEvent(t, Player(i), EVENT_PLAYER_UNIT_DEATH, null)
        
        set i=i + 1
    endloop
    
    call TriggerAddAction(t, function Continues_onPlayerUnitDied)
endfunction

//library Continues ends
//library EDWPlayerStart:
 function GetFirstLevel takes nothing returns integer
        if false or CONFIGURATION_PROFILE != RELEASE then
            //3 == first ice level
            //24/31 == last ice levels
            //9 == first platforming level
            
            //66 == debug platform testing
            return (1)
        else
            return (1)
        endif
    endfunction
 function GetFirstCheckpoint takes nothing returns integer
		if false or CONFIGURATION_PROFILE != RELEASE then
            return 0
        else
            return 0
        endif
	endfunction

//library EDWPlayerStart ends
//library FastLoad:
	
		
		
		
		
		
				
  function s__FastLoad_BroadcastOverclockFactor takes integer this,real overclockFactor returns nothing
   local integer curNode= s__SimpleList_List_first[s__Levels_Level_Startables[s__IStartable_ParentLevel[this]]]
			



			
			loop
			exitwhen curNode == 0
				if si__IStartable_type[(s__SimpleList_ListNode_value[curNode])] == si__RelayGenerator then
					call s__RelayGenerator_SetOverclockFactor((s__SimpleList_ListNode_value[curNode]),overclockFactor)
				elseif si__IStartable_type[(s__SimpleList_ListNode_value[curNode])] == si__SimpleGenerator then
					call s__SimpleGenerator_SetOverclockFactor((s__SimpleList_ListNode_value[curNode]),overclockFactor)
				endif
			set curNode=s__SimpleList_ListNode_next[curNode]
			endloop
			



  endfunction
		
  function s__FastLoad_OverclockLoadPlayerCB takes nothing returns nothing
   local timer t= GetExpiredTimer()
   local integer fastLoad= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
   local integer curNode
			// local Checkpoint checkpoint
			
			loop
			set curNode=s__SimpleList_List_pop(s__FastLoad_AwaitingTeams[fastLoad])
			exitwhen curNode == 0
				// set checkpoint = fastLoad.ParentLevel.Checkpoints.get(Teams_MazingTeam(curNode.value).OnCheckpoint).value
				// if checkpoint == fastLoad.Checkpoint then
					// call Teams_MazingTeam(curNode.value).PauseTeam(false)
				// endif
				call s__Teams_MazingTeam_PauseTeam((s__SimpleList_ListNode_value[curNode]),false)
			endloop
			
			call ReleaseTimer(t)
			set s__FastLoad_OverclockTimer[fastLoad]=null
			set t=null
  endfunction
  function s__FastLoad_OverclockLoadCB takes nothing returns nothing
   local timer t= GetExpiredTimer()
   local integer fastLoad= (LoadInteger(TimerUtils___ht, 0, GetHandleId((t)))) // INLINED!!
   local integer curNode
			
			set s__FastLoad_LoadState[fastLoad]=FastLoad___LOADED
			call s__FastLoad_BroadcastOverclockFactor(fastLoad,1.0)
			
			call TimerStart(t, FastLoad___OVERCLOCK_LOADED_EXTRA_WAIT, false, function s__FastLoad_OverclockLoadPlayerCB)
  endfunction
		
  function s__FastLoad_GetCheckpointFastLoad takes integer level,integer checkpoint returns integer
   local integer curActiveLoaderNode= s__SimpleList_List_first[s__FastLoad_ActiveLoaders]
   local integer fastLoad= 0
			
			loop
			exitwhen curActiveLoaderNode == 0 or fastLoad != 0
				if s__IStartable_ParentLevel[(s__SimpleList_ListNode_value[curActiveLoaderNode])] == level and s__FastLoad_Checkpoint[(s__SimpleList_ListNode_value[curActiveLoaderNode])] == checkpoint then
					set fastLoad=s__SimpleList_ListNode_value[curActiveLoaderNode]
				endif
			set curActiveLoaderNode=s__SimpleList_ListNode_next[curActiveLoaderNode]
			endloop
			
			return fastLoad
  endfunction
  function s__FastLoad_CheckpointChangeCB takes nothing returns nothing
   local integer fastLoad= s__FastLoad_GetCheckpointFastLoad(EventCurrentLevel , EventCheckpoint)
   local integer curNode
						
			if fastLoad != 0 and s__FastLoad_LoadState[fastLoad] != FastLoad___LOADED and ( TimerGetRemaining(s__FastLoad_OverclockTimer[fastLoad]) + FastLoad___OVERCLOCK_LOADED_EXTRA_WAIT ) > s__Teams_MazingTeam_GetAutoUnpauseLeastRemainingTime(s__Levels_Level_CBTeam) then
				call s__SimpleList_List_addEnd(s__FastLoad_AwaitingTeams[fastLoad],s__Levels_Level_CBTeam)
				
				call s__Teams_MazingTeam_CancelAutoUnpauseForTeam(s__Levels_Level_CBTeam)
				call s__Teams_MazingTeam_PauseTeam(s__Levels_Level_CBTeam,true)
			endif
  endfunction
		
  function s__FastLoad_Start takes integer this returns nothing
			if not s__SimpleList_List_contains(s__FastLoad_ActiveLoaders,this) then
				if s__FastLoad_LoadState[this] == FastLoad___UNLOADED then
					set s__FastLoad_LoadState[this]=FastLoad___LOADING
					call s__FastLoad_BroadcastOverclockFactor(this,s__FastLoad_OverclockFactor[this])
					
					set s__FastLoad_OverclockTimer[this]=NewTimerEx(this)
					call TimerStart(s__FastLoad_OverclockTimer[this], s__FastLoad_FastLoadTime[this], false, function s__FastLoad_OverclockLoadCB)
				endif
				
				call s__SimpleList_List_add(s__FastLoad_ActiveLoaders,this)
            endif
  endfunction
  function s__FastLoad_Stop takes integer this returns nothing
			if s__SimpleList_List_contains(s__FastLoad_ActiveLoaders,this) then
				set s__FastLoad_LoadState[this]=FastLoad___UNLOADED
				
                call s__SimpleList_List_remove(s__FastLoad_ActiveLoaders,this)
            endif
  endfunction
		
		//registers a fast load event
  function s__FastLoad_create takes integer parentLevel,integer checkpoint,real overclockFactor,real fastLoadTime returns integer
   local integer new= s__FastLoad__allocate()
			call s__Levels_Level_AddStartable(parentLevel,new)
			//TODO check that no other fast loads already exist in this level. ONE PER LEVEL
			
			set s__FastLoad_Checkpoint[new]=checkpoint
			set s__FastLoad_OverclockFactor[new]=overclockFactor
			set s__FastLoad_FastLoadTime[new]=fastLoadTime
			
			set s__FastLoad_LoadState[new]=FastLoad___UNLOADED
			set s__FastLoad_AwaitingTeams[new]=s__SimpleList_List_create()
			
			call s__Levels_Level_AddCheckpointChangeCB(parentLevel,Condition(function s__FastLoad_CheckpointChangeCB))
			
			return new
  endfunction
		
  function s__FastLoad_onInit takes nothing returns nothing
			set s__FastLoad_ActiveLoaders=s__SimpleList_List_create()
  endfunction

//library FastLoad ends
//library IW1:
 function IW1_InitializeStartableContent takes nothing returns nothing
  local integer l= (IW1_LEVEL_ID)
		
  local integer nsync
  local integer jtimber
        
  local integer i
		
		set nsync=s__SynchronizedGroup_create()
		call s__Levels_Level_AddStartable(l,nsync)
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,LGUARD)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_056))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_057))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,LGUARD)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_058))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_059))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
				
		if RewardMode == GameModesGlobals_HARD then
			set i=s__Levels_Level_GetWeightedRandomInt(l,4 , 5)
		else
			set i=3
		endif
		loop
			exitwhen i == 0
			call s__Levels_Level_AddStartable(l,s__MortarNTarget_create(SMLMORT , SMLTARG , Player(8) , gg_rct_IW1_Mortar1 , gg_rct_IW1_Target1))
			call s__Levels_Level_AddStartable(l,s__MortarNTarget_create(SMLMORT , SMLTARG , Player(8) , gg_rct_IW1_Mortar2 , gg_rct_IW1_Target2))
			call s__Levels_Level_AddStartable(l,s__MortarNTarget_create(SMLMORT , SMLTARG , Player(8) , gg_rct_IW1_Mortar3 , gg_rct_IW1_Target3))
		set i=i - 1
		endloop
	endfunction
	
 function IW1Start takes nothing returns nothing
  local integer parentLevel= (IW1_LEVEL_ID)
		
		//patrols
		// call Recycle_MakeUnitAndPatrolRect(LGUARD, gg_rct_Rect_056, gg_rct_Rect_057)
		// call Recycle_MakeUnitAndPatrolRect(LGUARD, gg_rct_Rect_058, gg_rct_Rect_059)
		call Recycle_MakeUnitAndPatrolRect(GUARD , gg_rct_Rect_060 , gg_rct_Rect_061)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_062 , gg_rct_Rect_063)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_064 , gg_rct_Rect_065)
		if RewardMode == GameModesGlobals_HARD then
			call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_066 , gg_rct_Rect_067)
		endif
	endfunction

 function IW1Stop takes nothing returns nothing

	endfunction

//library IW1 ends
//library IW2:
 function IW2_InitializeStartableContent takes nothing returns nothing
  local integer l= (IW2_LEVEL_ID)
		
  local integer pattern
  local integer sg
		
  local integer nsync
  local integer jtimber
        
  local integer i
		
		set pattern=s__LinePatternSpawn_createFromRect((1) , 1 , gg_rct_Rect_092 , TERRAIN_TILE_SIZE)
		set sg=s__SimpleGenerator_create(pattern , .9 , 0 , 23)
        call s__Levels_Level_AddStartable(l,sg)
		
		if RewardMode == GameModesGlobals_HARD then
			set i=s__Levels_Level_GetWeightedRandomInt(l,3 , 4)
		else
			set i=2
		endif
		loop
			exitwhen i == 0
			call s__Levels_Level_AddStartable(l,s__MortarNTarget_create(SMLMORT , SMLTARG , Player(8) , gg_rct_IW2_Mortar1 , gg_rct_IW2_Target1))
			call s__Levels_Level_AddStartable(l,s__MortarNTarget_create(SMLMORT , SMLTARG , Player(8) , gg_rct_IW2_Mortar1 , gg_rct_IW2_Target3))
			call s__Levels_Level_AddStartable(l,s__MortarNTarget_create(SMLMORT , SMLTARG , Player(8) , gg_rct_IW2_Mortar2 , gg_rct_IW2_Target2))
			call s__Levels_Level_AddStartable(l,s__MortarNTarget_create(SMLMORT , SMLTARG , Player(8) , gg_rct_IW2_Mortar2 , gg_rct_IW2_Target4))
		set i=i - 1
		endloop
		
		if RewardMode == GameModesGlobals_HARD then
			call SetTerrainType(GetRectCenterX(gg_rct_IW2_TC1), GetRectCenterY(gg_rct_IW2_TC1), ABYSS, 0, 1, 0)
		endif
		
		//sync group 1
		set nsync=s__SynchronizedGroup_create()
		call s__Levels_Level_AddStartable(l,nsync)
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,LGUARD)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_071))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_072))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		if RewardMode == GameModesGlobals_HARD then
			set jtimber=s__SynchronizedGroup_AddUnit(nsync,LGUARD)
			call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_073))
			call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_074))
			set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		endif
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,LGUARD)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_075))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_076))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		//sync group 2
		set nsync=s__SynchronizedGroup_create()
		call s__Levels_Level_AddStartable(l,nsync)
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,LGUARD)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_077))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_078))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,LGUARD)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_079))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_080))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,LGUARD)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_081))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_082))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		//sync group 3
		if RewardMode == GameModesGlobals_HARD then
			set nsync=s__SynchronizedGroup_create()
			call s__Levels_Level_AddStartable(l,nsync)
			
			set jtimber=s__SynchronizedGroup_AddUnit(nsync,LGUARD)
			call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_085))
			call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_086))
			set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
			
			set jtimber=s__SynchronizedGroup_AddUnit(nsync,LGUARD)
			call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_087))
			call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_088))
			set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		endif
	endfunction
	
 function IW2Start takes nothing returns nothing
  local integer parentLevel= (IW2_LEVEL_ID)
		
		//patrols
		//P1
		call Recycle_MakeUnitAndPatrolRect(GUARD , gg_rct_Rect_083 , gg_rct_Rect_084)
		if RewardMode != GameModesGlobals_HARD then
			call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_085 , gg_rct_Rect_086)
		endif
		
		//P3
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_095 , gg_rct_Rect_096)
		call Recycle_MakeUnitAndPatrolRect(GUARD , gg_rct_Rect_097 , gg_rct_Rect_098)
		if RewardMode == GameModesGlobals_HARD then
			call Recycle_MakeUnitAndPatrolRect(GUARD , gg_rct_Rect_099 , gg_rct_Rect_100)
		endif
		call Recycle_MakeUnitAndPatrolRect(GUARD , gg_rct_Rect_101 , gg_rct_Rect_102)
		if RewardMode == GameModesGlobals_HARD then
			call Recycle_MakeUnitAndPatrolRect(GUARD , gg_rct_Rect_105 , gg_rct_Rect_106)
		endif
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_107 , gg_rct_Rect_108)
			
		//turn on periodic functions
	endfunction

 function IW2Stop takes nothing returns nothing

	endfunction

//library IW2 ends
//library IW3:
 function IW3_InitializeStartableContent takes nothing returns nothing
  local integer l= (IW3_LEVEL_ID)
		
  local integer pattern
  local integer sg
		
  local integer nsync
  local integer jtimber
        
  local integer i
		
		set nsync=s__SynchronizedGroup_create()
		call s__Levels_Level_AddStartable(l,nsync)
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,GUARD)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_128))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_129))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,GUARD)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_130))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_131))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		if RewardMode == GameModesGlobals_HARD then
			set i=s__Levels_Level_GetWeightedRandomInt(l,3 , 7)
			loop
			exitwhen i == 0
				call s__Levels_Level_AddStartable(l,s__MortarNTarget_create(SMLMORT , SMLTARG , Player(8) , gg_rct_IW3_Mortar1 , gg_rct_IW3_Target2))
			set i=i - 1
			endloop
			
			set i=s__Levels_Level_GetWeightedRandomInt(l,3 , 7)
			loop
			exitwhen i == 0
				call s__Levels_Level_AddStartable(l,s__MortarNTarget_create(SMLMORT , SMLTARG , Player(8) , gg_rct_IW3_Mortar1 , gg_rct_IW3_Target3))
			set i=i - 1
			endloop
			
			set i=s__Levels_Level_GetWeightedRandomInt(l,5 , 7)
		else
			set i=4
		endif
		loop
		exitwhen i == 0
			call s__Levels_Level_AddStartable(l,s__MortarNTarget_create(SMLMORT , SMLTARG , Player(8) , gg_rct_IW3_Mortar1 , gg_rct_IW3_Target1))
		set i=i - 1
		endloop
		
		call s__Levels_Level_AddStartable(l,s__Blackhole_create(15000 , 3330 , true))
		
		//
		set nsync=s__SynchronizedGroup_create()
		call s__Levels_Level_AddStartable(l,nsync)
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,GUARD)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_170))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_171))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,GUARD)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_172))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_173))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
        
		//
		set nsync=s__SynchronizedGroup_create()
		call s__Levels_Level_AddStartable(l,nsync)
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,LGUARD)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_182))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_183))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,LGUARD)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_184))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_185))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		//
		set nsync=s__SynchronizedGroup_create()
		call s__Levels_Level_AddStartable(l,nsync)
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,LGUARD)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_186))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_187))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,LGUARD)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_188))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_189))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		//
		set nsync=s__SynchronizedGroup_create()
		call s__Levels_Level_AddStartable(l,nsync)
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,LGUARD)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_198))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_199))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,LGUARD)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_200))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_201))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		if RewardMode == GameModesGlobals_HARD then
			//
			set nsync=s__SynchronizedGroup_create()
			call s__Levels_Level_AddStartable(l,nsync)
			
			set jtimber=s__SynchronizedGroup_AddUnit(nsync,LGUARD)
			call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_202))
			call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_203))
			set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
			
			set jtimber=s__SynchronizedGroup_AddUnit(nsync,LGUARD)
			call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_204))
			call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_205))
			set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
			call s__Levels_Level_AddStartable(l,s__DrunkWalker_DrunkWalkerSpawn_create(gg_rct_IW3_Drunks_1 , 6 , LGUARD , 24))
			call s__Levels_Level_AddStartable(l,s__DrunkWalker_DrunkWalkerSpawn_create(gg_rct_IW3_Drunks_2 , 8 , LGUARD , 16))
		else
			call s__Levels_Level_AddStartable(l,s__DrunkWalker_DrunkWalkerSpawn_create(gg_rct_IW3_Drunks_1 , 6 , LGUARD , 20))
			call s__Levels_Level_AddStartable(l,s__DrunkWalker_DrunkWalkerSpawn_create(gg_rct_IW3_Drunks_2 , 8 , LGUARD , 12))
		endif
	endfunction
	
 function IW3Start takes nothing returns nothing
  local integer parentLevel= (IW3_LEVEL_ID)
		
		//patrols
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_124 , gg_rct_Rect_125)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_126 , gg_rct_Rect_127)
		// call Recycle_MakeUnitAndPatrolRect(GUARD, gg_rct_Rect_128, gg_rct_Rect_129)
		// call Recycle_MakeUnitAndPatrolRect(GUARD, gg_rct_Rect_130, gg_rct_Rect_131)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_132 , gg_rct_Rect_133)
		if RewardMode == GameModesGlobals_HARD then
			call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_135 , gg_rct_Rect_134)
		endif
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_136 , gg_rct_Rect_137)
		
		//P2
		call Recycle_MakeUnitAndPatrolRect(GUARD , gg_rct_Rect_138 , gg_rct_Rect_139)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_140 , gg_rct_Rect_141)
		call Recycle_MakeUnitAndPatrolRect(GUARD , gg_rct_Rect_142 , gg_rct_Rect_143)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_144 , gg_rct_Rect_145)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_146 , gg_rct_Rect_147)
		if RewardMode == GameModesGlobals_HARD then
			call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_148 , gg_rct_Rect_149)
		endif
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_150 , gg_rct_Rect_151)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_152 , gg_rct_Rect_153)
		if RewardMode == GameModesGlobals_HARD then
			call Recycle_MakeUnitAndPatrolRect(GUARD , gg_rct_Rect_154 , gg_rct_Rect_155)
		endif
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_156 , gg_rct_Rect_157)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_158 , gg_rct_Rect_159)
		if RewardMode == GameModesGlobals_HARD then
			call Recycle_MakeUnitAndPatrolRect(GUARD , gg_rct_Rect_160 , gg_rct_Rect_161)
			call Recycle_MakeUnitAndPatrolRect(GUARD , gg_rct_Rect_162 , gg_rct_Rect_163)
		else
			call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_160 , gg_rct_Rect_161)
			call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_162 , gg_rct_Rect_163)
		endif
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_164 , gg_rct_Rect_165)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_166 , gg_rct_Rect_167)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_168 , gg_rct_Rect_169)
		// call Recycle_MakeUnitAndPatrolRect(GUARD, gg_rct_Rect_170, gg_rct_Rect_171)
		// call Recycle_MakeUnitAndPatrolRect(GUARD, gg_rct_Rect_172, gg_rct_Rect_173)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_174 , gg_rct_Rect_175)
		if RewardMode == GameModesGlobals_HARD then
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_176 , gg_rct_Rect_177)
		endif
		call Recycle_MakeUnitAndPatrolRect(GUARD , gg_rct_Rect_178 , gg_rct_Rect_179)
		
		call Recycle_MakeUnitAndPatrolRect(GUARD , gg_rct_Rect_180 , gg_rct_Rect_181)
		if RewardMode == GameModesGlobals_HARD then
			call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_280 , gg_rct_Rect_281)
		endif
		// call Recycle_MakeUnitAndPatrolRect(LGUARD, gg_rct_Rect_182, gg_rct_Rect_183)
		// call Recycle_MakeUnitAndPatrolRect(LGUARD, gg_rct_Rect_184, gg_rct_Rect_185)
		// call Recycle_MakeUnitAndPatrolRect(LGUARD, gg_rct_Rect_186, gg_rct_Rect_187)
		// call Recycle_MakeUnitAndPatrolRect(LGUARD, gg_rct_Rect_188, gg_rct_Rect_189)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_190 , gg_rct_Rect_191)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_192 , gg_rct_Rect_193)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_194 , gg_rct_Rect_195)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_196 , gg_rct_Rect_197)
		// call Recycle_MakeUnitAndPatrolRect(LGUARD, gg_rct_Rect_198, gg_rct_Rect_199)
		// call Recycle_MakeUnitAndPatrolRect(LGUARD, gg_rct_Rect_200, gg_rct_Rect_201)
		if RewardMode == GameModesGlobals_HARD then
			call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_207 , gg_rct_Rect_208)
		endif
		
		if RewardMode != GameModesGlobals_HARD then
			call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_202 , gg_rct_Rect_203)
		endif
	endfunction

 function IW3Stop takes nothing returns nothing
	endfunction

//library IW3 ends
//library IW4:
 function IW4Start takes nothing returns nothing
  local integer parentLevel= (IW4_LEVEL_ID)
		
		call Recycle_MakeUnitAndPatrol(LGUARD , 6911 , 9602 , 7553 , 9602)
		call Recycle_MakeUnitAndPatrol(LGUARD , 7553 , 9472 , 6911 , 9472)
		call Recycle_MakeUnitAndPatrol(LGUARD , 7170 , 8961 , 7546 , 9222)
		
		call Recycle_MakeUnitAndPatrol(GUARD , 5758 , 6918 , 5758 , 6405)
	endfunction

 function IW4Stop takes nothing returns nothing
	endfunction

//library IW4 ends
//library IW5:
 function IW5Start takes nothing returns nothing
		call Recycle_MakeUnitAndPatrol(LGUARD , 2432 , 7043 , 3072 , 6915)
		call Recycle_MakeUnitAndPatrol(LGUARD , 2179 , 6651 , 2818 , 6528)
	endfunction

 function IW5Stop takes nothing returns nothing
	endfunction

//library IW5 ends
//library IWB1:
 function IWB1Start takes nothing returns nothing
		//patrols
		
	endfunction

 function IWB1Stop takes nothing returns nothing

	endfunction

//library IWB1 ends
//library IntroWorld:
 function IntroWorld_InitializeStartableContent takes nothing returns nothing
  local integer l= (INTRO_LEVEL_ID)
		
  local integer pattern
  local integer sg
		
  local integer boundedSpoke
		
  local integer nsync
  local integer jtimber
		
		set nsync=s__SynchronizedGroup_create()
		call s__Levels_Level_AddStartable(l,nsync)
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,GUARD)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_012))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_013))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,GUARD)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_332))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_331))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		set pattern=s__LinePatternSpawn_createFromRect((2) , 1 , gg_rct_Rect_052 , TERRAIN_TILE_SIZE)
		if RewardMode == GameModesGlobals_HARD then
			set sg=s__SimpleGenerator_create(pattern , .75 , 270 , 14)
			call s__SimpleGenerator_SetMoveSpeed(sg,200.)
		else
			set sg=s__SimpleGenerator_create(pattern , 1. , 270 , 14)
			call s__SimpleGenerator_SetMoveSpeed(sg,175.)
		endif
        call s__Levels_Level_AddStartable(l,sg)
		
        set boundedSpoke=s__BoundedSpoke_create(11970 , 14465)
        set s__BoundedSpoke_InitialOffset[boundedSpoke]=2.25 * TERRAIN_TILE_SIZE
        set s__BoundedSpoke_LayerOffset[boundedSpoke]=2.25 * TERRAIN_QUADRANT_SIZE
        set s__BoundedSpoke_CurrentRotationSpeed[boundedSpoke]=bj_PI / 6. * BoundedSpoke_TIMESTEP
        call s__BoundedSpoke_AddUnits(boundedSpoke,'e00A' , 3)
        // call boundedSpoke.SetAngleBounds(bj_PI/4, bj_PI*3./4.)
		call s__BoundedSpoke_SetAngleBounds(boundedSpoke,55. / 180. * bj_PI , 125. / 180. * bj_PI)
        
		call s__Levels_Level_AddStartable(l,boundedSpoke)
		
		if RewardMode == GameModesGlobals_HARD then
			set nsync=s__SynchronizedGroup_create()
			call s__Levels_Level_AddStartable(l,nsync)
			
			set jtimber=s__SynchronizedGroup_AddUnit(nsync,LGUARD)
			call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_027))
			call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_028))
			set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
			
			set jtimber=s__SynchronizedGroup_AddUnit(nsync,LGUARD)
			call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_031))
			call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_032))
			set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
			call s__Levels_Level_AddStartable(l,s__MortarNTarget_create(SMLMORT , SMLTARG , Player(8) , gg_rct_IntroWorld_Mortar1 , gg_rct_IntroWorld_Target1))
		else
			call SetTerrainType(GetRectCenterX(gg_rct_IntroWorld_TC1), GetRectCenterY(gg_rct_IntroWorld_TC1), ABYSS, 0, 1, 0)
		endif
		
		set nsync=s__SynchronizedGroup_create()
		call s__Levels_Level_AddStartable(l,nsync)
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,GUARD)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_271))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_272))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,GUARD)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_273))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_274))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
	endfunction
	
 function IntroWorldLevelStart takes nothing returns nothing
		//patrols
		// call Recycle_MakeUnitAndPatrolRect(GUARD, gg_rct_Rect_012, gg_rct_Rect_013)
		// call Recycle_MakeUnitAndPatrolRect(GUARD, gg_rct_Region_332, gg_rct_Region_331)
		call Recycle_MakeUnitAndPatrolRect(GUARD , gg_rct_Rect_014 , gg_rct_Rect_015)
		call Recycle_MakeUnitAndPatrolRect(GUARD , gg_rct_Rect_016 , gg_rct_Rect_017)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_049 , gg_rct_Rect_050)
		
		if RewardMode != GameModesGlobals_HARD then
			call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_031 , gg_rct_Rect_032)
		endif
		
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_041 , gg_rct_Rect_042)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_040 , gg_rct_Rect_043)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_039 , gg_rct_Rect_044)
		call Recycle_MakeUnitAndPatrolRect(GUARD , gg_rct_Rect_038 , gg_rct_Rect_045)
		call Recycle_MakeUnitAndPatrolRect(GUARD , gg_rct_Rect_037 , gg_rct_Rect_046)
		
		call Recycle_MakeUnitAndPatrolRect(GUARD , gg_rct_Rect_275 , gg_rct_Rect_276)
		call Recycle_MakeUnitAndPatrolRect(ICETROLL , gg_rct_Rect_277 , gg_rct_Rect_278)
		// call Recycle_MakeUnitAndPatrolRect(LGUARD, gg_rct_Rect_271, gg_rct_Rect_272)
		// call Recycle_MakeUnitAndPatrolRect(LGUARD, gg_rct_Rect_273, gg_rct_Rect_274)
		
		if RewardMode == GameModesGlobals_HARD then
			call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_047 , gg_rct_Rect_048)
		endif
		
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_029 , gg_rct_Rect_030)
	endfunction

 function IntroWorldLevelStop takes nothing returns nothing
		
	endfunction

//library IntroWorld ends
//library LW1:
 function LW1_InitializeStartableContent takes nothing returns nothing
  local integer l= (LW1_LEVEL_ID)
		
  local integer sg
  local integer rg
		
  local integer nsync
  local integer jtimber
		
  local integer pattern
		
  local integer rand
		
		call s__FastLoad_create(l , s__SimpleList_ListNode_value[s__SimpleList_List_first[s__Levels_Level_Checkpoints[l]]] , 50. , .5)
		
		//synced patrol set
		set nsync=s__SynchronizedGroup_create()
		call s__Levels_Level_AddStartable(l,nsync)
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,GUARD)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_221))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_222))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,GUARD)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_224))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_223))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,GUARD)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_225))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_226))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,GUARD)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_228))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_227))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		//outer sync group
		set nsync=s__SynchronizedGroup_create()
		call s__Levels_Level_AddStartable(l,nsync)
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,CLAWMAN)
		set s__SynchronizedUnit_MoveSpeed[jtimber]=200
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_229))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_230))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_231))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_232))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,CLAWMAN)
		set s__SynchronizedUnit_MoveSpeed[jtimber]=200
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_231))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_232))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_229))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_230))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,CLAWMAN)
		set s__SynchronizedUnit_MoveSpeed[jtimber]=200
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_246))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_232))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_445))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_247))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,CLAWMAN)
		set s__SynchronizedUnit_MoveSpeed[jtimber]=200
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_445))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_247))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_246))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_232))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		//inner sync group A
		set nsync=s__SynchronizedGroup_create()
		call s__Levels_Level_AddStartable(l,nsync)
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,ICETROLL)
		if RewardMode == GameModesGlobals_HARD then
			set s__SynchronizedUnit_MoveSpeed[jtimber]=200
		else
			set s__SynchronizedUnit_MoveSpeed[jtimber]=150
		endif
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_233))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_234))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_235))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_236))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,ICETROLL)
		if RewardMode == GameModesGlobals_HARD then
			set s__SynchronizedUnit_MoveSpeed[jtimber]=200
		else
			set s__SynchronizedUnit_MoveSpeed[jtimber]=150
		endif
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_235))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_236))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_233))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_234))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		//inner sync group B
		set nsync=s__SynchronizedGroup_create()
		call s__Levels_Level_AddStartable(l,nsync)
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,ICETROLL)
		if RewardMode == GameModesGlobals_HARD then
			set s__SynchronizedUnit_MoveSpeed[jtimber]=200
		else
			set s__SynchronizedUnit_MoveSpeed[jtimber]=150
		endif
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_442))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_441))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_440))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_439))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,ICETROLL)
		if RewardMode == GameModesGlobals_HARD then
			set s__SynchronizedUnit_MoveSpeed[jtimber]=200
		else
			set s__SynchronizedUnit_MoveSpeed[jtimber]=150
		endif
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_440))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_439))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_442))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_441))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		//width 3 behavior diagonal cross
		set pattern=s__LinePatternSpawn_createFromRect((3) , 4 , gg_rct_LW1_Generator1 , TERRAIN_TILE_SIZE)
		set s__PatternSpawn_Data[pattern]=ICETROLL
		set sg=s__SimpleGenerator_create(pattern , 2. , 270 , 21)
		call s__SimpleGenerator_SetMoveSpeed(sg,150.)
		call s__Levels_Level_AddStartable(l,sg)
		
		//gateways
		call s__Levels_Level_AddStartable(l,s__RespawningGateway_CreateFromVectors(RFIRE , s__vector2_createFromRect(gg_rct_Region_451) , s__vector2_createFromRect(gg_rct_Region_446) , 1 * 15))
		call s__Levels_Level_AddStartable(l,s__RespawningGateway_CreateFromVectors(RFIRE , s__vector2_createFromRect(gg_rct_Region_452) , s__vector2_createFromRect(gg_rct_Region_447) , 10 * 60))
		call s__Levels_Level_AddStartable(l,s__RespawningGateway_CreateFromVectors(BFIRE , s__vector2_createFromRect(gg_rct_Region_453) , s__vector2_createFromRect(gg_rct_Region_448) , 2 * 60))
		call s__Levels_Level_AddStartable(l,s__RespawningGateway_CreateFromVectors(RFIRE , s__vector2_createFromRect(gg_rct_Region_454) , s__vector2_createFromRect(gg_rct_Region_449) , 2 * 60))
		call s__Levels_Level_AddStartable(l,s__RespawningGateway_CreateFromVectors(BFIRE , s__vector2_createFromRect(gg_rct_Region_455) , s__vector2_createFromRect(gg_rct_Region_450) , 2 * 60))
		
		//********checkpoint 2
		call s__Levels_Level_AddStartable(l,s__RespawningGateway_CreateFromVectors(RFIRE , s__vector2_createFromRect(gg_rct_Region_483) , s__vector2_createFromRect(gg_rct_Region_438) , 5 * 60))
		call s__Levels_Level_AddStartable(l,s__RespawningGateway_CreateFromVectors(BFIRE , s__vector2_createFromRect(gg_rct_Region_484) , s__vector2_createFromRect(gg_rct_Region_479) , 5 * 60))
		call s__Levels_Level_AddStartable(l,s__RespawningGateway_CreateFromVectors(RFIRE , s__vector2_createFromRect(gg_rct_Region_485) , s__vector2_createFromRect(gg_rct_Region_480) , 5 * 60))
		call s__Levels_Level_AddStartable(l,s__RespawningGateway_CreateFromVectors(BFIRE , s__vector2_createFromRect(gg_rct_Region_486) , s__vector2_createFromRect(gg_rct_Region_481) , 5 * 60))
		
		if RewardMode == GameModesGlobals_HARD then
			call s__Levels_Level_AddStartable(l,s__RespawningGateway_CreateFromVectors(RFIRE , s__vector2_createFromRect(gg_rct_Region_487) , s__vector2_createFromRect(gg_rct_Region_482) , 5 * 60))
		else
			//x, y, ttype, variation (-1 : random), radius, shape (0 : circ, 1 : rect)
			call SetTerrainType(- 9984, - 13432, ABYSS, 0, 4, 1)
			call SetTerrainType(- 9092, - 13432, ABYSS, 0, 6, 1)
			
			call SetTerrainType(- 9602, - 14718, NOEFFECT, 0, 1, 1)
			call SetTerrainType(- 9602, - 14846, ABYSS, 0, 1, 1)
			
			call SetTerrainType(- 9602, - 15738, NOEFFECT, 0, 1, 1)
		endif
		
		//width 4 spawn
		set pattern=s__LinePatternSpawn_createFromRect((4) , 5 , gg_rct_LW1_Generator2 , TERRAIN_TILE_SIZE)
		set s__PatternSpawn_CycleVariations[pattern]=3
		set sg=s__SimpleGenerator_create(pattern , 2.2 , 90 , 22)
		if RewardMode == GameModesGlobals_HARD then
			set s__SimpleGenerator_SpawnTimeStep[sg]=1.8
			call s__SimpleGenerator_SetMoveSpeed(sg,175.)
		else
			call s__SimpleGenerator_SetMoveSpeed(sg,150.)
		endif
		
		call s__Levels_Level_AddStartable(l,sg)
		
		//width 3 spawn
		set pattern=s__LinePatternSpawn_createFromRect((5) , 3 , gg_rct_LW1_Generator3 , TERRAIN_TILE_SIZE)
		set s__PatternSpawn_CycleVariations[pattern]=4
		set sg=s__SimpleGenerator_create(pattern , 1.4 , 270 , 16)
		call s__SimpleGenerator_SetMoveSpeed(sg,350.)
		call s__Levels_Level_AddStartable(l,sg)
		
		//standard simple generators
		set pattern=s__LinePatternSpawn_createFromPoint((6) , 1 , gg_rct_LW1_Generator4)
		set s__PatternSpawn_Data[pattern]=SPIRITWALKER
		set sg=s__SimpleGenerator_create(pattern , 5 , 270 , 14)
		call s__SimpleGenerator_SetMoveSpeed(sg,270.)
		call s__Levels_Level_AddStartable(l,sg)
		
		if RewardMode == GameModesGlobals_HARD then
			set pattern=s__LinePatternSpawn_createFromPoint((6) , 1 , gg_rct_LW1_Generator6)
			set s__PatternSpawn_Data[pattern]=SPIRITWALKER
			set sg=s__SimpleGenerator_create(pattern , 5 , 270 , 22)
			call s__SimpleGenerator_SetMoveSpeed(sg,200.)
			call s__Levels_Level_AddStartable(l,sg)
		endif
		
		//synced patrol set
		set nsync=s__SynchronizedGroup_create()
		call s__Levels_Level_AddStartable(l,nsync)
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,GUARD)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_237))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_238))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,GUARD)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_239))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_240))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,GUARD)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_241))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Rect_242))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		//terrain changes below teleport area
		if RewardMode == GameModesGlobals_HARD then
			set rand=s__Levels_Level_GetWeightedRandomInt(l,0 , 9)
			
			if rand > 0 then
				//x, y, ttype, variation (-1 : random), radius, shape (0 : circ, 1 : rect)
				call SetTerrainType(- 9992, - 14578, ABYSS, 0, 1, 1)
			endif
			if rand > 4 then
				call SetTerrainType(- 9728, - 14838, ABYSS, 0, 1, 1)
			endif
			if rand > 8 then
				call SetTerrainType(- 9992, - 15098, ABYSS, 0, 1, 1)
			endif
		endif
		
		//sync movement below teleport area
		//left & right
		set nsync=s__SynchronizedGroup_create()
		call s__Levels_Level_AddStartable(l,nsync)
		
		//left sync group
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,ICETROLL)
		if RewardMode == GameModesGlobals_HARD then
			set s__SynchronizedUnit_MoveSpeed[jtimber]=180
		else
			set s__SynchronizedUnit_MoveSpeed[jtimber]=160
		endif
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_456))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_464))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_463))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_459))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		//right sync group		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,ICETROLL)
		if RewardMode == GameModesGlobals_HARD then
			set s__SynchronizedUnit_MoveSpeed[jtimber]=180
		else
			set s__SynchronizedUnit_MoveSpeed[jtimber]=160
		endif
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_463))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_459))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_456))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_464))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		//top & bottom
		set nsync=s__SynchronizedGroup_create()
		call s__Levels_Level_AddStartable(l,nsync)
		
		//top sync group
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,CLAWMAN)
		if RewardMode == GameModesGlobals_HARD then
			set s__SynchronizedUnit_MoveSpeed[jtimber]=360
		else
			set s__SynchronizedUnit_MoveSpeed[jtimber]=320
		endif
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_467))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_462))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_461))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_466))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
				
		//bottom sync group		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,CLAWMAN)
		if RewardMode == GameModesGlobals_HARD then
			set s__SynchronizedUnit_MoveSpeed[jtimber]=360
		else
			set s__SynchronizedUnit_MoveSpeed[jtimber]=320
		endif
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_461))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_466))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_467))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_462))
		
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		//sync movement near gate
		//outer sync group
		set nsync=s__SynchronizedGroup_create()
		call s__Levels_Level_AddStartable(l,nsync)
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,CLAWMAN)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_476))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_477))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_478))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_479))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,CLAWMAN)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_478))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_479))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_476))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_477))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		//inner sync group
		//left unit
		set nsync=s__SynchronizedGroup_create()
		call s__Levels_Level_AddStartable(l,nsync)
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,ICETROLL)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_469))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_468))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_471))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_470))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		//center unit
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,ICETROLL)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_472))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_473))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_469))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_468))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		//right unit
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,ICETROLL)
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_474))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_475))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_472))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_Region_473))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
	endfunction
	
 function LW1Start takes nothing returns nothing
  local integer parentLevel= (LW1_LEVEL_ID)
		
		//patrols
		//P1
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_209 , gg_rct_Rect_210)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_212 , gg_rct_Rect_211)
		
		call Recycle_MakeUnitAndPatrolRect(GUARD , gg_rct_Rect_213 , gg_rct_Rect_214)
		call Recycle_MakeUnitAndPatrolRect(GUARD , gg_rct_Rect_216 , gg_rct_Rect_215)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_217 , gg_rct_Rect_218)
		call Recycle_MakeUnitAndPatrolRect(GUARD , gg_rct_Rect_219 , gg_rct_Rect_220)
		
		// call Recycle_MakeUnitAndPatrolRect(GUARD, gg_rct_Rect_221, gg_rct_Rect_222)
		// call Recycle_MakeUnitAndPatrolRect(GUARD, gg_rct_Rect_224, gg_rct_Rect_223)
		// call Recycle_MakeUnitAndPatrolRect(GUARD, gg_rct_Rect_225, gg_rct_Rect_226)
		// call Recycle_MakeUnitAndPatrolRect(GUARD, gg_rct_Rect_228, gg_rct_Rect_227)
		
		//call CreateMortarCenterRect(SMLMORT, Player(10), gg_rct_Rect_247, gg_rct_Rect_246)
		
		// call Recycle_MakeUnitAndPatrolRect(GUARD, gg_rct_Rect_237, gg_rct_Rect_238)
		// call Recycle_MakeUnitAndPatrolRect(GUARD, gg_rct_Rect_239, gg_rct_Rect_240)
		// call Recycle_MakeUnitAndPatrolRect(GUARD, gg_rct_Rect_241, gg_rct_Rect_242)
			
		//turn on periodic functions
		//call EnableTrigger(gg_trg_LW1_MassCreate)
	endfunction

 function LW1Stop takes nothing returns nothing
		//call DisableTrigger(gg_trg_LW1_MassCreate)
	endfunction

//library LW1 ends
//library LW2:
 function LW2_InitializeStartableContent takes nothing returns nothing
  local integer l= (LW2_LEVEL_ID)
		
  local integer rg
		
  local integer nsync
  local integer jtimber
		
  local integer collectibleSet
  local integer collectible
		
  local integer wheel
		
  local integer lastRand
  local integer i
		
		//collect all 3 to beat the level
		set collectibleSet=s__CollectibleSet_create(l , (6))
		
		set collectible=s__Collectible_createFromPoint(ORANGEFROG , gg_rct_LW2_C1 , 270)
		// call SetUnitX(collectible.CollectedUnit, GetRectCenterX(gg_rct_LW2_C1b))
		// call SetUnitY(collectible.CollectedUnit, GetRectCenterY(gg_rct_LW2_C1b))
		// call SetUnitPosition(collectible.CollectedUnit, GetRectCenterX(gg_rct_LW2_C1b), GetRectCenterY(gg_rct_LW2_C1b))
		call s__SimpleList_List_addEnd(s__CollectibleSet_Collectibles[(collectibleSet)],(collectible)) // INLINED!!
		
		set collectible=s__Collectible_createFromPoint(GREENFROG , gg_rct_LW2_C2 , 180)
		//set collectible.ReturnToCheckpoint = true
		call s__SimpleList_List_addEnd(s__CollectibleSet_Collectibles[(collectibleSet)],(collectible)) // INLINED!!
		
		if RewardMode == GameModesGlobals_HARD then
			set collectible=s__Collectible_createFromPoint(PURPLEFROG , gg_rct_LW2_WW3 , 90)
		else
			set collectible=s__Collectible_createFromPoint(PURPLEFROG , gg_rct_LW2_WW2 , 270)
		endif
		//set collectible.ReturnToCheckpoint = true
		call s__SimpleList_List_addEnd(s__CollectibleSet_Collectibles[(collectibleSet)],(collectible)) // INLINED!!
		
		set collectible=s__Collectible_createFromPoint(REDFROG , gg_rct_LW2_C4 , 180)
		//set collectible.ReturnToCheckpoint = true
		call s__SimpleList_List_addEnd(s__CollectibleSet_Collectibles[(collectibleSet)],(collectible)) // INLINED!!
		
		set collectible=s__Collectible_createFromPoint(TURQOISEFROG , gg_rct_LW2_C5 , 0)
		//set collectible.ReturnToCheckpoint = true
		call s__SimpleList_List_addEnd(s__CollectibleSet_Collectibles[(collectibleSet)],(collectible)) // INLINED!!
				
		call s__FastLoad_create(l , s__SimpleList_ListNode_value[s__SimpleList_List_first[s__Levels_Level_Checkpoints[l]]] , 30. , 1.)
		
		//
		set wheel=s__Wheel_createFromPoint(gg_rct_LW2_WW1)
		
        set s__Wheel_AngleBetween[wheel]=bj_PI
		set s__Wheel_DistanceBetween[wheel]=.5 * TERRAIN_TILE_SIZE
		set s__Wheel_SpokeCount[wheel]=2
		
		if RewardMode == GameModesGlobals_HARD then
			set s__Wheel_RotationSpeed[wheel]=bj_PI / 1.45 * Wheel_TIMEOUT
			set s__Wheel_InitialOffset[wheel]=.7 * TERRAIN_TILE_SIZE
			set s__Wheel_LayerCount[wheel]=7
			call s__Wheel_AddUnits(wheel,WWWISP , 14)
		else
			set s__Wheel_RotationSpeed[wheel]=bj_PI / 1.55 * Wheel_TIMEOUT
			set s__Wheel_InitialOffset[wheel]=TERRAIN_TILE_SIZE
			set s__Wheel_LayerCount[wheel]=6
			call s__Wheel_AddUnits(wheel,WWWISP , 12)
		endif
		
		call s__Levels_Level_AddStartable(l,wheel)
		
		//
		set wheel=s__Wheel_createFromPoint(gg_rct_LW2_WW2)
		set s__Wheel_AngleBetween[wheel]=bj_PI
		set s__Wheel_RotationSpeed[wheel]=bj_PI / 1.5 * Wheel_TIMEOUT
		set s__Wheel_DistanceBetween[wheel]=.45 * TERRAIN_TILE_SIZE
		set s__Wheel_SpokeCount[wheel]=2
		
		if RewardMode == GameModesGlobals_HARD then
			set s__Wheel_InitialOffset[wheel]=.5 * TERRAIN_TILE_SIZE
			set s__Wheel_LayerCount[wheel]=7
			call s__Wheel_AddUnits(wheel,WWWISP , 14)
		else
			set s__Wheel_InitialOffset[wheel]=1.5 * TERRAIN_TILE_SIZE
			set s__Wheel_LayerCount[wheel]=5
			call s__Wheel_AddUnits(wheel,WWWISP , 10)
		endif
		
		call s__Levels_Level_AddStartable(l,wheel)
		
		if RewardMode == GameModesGlobals_HARD then
			//outer shell
			set wheel=s__Wheel_createFromPoint(gg_rct_LW2_WW3)
			set s__Wheel_LayerCount[wheel]=1
			set s__Wheel_InitialOffset[wheel]=3.25 * TERRAIN_TILE_SIZE
			//C = 2*pi*r = 2*pi*wheel.DistanceBetween = 2411.52
			//dist between = C / (GetUnitDefaultRadius(WWWISP) * 2) = (pi*wheel.DistanceBetween) / GetUnitDefaultRadius(WWWISP) = 64
			//% circ = (2*GetUnitDefaultRadius(WWWISP)) / C
			//angle between = % circ * 2 * bj_PI
			set s__Wheel_AngleBetween[wheel]=10 * bj_PI / 180
			set s__Wheel_SpokeCount[wheel]=R2I(( 2 * bj_PI / s__Wheel_AngleBetween[wheel] ) + .5)
			set s__Wheel_RotationSpeed[wheel]=bj_PI / 5 * Wheel_TIMEOUT
			
			set i=( s__Wheel_SpokeCount[wheel] - 12 ) / 2
			call s__Wheel_AddUnits(wheel,WWWISP , i)
			call s__Wheel_AddEmptySpace(wheel,5)
			call s__Wheel_AddUnits(wheel,WWWISP , i)
			call s__Wheel_AddEmptySpace(wheel,5)
			
			call s__Levels_Level_AddStartable(l,wheel)
			
			//inner shell
			set wheel=s__Wheel_createFromPoint(gg_rct_LW2_WW3)
			set s__Wheel_LayerCount[wheel]=1
			set s__Wheel_InitialOffset[wheel]=1.25 * TERRAIN_TILE_SIZE
			set s__Wheel_AngleBetween[wheel]=15 * bj_PI / 180
			set s__Wheel_SpokeCount[wheel]=R2I(( 2 * bj_PI / s__Wheel_AngleBetween[wheel] ) + .5)
			set s__Wheel_RotationSpeed[wheel]=bj_PI / 5 * Wheel_TIMEOUT
			
			//facing right
			// call wheel.AddEmptySpace(2)
			// call wheel.AddUnits(WWWISP, wheel.SpokeCount - 4)
			
			//facing ?
			set i=R2I(( s__Wheel_SpokeCount[wheel] - 4 ) / ( bj_PI * 1.5 ))
			// call wheel.AddUnits(WWWISP, i)
			// call wheel.AddEmptySpace(4)
			// call wheel.AddUnits(WWWISP, i)
			call s__Wheel_SetInitialAngle(wheel,.5 * bj_PI)
			call s__Wheel_AddEmptySpace(wheel,2)
			call s__Wheel_AddUnits(wheel,WWWISP , s__Wheel_SpokeCount[wheel] - 4)
			// call wheel.AddEmptySpace(3)
			// call wheel.AddUnits(WWWISP, i)
			// keep this wheel static, dont start/stop it
			//call l.AddStartable(wheel)
			
			//even odd inbetween
			set wheel=s__Wheel_createFromPoint(gg_rct_LW2_WW3)
			set s__Wheel_LayerCount[wheel]=2
			set s__Wheel_DistanceBetween[wheel]=1 * TERRAIN_TILE_SIZE
			set s__Wheel_InitialOffset[wheel]=1.75 * TERRAIN_TILE_SIZE
			set s__Wheel_AngleBetween[wheel]=45 * bj_PI / 180
			set s__Wheel_SpokeCount[wheel]=R2I(( 2 * bj_PI / s__Wheel_AngleBetween[wheel] ) + .5)
			set s__Wheel_RotationSpeed[wheel]=bj_PI / 5 * Wheel_TIMEOUT
			
			set i=s__Wheel_SpokeCount[wheel]
			loop
			exitwhen i <= 1
				call s__Wheel_AddEmptySpace(wheel,1)
				call s__Wheel_AddUnits(wheel,WWWISP , 1)
			set i=i - 2
			endloop
			set i=s__Wheel_SpokeCount[wheel]
			loop
			exitwhen i <= 1
				call s__Wheel_AddUnits(wheel,WWWISP , 1)
				call s__Wheel_AddEmptySpace(wheel,1)
			set i=i - 2
			endloop
			
			call s__Levels_Level_AddStartable(l,wheel)
		else
			call SetTerrainType(GetRectCenterX(gg_rct_LW2_WW3), GetRectCenterY(gg_rct_LW2_WW3), ABYSS, 0, 4, 1)
		endif
		
		set rg=s__RelayGenerator_createFromPoint(gg_rct_LW2_RG1 , 3 , 3 , 270 , 38 , 1.75 , (7) , 6)
		// call rg.AddTurnSimple(180, 4)
		// call rg.AddTurnSimple(270, 26)
		call s__RelayGenerator_EndTurns(rg,270)
		
		call s__Levels_Level_AddStartable(l,rg)
		
		set rg=s__RelayGenerator_createFromPoint(gg_rct_LW2_RG2 , 2 , 2 , 90 , 26 , 1.75 , (8) , 4)
		call s__RelayGenerator_AddTurnSimple(rg,0 , 7)
		call s__RelayGenerator_AddTurnSimple(rg,270 , 26)
		call s__RelayGenerator_EndTurns(rg,270)
		
		call s__Levels_Level_AddStartable(l,rg)
		
		//TODO replace with SimpleGenerator
		set rg=s__RelayGenerator_createFromPoint(gg_rct_LW2_RG3 , 2 , 2 , 270 , 44 , 1.25 , (9) , 4)
		call s__RelayGenerator_EndTurns(rg,270)
		
		call s__Levels_Level_AddStartable(l,rg)
		
		//MS = 2. * TERRAIN_TILE_SIZE
		set rg=s__RelayGenerator_createFromPoint(gg_rct_LW2_RG4 , 2 , 2 , 180 , 5 , .666 , (10) , 5)
		if RewardMode == GameModesGlobals_HARD then
			set s__PatternSpawn_CycleCount[s__RelayPatternSpawn_Pattern[s__RelayGenerator_SpawnPattern[rg]]]=4
		endif
		call s__RelayGenerator_AddTurnSimple(rg,90 , 22)
		call s__RelayGenerator_EndTurns(rg,90)
		
		call s__Levels_Level_AddStartable(l,rg)
		
		//bottom outer
		set nsync=s__SynchronizedGroup_create()
		call s__Levels_Level_AddStartable(l,nsync)
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,CLAWMAN)
		set s__SynchronizedUnit_MoveSpeed[jtimber]=500
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG1_2))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG1_1))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG1_4))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG1_3))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,CLAWMAN)
		set s__SynchronizedUnit_MoveSpeed[jtimber]=500
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG1_4))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG1_3))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG1_2))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG1_1))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		//top outer
		set nsync=s__SynchronizedGroup_create()
		call s__Levels_Level_AddStartable(l,nsync)
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,CLAWMAN)
		set s__SynchronizedUnit_MoveSpeed[jtimber]=375
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG3_1))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG3_4))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG3_3))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG3_2))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,CLAWMAN)
		set s__SynchronizedUnit_MoveSpeed[jtimber]=375
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG3_3))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG3_2))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG3_1))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG3_4))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		//bottom inner
		set nsync=s__SynchronizedGroup_create()
		call s__Levels_Level_AddStartable(l,nsync)
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,ICETROLL)
		set s__SynchronizedUnit_MoveSpeed[jtimber]=375
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG2_2))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG2_3))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG2_4))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG2_1))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,ICETROLL)
		set s__SynchronizedUnit_MoveSpeed[jtimber]=375
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG2_4))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG2_1))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG2_2))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG2_3))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		//top inner
		set nsync=s__SynchronizedGroup_create()
		call s__Levels_Level_AddStartable(l,nsync)
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,ICETROLL)
		set s__SynchronizedUnit_MoveSpeed[jtimber]=250
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG4_4))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG4_1))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG4_2))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG4_3))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		set jtimber=s__SynchronizedGroup_AddUnit(nsync,ICETROLL)
		set s__SynchronizedUnit_MoveSpeed[jtimber]=250
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG4_2))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG4_3))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG4_4))
		call s__SimpleList_List_addEnd(s__SynchronizedUnit_AllOrders[jtimber],s__vector2_createFromRect(gg_rct_LW2_SG4_1))
		set s__SimpleList_ListNode_next[s__SimpleList_List_last[s__SynchronizedUnit_AllOrders[jtimber]]]=s__SimpleList_List_first[s__SynchronizedUnit_AllOrders[jtimber]]
		
		//mortars
		if RewardMode == GameModesGlobals_HARD then
			set i=s__Levels_Level_GetWeightedRandomInt(l,3 , 5)
			set lastRand=i
		else
			set i=3
		endif
		loop
		exitwhen i == 0
			call s__Levels_Level_AddStartable(l,s__MortarNTarget_create(SMLMORT , SMLTARG , Player(8) , gg_rct_LW2_Mortar1 , gg_rct_LW2_Target1))
		set i=i - 1
		endloop
		
		if RewardMode == GameModesGlobals_HARD then
			set i=s__Levels_Level_GetWeightedRandomInt(l,lastRand , 6)
			set lastRand=i
		else
			set i=4
		endif
		loop
		exitwhen i == 0
			call s__Levels_Level_AddStartable(l,s__MortarNTarget_create(SMLMORT , SMLTARG , Player(8) , gg_rct_LW2_Mortar2 , gg_rct_LW2_Target2))
		set i=i - 1
		endloop
		
		if RewardMode == GameModesGlobals_HARD then
			set i=s__Levels_Level_GetWeightedRandomInt(l,lastRand , 8)
			set lastRand=i
		else
			set i=6
		endif
		loop
		exitwhen i == 0
			call s__Levels_Level_AddStartable(l,s__MortarNTarget_create(SMLMORT , SMLTARG , Player(8) , gg_rct_LW2_Mortar3 , gg_rct_LW2_Target3))
		set i=i - 1
		endloop
	endfunction
	
 function LW2Start takes nothing returns nothing
  local integer parentLevel= (LW2_LEVEL_ID)
		
		//patrols
		//P1
		if RewardMode == GameModesGlobals_HARD then
			call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_LW2_P1_1 , gg_rct_LW2_P1_2)
		endif
		
		//create single units

		//create regular mortars
		
		//unpause MnT's
		
		//unpause wisp wheels
		
		//turn on periodic functions
		
	endfunction

 function LW2Stop takes nothing returns nothing

	endfunction

//library LW2 ends
//library Minigame:
	
		
  function s__Minigame_TransferAllTeams takes integer this returns nothing
   local integer curTeamNode= s__SimpleList_List_first[s__Teams_MazingTeam_AllTeams]
   local integer save
			
			loop
			exitwhen curTeamNode == 0
				set save=s__TeamSaveLocation_GetFirstSaveForTeam(Minigame___MINIGAME_SAVE_NAME , s__SimpleList_ListNode_value[curTeamNode])
				if save != 0 then
					call s__TeamSaveLocation_destroy(save)
				endif
				
				//save original location
				call s__TeamSaveLocation_create(Minigame___MINIGAME_SAVE_NAME , s__SimpleList_ListNode_value[curTeamNode])
				
				//switch to minigame
				call s__Levels_Level_SwitchLevels(s__Teams_MazingTeam_OnLevel[(s__SimpleList_ListNode_value[curTeamNode])],this , s__SimpleList_ListNode_value[curTeamNode] , 0 , false)
			set curTeamNode=s__SimpleList_ListNode_next[curTeamNode]
			endloop
			
			//hide multiboard
			call MultiboardDisplay(s__Teams_MazingTeam_PlayerStats, false)
			//show leaderboard with level name as title
			call LeaderboardSetLabel(s__Minigame_Scores, s__Levels_Level_Name[(this)])
			call LeaderboardDisplay(s__Minigame_Scores, true)
  endfunction
  function s__Minigame_ResetAllTeams takes integer this returns nothing
   local integer curTeamNode= s__SimpleList_List_first[s__Teams_MazingTeam_AllTeams]
   local integer save
			
			loop
			exitwhen curTeamNode == 0
				set save=s__TeamSaveLocation_GetFirstSaveForTeam(Minigame___MINIGAME_SAVE_NAME , s__SimpleList_ListNode_value[curTeamNode])
				if save != 0 then
					call s__TeamSaveLocation_Restore(save)
					
					call s__TeamSaveLocation_destroy(save)
				endif
			set curTeamNode=s__SimpleList_ListNode_next[curTeamNode]
			endloop
			
			//show multiboard
			call MultiboardDisplay(s__Teams_MazingTeam_PlayerStats, true)
			//hide leaderboard
			call LeaderboardDisplay(s__Minigame_Scores, false)
  endfunction
		
  function s__Minigame_create takes integer levelID,string name,string startFunction,string stopFunction,rect revive,rect vision returns integer
			//default parameters in order: rawContinues, rawScore, levelEnd, previousLevel
   local integer new= s__Levels_Level_create(levelID , name , 0 , 0 , startFunction , stopFunction , revive , vision , null , 0)
			
			return new
  endfunction
		
  function s__Minigame_onInit takes nothing returns nothing
			set s__Minigame_Scores=CreateLeaderboard()
  endfunction

//library Minigame ends
//library PW1:
 function PW1Start takes nothing returns nothing
  local integer parentLevel= (PW1_LEVEL_ID)
		
		//cp 0
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_284 , gg_rct_Rect_285)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_288 , gg_rct_Rect_289)
		//cp 1
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_299 , gg_rct_Rect_300)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_293 , gg_rct_Rect_294)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_295 , gg_rct_Rect_296)
		
		call Recycle_MakeUnitAndPatrolRect(GUARD , gg_rct_Rect_292 , gg_rct_Rect_291)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_298 , gg_rct_Rect_297)
		call Recycle_MakeUnitAndPatrolRect(GUARD , gg_rct_Rect_311 , gg_rct_Rect_312)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_303 , gg_rct_Rect_304)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_306 , gg_rct_Rect_305)
		//after fall
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_313 , gg_rct_Rect_314)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_314 , gg_rct_Rect_315)
		//right
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_319 , gg_rct_Rect_320)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_321 , gg_rct_Rect_322)
		call Recycle_MakeUnitAndPatrolRect(GUARD , gg_rct_Rect_343 , gg_rct_Rect_344)
		//left
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_327 , gg_rct_Rect_328)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_335 , gg_rct_Rect_336)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_337 , gg_rct_Rect_338)
	endfunction

 function PW1Stop takes nothing returns nothing
	endfunction

//library PW1 ends
//library PW2:
 function PW2Start takes nothing returns nothing
  local integer parentLevel= (PW2_LEVEL_ID)
		
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_357 , gg_rct_Rect_360)
		call Recycle_MakeUnitAndPatrolRect(LGUARD , gg_rct_Rect_358 , gg_rct_Rect_359)
	endfunction

 function PW2Stop takes nothing returns nothing
	endfunction

//library PW2 ends
//library PW3:
 function PW3TeamStart takes nothing returns nothing
		//local Teams_MazingTeam mt = Levels_Level.CBTeam
		
		//call mt.SetPlatformerProfile(PlatformerProfile_CrazyIceProfileID)
	endfunction

 function PW3TeamStop takes nothing returns nothing
		//local Teams_MazingTeam mt = Levels_Level.CBTeam
		
		//call mt.SetPlatformerProfile(PlatformerProfile_DefaultProfileID)
	endfunction

 function PW3Start takes nothing returns nothing
  local integer parentLevel= (PW3_LEVEL_ID)
		
	endfunction

 function PW3Stop takes nothing returns nothing

	endfunction

//library PW3 ends
//library PW4:
 function PW4TeamStart takes nothing returns nothing
  local integer mt= s__Levels_Level_CBTeam
		
		call s__Teams_MazingTeam_SetPlatformerProfile(mt,PlatformerProfile_MoonProfileID)
	endfunction

 function PW4TeamStop takes nothing returns nothing
  local integer mt= s__Levels_Level_CBTeam
		
		call s__Teams_MazingTeam_SetPlatformerProfile(mt,PlatformerProfile_DefaultProfileID)
	endfunction

 function PW4Start takes nothing returns nothing
  local integer parentLevel= (PW4_LEVEL_ID)
		
		
	endfunction

 function PW4Stop takes nothing returns nothing

	endfunction

//library PW4 ends
//library EDWLevels:
 function EDWLevels_Initialize takes nothing returns nothing
  local integer l
  local integer cp
		
		//FIRST LEVEL INITS HARD CODED
        set l=s__Levels_Level_create(INTRO_LEVEL_ID , "???" , 0 , 0 , "IntroWorldLevelStart" , "IntroWorldLevelStop" , gg_rct_IntroWorld_R1 , gg_rct_IntroWorld_Vision , gg_rct_IntroWorld_End , 0)
        call s__Levels_Level_AddCheckpoint(l,gg_rct_IntroWorldCP_1_1 , gg_rct_IntroWorld_R2)
        call s__Levels_Level_AddCheckpoint(l,gg_rct_IntroWorldCP_1_2a , gg_rct_IntroWorld_R3a)
        call s__Levels_Level_AddCheckpoint(l,gg_rct_IntroWorldCP_1_2 , gg_rct_IntroWorld_R3)
		
		//DOORS HARD CODED
        set l=s__Levels_Level_CreateDoors(l , null , null , gg_rct_HubWorld_R , gg_rct_HubWorld_Vision)
		call s__RectList_addEnd(s__Levels_Level_Boundaries[l],gg_rct_HubWorld_Vision2)
		call s__RectList_addEnd(s__Levels_Level_Boundaries[l],gg_rct_HubWorld_Vision3)
		call s__RectList_addEnd(s__Levels_Level_Boundaries[l],gg_rct_HubWorld_Vision4)
		call s__RectList_addEnd(s__Levels_Level_Boundaries[l],gg_rct_HubWorld_Vision5)
        
        //ICE WORLD TECH / ENVY WORLD
        //LEVEL 1
        set l=s__Levels_Level_create(IW1_LEVEL_ID , "Cruise Control" , 3 , 2 , "IW1Start" , "IW1Stop" , gg_rct_IWR_1_1 , gg_rct_IW1_Vision , gg_rct_IW1_End , 0)
        call s__Levels_Level_AddCheckpoint(l,gg_rct_IWCP_1_1 , gg_rct_IWR_1_2)
		
		//LEVEL 2
        set l=s__Levels_Level_create(IW2_LEVEL_ID , "Jesus on Wheel" , 4 , 3 , "IW2Start" , "IW2Stop" , gg_rct_IWR_2_1 , gg_rct_IW2_Vision , gg_rct_IW2_End , l)
        call s__Levels_Level_AddCheckpoint(l,gg_rct_IWCP_2_1 , gg_rct_IWR_2_2)
        call s__Levels_Level_AddCheckpoint(l,gg_rct_IWCP_2_2 , gg_rct_IWR_2_3)
		
		//LEVEL 3
        set l=s__Levels_Level_create(IW3_LEVEL_ID , "Illidan Goes Skiing" , 6 , 6 , "IW3Start" , "IW3Stop" , gg_rct_IWR_3_1 , gg_rct_IW3_Vision , gg_rct_IW3_End , l)
        call s__Levels_Level_AddCheckpoint(l,gg_rct_IWCP_3_1 , gg_rct_IWR_3_2)
        call s__Levels_Level_AddCheckpoint(l,gg_rct_IWCP_3_2 , gg_rct_IWR_3_3)
        call s__Levels_Level_AddCheckpoint(l,gg_rct_IWCP_3_3 , gg_rct_IWR_3_4)
		
		//LEVEL 4
        set l=s__Levels_Level_create(IW4_LEVEL_ID , "Hard Angles" , 6 , 4 , "IW4Start" , "IW4Stop" , gg_rct_IWR_4_1 , gg_rct_IW4_Vision , gg_rct_IW4_End , l)
        set cp=s__Levels_Level_AddCheckpoint(l,gg_rct_IWCP_4_1 , gg_rct_IWR_4_2)
        set s__Checkpoint_DefaultColor[cp]=KEY_RED
        call s__Levels_Level_AddCheckpoint(l,gg_rct_IWCP_4_2 , gg_rct_IWR_4_3)
		
		//LEVEL 5
		if CONFIGURATION_PROFILE != RELEASE then
			set l=s__Levels_Level_create(IW5_LEVEL_ID , "Frosty" , 4 , 4 , "IW5Start" , "IW5Stop" , gg_rct_IWR_5_1 , gg_rct_IW5_Vision , gg_rct_IW5_End , l)
			call s__Levels_Level_AddCheckpoint(l,gg_rct_IWCP_5_1 , gg_rct_IWR_5_2)
        endif
		
		//ICE WORLD B
		//LEVEL 1
		set l=s__Levels_Level_create(IWB1_LEVEL_ID , "Training Wheels" , 4 , 2 , "IWB1Start" , "IWB1Stop" , gg_rct_EIWR_1_1 , gg_rct_EIW1_Vision , gg_rct_EIW1_End , 0)
        call s__Levels_Level_AddCheckpoint(l,gg_rct_EIWCP_1_1 , gg_rct_EIWR_1_2)
		
		//LAND WORLD A
		//LEVEL 1
		set l=s__Levels_Level_create(LW1_LEVEL_ID , "Need For Speed" , 3 , 3 , "LW1Start" , "LW1Stop" , gg_rct_LWR_1_1 , gg_rct_LW1_Vision , gg_rct_LW1_End , 0)
		call s__Levels_Level_AddCheckpoint(l,gg_rct_LWCP_1_1 , gg_rct_LWR_1_2)
		
		//LEVEL 2
		set l=s__Levels_Level_create(LW2_LEVEL_ID , "Monday Commute" , 3 , 3 , "LW2Start" , "LW2Stop" , gg_rct_LWR_2_1 , gg_rct_LW2_Vision , gg_rct_LW2_End , l)
		set s__Levels_Level_MaxCollisionSize[l]=300.
		
		//PRIDE WORLD / PLATFORMING
        //LEVEL 1
        set l=s__Levels_Level_create(PW1_LEVEL_ID , "Perspective" , 4 , 2 , "PW1Start" , "PW1Stop" , gg_rct_PWR_1_1 , gg_rct_PW1_Vision , gg_rct_PW1_End , 0) //gg_rct_PW1_Vision
        set cp=s__Levels_Level_AddCheckpoint(l,gg_rct_PWCP_1_1 , gg_rct_PWR_1_2)
		set s__Checkpoint_DefaultGameMode[cp]=Teams_GAMEMODE_PLATFORMING
		
        set cp=s__Levels_Level_AddCheckpoint(l,gg_rct_PWCP_1_2 , gg_rct_PWR_1_3)
        set s__Checkpoint_DefaultGameMode[cp]=Teams_GAMEMODE_PLATFORMING
		
		set cp=s__Levels_Level_AddCheckpoint(l,gg_rct_PWCP_1_3 , gg_rct_PWR_1_4)
		set s__Checkpoint_RequiresSameGameMode[cp]=true
		
		//LEVEL 2
        set l=s__Levels_Level_create(PW2_LEVEL_ID , "Palindrome" , 5 , 5 , "PW2Start" , "PW2Stop" , gg_rct_PWR_2_1 , gg_rct_PW2_Vision , gg_rct_PW2_End , l) //gg_rct_PW1_Vision
		//set cpID = l.AddCheckpoint(gg_rct_PWCP_2_1, gg_rct_PWR_2_2)
        call s__Levels_Level_AddCheckpoint(l,gg_rct_PWCP_2_2 , gg_rct_PWR_2_3)
        
		set cp=s__Levels_Level_AddCheckpoint(l,gg_rct_PWCP_2_3 , gg_rct_PWR_2_4)
        set s__Checkpoint_DefaultGameMode[cp]=Teams_GAMEMODE_PLATFORMING
        
		set cp=s__Levels_Level_AddCheckpoint(l,gg_rct_PWCP_2_4 , gg_rct_PWR_2_5)
        set s__Checkpoint_DefaultGameMode[cp]=Teams_GAMEMODE_PLATFORMING
        set s__Checkpoint_RequiresSameGameMode[cp]=true
		
		//LEVEL 3
        set l=s__Levels_Level_create(PW3_LEVEL_ID , "Playground" , 5 , 4 , "PW3Start" , "PW3Stop" , gg_rct_PWR_3_1 , gg_rct_PW3_Vision , gg_rct_PW3_End , l) //gg_rct_PW1_Vision
        call s__RectList_addEnd(s__Levels_Level_Boundaries[l],gg_rct_PW3_Vision2)
		set s__Checkpoint_DefaultGameMode[(s__SimpleList_ListNode_value[s__SimpleList_List_first[s__Levels_Level_Checkpoints[l]]])]=Teams_GAMEMODE_PLATFORMING
        
		set cp=s__Levels_Level_AddCheckpoint(l,gg_rct_PWCP_3_1 , gg_rct_PWR_3_2)
        set s__Checkpoint_DefaultGameMode[cp]=Teams_GAMEMODE_PLATFORMING
        
		set cp=s__Levels_Level_AddCheckpoint(l,gg_rct_PWCP_3_2 , gg_rct_PWR_3_3)
        set s__Checkpoint_DefaultGameMode[cp]=Teams_GAMEMODE_PLATFORMING
        
		set cp=s__Levels_Level_AddCheckpoint(l,gg_rct_PWCP_3_3 , gg_rct_PWR_3_4)
        set s__Checkpoint_DefaultGameMode[cp]=Teams_GAMEMODE_PLATFORMING
		
		//LEVEL 4
		if CONFIGURATION_PROFILE != RELEASE then
			set l=s__Levels_Level_create(PW4_LEVEL_ID , "Moon" , 5 , 4 , "PW4Start" , "PW4Stop" , gg_rct_PWR_4_1 , gg_rct_PW4_Vision , gg_rct_PW4_End , l) //gg_rct_PW1_Vision
			call s__RectList_addEnd(s__Levels_Level_Boundaries[l],gg_rct_PW4_Vision2)
			set s__Checkpoint_DefaultGameMode[(s__SimpleList_ListNode_value[s__SimpleList_List_first[s__Levels_Level_Checkpoints[l]]])]=Teams_GAMEMODE_PLATFORMING
			call s__Levels_Level_AddLevelStartCB(l,Condition(function PW4TeamStart))
			call s__Levels_Level_AddLevelStopCB(l,Condition(function PW4TeamStop))
		endif
		
        //Justine's Four Seasons
		set l=s__Levels_Level_create(FS1_LEVEL_ID , "Spring" , 3 , 2 , "FourSeason1Start" , "FourSeason1Stop" , gg_rct_FSR_1_1 , gg_rct_FS1_Vision , gg_rct_FS1_End , 0)
		call s__Levels_Level_AddCheckpoint(l,gg_rct_FSCP_1_1 , gg_rct_FSR_1_2)
		
		//Minigames
		set l=s__Minigame_create(BRICK_BREAK_LEVEL_ID , "Brick Break" , "BrickBreakStart" , "BrickBreakStop" , gg_rct_BB_Revive , gg_rct_BB_Vision)
		// call l.Boundaries.addEnd(gg_rct_PW3_Vision2)
		set s__Checkpoint_DefaultGameMode[(s__SimpleList_ListNode_value[s__SimpleList_List_first[s__Levels_Level_Checkpoints[l]]])]=Teams_GAMEMODE_PLATFORMING
		
		
        //Testing worlds
        set l=s__Levels_Level_create(TESTDH_LEVEL_ID , "Test Standard" , 0 , 0 , null , null , gg_rct_SWR_2_1 , null , null , 0)
		
		set l=s__Levels_Level_create(TESTP_LEVEL_ID , "Test Platforming" , 0 , 0 , null , null , gg_rct_SWR_1_1 , null , null , 0)
        set s__Checkpoint_DefaultGameMode[(s__SimpleList_ListNode_value[s__SimpleList_List_first[s__Levels_Level_Checkpoints[l]]])]=Teams_GAMEMODE_PLATFORMING
	endfunction

//library EDWLevels ends
//library EDWLevelContent:
 function EDWLevelContent___FinishedIntro takes nothing returns nothing
		call TrackGameTime()
	endfunction
		
 function EDWLevelContent_Initialize takes nothing returns nothing
  local integer l
  local integer cp
                
        local integer boundedSpoke
        local integer wheel
        local integer boundedWheel
        
        local integer sg
        local integer rg
		
  local integer nsync
  local integer jtimber
		
  local integer pattern
		
  local integer collectibleSet
  local integer collectible
		
  local integer fastLoad
		
  local unit u
  local integer i
				
		//FIRST LEVEL INITS HARD CODED
        set l=(INTRO_LEVEL_ID)
		call s__Levels_Level_AddLevelStopCB(l,Condition(function EDWLevelContent___FinishedIntro))
		
		call IntroWorld_InitializeStartableContent()
		
        //DOORS HARD CODED
        //currently no start or stop logic
        
        //ICE WORLD TECH / ENVY WORLD
        //LEVEL 1
        set l=(IW1_LEVEL_ID)
        
		call IW1_InitializeStartableContent()
        
        //LEVEL 2
        set l=(IW2_LEVEL_ID)
        
		call IW2_InitializeStartableContent()
		
        
        //LEVEL 3
        set l=(IW3_LEVEL_ID)
        
		call IW3_InitializeStartableContent()
		
        //LEVEL 4
        set l=(IW4_LEVEL_ID)
        
		call s__FastLoad_create(l , s__SimpleList_ListNode_value[s__SimpleList_List_first[s__Levels_Level_Checkpoints[l]]] , 10. , 2.5)
		
        //
        set rg=s__RelayGenerator_create(5373 , 9984 , 3 , 6 , 270 , 0 , 2. , (11) , 1)
		set s__PatternSpawn_Data[s__RelayPatternSpawn_Pattern[s__RelayGenerator_SpawnPattern[rg]]]=LGUARD
        call s__RelayGenerator_AddTurnSimple(rg,0 , 6)
        call s__RelayGenerator_AddTurnSimple(rg,90 , 0)
        call s__RelayGenerator_EndTurns(rg,90)
        
        call s__Levels_Level_AddStartable(l,rg)
		
        //
		if RewardMode == GameModesGlobals_HARD then
			set rg=s__RelayGenerator_create(6654 , 6528 , 3 , 6 , 90 , 7 , 1.5 , (11) , 1)
		else
			set rg=s__RelayGenerator_create(6654 , 6528 , 3 , 6 , 90 , 7 , 2. , (11) , 1)
		endif
		set s__PatternSpawn_Data[s__RelayPatternSpawn_Pattern[s__RelayGenerator_SpawnPattern[rg]]]=LGUARD
        call s__RelayGenerator_AddTurnSimple(rg,180 , 7)
        call s__RelayGenerator_AddTurnSimple(rg,270 , 1)
        call s__RelayGenerator_AddTurnSimple(rg,0 , 13)
        call s__RelayGenerator_AddTurnSimple(rg,90 , 3)
        call s__RelayGenerator_AddTurnSimple(rg,0 , 6)
        call s__RelayGenerator_AddTurnSimple(rg,270 , 1)
        call s__RelayGenerator_AddTurnSimple(rg,0 , 1)
        call s__RelayGenerator_AddTurnSimple(rg,90 , 1)
        call s__RelayGenerator_AddTurnSimple(rg,0 , 3)
        call s__RelayGenerator_EndTurns(rg,0)
        
		call s__Levels_Level_AddStartable(l,rg)
		
		if RewardMode == GameModesGlobals_HARD then
			call s__Levels_Level_AddStartable(l,s__DrunkWalker_DrunkWalkerSpawn_create(gg_rct_IW4_Drunks , 6 , LGUARD , 24))
		else
			call s__Levels_Level_AddStartable(l,s__DrunkWalker_DrunkWalkerSpawn_create(gg_rct_IW4_Drunks , 6 , LGUARD , 10))
		endif
        call s__Levels_Level_AddStartable(l,s__Blackhole_create(8958 , 6400 , true))
		
        //
        set rg=s__RelayGenerator_create(3830 , 6278 , 3 , 6 , 90 , 3 , 3. , (11) , 1)
		set s__PatternSpawn_Data[s__RelayPatternSpawn_Pattern[s__RelayGenerator_SpawnPattern[rg]]]=GUARD
        call s__RelayGenerator_AddTurnSimple(rg,0 , 1)
        call s__RelayGenerator_AddTurnSimple(rg,270 , 3)
        call s__RelayGenerator_EndTurns(rg,270)
        
        call s__Levels_Level_AddStartable(l,rg)
                
        //LEVEL 5
		if CONFIGURATION_PROFILE != RELEASE then
			set l=(IW5_LEVEL_ID)
						
			call s__Levels_Level_AddStartable(l,s__DrunkWalker_DrunkWalkerSpawn_create(gg_rct_IW5_Drunks_3 , 2 , GUARD , 12))
			call s__Levels_Level_AddStartable(l,s__DrunkWalker_DrunkWalkerSpawn_create(gg_rct_IW5_Drunks_2 , 6 , LGUARD , 16))
			call s__Levels_Level_AddStartable(l,s__DrunkWalker_DrunkWalkerSpawn_create(gg_rct_IW5_Drunks_1 , 10 , LGUARD , 60))
        endif
				
		//ICE WORLD B
		//LEVEL 1
		set l=(IWB1_LEVEL_ID)
				
		set rg=s__RelayGenerator_create(- 5948 , 10836 , 4 , 4 , 270 , 0 , 2. , (11) , 1)
		set s__PatternSpawn_Data[s__RelayPatternSpawn_Pattern[s__RelayGenerator_SpawnPattern[rg]]]=ICETROLL
        call s__RelayGenerator_AddTurnSimple(rg,0 , 12)
        call s__RelayGenerator_AddTurnSimple(rg,90 , 11)
        call s__RelayGenerator_EndTurns(rg,90)
		        
        call s__Levels_Level_AddStartable(l,rg)
				
		//LAND WORLD A
		//LEVEL 1
		if RewardMode == GameModesGlobals_EASY then
			set cp=s__Levels_Level_InsertCheckpoint((LW1_LEVEL_ID),gg_rct_LWCP_1_1a , gg_rct_LWR_1_2a , 1)
			call s__Checkpoint_InitGate(cp,bj_PI , 1.25)
		endif
		
		call LW1_InitializeStartableContent()
		//LEVEL 2
		call LW2_InitializeStartableContent()
		
        //PRIDE WORLD / PLATFORMING
        //LEVEL 1
        set l=(PW1_LEVEL_ID)
                
        call s__Levels_Level_AddStartable(l,s__MortarNTarget_create(SMLMORT , SMLTARG , Player(8) , gg_rct_Rect_340 , gg_rct_Rect_339))
        call s__Levels_Level_AddStartable(l,s__MortarNTarget_create(SMLMORT , SMLTARG , Player(8) , gg_rct_Rect_340 , gg_rct_Rect_339))
        
        call s__Levels_Level_AddStartable(l,s__MortarNTarget_create(SMLMORT , SMLTARG , Player(8) , gg_rct_Rect_352 , gg_rct_Rect_351))
		
        //LEVEL 2
        set l=(PW2_LEVEL_ID)
                        
        call s__Levels_Level_AddStartable(l,s__MortarNTarget_create(SMLMORT , SMLTARG , Player(8) , gg_rct_PW2_Mortar , gg_rct_PW2_Target))
        call s__Levels_Level_AddStartable(l,s__MortarNTarget_create(SMLMORT , SMLTARG , Player(8) , gg_rct_PW2_Mortar , gg_rct_PW2_Target))
        call s__Levels_Level_AddStartable(l,s__MortarNTarget_create(SMLMORT , SMLTARG , Player(8) , gg_rct_PW2_Mortar , gg_rct_PW2_Target))
        call s__Levels_Level_AddStartable(l,s__MortarNTarget_create(SMLMORT , SMLTARG , Player(8) , gg_rct_PW2_Mortar , gg_rct_PW2_Target))
        call s__Levels_Level_AddStartable(l,s__MortarNTarget_create(SMLMORT , SMLTARG , Player(8) , gg_rct_PW2_Mortar , gg_rct_PW2_Target))
        call s__Levels_Level_AddStartable(l,s__MortarNTarget_create(SMLMORT , SMLTARG , Player(8) , gg_rct_PW2_Mortar , gg_rct_PW2_Target))
        
        //public static method create takes rect spawn, real spawntimeout, real walktimeout, integer uid, real lifespan returns thistype
        call s__Levels_Level_AddStartable(l,s__DrunkWalker_DrunkWalkerSpawn_create(gg_rct_PW2_Drunks_1 , 6 , LGUARD , 14))
        call s__Levels_Level_AddStartable(l,s__DrunkWalker_DrunkWalkerSpawn_create(gg_rct_PW2_Drunks_1 , 10 , LGUARD , 8))
        call s__Levels_Level_AddStartable(l,s__DrunkWalker_DrunkWalkerSpawn_create(gg_rct_PW2_Drunks_2 , 6 , LGUARD , 8))
        call s__Levels_Level_AddStartable(l,s__DrunkWalker_DrunkWalkerSpawn_create(gg_rct_PW2_Drunks_3 , 5 , LGUARD , 14))
        call s__Levels_Level_AddStartable(l,s__DrunkWalker_DrunkWalkerSpawn_create(gg_rct_PW2_Drunks_4 , 4 , LGUARD , 10))
        
        set rg=s__RelayGenerator_create(8186 , - 3191 , 3 , 3 , 0 , 0 , 2.5 , (12) , 4)
		set s__PatternSpawn_Data[s__RelayPatternSpawn_Pattern[s__RelayGenerator_SpawnPattern[rg]]]=ICETROLL
        call s__RelayGenerator_AddTurnSimple(rg,90 , 4)
        call s__RelayGenerator_AddTurnSimple(rg,180 , 1)
        call s__RelayGenerator_AddTurnSimple(rg,270 , 0)
        call s__RelayGenerator_AddTurnSimple(rg,180 , 0)
        call s__RelayGenerator_AddTurnSimple(rg,270 , 1)
        call s__RelayGenerator_AddTurnSimple(rg,180 , 1)
        call s__RelayGenerator_AddTurnSimple(rg,90 , 3)
        call s__RelayGenerator_AddTurnSimple(rg,180 , 1)
        call s__RelayGenerator_AddTurnSimple(rg,270 , 0)
        call s__RelayGenerator_AddTurnSimple(rg,180 , 3)
        call s__RelayGenerator_AddTurnSimple(rg,90 , 8)
        call s__RelayGenerator_AddTurnSimple(rg,0 , 3)
        call s__RelayGenerator_AddTurnSimple(rg,270 , 0)
        call s__RelayGenerator_AddTurnSimple(rg,0 , 3)
        call s__RelayGenerator_AddTurnSimple(rg,90 , 0)
		call s__RelayGenerator_AddTurnSimple(rg,0 , 14)
        call s__RelayGenerator_EndTurns(rg,0)
        
        //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "PW2 RG: " + rg.ToString())
        //debug call rg.DrawTurns()
        
        call s__Levels_Level_AddStartable(l,rg)
        		
        //LEVEL 3
        set l=(PW3_LEVEL_ID)
        
		call s__Levels_Level_AddStartable(l,s__SimplePatrol_create(BOUNCER , 1472 , - 7168 , 1792 , - 7168))
		call s__Levels_Level_AddStartable(l,s__SimplePatrol_create(BOUNCER , 1536 , - 6912 , 2048 , - 6912))
		call s__Levels_Level_AddStartable(l,s__SimplePatrol_create(GRAVITY , 2304 , - 9592 , 2564 , - 9592))
		call s__Levels_Level_AddStartable(l,s__SimplePatrol_create(BOUNCER , 2654 , - 4864 , 2816 , - 4728))
		
		set pattern=s__LinePatternSpawn_createFromRect((13) , 1 , gg_rct_PW3_MassCreate , TERRAIN_TILE_SIZE)
		set s__PatternSpawn_Data[pattern]=BOUNCER
		set sg=s__SimpleGenerator_create(pattern , 1.5 , 180 , 19)
		call s__SimpleGenerator_SetMoveSpeed(sg,100.)
        call s__Levels_Level_AddStartable(l,sg)
        
        //set wheel = Wheel.create(-2694, -9200)
        set boundedWheel=s__BoundedWheel_create(- 2694 , - 9200)
        set s__Wheel_SpokeCount[boundedWheel]=16
        set s__Wheel_AngleBetween[boundedWheel]=bj_PI / 8
        set s__Wheel_RotationSpeed[boundedWheel]=bj_PI / 20 * Wheel_TIMEOUT
        set s__Wheel_InitialOffset[boundedWheel]=2. * TERRAIN_TILE_SIZE
        call s__BoundedWheel_SetAngleBounds(boundedWheel,bj_PI * 3 / 6 , bj_PI * 5 / 6)
        call s__Wheel_AddEmptySpace(boundedWheel,1)
        call s__Wheel_AddUnits(boundedWheel,'e00A' , 6)
        call s__Wheel_AddUnits(boundedWheel,'e00J' , 1)
        call s__Wheel_AddUnits(boundedWheel,'e00A' , 6)
        call s__Wheel_AddEmptySpace(boundedWheel,2)
        call s__Levels_Level_AddStartable(l,boundedWheel)
        
		set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((BOUNCER )))),(( - 554 )*1.0) , (( - 4840)*1.0))) // INLINED!!
		call SetUnitOwner(u, Player(11), true)
		
        set wheel=s__Wheel_create(- 554 , - 4840)
        set s__Wheel_SpokeCount[wheel]=4
        set s__Wheel_AngleBetween[wheel]=bj_PI / 2
        set s__Wheel_RotationSpeed[wheel]=bj_PI / 10 * Wheel_TIMEOUT
		set s__Wheel_InitialOffset[wheel]=2. * TERRAIN_TILE_SIZE
        call s__Wheel_AddUnits(wheel,'e00K' , 4)
        call s__Levels_Level_AddStartable(l,wheel)
        
		//LEVEL 4
		if CONFIGURATION_PROFILE != RELEASE then
			set l=(PW4_LEVEL_ID)
						
			set wheel=s__Wheel_create(- 7040 , - 2942)
			set s__Wheel_LayerCount[wheel]=2
			set s__Wheel_SpokeCount[wheel]=4
			set s__Wheel_AngleBetween[wheel]=90 * bj_PI / 180.
			set s__Wheel_RotationSpeed[wheel]=bj_PI / 16. * Wheel_TIMEOUT
			set s__Wheel_DistanceBetween[wheel]=3 * TERRAIN_TILE_SIZE
			set s__Wheel_InitialOffset[wheel]=2 * TERRAIN_TILE_SIZE
			
			//layer 1
			call s__Wheel_AddUnits(wheel,'e00K' , 1)
			call s__Wheel_AddEmptySpace(wheel,1)
			call s__Wheel_AddUnits(wheel,'e00K' , 1)
			call s__Wheel_AddEmptySpace(wheel,1)
			//layer 2
			call s__Wheel_AddEmptySpace(wheel,1)
			call s__Wheel_AddUnits(wheel,'e00K' , 1)
			call s__Wheel_AddEmptySpace(wheel,1)
			call s__Wheel_AddUnits(wheel,'e00K' , 1)
			
			call s__Levels_Level_AddStartable(l,wheel)
		endif
		
        //Justine's Four Seasons
		set l=(FS1_LEVEL_ID)
		
		call s__Levels_Level_AddStartable(l,s__DrunkWalker_DrunkWalkerSpawn_create(gg_rct_FS_1_Drunks , 3 , LGUARD , 16))
	        
		
        //Testing worlds
        
	endfunction

//library EDWLevelContent ends
//library EDWCinematicContent:
 function EDWCinematicContent___IsUserRed takes integer user returns boolean
        return s__MazerColor[user] == KEY_RED
    endfunction
    function EDWCinematicContent___IsUserNotRed takes integer user returns boolean
        return s__MazerColor[user] != KEY_RED
    endfunction
 function EDWCinematicContent___IsUserBlue takes integer user returns boolean
        return s__MazerColor[user] == KEY_BLUE
    endfunction
 function EDWCinematicContent___IsUserPlayerOne takes integer user returns boolean
        return user == 0
    endfunction
    function EDWCinematicContent___IsUserPlayerTwo takes integer user returns boolean
        return user == 1
    endfunction
    function EDWCinematicContent___IsUserCinemaQueueBig takes integer user returns boolean
        return s__SimpleList_List_count[s__User_CinematicQueue[user]] >= 3
    endfunction
    function EDWCinematicContent___IsUserInCinema takes integer user returns boolean
		return s__User_CinematicPlaying[user] != 0
    endfunction
 function EDWCinematicContent___IsUserNotInCinema takes integer user returns boolean
		return s__User_CinematicPlaying[user] == 0
	endfunction
 function EDWCinematicContent___IsUserStandard takes integer user returns boolean
		return s__User_GameMode[user] == Teams_GAMEMODE_STANDARD or s__User_GameMode[user] == Teams_GAMEMODE_STANDARD_PAUSED
	endfunction
 function EDWCinematicContent___IsUserPlatforming takes integer user returns boolean
		return s__User_GameMode[user] == Teams_GAMEMODE_PLATFORMING or s__User_GameMode[user] == Teams_GAMEMODE_PLATFORMING_PAUSED
	endfunction
    function EDWCinematicContent___IsUserDying takes integer user returns boolean
        return s__User_GameMode[user] == Teams_GAMEMODE_DYING or s__User_GameMode[user] == Teams_GAMEMODE_DEAD
    endfunction
	
 function EDWCinematicContent_Initialize takes nothing returns nothing
  local integer cine
        local integer cineMsg
		
		//FIRST LEVEL INITS
        //set l = Levels_Level.create(1, "???", 0, 0, "IntroWorldLevelStart", "IntroWorldLevelStop", gg_rct_IntroWorld_R1, gg_rct_IntroWorld_Vision, gg_rct_IntroWorld_End, 0)
		//1st level is now handled in EDWVisualVote vote finish callback
        //call l.StartLevel() //just start it, intro level vision handled by Reveal Intro World... i like the reveal effect
        
        
        
        set cineMsg=s__CinemaMessage_create(null , GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Hey you!" , DEFAULT_TEXT_COLOR) , DEFAULT_SHORT_TEXT_SPEED)
        set cine=s__Cinematic_create(gg_rct_SargeIntro1 , false , false , cineMsg)
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Yeah, you" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "...Maggot" , ANGRY_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Sorry, but that just felt right" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
        set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[(cine)]]])]=((- 1)*1.0) // INLINED!!
		call s__Levels_Level_AddCinematic((1),cine)
        
		
        //set cineMsg = CinemaMessage.create(null, GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME, "Anyways, like I was saying, how'd we even get into this pit?", DEFAULT_TEXT_COLOR), DEFAULT_SHORT_TEXT_SPEED)
        set cineMsg=s__CinemaMessage_create(null , GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Oh man, I think I mighta had one too many last night" , DEFAULT_TEXT_COLOR) , DEFAULT_SHORT_TEXT_SPEED)
        set cine=s__Cinematic_create(gg_rct_SargeIntro2 , true , false , cineMsg)
        //call cine.AddMessage(null, GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME, "Oh man, I think I mighta had one too many last night", DEFAULT_TEXT_COLOR), DEFAULT_SHORT_TEXT_SPEED)
		call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Wait..." , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_TINY_TEXT_SPEED)*1.0))) // INLINED!!
		call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "I'm remembering something..." , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Yeah, okay. You probably shouldn't get near those colorful dragons" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
        //call cine.AddMessage(null, GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME, "...I don't want to talk about it", SAD_TEXT_COLOR), DEFAULT_TINY_TEXT_SPEED)
        set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[(cine)]]])]=((- 1)*1.0) // INLINED!!
		call s__Levels_Level_AddCinematic((1),cine)
        
        set cineMsg=s__CinemaMessage_create(null , GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Whoa!" , ANGRY_TEXT_COLOR) , DEFAULT_TINY_TEXT_SPEED)
        set cine=s__Cinematic_create(gg_rct_SargeFireWarning , true , false , cineMsg)
        set s__Cinematic_ActivationCondition[cine]=(1)
		set s__Cinematic_Priority[cine]=3
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Better stay clear of that fire" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
		call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "I don't think it likes how you look" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
        set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[(cine)]]])]=((- 1)*1.0) // INLINED!!
		call s__Levels_Level_AddCinematic((1),cine)
                
        set cineMsg=s__CinemaMessage_create(null , GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Nice!" , HAPPY_TEXT_COLOR) , DEFAULT_TINY_TEXT_SPEED)
        set cine=s__Cinematic_create(gg_rct_SargeFoundRed , true , false , cineMsg)
        set s__Cinematic_ActivationCondition[cine]=(2)
		set s__Cinematic_Priority[cine]=2
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Your skin's glowing red!" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "I bet you could go through that fire now" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Everyone knows that the best color is the same color!" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_MEDIUM_TEXT_SPEED)*1.0))) // INLINED!!
        set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[((cine))]]])]=((DEFAULT_CONVERSATION_BUFFER)*1.0) // INLINED!!
		call s__Levels_Level_AddCinematic((1),cine)
        
        set cineMsg=s__CinemaMessage_create(null , GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Hah, classic Red" , HAPPY_TEXT_COLOR) , DEFAULT_SHORT_TEXT_SPEED)
        set cine=s__Cinematic_create(gg_rct_SargeBeatRed , true , false , cineMsg)
        set s__Cinematic_ActivationCondition[cine]=(2)
        set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[((cine))]]])]=((DEFAULT_CONVERSATION_BUFFER)*1.0) // INLINED!!
		call s__Levels_Level_AddCinematic((1),cine)
        
        set cineMsg=s__CinemaMessage_create(null , GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Wow..." , DEFAULT_TEXT_COLOR) , DEFAULT_SHORT_TEXT_SPEED)
        set cine=s__Cinematic_create(gg_rct_SargeVines , true , false , cineMsg)
        set s__Cinematic_ActivationCondition[cine]=(3)
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "It's like a Special Ed class took a field trip to a Catholic Church" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_MEDIUM_TEXT_SPEED)*1.0))) // INLINED!!
        set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[((cine))]]])]=((DEFAULT_CONVERSATION_BUFFER)*1.0) // INLINED!!
		call s__Levels_Level_AddCinematic((1),cine)
                        
        set cineMsg=s__CinemaMessage_create(null , GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "I see that you, too, hold a secret passion for the elegant art of figure skating" , DEFAULT_TEXT_COLOR) , DEFAULT_MEDIUM_TEXT_SPEED)
        set cine=s__Cinematic_create(gg_rct_IceTutorial , false , false , cineMsg)
		set s__Cinematic_Priority[cine]=3
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Remember to hold your head high, and always face towards your future" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_MEDIUM_TEXT_SPEED)*1.0))) // INLINED!!
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "There's no stopping, just relentless progress towards that future" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_MEDIUM_TEXT_SPEED)*1.0))) // INLINED!!
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Keep track of yourself using the arrow keys or mouse, or press the 'escape' key" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_MEDIUM_TEXT_SPEED)*1.0))) // INLINED!!
        set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[((cine))]]])]=((DEFAULT_CONVERSATION_BUFFER)*1.0) // INLINED!!
		call s__Levels_Level_AddCinematic((1),cine)
        
        set cineMsg=s__CinemaMessage_create(null , GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Another one of these shimmering portals..." , DEFAULT_TEXT_COLOR) , DEFAULT_SHORT_TEXT_SPEED)
        set cine=s__Cinematic_create(gg_rct_SargeCheckpoint , true , false , cineMsg)
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Stepping over them seems to give you a checkpoint, and brings your friends back to life" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_MEDIUM_TEXT_SPEED)*1.0))) // INLINED!!
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "But are they the same friends?" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
        set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[((cine))]]])]=((DEFAULT_CONVERSATION_BUFFER)*1.0) // INLINED!!
		call s__Levels_Level_AddCinematic((1),cine)
        
        set cineMsg=s__CinemaMessage_create(null , GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Ahh, I'd know that mossy brick tile up ahead from anywhere" , DEFAULT_TEXT_COLOR) , DEFAULT_SHORT_TEXT_SPEED)
        set cine=s__Cinematic_create(gg_rct_SargePlatformingTile , true , false , cineMsg)
        set s__Cinematic_Priority[cine]=2
		call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Brings me right back to my time in 'Nam" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Touch it and your world will change" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
        set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[(cine)]]])]=((- 1)*1.0) // INLINED!!
		call s__Levels_Level_AddCinematic((1),cine)
        
        set cineMsg=s__CinemaMessage_create(null , GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Pull yourself together soldier!" , DEFAULT_TEXT_COLOR) , DEFAULT_SHORT_TEXT_SPEED)
        set cine=s__Cinematic_create(gg_rct_SargePlatformingMovement , true , false , cineMsg)
        set s__Cinematic_Priority[cine]=5
		call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "You're a circle now!" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Show some dignity, and use your arrow keys to move" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
        set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[(cine)]]])]=((- 1)*1.0) // INLINED!!
		call s__Levels_Level_AddCinematic((1),cine)
        
        set cineMsg=s__CinemaMessage_create(null , GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Jesus christ, no, not like that" , DEFAULT_TEXT_COLOR) , DEFAULT_SHORT_TEXT_SPEED)
        set cine=s__Cinematic_create(gg_rct_SargeJump , true , false , cineMsg)
		set s__Cinematic_ActivationCondition[cine]=(4)
        set s__Cinematic_Priority[cine]=100
		call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Press up to jump UP!" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_MEDIUM_TEXT_SPEED)*1.0))) // INLINED!!
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "I swear, you're the reason I needed to add these tutorials" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
        set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[(cine)]]])]=((- 1)*1.0) // INLINED!!
		call s__Levels_Level_AddCinematic((1),cine)
        
        set cineMsg=s__CinemaMessage_create(null , GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Now, hold that wall close," , DEFAULT_TEXT_COLOR) , DEFAULT_SHORT_TEXT_SPEED)
        set cine=s__Cinematic_create(gg_rct_SargeWallJump , true , false , cineMsg)
		set s__Cinematic_ActivationCondition[cine]=(3)
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Like it was your fiance who promised that you'd never be alone but died far too young in a horrible accident that was no ones fault but has still left you a soul-less husk" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_TINY_TEXT_SPEED)*1.0))) // INLINED!!
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "And then press the Up key to do a wall-jump!" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_MEDIUM_TEXT_SPEED)*1.0))) // INLINED!!
        set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[((cine))]]])]=((DEFAULT_CONVERSATION_BUFFER)*1.0) // INLINED!!
		call s__Levels_Level_AddCinematic((1),cine)
		
		set cineMsg=s__CinemaMessage_create(null , GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Here's a life lesson for you, son" , DEFAULT_TEXT_COLOR) , DEFAULT_SHORT_TEXT_SPEED)
        set cine=s__Cinematic_create(gg_rct_SargeBlue , true , false , cineMsg)
        set s__Cinematic_ActivationCondition[cine]=(5)
		call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Everybody knows circles can't be blue" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "But, when you turn back into a demon hunter," , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "You can take your trusty circle, and blue yourself with it!" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_MEDIUM_TEXT_SPEED)*1.0))) // INLINED!!
		call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "(this is true wisdom for all colors!)" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
		set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[((cine))]]])]=((DEFAULT_CONVERSATION_BUFFER)*1.0) // INLINED!!
		call s__Levels_Level_AddCinematic((1),cine)
        
        //DOORS HARD CODED
        //currently no start or stop logic
        //call Levels_Level.CreateDoors(l, null, null, gg_rct_HubWorld_R, gg_rct_HubWorld_Vision)
		set cineMsg=s__CinemaMessage_create(null , GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Love hurts, son" , DEFAULT_TEXT_COLOR) , DEFAULT_MEDIUM_TEXT_SPEED)
        set cine=s__Cinematic_create(gg_rct_SargeHeart , true , false , cineMsg)
		set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[((cine))]]])]=((DEFAULT_CONVERSATION_BUFFER)*1.0) // INLINED!!
		call s__Levels_Level_AddCinematic((2),cine)
        
        //REMAINING LEVELS
        //takes integer levelID, trigger start, trigger stop, trigger preload, trigger unload, boolean haspreload, rect startspawn, rect vision, rect tothislevel, Level previouslevel returns Level
        //config extension methods:
        //.setPreload(trigger preload, trigger unload) returns Levels_Level
        
		//ICE WORLD TECH / ENVY WORLD
        //LEVEL 1
        //set l = Levels_Level.create(3, "Cruise Control", 3, 2, "IW1Start", "IW1Stop", gg_rct_IWR_1_1, gg_rct_IW1_Vision, gg_rct_IW1_End, 0)
        set cineMsg=s__CinemaMessage_create(null , GetEDWSpeakerMessage("Phil" , "I ain't never seen nothin like it, Marge" , DEFAULT_TEXT_COLOR) , DEFAULT_MEDIUM_TEXT_SPEED)
        set cine=s__Cinematic_create(gg_rct_IW1Runes , true , true , cineMsg)
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage("Marge (lost forever to the Oblivion)" , "The runes... so pretty..." , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_MEDIUM_TEXT_SPEED)*1.0))) // INLINED!!
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage("Phil" , "I'll tell you what though," , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
		call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage("Phil" , "Ain't never using no organic pesticides again" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
        set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[(cine)]]])]=((- 1)*1.0) // INLINED!!
		call s__Levels_Level_AddCinematic((3),cine)
		
		set cineMsg=s__CinemaMessage_create(null , GetEDWSpeakerMessage("Bobby" , "Hey Little Timmy, I really appreciate you talking to me" , DEFAULT_TEXT_COLOR) , DEFAULT_LONG_TEXT_SPEED)
        set cine=s__Cinematic_create(gg_rct_IW1Listen , true , true , cineMsg)
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage("Bobby" , "Look, I know we both like Becky, let's face it who wouldn't" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_MEDIUM_TEXT_SPEED)*1.0))) // INLINED!!
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage("Little Timmy" , "Bobby, pal, I'm going to have to cut you off right here," , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_LONG_TEXT_SPEED)*1.0))) // INLINED!!
		call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage("Little Timmy" , "Becky isn't even on my radar." , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_MEDIUM_TEXT_SPEED)*1.0))) // INLINED!!
		call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage("Little Timmy" , "But, if you wanted to impress her," , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
		call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage("Little Timmy" , "You'd grab her some of the flowers from inside the fake cage up on Hagatha Hill" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_LONG_TEXT_SPEED)*1.0))) // INLINED!!
        set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[(cine)]]])]=((- 1)*1.0) // INLINED!!
		call s__Levels_Level_AddCinematic((3),cine)
		
		set cineMsg=s__CinemaMessage_create(null , GetEDWSpeakerMessage("Becky" , "..." , DEFAULT_TEXT_COLOR) , DEFAULT_SHORT_TEXT_SPEED)
        set cine=s__Cinematic_create(gg_rct_IW1Becky , true , true , cineMsg)
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage("Becky" , "*Eats 3 flowers at once*" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage("Becky" , "..." , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_MEDIUM_TEXT_SPEED)*1.0))) // INLINED!!
        set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[(cine)]]])]=((- 1)*1.0) // INLINED!!
		call s__Levels_Level_AddCinematic((3),cine)
		
		set cineMsg=s__CinemaMessage_create(null , GetEDWSpeakerMessage("Bobby" , "Wow..." , DEFAULT_TEXT_COLOR) , DEFAULT_SHORT_TEXT_SPEED)
        set cine=s__Cinematic_create(gg_rct_IW1Cage , true , true , cineMsg)
		call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage("Bobby" , "this" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_TINY_TEXT_SPEED)*1.0))) // INLINED!!
		call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage("Bobby" , "THIS" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
		call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage("Bobby" , "IS THE BEST FAKE CAGE EVERR!@!" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_MEDIUM_TEXT_SPEED)*1.0))) // INLINED!!
        set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[(cine)]]])]=((- 1)*1.0) // INLINED!!
		call s__Levels_Level_AddCinematic((3),cine)
		
		
        //LEVEL 2
        //set l = Levels_Level.create(10, "Jesus on Wheel", 6, 4, "IW2Start", "IW2Stop", gg_rct_IWR_2_1, gg_rct_IW2_Vision, gg_rct_IW2_End, l)
        set cineMsg=s__CinemaMessage_create(null , GetEDWSpeakerMessage("Little Timmy" , "Uuhh" , DEFAULT_TEXT_COLOR) , DEFAULT_SHORT_TEXT_SPEED)
        set cine=s__Cinematic_create(gg_rct_IW2Yikes , true , true , cineMsg)
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage("Little Timmy" , "That's a yikes for me" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
		set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[(cine)]]])]=((- 1)*1.0) // INLINED!!
		call s__Levels_Level_AddCinematic((10),cine)
		
        //LEVEL 3
        //set l = Levels_Level.create(17, "Illidan Goes Skiing", 8, 8, "IW3Start", "IW3Stop", gg_rct_IWR_3_1, gg_rct_IW3_Vision, gg_rct_IW3_End, l)
		set cineMsg=s__CinemaMessage_create(null , GetEDWSpeakerMessage("???" , "Why, it's 'Little Timmy'!" , DEFAULT_TEXT_COLOR) , DEFAULT_SHORT_TEXT_SPEED)
		//set cineMsg = CinemaMessage.create(null, GetEDWSpeakerMessage("Little Timmy", "We had a deal you jive ass snowball", DEFAULT_TEXT_COLOR), DEFAULT_SHORT_TEXT_SPEED)
        set cine=s__Cinematic_create(gg_rct_IW3Deal , true , true , cineMsg)
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage("???" , "Now what seems to be the problem, my dear 'Little Timmy'?" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_MEDIUM_TEXT_SPEED)*1.0))) // INLINED!!
		call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage("Little Timmy" , "Problem??" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_TINY_TEXT_SPEED)*1.0))) // INLINED!!
		call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage("Little Timmy" , "We had a deal you jive ass snowball" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
		call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage("Little Timmy" , "I get you out of the cage, you take care of my Bobby problem" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_LONG_TEXT_SPEED)*1.0))) // INLINED!!
		call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage("Little Timmy" , "Now Sally is fucking dead, and it's all cuz of you" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_MEDIUM_TEXT_SPEED)*1.0))) // INLINED!!
		set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[(cine)]]])]=((- 1)*1.0) // INLINED!!
		call s__Levels_Level_AddCinematic((17),cine)
		
        //LEVEL 4
        //set l = Levels_Level.create(24, "Hard Angles", 6, 6, "IW4Start", "IW4Stop", gg_rct_IWR_4_1, gg_rct_IW4_Vision, gg_rct_IW4_End, l)
        set cineMsg=s__CinemaMessage_create(null , GetEDWSpeakerMessage("Rocco" , "Uhhhhhhhhhhh" , DEFAULT_TEXT_COLOR) , DEFAULT_MEDIUM_TEXT_SPEED)
        set cine=s__Cinematic_create(gg_rct_IW4QuestionMark , true , false , cineMsg)
		set s__Cinematic_ActivationCondition[cine]=(4)
		call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage("Rocco" , "Quuuestion mark?" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_MEDIUM_TEXT_SPEED)*1.0))) // INLINED!!
		set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[(cine)]]])]=((- 1)*1.0) // INLINED!!
		call s__Levels_Level_AddCinematic((24),cine)
		
		if CONFIGURATION_PROFILE == RELEASE then
			set cineMsg=s__CinemaMessage_create(null , GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Haven't seen a tear in space this bad in awhile" , DEFAULT_TEXT_COLOR) , DEFAULT_MEDIUM_TEXT_SPEED)
			set cine=s__Cinematic_create(gg_rct_IW4Performance , true , false , cineMsg)
			call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "It's like the level was cut right down the middle" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_MEDIUM_TEXT_SPEED)*1.0))) // INLINED!!
			call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Only one thing that could do this" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_MEDIUM_TEXT_SPEED)*1.0))) // INLINED!!
			//call cine.AddMessage(null, GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME, "4 words:", DEFAULT_TEXT_COLOR), DEFAULT_SHORT_TEXT_SPEED)
			call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Big." , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_TINY_TEXT_SPEED)*1.0))) // INLINED!!
			call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Ass." , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_TINY_TEXT_SPEED)*1.0))) // INLINED!!
			call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Optimization problems." , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
			//call cine.AddMessage(null, GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME, "Big. Ass. Optimization problems.", DEFAULT_TEXT_COLOR), DEFAULT_MEDIUM_TEXT_SPEED)
			set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[(cine)]]])]=((- 1)*1.0) // INLINED!!
			call s__Levels_Level_AddCinematic((24),cine)
		endif
		
        //LEVEL 5
        //set l = Levels_Level.create(31, "TODO SHIIIIT", 4, 4, "IW5Start", "IW5Stop", gg_rct_IWR_5_1, gg_rct_IW5_Vision, gg_rct_IW5_End, l)
                
        //PRIDE WORLD / PLATFORMING
        //LEVEL 1
        //set l = Levels_Level.create(9, "Perspective", 4, 2, "PW1Start", "PW1Stop", gg_rct_PWR_1_1, gg_rct_PW1_Vision, gg_rct_PW1_End, 0) //gg_rct_PW1_Vision
        
        //LEVEL 2
        //set l = Levels_Level.create(16, "Palindrome", 5, 5, "PW2Start", "PW2Stop", gg_rct_PWR_2_1, gg_rct_PW2_Vision, gg_rct_PW2_End, l) //gg_rct_PW1_Vision
        set cineMsg=s__CinemaMessage_create(null , GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Hmmm..." , DEFAULT_TEXT_COLOR) , DEFAULT_MEDIUM_TEXT_SPEED)
        set cine=s__Cinematic_create(gg_rct_SargeInconvenient , true , false , cineMsg)
        set s__Cinematic_ActivationCondition[cine]=(6)
		call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "My expert opinion?" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
		call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "'50% inconvenient.'" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
		set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[((cine))]]])]=((DEFAULT_CONVERSATION_BUFFER)*1.0) // INLINED!!
		call s__Levels_Level_AddCinematic((16),cine)
		
		set cineMsg=s__CinemaMessage_create(null , GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "I hope you brought your floaties" , DEFAULT_TEXT_COLOR) , DEFAULT_SHORT_TEXT_SPEED)
        set cine=s__Cinematic_create(gg_rct_SargeOcean_1 , true , false , cineMsg)
        set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[(cine)]]])]=((- 10)*1.0) // INLINED!!
		call s__Levels_Level_AddCinematic((16),cine)
		
		set cineMsg=s__CinemaMessage_create(null , GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "Cuz" , DEFAULT_TEXT_COLOR) , DEFAULT_TINY_TEXT_SPEED)
        set cine=s__Cinematic_create(gg_rct_SargeOcean_2 , true , false , cineMsg)
		//call cine.AddMessage(null, GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME, "It's", DEFAULT_TEXT_COLOR), DEFAULT_TINY_TEXT_SPEED)
		set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[(cine)]]])]=((- 10)*1.0) // INLINED!!
		call s__Levels_Level_AddCinematic((16),cine)
		
		set cineMsg=s__CinemaMessage_create(null , GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "It's" , DEFAULT_TEXT_COLOR) , DEFAULT_TINY_TEXT_SPEED)
        set cine=s__Cinematic_create(gg_rct_SargeOcean_3 , true , false , cineMsg)
        set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[(cine)]]])]=((- 10)*1.0) // INLINED!!
		call s__Levels_Level_AddCinematic((16),cine)
		
		set cineMsg=s__CinemaMessage_create(null , GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "tHHEEE OCCEEAANNN" , DEFAULT_TEXT_COLOR) , DEFAULT_SHORT_TEXT_SPEED)
        set cine=s__Cinematic_create(gg_rct_SargeOcean_4 , true , false , cineMsg)
        set s__Cinematic_ActivationCondition[cine]=(7)
		call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(cine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(PRIMARY_SPEAKER_NAME , "*rapid-fire airhorn noises*" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_MEDIUM_TEXT_SPEED)*1.0))) // INLINED!!
		//call cine.SetLastMessageBuffer(-10)
		call s__Levels_Level_AddCinematic((16),cine)
		
        //LEVEL 3
        //set l = Levels_Level.create(23, "Playground", 5, 4, "PW3Start", "PW3Stop", gg_rct_PWR_3_1, gg_rct_PW3_Vision, gg_rct_PW3_End, l) //gg_rct_PW1_Vision
        set cineMsg=s__CinemaMessage_create(null , GetEDWSpeakerMessage("Joe" , "*sniff*" , DEFAULT_TEXT_COLOR) , DEFAULT_SHORT_TEXT_SPEED)
        set cine=s__Cinematic_create(gg_rct_PW3Sniff , true , false , cineMsg)
		set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[(cine)]]])]=((- 1)*1.0) // INLINED!!
		call s__Levels_Level_AddCinematic((23),cine)
		
        //Justine's Four Seasons
		//set l = Levels_Level.create(7, "Spring", 3, 2, "FourSeason1Start", "FourSeason1Stop", gg_rct_FSR_1_1, gg_rct_FS1_Vision, gg_rct_FS1_End, 0)
	
        //LANDWORLD / LUSTWORLD
        
	endfunction

//library EDWCinematicContent ends
//library EDWVisualVote:
    	
    function EDWVisualVote_GameModeSolo takes nothing returns nothing
        //call DisplayTextToPlayer(Player(0), 0, 0, "solo")
                
        set GameMode=GameModesGlobals_SOLO
    endfunction
    
    function EDWVisualVote_GameModeRandom takes nothing returns nothing
        //call DisplayTextToPlayer(Player(0), 0, 0, "random")
        
        set GameMode=GameModesGlobals_TEAMRANDOM
    endfunction
    
    function EDWVisualVote_GameModeAllIsOne takes nothing returns nothing
        //call DisplayTextToPlayer(Player(0), 0, 0, "all is one")
        
        set GameMode=GameModesGlobals_TEAMALL
    endfunction
    
    function EDWVisualVote_RewardStandard takes nothing returns nothing
        //call DisplayTextToPlayer(Player(0), 0, 0, "standard")
        
        set RewardMode=GameModesGlobals_EASY
    endfunction
    
    function EDWVisualVote_RewardChallenge takes nothing returns nothing
        //call DisplayTextToPlayer(Player(0), 0, 0, "challenge")
        
        set RewardMode=GameModesGlobals_HARD
    endfunction
    
    function EDWVisualVote_Reward99AndNone takes nothing returns nothing
        //call DisplayTextToPlayer(Player(0), 0, 0, "99 and none")
        
        set RewardMode=GameModesGlobals_CHEAT
    endfunction
    
    function EDWVisualVote_MinigamesOn takes nothing returns nothing
        //call DisplayTextToPlayer(Player(0), 0, 0, "minigames on (actually off)")
        
        //no minigames yet!
        set MinigamesMode=false
        //set MinigamesMode = true
    endfunction
    function EDWVisualVote_MinigamesOff takes nothing returns nothing
        //call DisplayTextToPlayer(Player(0), 0, 0, "minigames off")
        
        set MinigamesMode=false
    endfunction
    
    function EDWVisualVote_InstantRespawnOn takes nothing returns nothing
        //call DisplayTextToPlayer(Player(0), 0, 0, "respawn ASAP on")
        
        set RespawnASAPMode=true
		set RespawnPauseTime=2.5
    endfunction
    function EDWVisualVote_InstantRespawnOff takes nothing returns nothing
        //call DisplayTextToPlayer(Player(0), 0, 0, "respawn ASAP off")
        
        set RespawnASAPMode=false
		set RespawnPauseTime=1.5
    endfunction
	
 function EDWVisualVote___FadeCBTwo takes nothing returns nothing
		call DisplayCineFilter(false)
		call EnableUserUI(true)
						
		call ReleaseTimer(GetExpiredTimer())
	endfunction
 function EDWVisualVote___FadeCBOne takes nothing returns nothing
		call DisplayCineFilter(false)
		
		call SetCineFilterTexture("ReplaceableTextures\\CameraMasks\\Black_mask.blp")
		call SetCineFilterBlendMode(BLEND_MODE_BLEND)
		call SetCineFilterTexMapFlags(TEXMAP_FLAG_NONE)
		call SetCineFilterStartUV(0, 0, 1, 1)
		call SetCineFilterEndUV(0, 0, 1, 1)
		call SetCineFilterStartColor(PercentTo255(100), PercentTo255(100), PercentTo255(100), PercentTo255(100))
		call SetCineFilterEndColor(PercentTo255(100), PercentTo255(100), PercentTo255(100), PercentTo255(0))
		call SetCineFilterDuration(3)
		call DisplayCineFilter(true)
		
		//call EnableUserUI(true)
		
		call TimerStart(GetExpiredTimer(), 3, false, function EDWVisualVote___FadeCBTwo)
	endfunction
 function EDWVisualVote___MultiboardMinimizeCB takes nothing returns nothing
		call MultiboardMinimize(s__Teams_MazingTeam_PlayerStats, true)
		
		call ReleaseTimer(GetExpiredTimer())
	endfunction
    
 function EDWVisualVote_InitializeGameForGlobals takes nothing returns nothing
  local integer fp= PlayerUtils_FirstPlayer
        
        local integer count= (PlayerUtils___ACTIVE_HUMAN_PLAYERS_COUNT) // INLINED!!
        local integer array team
        local integer i= 0
        local integer teamCount= 1
        local integer array teamSize
        local integer array teamSlotsRemaining
        
        local integer rand
        local boolean flag
		
		//get first level -- mostly for debugging, should always be 0 in release
        local integer firstLevel= GetFirstLevel()
		
  local real welcomeCineTime= 0
  local integer welcomeCine
        local integer cineMsg
        
        //call DisplayTextToPlayer(Player(0), 0, 0, "Initializing Game For Globals")
        //call DisplayTextToPlayer(Player(0), 0, 0, "Human count: " + I2S(count))
        
		//now that difficulty is set, we can initialize all startable content
		call EDWLevelContent_Initialize()
		
        if GameMode == 0 then
            //create a team for each player
            set i=0
            loop
            exitwhen fp == 0
                set team[i]=s__Teams_MazingTeam_create()
                call s__Teams_MazingTeam_AddPlayer(team[i],s__SimpleList_ListNode_value[fp])
                set s__Teams_MazingTeam_Weight[team[i]]=1
            set fp=s__SimpleList_ListNode_next[fp]
            set i=i + 1
            endloop
            
            set teamCount=i
        elseif GameMode == 1 then
            //one team for all players
            set team[0]=s__Teams_MazingTeam_create()
            loop
            exitwhen fp == 0
                call s__Teams_MazingTeam_AddPlayer(team[0],s__SimpleList_ListNode_value[fp])
            set fp=s__SimpleList_ListNode_next[fp]
            endloop
            
            set s__Teams_MazingTeam_Weight[team[0]]=1
        elseif GameMode == 2 then
            //define team sizes
            if count == 1 or count == 2 or count == 3 then
                if GetRandomInt(0, 1) == 0 then
					//1v1 or 1v1v1
					set teamCount=count
					
					//set all teams to have size = 1
					set i=0
					loop
						set teamSize[i]=1
						
					set i=i + 1
					exitwhen i >= count
					endloop
				else
					//all on same team
					set teamCount=1
					set teamSize[0]=count
				endif
            elseif count == 4 or count == 6 or count == 8 then
                if count == 4 then
                    set teamCount=2
                elseif count == 6 then
                    if GetRandomInt(0, 1) == 0 then
                        //3v3
                        set teamCount=2
                    else
                        //2v2v2
                        set teamCount=3
                    endif
                elseif count == 8 then
                    if GetRandomInt(0, 1) == 0 then
                        //4v4
                        set teamCount=2
                    else
                        //2v2v2v2
                        set teamCount=4
                    endif
                endif
                
                set i=0
                loop
                    set teamSize[i]=count / teamCount
                    
                    set i=i + 1
                exitwhen i >= count
                endloop
                
            elseif count == 5 then
                set teamCount=2
                set teamSize[0]=3
                set teamSize[1]=2
            else //count == 7
                if ( GetRandomInt(0, 1) == 0 ) then
                    //4v3
                    set teamCount=2
                    set teamSize[0]=4
                    set teamSize[1]=3
                else
                    //3v2v2
                    set teamCount=3
                    set teamSize[0]=3
                    set teamSize[1]=2
                    set teamSize[2]=2
                endif
            endif
            //call DisplayTextToForce(bj_FORCE_PLAYER[0], "Team Count: " + I2S(teamCount))
            //create teams
            set i=0
            loop
                //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Team Size: " + I2S(teamSize[i]))
                set team[i]=s__Teams_MazingTeam_create()
                set teamSlotsRemaining[i]=teamSize[i]
                
                set i=i + 1
            exitwhen i >= teamCount
            endloop
            
            //randomly place players in teams        
            loop
            exitwhen fp == 0
                //roll a random number that corresponds to player i's assigned team
                set rand=GetRandomInt(0, count) //count is both a measure of number players left teamless and number slots remaining
                //call DisplayTextToForce(bj_FORCE_PLAYER[0], "Rand: " + I2S(rand) + " remaining: " + I2S(count))
                //place player i into the 0 based slot # (rand) of the available remaining slots
                set i=0
                set flag=false
                loop
                    if teamSlotsRemaining[i] != 0 and teamSlotsRemaining[i] >= rand then
                        call s__Teams_MazingTeam_AddPlayer(team[i],s__SimpleList_ListNode_value[fp])
                        //call PauseUnit(MazersArray[fp.value], false)
                        //call DisplayTextToForce(bj_FORCE_PLAYER[0], "Added player: " + I2S(fp.value) + " to team: " + I2S(i))
                        
                        set count=count - 1
                        set teamSlotsRemaining[i]=teamSlotsRemaining[i] - 1
                        
                        set flag=true //this loop ends after a player is added to a random group
                    else
                        set rand=rand - teamSlotsRemaining[i]
                        //call DisplayTextToForce(bj_FORCE_PLAYER[0], "No room in team: " + I2S(i))
                    endif
                    
                    set i=i + 1
                exitwhen flag or i >= teamCount
                endloop
            set fp=s__SimpleList_ListNode_next[fp]
            endloop
        else
            call DisplayTextToForce(bj_FORCE_PLAYER[0], "Invalid Gamemode!")
            return
        endif
        
        //determine starting continues
        call s__Teams_MazingTeam_ComputeTeamWeights()
		
		//initialize multiboard
		call s__Teams_MazingTeam_MultiboardSetupInit()
		
        //debug call DisplayTextToPlayer(Player(0), 0, 0, "Team count " + I2S(teamCount))
        //call firstLevel.Start()
		
		if GameMode == GameModesGlobals_SOLO then
			set cineMsg=s__CinemaMessage_create(null , ColorMessage("Solo mode" , SPEAKER_COLOR) + " selected. Fend for yourselves" , DEFAULT_MEDIUM_TEXT_SPEED)
			set welcomeCineTime=welcomeCineTime + DEFAULT_MEDIUM_TEXT_SPEED
		elseif GameMode == GameModesGlobals_TEAMALL then
			set cineMsg=s__CinemaMessage_create(null , ColorMessage("One team" , SPEAKER_COLOR) + " selected. Get cozy" , DEFAULT_MEDIUM_TEXT_SPEED)
			set welcomeCineTime=welcomeCineTime + DEFAULT_MEDIUM_TEXT_SPEED
		else //TEAMRANDOM
			set cineMsg=s__CinemaMessage_create(null , ColorMessage("Random teams" , SPEAKER_COLOR) + " selected. Check out the scoreboard for specifics" , DEFAULT_MEDIUM_TEXT_SPEED)
			set welcomeCineTime=welcomeCineTime + DEFAULT_MEDIUM_TEXT_SPEED
		endif
		
		set welcomeCine=s__Cinematic_create(null , false , true , cineMsg)
		
		if RewardMode == GameModesGlobals_EASY then
			call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(welcomeCine)],s__CinemaMessage_create((null ) , ( ColorMessage("Easy mode" , SPEAKER_COLOR) + " selected. Gotta start somewhere" ) , (( DEFAULT_MEDIUM_TEXT_SPEED)*1.0))) // INLINED!!
			set welcomeCineTime=welcomeCineTime + DEFAULT_MEDIUM_TEXT_SPEED
		elseif RewardMode == GameModesGlobals_HARD then
			call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(welcomeCine)],s__CinemaMessage_create((null ) , ( ColorMessage("Hard mode" , SPEAKER_COLOR) + " selected. Yikes" ) , (( DEFAULT_MEDIUM_TEXT_SPEED)*1.0))) // INLINED!!
			set welcomeCineTime=welcomeCineTime + DEFAULT_MEDIUM_TEXT_SPEED
		else //CHEAT
			call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(welcomeCine)],s__CinemaMessage_create((null ) , ( ColorMessage("99 and None mode" , SPEAKER_COLOR) + " selected. Like " + ColorMessage("easy mode" , SPEAKER_COLOR) + ", but cheatier" ) , (( DEFAULT_LONG_TEXT_SPEED)*1.0))) // INLINED!!
			set welcomeCineTime=welcomeCineTime + DEFAULT_LONG_TEXT_SPEED
		endif
		
		call TimerStart((NewTimerEx(0)), welcomeCineTime + .5, false, function EDWVisualVote___MultiboardMinimizeCB) // INLINED!!
		
		set s__CinemaMessage_NextMessageBuffer[(s__SimpleList_ListNode_value[s__SimpleList_List_last[s__Cinematic_CinemaMessages[(welcomeCine)]]])]=((1)*1.0) // INLINED!!
		set welcomeCineTime=welcomeCineTime + 1

		call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(welcomeCine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(FINAL_BOSS_PRE_REVEAL , "Welcome" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_TINY_TEXT_SPEED)*1.0))) // INLINED!!
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(welcomeCine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(FINAL_BOSS_PRE_REVEAL , "To" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_TINY_TEXT_SPEED)*1.0))) // INLINED!!
        call s__SimpleList_List_addEnd(s__Cinematic_CinemaMessages[(welcomeCine)],s__CinemaMessage_create((null ) , ( GetEDWSpeakerMessage(FINAL_BOSS_PRE_REVEAL , "Dream World" , DEFAULT_TEXT_COLOR) ) , (( DEFAULT_SHORT_TEXT_SPEED)*1.0))) // INLINED!!
		
		set welcomeCineTime=welcomeCineTime + 2 * DEFAULT_TINY_TEXT_SPEED //don't include last message, more dramatic that way
		
        set i=0
        loop
            call s__Teams_MazingTeam_ApplyTeamDefaultCameras(team[i])
		
			if (CONFIGURATION_PROFILE == RELEASE or FORCE_SETTING_MENU) then // INLINED!!
				call s__Teams_MazingTeam_AddTeamCinema(team[i],welcomeCine , s__SimpleList_ListNode_value[s__Teams_MazingTeam_FirstUser[team[i]]])
			endif
						
			call s__Levels_Level_StartLevelForTeam(firstLevel,team[i])
			
			if (CONFIGURATION_PROFILE == RELEASE or FORCE_SETTING_MENU) then // INLINED!!
				call s__Teams_MazingTeam_CancelAutoUnpauseForTeam(team[i])
			endif
			
            //debug call DisplayTextToPlayer(Player(0), 0, 0, "Team " + I2S(team[i]) + " on level: " + I2S(team[i].OnLevel))
        set i=i + 1
        exitwhen i >= teamCount
        endloop
				
		if (CONFIGURATION_PROFILE == RELEASE or FORCE_SETTING_MENU) then // INLINED!!
			call EnableUserUI(false)
			call SetCineFilterTexture("ReplaceableTextures\\CameraMasks\\Black_mask.blp")
			call SetCineFilterBlendMode(BLEND_MODE_BLEND)
			call SetCineFilterTexMapFlags(TEXMAP_FLAG_NONE)
			call SetCineFilterStartUV(0, 0, 1, 1)
			call SetCineFilterEndUV(0, 0, 1, 1)
			call SetCineFilterStartColor(PercentTo255(100), PercentTo255(100), PercentTo255(100), PercentTo255(100))
			call SetCineFilterEndColor(PercentTo255(100), PercentTo255(100), PercentTo255(100), PercentTo255(100))
			call SetCineFilterDuration(0)
			call DisplayCineFilter(true)
			
			call TimerStart((NewTimerEx(0)), welcomeCineTime, false, function EDWVisualVote___FadeCBOne) // INLINED!!
		else
			set fp=PlayerUtils_FirstPlayer
			loop
			exitwhen fp == 0
				call PauseUnit(s__MazersArray[s__SimpleList_ListNode_value[fp]], false)
			set fp=s__SimpleList_ListNode_next[fp]
			endloop
		endif
		
        //apply the player's (custom) Default camerasetup and pan to their default mazer
        //call SelectAndPanAllDefaultUnits()
        
		if not (CONFIGURATION_PROFILE == RELEASE or FORCE_SETTING_MENU) or RewardMode == GameModesGlobals_CHEAT then // INLINED!!
			set i=0
			loop
				call s__Teams_MazingTeam_SetContinueCount(team[i],99)
			set i=i + 1
			exitwhen i >= teamCount
			endloop
		endif
		
        //call DisplayTextToForce(bj_FORCE_PLAYER[0], "Finished Initializing Game For Globals!")
	endfunction
	    
 function EDWVisualVote_OnRoundOneFinishCB takes nothing returns nothing
  local integer MyMenu
  local integer col
        local integer con
        local integer opt
		
		if GameMode != 0 then
			
			
			//I think I actually like just always setting game to We Band of Brothers
			set RespawnASAPMode=false
			set MinigamesMode=false
			
			call EDWVisualVote_InitializeGameForGlobals()
		else
			set RespawnASAPMode=true
			set MinigamesMode=false
			
			call EDWVisualVote_InitializeGameForGlobals()
		endif
	endfunction
    
    //2 stage menu, first choose difficulty and team breakdown -- then specify for final options
    function EDWVisualVote_CreateMenu takes nothing returns nothing
  local integer MyMenu
  local integer col
        local integer con
        local integer opt

		if not (CONFIGURATION_PROFILE == RELEASE or FORCE_SETTING_MENU) then // INLINED!!
            if EDWVisualVote___DEBUG_USE_FULL_VISIBILITY then
				call CreateFogModifierRectBJ(true, Player(0), FOG_OF_WAR_VISIBLE, GetPlayableMapRect())
			endif
			
			set GameMode=GameModesGlobals_TEAMALL // INLINED!!
			//set GameMode = GameModesGlobals_TEAMALL
            //99 and none
			set RewardMode=EDWVisualVote___DEBUG_DIFFICULTY_MODE
            //respawn as soon as you die
            call EDWVisualVote_InstantRespawnOff()
			//set RespawnASAPMode = false
            //currently unimplemented
            set MinigamesMode=false // INLINED!!
			//set MinigamesMode = false
            
            call EDWVisualVote_InitializeGameForGlobals()
			
			call MultiboardMinimize(s__Teams_MazingTeam_PlayerStats, true)
			
			if GetFirstLevel() != (1) then
				call TrackGameTime()
			endif
		elseif (PlayerUtils___ACTIVE_HUMAN_PLAYERS_COUNT) == 1 then // INLINED!!
			set GameMode=GameModesGlobals_SOLO // INLINED!!
			call EDWVisualVote_InstantRespawnOn()
			set MinigamesMode=false // INLINED!!
			
			set MyMenu=s__VisualVote_voteMenu_create(3060 , 5800 , EDWVisualVote___VOTE_TIME_ROUND_ONE , null)
            set s__VisualVote_voteMenu_onDestroyFinish[MyMenu]="EDWVisualVote_InitializeGameForGlobals"
            call s__VisualVote_voteMenu_addAllPlayersToMenu(MyMenu)
			
			set col=s__VisualVote_voteMenu_addColumn(MyMenu,512)
			
			set con=s__VisualVote_voteColumn_addContainer(col,"Difficulty")
            set s__VisualVote_voteContainer_required[con]=true
			call s__VisualVote_voteContainer_addOption(con,"Vanilla" , "EDWVisualVote_RewardStandard")
            call s__VisualVote_voteContainer_addOption(con,"Chocolate" , "EDWVisualVote_RewardChallenge")
            set opt=s__VisualVote_voteContainer_addOption(con,"99 and None" , "EDWVisualVote_Reward99AndNone")
            set s__VisualVote_voteContainer_defaultOption[con]=opt
			
			call s__VisualVote_voteMenu_render(MyMenu)
            call s__VisualVote_voteMenu_enforceVoteMode(MyMenu)
        else
            set MyMenu=s__VisualVote_voteMenu_create(3060 , 5800 , EDWVisualVote___VOTE_TIME_ROUND_ONE , null)
            set s__VisualVote_voteMenu_onDestroyFinish[MyMenu]="EDWVisualVote_OnRoundOneFinishCB"
            call s__VisualVote_voteMenu_addAllPlayersToMenu(MyMenu)
            //set MyMenu = VisualVote_voteMenu.create(-1600, 7556)
            
            set col=s__VisualVote_voteMenu_addColumn(MyMenu,512)
            //
            set con=s__VisualVote_voteColumn_addContainer(col,"Teams")
            set s__VisualVote_voteContainer_required[con]=true
            
            call s__VisualVote_voteContainer_addOption(con,"Solo" , "EDWVisualVote_GameModeSolo")
            set opt=s__VisualVote_voteContainer_addOption(con,"Teams - Mixer" , "EDWVisualVote_GameModeRandom")
            set opt=s__VisualVote_voteContainer_addOption(con,"Teams - One for All" , "EDWVisualVote_GameModeAllIsOne")
            set s__VisualVote_voteContainer_defaultOption[con]=opt
			//debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Default: " + con.defaultOption.text)
            
			set con=s__VisualVote_voteColumn_addContainer(col,"Difficulty")
            set s__VisualVote_voteContainer_required[con]=true
            
            call s__VisualVote_voteContainer_addOption(con,"Vanilla" , "EDWVisualVote_RewardStandard")
            call s__VisualVote_voteContainer_addOption(con,"Chocolate" , "EDWVisualVote_RewardChallenge")
            set opt=s__VisualVote_voteContainer_addOption(con,"99 and None" , "EDWVisualVote_Reward99AndNone")
            set s__VisualVote_voteContainer_defaultOption[con]=opt
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Default: " + con.defaultOption.text)
            
            //debug call DisplayTextToForce(bj_FORCE_PLAYER[0], "Default: " + con.defaultOption.text)
			if CONFIGURATION_PROFILE != RELEASE then
				set col=s__VisualVote_voteMenu_addColumn(MyMenu,512)
				
				set con=s__VisualVote_voteColumn_addContainer(col,"Contests")
				set s__VisualVote_voteContainer_required[con]=false
				set s__VisualVote_voteContainer_enabled[con]=false
				set opt=s__VisualVote_voteContainer_addOption(con,"yea" , "EDWVisualVote_MinigamesOn")
				set opt=s__VisualVote_voteContainer_addOption(con,"nei" , "EDWVisualVote_MinigamesOn")
				call s__VisualVote_voteOption_setDefault(opt)

				set con=s__VisualVote_voteColumn_addContainer(col,"RPG Mode")
				set s__VisualVote_voteContainer_required[con]=false
				set s__VisualVote_voteContainer_enabled[con]=false
				set opt=s__VisualVote_voteContainer_addOption(con,"yea" , "EDWVisualVote_MinigamesOn")
				set opt=s__VisualVote_voteContainer_addOption(con,"nei" , "EDWVisualVote_MinigamesOn")
				call s__VisualVote_voteOption_setDefault(opt)
            endif
			
            call s__VisualVote_voteMenu_render(MyMenu)
            
            call s__VisualVote_voteMenu_enforceVoteMode(MyMenu)
        endif
    endfunction

//library EDWVisualVote ends
//library EDWGameStart:
    
    function EDWGameStart___PlayerInit takes nothing returns nothing
        local integer fp= PlayerUtils_FirstPlayer
        local integer u
        
        loop
        exitwhen fp == 0
            set u=s__SimpleList_ListNode_value[fp]
            
            if s__User_IsPlaying[u] then
                set s__User_ActiveUnit[u]=s__MazersArray[u]
            endif
        set fp=s__SimpleList_ListNode_next[fp]
        endloop
    endfunction
                    
    function EDWGameStart___PreplacedUnitInit takes nothing returns nothing
        local unit u
        local integer uID
                
        call GroupEnumUnitsInRect(TempGroup, bj_mapInitialPlayableArea, null)
        
        loop
        set u=FirstOfGroup(TempGroup)
        exitwhen u == null
            set uID=GetUnitTypeId(u)
            
            if uID == POWERUP_MARKER or s__InWorldPowerup_IsPowerupUnit(uID) then
				call s__InWorldPowerup_CreateFromUnit(u)
            elseif uID == UBOUNCE then
                //call AddUnitLocust(CreateUnit(Player(11), UBOUNCE, GetUnitX(u), GetUnitY(u), 90))
call sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((UBOUNCE )))),(( GetUnitX(u) )*1.0) , (( GetUnitY(u))*1.0)) // INLINED!!
                call RemoveUnit(u)
            elseif uID == LBOUNCE then
                //call AddUnitLocust(CreateUnit(Player(11), LBOUNCE, GetUnitX(u), GetUnitY(u), 180))
call sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((LBOUNCE )))),(( GetUnitX(u) )*1.0) , (( GetUnitY(u))*1.0)) // INLINED!!
                call RemoveUnit(u)
            elseif uID == DBOUNCE then
                // call AddUnitLocust(CreateUnit(Player(11), DBOUNCE, GetUnitX(u), GetUnitY(u), 270))
call sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((DBOUNCE )))),(( GetUnitX(u) )*1.0) , (( GetUnitY(u))*1.0)) // INLINED!!
                call RemoveUnit(u)
            elseif uID == RBOUNCE then
                // call AddUnitLocust(CreateUnit(Player(11), RBOUNCE, GetUnitX(u), GetUnitY(u), 0))
call sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((RBOUNCE )))),(( GetUnitX(u) )*1.0) , (( GetUnitY(u))*1.0)) // INLINED!!
                call RemoveUnit(u)
			//elseif GetPlayerId(GetOwningPlayer(u)) == 11 and (uID == BFIRE or uID == BKEY or uID == RFIRE or uID == RKEY or uID == GFIRE or uID == GKEY or uID == KEYR or uID == REGRET or uID == LMEMORY or uID == GUILT or uID == GRAVITY or uID == BOUNCER or uID == SUPERSPEED) then
			else
				call s__IndexedUnit_create(u)
            endif
        call GroupRemoveUnit(TempGroup, u)
        endloop
        
        call GroupClear(TempGroup)
    endfunction

    
    function EDWGameStart___LevelRewardsInit takes nothing returns nothing
        if RewardMode == 0 or RewardMode == 2 then
            
        elseif RewardMode == 1 then
            
        endif
    endfunction
	











            
    function EDWGameStart___First takes nothing returns nothing
        //INITIALIZE MAP SETTINGS
        //time should be fixed at noon
        call SetFloatGameState(GAME_STATE_TIME_OF_DAY, 12.00001)
        call SetTimeOfDayScale(0)
        
        //ADD LOCUST TO ALL OF BROWNS UNITS
        call AddLocustAll()
        
        //CALL OTHER INITS
        call EDWPlayerSlotsInit()
        
        //GAME MODE INIT
        //Menu should happen after level creation so that it doesn't mess with the number of players on the intro world
        //use single players when in debug mode, now that menu is functional
        call EDWVisualVote_CreateMenu()
        
		//theres no way to detect the game paused / resumed event, so all other events cannot be unhooked during that state
		//some of those events, such as platforming arrow keys, can be abused
		//waste all 3 pauses
		call PauseGame(true)
		call PauseGame(false)
		call PauseGame(true)
		call PauseGame(false)
		call PauseGame(true)
		call PauseGame(false)
		






		
		call ReleaseTimer(GetExpiredTimer())
    endfunction	
            
    function EDWGameStart___Init takes nothing returns nothing
        call TimerStart((NewTimerEx(0)), GAME_INIT_TIME_INITIAL, false, function EDWGameStart___First) // INLINED!!
        



		
		//connect editor placed units with their needed logic
        call EDWGameStart___PreplacedUnitInit()
		



		
        //call level initalizer
		call EDWLevels_Initialize()
		



		
		// call EDWLevelContent_Initialize()
		



		
		//call cinematic initalizer after levels are ready
		call EDWCinematicContent_Initialize()
		



		






    endfunction

//library EDWGameStart ends
//===========================================================================
// 
// Escape Dream World v18
// 
//   Warcraft III map script
//   Generated by the Warcraft III World Editor
//   Date: Wed Oct 16 08:28:11 2019
//   Map Author: Serenity09
// 
//===========================================================================

//***************************************************************************
//*
//*  Global Variables
//*
//***************************************************************************


function InitGlobals takes nothing returns nothing
endfunction

//***************************************************************************
//*
//*  Custom Script Code
//*
//***************************************************************************
//***************************************************************************
//*  SpecialEffect

//***************************************************************************
//*
//*  Sounds
//*
//***************************************************************************

function InitSounds takes nothing returns nothing
    set gg_snd_ReceiveGold=CreateSound("Abilities\\Spells\\Items\\ResourceItems\\ReceiveGold.wav", false, true, true, 10, 10, "SpellsEAX")
    call SetSoundParamsFromLabel(gg_snd_ReceiveGold, "ReceiveGold")
    call SetSoundDuration(gg_snd_ReceiveGold, 589)
    set gg_snd_FroggerPS1Victory_EDW=CreateSound("war3mapImported\\FroggerPS1Victory_EDW.wav", false, false, false, 10, 10, "SpellsEAX")
    call SetSoundDuration(gg_snd_FroggerPS1Victory_EDW, 2331)
    call SetSoundChannel(gg_snd_FroggerPS1Victory_EDW, 13)
    call SetSoundVolume(gg_snd_FroggerPS1Victory_EDW, 127)
    call SetSoundPitch(gg_snd_FroggerPS1Victory_EDW, 1.0)
endfunction

//***************************************************************************
//*
//*  Items
//*
//***************************************************************************

function CreateAllItems takes nothing returns nothing
    local integer itemID

    call CreateItem('I000', - 12555.0, - 14897.9)
endfunction

//***************************************************************************
//*
//*  Unit Creation
//*
//***************************************************************************

//===========================================================================
function CreateUnitsForPlayer0 takes nothing returns nothing
    local player p= Player(0)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set gg_unit_Edem_0001=CreateUnit(p, 'Edem', 11352.6, 12470.7, 45.000)
    set u=CreateUnit(p, 'pMRK', - 14912.9, - 6749.8, 277.226)
    set u=CreateUnit(p, 'o000', - 12473.9, 13741.0, 287.664)
endfunction

//===========================================================================
function CreateUnitsForPlayer1 takes nothing returns nothing
    local player p= Player(1)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set gg_unit_Edem_0002=CreateUnit(p, 'Edem', 11511.5, 12497.3, 45.000)
endfunction

//===========================================================================
function CreateUnitsForPlayer2 takes nothing returns nothing
    local player p= Player(2)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set gg_unit_Edem_0014=CreateUnit(p, 'Edem', 11558.1, 12336.2, 45.000)
endfunction

//===========================================================================
function CreateUnitsForPlayer3 takes nothing returns nothing
    local player p= Player(3)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set gg_unit_Edem_0015=CreateUnit(p, 'Edem', 11260.8, 12535.9, 45.000)
endfunction

//===========================================================================
function CreateUnitsForPlayer4 takes nothing returns nothing
    local player p= Player(4)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set gg_unit_Edem_0016=CreateUnit(p, 'Edem', 11617.9, 12439.8, 45.000)
endfunction

//===========================================================================
function CreateUnitsForPlayer5 takes nothing returns nothing
    local player p= Player(5)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set gg_unit_Edem_0017=CreateUnit(p, 'Edem', 11414.4, 12565.2, 45.000)
endfunction

//===========================================================================
function CreateUnitsForPlayer6 takes nothing returns nothing
    local player p= Player(6)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set gg_unit_Edem_0018=CreateUnit(p, 'Edem', 11450.0, 12413.5, 45.000)
endfunction

//===========================================================================
function CreateUnitsForPlayer7 takes nothing returns nothing
    local player p= Player(7)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set gg_unit_Edem_0019=CreateUnit(p, 'Edem', 11336.7, 12641.2, 45.000)
endfunction

//===========================================================================
function CreateUnitsForPlayer9 takes nothing returns nothing
    local player p= Player(9)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u=CreateUnit(p, 'hfoo', 119.5, 2286.6, 302.965)
    set u=CreateUnit(p, 'emtg', - 15082.9, 9969.6, 270.000)
    set u=CreateUnit(p, 'edoc', - 14845.8, 9975.9, 270.000)
    set u=CreateUnit(p, 'n002', - 14082.5, 9972.0, 270.000)
    set u=CreateUnit(p, 'hmtt', - 14592.6, 9970.7, 270.000)
    set u=CreateUnit(p, 'otau', - 15088.6, 9716.9, 270.000)
    set u=CreateUnit(p, 'pMRK', 5381.7, - 466.4, 144.727)
    set u=CreateUnit(p, 'ospw', - 14850.2, 9720.9, 270.000)
    set u=CreateUnit(p, 'uabo', - 14594.6, 9713.7, 270.000)
    set u=CreateUnit(p, 'e00J', - 14844.9, 9453.8, 270.000)
    set u=CreateUnit(p, 'e000', - 14333.8, 9980.6, 270.000)
    set u=CreateUnit(p, 'e005', - 13816.4, 9729.7, 270.000)
    set u=CreateUnit(p, 'e003', - 14333.1, 9714.7, 270.000)
    set u=CreateUnit(p, 'e004', - 14075.9, 9715.8, 270.000)
    set u=CreateUnit(p, 'e00K', - 14590.1, 9451.3, 270.000)
    set u=CreateUnit(p, 'e00N', - 14330.6, 9455.1, 270.000)
    set u=CreateUnit(p, 'e00Q', - 14074.8, 9442.5, 270.000)
    set u=CreateUnit(p, 'e00A', - 15102.0, 9465.2, 270.000)
    set u=CreateUnit(p, 'o002', - 13818.7, 9970.7, 270.000)
    set u=CreateUnit(p, 'e00U', - 13569.5, 9972.3, 270.000)
endfunction

//===========================================================================
function CreateUnitsForPlayer11 takes nothing returns nothing
    local player p= Player(11)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u=CreateUnit(p, 'e00E', 12894.9, 12136.4, 329.995)
    set u=CreateUnit(p, 'e00B', - 12950.3, 13694.5, 194.376)
    set u=CreateUnit(p, 'e00C', - 12663.8, 13467.0, 331.556)
    set u=CreateUnit(p, 'e005', - 1206.9, 14392.5, 326.612)
    set u=CreateUnit(p, 'e005', - 1619.2, 14853.0, 278.325)
    set u=CreateUnit(p, 'e005', - 1689.8, 14195.1, 304.386)
    set u=CreateUnit(p, 'e00E', - 12030.7, 14204.1, 316.504)
    set u=CreateUnit(p, 'e005', 10994.0, 7117.4, 120.000)
    set u=CreateUnit(p, 'e005', 11208.3, 6820.1, 301.342)
    set u=CreateUnit(p, 'e005', 10787.3, 6362.1, 7.954)
    set u=CreateUnit(p, 'e003', 11192.4, 5498.8, 162.482)
    set u=CreateUnit(p, 'e004', 10948.1, 3747.1, 173.293)
    set u=CreateUnit(p, 'e00B', 14526.4, 10383.5, 129.027)
    set u=CreateUnit(p, 'e005', 10969.6, 3170.5, 157.285)
    set u=CreateUnit(p, 'e00C', 7469.0, 7835.1, 314.209)
    set u=CreateUnit(p, 'pMRK', - 12788.4, 12519.1, 161.317)
    set u=CreateUnit(p, 'e005', 10797.5, 3287.5, 282.698)
    set u=CreateUnit(p, 'e003', 10918.9, 5126.4, 142.145)
    set u=CreateUnit(p, 'e00K', - 2852.5, - 518.3, 286.576)
    set u=CreateUnit(p, 'e003', 11285.1, 5261.4, 130.577)
    set u=CreateUnit(p, 'e005', 11333.3, 4508.9, 96.122)
    set u=CreateUnit(p, 'e005', 10797.1, 4612.4, 181.774)
    set u=CreateUnit(p, 'e004', 11261.9, 4330.5, 213.932)
    set u=CreateUnit(p, 'e004', 11124.6, 4271.3, 26.038)
    set u=CreateUnit(p, 'e004', 11036.9, 4211.6, 308.604)
    set u=CreateUnit(p, 'e00M', 6661.6, 2553.9, 263.186)
    set u=CreateUnit(p, 'e004', 10901.3, 3718.3, 150.935)
    set u=CreateUnit(p, 'e004', 11012.5, 3798.0, 300.342)
    set u=CreateUnit(p, 'e00K', - 2606.5, - 271.0, 39.871)
    set u=CreateUnit(p, 'e00K', - 12587.1, 11340.3, 209.845)
    set u=CreateUnit(p, 'e004', 11295.9, 3615.3, 225.271)
    set u=CreateUnit(p, 'e004', 11168.0, 3513.6, 283.862)
    set u=CreateUnit(p, 'e004', 11194.8, 4342.7, 313.098)
    set u=CreateUnit(p, 'e00K', - 12108.4, 11340.2, 65.667)
    set u=CreateUnit(p, 'e005', 11661.3, 3855.5, 45.265)
    set u=CreateUnit(p, 'e005', 12154.2, 4300.9, 2.681)
    set u=CreateUnit(p, 'e004', 12298.8, 4488.6, 359.110)
    set u=CreateUnit(p, 'e004', 12890.4, 4345.6, 247.837)
    set u=CreateUnit(p, 'e004', 12614.7, 4359.4, 85.982)
    set u=CreateUnit(p, 'e004', 12545.3, 4653.2, 46.649)
    set u=CreateUnit(p, 'e004', 12458.6, 4186.6, 34.762)
    set u=CreateUnit(p, 'pTIN', - 11134.6, - 14981.2, 81.730)
    set u=CreateUnit(p, 'e00G', 3010.2, 7901.6, 274.238)
    set u=CreateUnit(p, 'e004', 12388.6, 4259.1, 185.499)
    set u=CreateUnit(p, 'e005', 12859.6, 4677.7, 37.761)
    set u=CreateUnit(p, 'e005', 12800.3, 3732.8, 295.289)
    set u=CreateUnit(p, 'e005', 12640.7, 3306.6, 244.618)
    set u=CreateUnit(p, 'e003', 12692.2, 3778.1, 33.839)
    set u=CreateUnit(p, 'e003', 12663.4, 3710.8, 223.029)
    set u=CreateUnit(p, 'e003', 12734.5, 3831.9, 185.554)
    set u=CreateUnit(p, 'e003', 12677.1, 4060.6, 322.623)
    set u=CreateUnit(p, 'e003', 12398.5, 4043.5, 212.790)
    set u=CreateUnit(p, 'e003', 12803.4, 3834.8, 137.839)
    set u=CreateUnit(p, 'h009', - 9616.3, - 10392.3, 267.200)
    set u=CreateUnit(p, 'eTEL', - 14784.0, - 12128.5, 12.832)
    set u=CreateUnit(p, 'e004', 12975.0, 3488.9, 217.547)
    set u=CreateUnit(p, 'e004', 13053.7, 3401.6, 169.843)
    set u=CreateUnit(p, 'e004', 13068.0, 3326.3, 73.050)
    set u=CreateUnit(p, 'e00K', 711.9, - 4494.8, 335.873)
    set u=CreateUnit(p, 'e00F', - 12509.3, 13464.5, 309.604)
    set u=CreateUnit(p, 'e00G', - 12013.6, 13688.9, 307.934)
    set u=CreateUnit(p, 'e00H', - 12325.9, 13440.7, 88.849)
    set u=CreateUnit(p, 'h00A', - 9697.7, - 10446.6, 84.608)
    set u=CreateUnit(p, 'h00B', - 9826.7, - 10731.6, 107.472)
    set u=CreateUnit(p, 'h00B', - 6394.1, - 15290.0, 0.000)
    set u=CreateUnit(p, 'e00Q', - 4861.6, - 15020.1, 90.000)
    set u=CreateUnit(p, 'e005', 11265.4, 6167.5, 218.096)
    set u=CreateUnit(p, 'e005', 11107.1, 6660.5, 151.660)
    set u=CreateUnit(p, 'e00D', - 12664.8, 14238.6, 157.109)
    set u=CreateUnit(p, 'e003', 11292.5, 5769.8, 304.342)
    set u=CreateUnit(p, 'e00B', 6142.3, 8334.4, 335.302)
    set u=CreateUnit(p, 'e005', 10715.4, 3455.8, 330.688)
    set u=CreateUnit(p, 'e005', 11542.6, 3197.5, 59.702)
    set u=CreateUnit(p, 'e005', 12121.2, 3584.3, 315.922)
    set u=CreateUnit(p, 'e005', 10904.2, 6961.5, 160.054)
    set u=CreateUnit(p, 'e005', 10950.0, 4714.7, 65.415)
    set u=CreateUnit(p, 'e00P', - 12261.9, 11351.2, 199.968)
    set u=CreateUnit(p, 'e005', 11999.7, 4334.6, 292.004)
    set u=CreateUnit(p, 'e003', 12865.3, 3870.9, 224.886)
    set u=CreateUnit(p, 'e003', 12908.4, 3914.9, 348.717)
    set u=CreateUnit(p, 'e004', 11248.5, 3555.1, 81.367)
    set u=CreateUnit(p, 'e00C', 12081.6, 14191.9, 112.602)
    set u=CreateUnit(p, 'e00K', - 307.1, - 6688.7, 158.032)
    set u=CreateUnit(p, 'e003', 14932.2, 14195.9, 33.883)
    set u=CreateUnit(p, 'e00E', - 4605.3, 14315.9, 208.087)
    set u=CreateUnit(p, 'e003', 15432.7, 13940.1, 150.067)
    set u=CreateUnit(p, 'e003', 15289.7, 13739.1, 312.296)
    set u=CreateUnit(p, 'e003', 15533.2, 13693.7, 283.873)
    set u=CreateUnit(p, 'e003', 15368.5, 13173.4, 106.571)
    set u=CreateUnit(p, 'e003', 15239.6, 13320.2, 212.142)
    set u=CreateUnit(p, 'e005', 13778.8, 12730.6, 8.383)
    set u=CreateUnit(p, 'e005', 13544.8, 12354.0, 340.367)
    set u=CreateUnit(p, 'e00K', - 657.6, - 6503.3, 158.032)
    set u=CreateUnit(p, 'e00C', 14020.3, 9027.1, 161.570)
    set u=CreateUnit(p, 'e00B', 11523.7, 10612.9, 207.088)
    set u=CreateUnit(p, 'e00C', 14074.7, 4494.3, 324.052)
    set u=CreateUnit(p, 'e00B', 12839.8, 6823.3, 57.054)
    set u=CreateUnit(p, 'e005', 11847.3, 4647.0, 160.076)
    set u=CreateUnit(p, 'e00F', - 3947.4, 12868.2, 206.505)
    set u=CreateUnit(p, 'e00B', 13903.4, 7159.8, 64.360)
    set u=CreateUnit(p, 'e00B', 14358.7, 7160.1, 3.626)
    set u=CreateUnit(p, 'e00B', 14429.5, 7106.8, 204.286)
    set u=CreateUnit(p, 'e00B', 10756.0, - 2976.4, 232.840)
    set u=CreateUnit(p, 'e00K', 3376.7, - 1516.0, 199.628)
    set u=CreateUnit(p, 'e00G', 521.7, 6862.3, 257.300)
    set u=CreateUnit(p, 'e00S', - 844.9, 7799.7, 2.526)
    set u=CreateUnit(p, 'e00K', - 2561.8, - 4495.1, 100.242)
    set u=CreateUnit(p, 'pMRK', - 12565.4, 12512.0, 288.730)
    set u=CreateUnit(p, 'e00E', 12743.4, 12452.0, 8.438)
    set u=CreateUnit(p, 'e00E', 12287.4, 12091.3, 47.638)
    set u=CreateUnit(p, 'e00E', 11771.8, 11767.6, 21.160)
    set u=CreateUnit(p, 'e00B', 14483.7, 7212.3, 60.471)
    set u=CreateUnit(p, 'e00E', 5989.9, 8188.3, 284.796)
    set u=CreateUnit(p, 'e00E', 5928.6, 8128.4, 169.469)
    set u=CreateUnit(p, 'e00E', 5918.9, 8241.5, 117.733)
    set u=CreateUnit(p, 'e00F', 3710.7, 7591.7, 244.431)
    set u=CreateUnit(p, 'e00M', 6576.9, 2543.1, 263.186)
    set u=CreateUnit(p, 'e00G', 1422.9, 8549.1, 335.950)
    set u=CreateUnit(p, 'e00B', 14595.4, 10508.9, 213.932)
    set u=CreateUnit(p, 'e00B', 14480.1, 10484.1, 170.579)
    set u=CreateUnit(p, 'e00J', 5099.2, - 21.2, 332.160)
    set u=CreateUnit(p, 'e00K', - 2090.9, - 5288.1, 90.651)
    set u=CreateUnit(p, 'e00K', - 1968.7, - 5500.2, 246.585)
    set u=CreateUnit(p, 'e00B', 11750.8, 13559.0, 209.417)
    set u=CreateUnit(p, 'e00J', - 2948.0, - 4366.4, 12.415)
    set u=CreateUnit(p, 'e00K', - 2985.0, - 4751.9, 100.242)
    set u=CreateUnit(p, 'e00K', - 345.0, - 6294.2, 158.032)
    set u=CreateUnit(p, 'pSIN', - 12359.1, 12511.8, 342.740)
    set u=CreateUnit(p, 'e00G', 1931.1, 6679.1, 25.401)
    set u=CreateUnit(p, 'e003', 11970.7, 4116.4, 35.849)
    set u=CreateUnit(p, 'e003', 12019.3, 4088.0, 124.633)
    set u=CreateUnit(p, 'e003', 12077.7, 4079.6, 272.810)
    set u=CreateUnit(p, 'e003', 12146.9, 4082.7, 341.136)
    set u=CreateUnit(p, 'pTIN', - 12158.7, 12488.8, 81.730)
    set u=CreateUnit(p, 'pMRK', - 12773.9, 12365.3, 215.108)
    set u=CreateUnit(p, 'e00J', 7612.9, 4301.2, 48.484)
    set u=CreateUnit(p, 'e00J', 8746.9, 3250.6, 333.907)
    set u=CreateUnit(p, 'e00Q', 2894.0, - 2507.8, 0.000)
    set u=CreateUnit(p, 'pMRK', - 12544.3, 12362.0, 33.103)
    set u=CreateUnit(p, 'pTCT', - 12350.8, 12367.8, 110.141)
    set u=CreateUnit(p, 'e00I', - 12153.6, 12355.5, 295.795)
    set u=CreateUnit(p, 'e00T', - 12140.3, 12140.8, 80.334)
    set u=CreateUnit(p, 'e00P', - 12346.7, 12132.3, 74.577)
    set u=CreateUnit(p, 'pMRK', 13547.7, 7.9, 13.898)
    set u=CreateUnit(p, 'e00J', 7114.7, 1873.3, 72.611)
    set u=CreateUnit(p, 'e00K', 6907.1, 1634.5, 63.646)
    set u=CreateUnit(p, 'pTCT', 15142.1, 3003.8, 322.634)
    set u=CreateUnit(p, 'e00K', 5061.4, - 3159.8, 45.144)
    set u=CreateUnit(p, 'e00K', 3373.5, - 1647.0, 199.628)
    set u=CreateUnit(p, 'e00J', 7544.4, - 5905.3, 139.102)
    set u=CreateUnit(p, 'e00K', - 2187.9, - 5823.7, 158.032)
    set u=CreateUnit(p, 'e00J', 6939.9, - 3830.5, 274.744)
    set u=CreateUnit(p, 'e00K', 6718.1, - 4246.3, 312.373)
    set u=CreateUnit(p, 'e00T', 4566.4, - 3589.1, 140.399)
    set u=CreateUnit(p, 'e00K', 907.7, - 7193.4, 45.144)
    set u=CreateUnit(p, 'e00K', 3390.2, - 1180.2, 272.403)
    set u=CreateUnit(p, 'e00T', 9097.4, 14398.5, 0.088)
    set u=CreateUnit(p, 'e00J', 6535.1, 1261.3, 172.579)
    set u=CreateUnit(p, 'e00J', 6016.0, 2443.6, 260.219)
    set u=CreateUnit(p, 'e00K', 3392.7, - 1393.8, 70.963)
    set u=CreateUnit(p, 'e00K', 7059.9, 2298.1, 290.004)
    set u=CreateUnit(p, 'e00K', 6768.1, 2327.3, 84.389)
    set u=CreateUnit(p, 'e00B', 4906.6, 7351.6, 26.555)
    set u=CreateUnit(p, 'e00K', 6519.4, 1759.1, 214.471)
    set u=CreateUnit(p, 'e00M', 6506.4, 2522.1, 285.642)
    set u=CreateUnit(p, 'e00B', 4986.2, 7282.9, 284.719)
    set u=CreateUnit(p, 'e00H', 1684.2, 9084.4, 326.798)
    set u=CreateUnit(p, 'e00E', - 240.7, 8957.9, 258.956)
    set u=CreateUnit(p, 'e00G', 433.5, 6789.9, 19.479)
    set u=CreateUnit(p, 'e00C', - 3253.6, 9267.8, 66.590)
    set u=CreateUnit(p, 'e00F', - 3335.2, 6410.8, 28.840)
    set u=CreateUnit(p, 'e00E', - 3284.8, 6703.7, 317.800)
    set u=CreateUnit(p, 'e00B', - 3158.6, 6436.6, 302.474)
    set u=CreateUnit(p, 'e00E', 4164.7, 8862.7, 38.717)
    set u=CreateUnit(p, 'e00K', 5057.3, - 3491.5, 45.144)
    set u=CreateUnit(p, 'e00K', 6394.6, - 4233.0, 261.472)
    set u=CreateUnit(p, 'e00E', 4232.7, 8765.0, 27.730)
    set u=CreateUnit(p, 'e00E', 4839.7, 8953.6, 169.711)
    set u=CreateUnit(p, 'e00E', 4966.9, 8953.6, 25.280)
    set u=CreateUnit(p, 'e00H', 3329.8, 7820.5, 331.830)
    set u=CreateUnit(p, 'e00B', 3426.3, 7969.4, 220.217)
    set u=CreateUnit(p, 'e00B', 3511.1, 7861.2, 350.178)
    set u=CreateUnit(p, 'e00G', 3227.6, 8157.3, 274.238)
    set u=CreateUnit(p, 'e00K', 3503.5, - 2765.3, 353.254)
    set u=CreateUnit(p, 'e00C', 2142.8, 8975.0, 302.243)
    set u=CreateUnit(p, 'e00B', 2089.9, 9378.8, 67.843)
    set u=CreateUnit(p, 'e00B', 2124.3, 9299.1, 318.536)
    set u=CreateUnit(p, 'e003', 15197.2, 13878.9, 12.547)
    set u=CreateUnit(p, 'e00Q', - 572.6, - 4280.8, 90.000)
    set u=CreateUnit(p, 'e00K', 1213.4, - 7606.9, 45.144)
    set u=CreateUnit(p, 'e00J', 2758.6, - 6500.2, 116.283)
    set u=CreateUnit(p, 'e00J', 1939.8, - 6722.7, 171.831)
    set u=CreateUnit(p, 'e00M', - 57.3, - 5311.6, 344.146)
    set u=CreateUnit(p, 'e00K', 993.5, - 4902.0, 335.873)
    set u=CreateUnit(p, 'e00K', 915.3, - 4694.1, 41.705)
    set u=CreateUnit(p, 'e00K', - 322.5, - 4042.4, 243.695)
    set u=CreateUnit(p, 'e00K', - 198.3, - 3732.7, 344.542)
    set u=CreateUnit(p, 'e00C', 12299.8, - 3447.8, 258.121)
    set u=CreateUnit(p, 'e00L', - 11727.8, 11363.4, 8.690)
    set u=CreateUnit(p, 'e00L', - 11605.1, 11552.4, 143.728)
    set u=CreateUnit(p, 'e00K', - 322.0, - 3895.7, 139.673)
    set u=CreateUnit(p, 'e00K', 717.8, - 3158.2, 98.375)
    set u=CreateUnit(p, 'e00K', 714.6, - 2858.5, 356.462)
    set u=CreateUnit(p, 'e00Q', 65.3, - 3074.5, 270.000)
    set u=CreateUnit(p, 'e00L', - 11731.7, 11740.4, 262.999)
    set u=CreateUnit(p, 'e00K', 5061.2, - 3806.7, 45.144)
    set u=CreateUnit(p, 'e00K', 3773.3, - 6327.0, 45.144)
    set u=CreateUnit(p, 'e00K', 3462.6, - 6701.8, 45.144)
    set u=CreateUnit(p, 'e00K', 3139.1, - 6533.1, 42.573)
    set u=CreateUnit(p, 'e00K', 3517.6, - 8840.8, 243.069)
    set u=CreateUnit(p, 'e00K', 3714.7, - 6999.2, 45.144)
    set u=CreateUnit(p, 'e00B', 12900.3, 6701.3, 57.054)
    set u=CreateUnit(p, 'e00K', 3505.5, - 8322.4, 310.780)
    set u=CreateUnit(p, 'e00J', 5662.8, - 3728.5, 332.160)
    set u=CreateUnit(p, 'e00K', 10034.8, 1783.6, 290.004)
    set u=CreateUnit(p, 'e00J', 3834.1, - 7639.4, 116.283)
    set u=CreateUnit(p, 'e00J', 2704.7, - 7454.5, 116.283)
    set u=CreateUnit(p, 'e00K', 9969.1, 2095.7, 290.004)
    set u=CreateUnit(p, 'e00K', 9927.5, 2658.9, 290.004)
    set u=CreateUnit(p, 'eTEL', - 11275.3, - 7606.8, 12.832)
    set u=CreateUnit(p, 'e00Q', - 12617.1, 5044.9, 90.000)
    set u=CreateUnit(p, 'e00Q', - 12869.0, 5044.9, 90.000)
endfunction

//===========================================================================
function CreateNeutralPassive takes nothing returns nothing
    local player p= Player(PLAYER_NEUTRAL_PASSIVE)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u=CreateUnit(p, 'nvk2', 5921.0, 12574.3, 14.506)
    set life=GetUnitState(u, UNIT_STATE_LIFE)
    call SetUnitState(u, UNIT_STATE_LIFE, 0.25 * life)
    set u=CreateUnit(p, 'nvlk', - 1945.5, 13715.1, 95.616)
    set u=CreateUnit(p, 'nvil', - 1514.2, 13254.5, 80.510)
    set u=CreateUnit(p, 'nvlw', - 1631.4, 13415.5, 334.533)
    set u=CreateUnit(p, 'nvk2', - 1973.8, 13179.3, 189.099)
    set u=CreateUnit(p, 'nvlk', - 2081.6, 13235.1, 335.505)
    set u=CreateUnit(p, 'nvlk', 668.6, 11130.9, 70.000)
    set u=CreateUnit(p, 'nvk2', 11866.2, 8211.9, 45.000)
    set life=GetUnitState(u, UNIT_STATE_LIFE)
    call SetUnitState(u, UNIT_STATE_LIFE, 0.10 * life)
    set u=CreateUnit(p, 'nvil', - 11483.5, - 11094.0, 270.000)
    set u=CreateUnit(p, 'nvk2', 11724.1, 6248.0, 135.000)
    set life=GetUnitState(u, UNIT_STATE_LIFE)
    call SetUnitState(u, UNIT_STATE_LIFE, 0.20 * life)
    set u=CreateUnit(p, 'nvlw', - 12481.7, - 15010.8, 137.223)
    set u=CreateUnit(p, 'nvl2', - 12592.5, - 14857.9, 300.917)
    set u=CreateUnit(p, 'nvlw', - 11415.5, - 11155.8, 180.000)
    set u=CreateUnit(p, 'nvl2', - 11564.9, - 11161.2, 0.000)
    set u=CreateUnit(p, 'zcso', - 11499.5, - 11511.4, 101.248)
    set u=CreateUnit(p, 'nvl2', - 11356.1, - 11395.7, 90.000)
    set u=CreateUnit(p, 'nvl2', - 11566.1, - 11359.9, 90.779)
    set u=CreateUnit(p, 'zhyd', - 11504.5, - 11389.5, 69.593)
    set u=CreateUnit(p, 'nvlw', - 11791.8, - 11089.0, 341.660)
    set u=CreateUnit(p, 'nvlw', - 11636.2, - 11298.8, 31.495)
    set u=CreateUnit(p, 'nvlw', - 11429.9, - 11289.5, 104.699)
    set u=CreateUnit(p, 'nvk2', - 11535.6, - 11273.7, 55.048)
    set u=CreateUnit(p, 'nvk2', - 11450.9, - 11439.4, 232.072)
    set u=CreateUnit(p, 'zmar', - 11767.5, - 11154.3, 357.533)
    set u=CreateUnit(p, 'nvlk', - 11692.0, - 11210.1, 136.528)
    set u=CreateUnit(p, 'nvil', - 11487.5, - 11306.4, 132.056)
    set u=CreateUnit(p, 'nvil', - 11436.3, - 11369.0, 90.000)
    set u=CreateUnit(p, 'nvil', - 11377.5, - 11297.2, 114.094)
    set u=CreateUnit(p, 'nvlk', - 11560.9, - 11453.8, 329.534)
endfunction

//===========================================================================
function CreatePlayerBuildings takes nothing returns nothing
endfunction

//===========================================================================
function CreatePlayerUnits takes nothing returns nothing
    call CreateUnitsForPlayer0()
    call CreateUnitsForPlayer1()
    call CreateUnitsForPlayer2()
    call CreateUnitsForPlayer3()
    call CreateUnitsForPlayer4()
    call CreateUnitsForPlayer5()
    call CreateUnitsForPlayer6()
    call CreateUnitsForPlayer7()
    call CreateUnitsForPlayer9()
    call CreateUnitsForPlayer11()
endfunction

//===========================================================================
function CreateAllUnits takes nothing returns nothing
    call CreatePlayerBuildings()
    call CreateNeutralPassive()
    call CreatePlayerUnits()
endfunction

//***************************************************************************
//*
//*  Regions
//*
//***************************************************************************

function CreateRegions takes nothing returns nothing
    local weathereffect we

    set gg_rct_HubWorld_R=Rect(128.0, 2208.0, 192.0, 2272.0)
    set gg_rct_IntroWorld_R1=Rect(11424.0, 12384.0, 11488.0, 12448.0)
    set gg_rct_Rect_012=Rect(12320.0, 13088.0, 12384.0, 13152.0)
    set gg_rct_Rect_013=Rect(13088.0, 13856.0, 13152.0, 13920.0)
    set gg_rct_Rect_014=Rect(12768.0, 13920.0, 12832.0, 13984.0)
    set gg_rct_Rect_015=Rect(11616.0, 13920.0, 11680.0, 13984.0)
    set gg_rct_Rect_016=Rect(11872.0, 14048.0, 11936.0, 14112.0)
    set gg_rct_Rect_017=Rect(12512.0, 14048.0, 12576.0, 14112.0)
    set gg_rct_IntroWorld_R2=Rect(12768.0, 14304.0, 12832.0, 14368.0)
    set gg_rct_Rect_027=Rect(14656.0, 14432.0, 14688.0, 14496.0)
    set gg_rct_Rect_028=Rect(15008.0, 14432.0, 15040.0, 14496.0)
    set gg_rct_Rect_029=Rect(11744.0, 12064.0, 11776.0, 12128.0)
    set gg_rct_Rect_030=Rect(12288.0, 11968.0, 12320.0, 12032.0)
    set gg_rct_Rect_031=Rect(14656.0, 13920.0, 14688.0, 13984.0)
    set gg_rct_Rect_032=Rect(15008.0, 13920.0, 15040.0, 13984.0)
    set gg_rct_IntroWorld_Mortar1=Rect(13568.0, 14080.0, 13632.0, 14144.0)
    set gg_rct_IntroWorld_Target1=Rect(13376.0, 13632.0, 14432.0, 14016.0)
    set gg_rct_Rect_037=Rect(13344.0, 13664.0, 13376.0, 13728.0)
    set gg_rct_Rect_038=Rect(13408.0, 13728.0, 13440.0, 13792.0)
    set gg_rct_Rect_039=Rect(13472.0, 13792.0, 13504.0, 13856.0)
    set gg_rct_Rect_040=Rect(13536.0, 13856.0, 13568.0, 13920.0)
    set gg_rct_Rect_041=Rect(13600.0, 13920.0, 13632.0, 13984.0)
    set gg_rct_Rect_042=Rect(14144.0, 13920.0, 14176.0, 13984.0)
    set gg_rct_Rect_043=Rect(14208.0, 13856.0, 14240.0, 13920.0)
    set gg_rct_Rect_044=Rect(14272.0, 13792.0, 14304.0, 13856.0)
    set gg_rct_Rect_045=Rect(14336.0, 13728.0, 14368.0, 13792.0)
    set gg_rct_Rect_046=Rect(14400.0, 13664.0, 14432.0, 13728.0)
    set gg_rct_Rect_047=Rect(13920.0, 12576.0, 13984.0, 12640.0)
    set gg_rct_Rect_048=Rect(14208.0, 12224.0, 14272.0, 12288.0)
    set gg_rct_Rect_049=Rect(11872.0, 14176.0, 11936.0, 14240.0)
    set gg_rct_Rect_050=Rect(12512.0, 14176.0, 12576.0, 14240.0)
    set gg_rct_Rect_052=Rect(10752.0, 15232.0, 11456.0, 15264.0)
    set gg_rct_IWR_1_1=Rect(96.0, 14816.0, 160.0, 14880.0)
    set gg_rct_Rect_056=Rect(- 288.0, 13792.0, - 224.0, 13856.0)
    set gg_rct_Rect_057=Rect(- 32.0, 14176.0, 32.0, 14240.0)
    set gg_rct_Rect_058=Rect(- 32.0, 13536.0, 32.0, 13600.0)
    set gg_rct_Rect_059=Rect(224.0, 13920.0, 288.0, 13984.0)
    set gg_rct_Rect_060=Rect(- 672.0, 13408.0, - 608.0, 13472.0)
    set gg_rct_Rect_061=Rect(- 224.0, 13632.0, - 160.0, 13696.0)
    set gg_rct_Rect_062=Rect(- 2464.0, 15168.0, - 2400.0, 15232.0)
    set gg_rct_Rect_063=Rect(- 2464.0, 14688.0, - 2400.0, 14752.0)
    set gg_rct_Rect_064=Rect(- 2720.0, 14304.0, - 2656.0, 14368.0)
    set gg_rct_Rect_065=Rect(- 2432.0, 14016.0, - 2368.0, 14080.0)
    set gg_rct_Rect_066=Rect(- 1056.0, 12736.0, - 992.0, 12800.0)
    set gg_rct_Rect_067=Rect(- 1056.0, 12160.0, - 992.0, 12224.0)
    set gg_rct_IWCP_1_1=Rect(- 96.0, 12384.0, 32.0, 13024.0)
    set gg_rct_IWR_1_2=Rect(352.0, 12640.0, 416.0, 12704.0)
    set gg_rct_IWR_2_1=Rect(9760.0, 11232.0, 9824.0, 11296.0)
    set gg_rct_Rect_071=Rect(9184.0, 11488.0, 9248.0, 11552.0)
    set gg_rct_Rect_072=Rect(9696.0, 12000.0, 9760.0, 12064.0)
    set gg_rct_Rect_073=Rect(9440.0, 12256.0, 9504.0, 12320.0)
    set gg_rct_Rect_074=Rect(8928.0, 11744.0, 8992.0, 11808.0)
    set gg_rct_Rect_075=Rect(8672.0, 12000.0, 8736.0, 12064.0)
    set gg_rct_Rect_076=Rect(9184.0, 12512.0, 9248.0, 12576.0)
    set gg_rct_Rect_077=Rect(7008.0, 12224.0, 7072.0, 12256.0)
    set gg_rct_Rect_078=Rect(7008.0, 11808.0, 7072.0, 11840.0)
    set gg_rct_Rect_079=Rect(6752.0, 11808.0, 6816.0, 11840.0)
    set gg_rct_Rect_080=Rect(6752.0, 12224.0, 6816.0, 12256.0)
    set gg_rct_Rect_081=Rect(6496.0, 12224.0, 6560.0, 12256.0)
    set gg_rct_Rect_082=Rect(6496.0, 11808.0, 6560.0, 11840.0)
    set gg_rct_Rect_083=Rect(7424.0, 11872.0, 7488.0, 11936.0)
    set gg_rct_Rect_084=Rect(7712.0, 11360.0, 7776.0, 11424.0)
    set gg_rct_Rect_085=Rect(7040.0, 11104.0, 7104.0, 11136.0)
    set gg_rct_Rect_086=Rect(7040.0, 10624.0, 7104.0, 10656.0)
    set gg_rct_Rect_087=Rect(6272.0, 11104.0, 6336.0, 11136.0)
    set gg_rct_Rect_088=Rect(6272.0, 10624.0, 6336.0, 10656.0)
    set gg_rct_IWCP_2_1=Rect(5728.0, 10496.0, 5856.0, 11296.0)
    set gg_rct_IWR_2_2=Rect(5376.0, 10816.0, 5440.0, 10880.0)
    set gg_rct_Rect_092=Rect(2112.0, 10400.0, 2144.0, 11808.0)
    set gg_rct_IWCP_2_2=Rect(1376.0, 12768.0, 2432.0, 12896.0)
    set gg_rct_IWR_2_3=Rect(2016.0, 13152.0, 2080.0, 13216.0)
    set gg_rct_Rect_095=Rect(1504.0, 14080.0, 1568.0, 14144.0)
    set gg_rct_Rect_096=Rect(2240.0, 13888.0, 2304.0, 13952.0)
    set gg_rct_Rect_097=Rect(2272.0, 14176.0, 2336.0, 14240.0)
    set gg_rct_Rect_098=Rect(1760.0, 14432.0, 1824.0, 14496.0)
    set gg_rct_Rect_099=Rect(2016.0, 14816.0, 2080.0, 14880.0)
    set gg_rct_Rect_100=Rect(2656.0, 14400.0, 2720.0, 14464.0)
    set gg_rct_Rect_101=Rect(2528.0, 15072.0, 2592.0, 15136.0)
    set gg_rct_Rect_102=Rect(2944.0, 14688.0, 3008.0, 14752.0)
    set gg_rct_Rect_105=Rect(3264.0, 14688.0, 3328.0, 14752.0)
    set gg_rct_Rect_106=Rect(3680.0, 15040.0, 3744.0, 15104.0)
    set gg_rct_Rect_107=Rect(3328.0, 14496.0, 3392.0, 14560.0)
    set gg_rct_Rect_108=Rect(3680.0, 14144.0, 3744.0, 14208.0)
    set gg_rct_IW2_Target1=Rect(8832.0, 14368.0, 9376.0, 15328.0)
    set gg_rct_IW2_Mortar1=Rect(9376.0, 14624.0, 9440.0, 14688.0)
    set gg_rct_IW2_Mortar2=Rect(9376.0, 13984.0, 9440.0, 14048.0)
    set gg_rct_IW2_End=Rect(9952.0, 13088.0, 10080.0, 13568.0)
    set gg_rct_IW1_End=Rect(- 3456.0, 9952.0, - 3328.0, 10496.0)
    set gg_rct_IWR_3_1=Rect(14912.0, 10176.0, 14976.0, 10240.0)
    set gg_rct_IW1_Target1=Rect(- 2208.0, 14272.0, - 1856.0, 15296.0)
    set gg_rct_IW1_Target2=Rect(- 1856.0, 13856.0, - 1344.0, 15296.0)
    set gg_rct_IW1_Target3=Rect(- 1344.0, 13728.0, - 704.0, 15200.0)
    set gg_rct_IW1_Mortar1=Rect(- 2272.0, 14944.0, - 2208.0, 15008.0)
    set gg_rct_IW1_Mortar2=Rect(- 1664.0, 14720.0, - 1600.0, 14784.0)
    set gg_rct_IW1_Mortar3=Rect(- 1152.0, 14272.0, - 1088.0, 14336.0)
    set gg_rct_LWR_1_1=Rect(- 14912.0, - 15136.0, - 14848.0, - 15072.0)
    set gg_rct_IntroWorld_Vision=Rect(10336.0, 10848.0, 16000.0, 15392.0)
    set gg_rct_IW_Entrance=Rect(2144.0, 4064.0, 2272.0, 4544.0)
    set gg_rct_IW3_End=Rect(11360.0, - 3584.0, 11776.0, - 3456.0)
    set gg_rct_Rect_124=Rect(13056.0, 9376.0, 13088.0, 9440.0)
    set gg_rct_Rect_125=Rect(13664.0, 9376.0, 13696.0, 9440.0)
    set gg_rct_Rect_126=Rect(11872.0, 9184.0, 11936.0, 9216.0)
    set gg_rct_Rect_127=Rect(11872.0, 10272.0, 11936.0, 10304.0)
    set gg_rct_Rect_128=Rect(12000.0, 9184.0, 12064.0, 9216.0)
    set gg_rct_Rect_129=Rect(12000.0, 10272.0, 12064.0, 10304.0)
    set gg_rct_Rect_130=Rect(12128.0, 10272.0, 12192.0, 10304.0)
    set gg_rct_Rect_131=Rect(12128.0, 9184.0, 12192.0, 9216.0)
    set gg_rct_Rect_132=Rect(11328.0, 7552.0, 11392.0, 7584.0)
    set gg_rct_Rect_133=Rect(11232.0, 8128.0, 11296.0, 8160.0)
    set gg_rct_Rect_134=Rect(11552.0, 7488.0, 11616.0, 7520.0)
    set gg_rct_Rect_135=Rect(11552.0, 8064.0, 11616.0, 8096.0)
    set gg_rct_Rect_136=Rect(12480.0, 7424.0, 12544.0, 7456.0)
    set gg_rct_Rect_137=Rect(12160.0, 7808.0, 12224.0, 7840.0)
    set gg_rct_Rect_138=Rect(14720.0, 6528.0, 14784.0, 6592.0)
    set gg_rct_Rect_139=Rect(15168.0, 6816.0, 15232.0, 6880.0)
    set gg_rct_Rect_140=Rect(14720.0, 6432.0, 14784.0, 6496.0)
    set gg_rct_Rect_141=Rect(15328.0, 6208.0, 15392.0, 6272.0)
    set gg_rct_Rect_142=Rect(14752.0, 5760.0, 14816.0, 5824.0)
    set gg_rct_Rect_143=Rect(15296.0, 6048.0, 15360.0, 6112.0)
    set gg_rct_Rect_144=Rect(14752.0, 5696.0, 14816.0, 5760.0)
    set gg_rct_Rect_145=Rect(15328.0, 5376.0, 15392.0, 5440.0)
    set gg_rct_Rect_146=Rect(14688.0, 4960.0, 14752.0, 5024.0)
    set gg_rct_Rect_147=Rect(15360.0, 5248.0, 15424.0, 5312.0)
    set gg_rct_Rect_148=Rect(14688.0, 4896.0, 14752.0, 4960.0)
    set gg_rct_Rect_149=Rect(15200.0, 4544.0, 15264.0, 4608.0)
    set gg_rct_Rect_150=Rect(14368.0, 4512.0, 14432.0, 4576.0)
    set gg_rct_Rect_151=Rect(14976.0, 4352.0, 15040.0, 4416.0)
    set gg_rct_Rect_152=Rect(14880.0, 4224.0, 14944.0, 4288.0)
    set gg_rct_Rect_153=Rect(14272.0, 4448.0, 14336.0, 4512.0)
    set gg_rct_Rect_154=Rect(14208.0, 4384.0, 14272.0, 4448.0)
    set gg_rct_Rect_155=Rect(14784.0, 4160.0, 14848.0, 4224.0)
    set gg_rct_Rect_156=Rect(14112.0, 4320.0, 14176.0, 4384.0)
    set gg_rct_Rect_157=Rect(14752.0, 4064.0, 14816.0, 4128.0)
    set gg_rct_Rect_158=Rect(14048.0, 4224.0, 14112.0, 4288.0)
    set gg_rct_Rect_159=Rect(14624.0, 3968.0, 14688.0, 4032.0)
    set gg_rct_Rect_160=Rect(13248.0, 3936.0, 13312.0, 4000.0)
    set gg_rct_Rect_161=Rect(14528.0, 3904.0, 14592.0, 3968.0)
    set gg_rct_Rect_162=Rect(14432.0, 3808.0, 14496.0, 3872.0)
    set gg_rct_Rect_163=Rect(13344.0, 3840.0, 13408.0, 3904.0)
    set gg_rct_Rect_164=Rect(13440.0, 3776.0, 13504.0, 3840.0)
    set gg_rct_Rect_165=Rect(14368.0, 3744.0, 14432.0, 3808.0)
    set gg_rct_Rect_166=Rect(14272.0, 3648.0, 14336.0, 3712.0)
    set gg_rct_Rect_167=Rect(13568.0, 3648.0, 13632.0, 3712.0)
    set gg_rct_Rect_168=Rect(14176.0, 3552.0, 14240.0, 3616.0)
    set gg_rct_Rect_169=Rect(13664.0, 3552.0, 13728.0, 3616.0)
    set gg_rct_Rect_170=Rect(13280.0, 4064.0, 13344.0, 4128.0)
    set gg_rct_Rect_171=Rect(13280.0, 4704.0, 13344.0, 4768.0)
    set gg_rct_Rect_172=Rect(13408.0, 4704.0, 13472.0, 4768.0)
    set gg_rct_Rect_173=Rect(13408.0, 4064.0, 13472.0, 4128.0)
    set gg_rct_Rect_174=Rect(13664.0, 5600.0, 13696.0, 5664.0)
    set gg_rct_Rect_175=Rect(13056.0, 5600.0, 13088.0, 5664.0)
    set gg_rct_Rect_176=Rect(10720.0, 4832.0, 10784.0, 4896.0)
    set gg_rct_Rect_177=Rect(10720.0, 5728.0, 10784.0, 5792.0)
    set gg_rct_Rect_178=Rect(11488.0, 3808.0, 11552.0, 3872.0)
    set gg_rct_Rect_179=Rect(12224.0, 3552.0, 12288.0, 3616.0)
    set gg_rct_Rect_180=Rect(14688.0, 2784.0, 14752.0, 2816.0)
    set gg_rct_Rect_181=Rect(14688.0, 1792.0, 14752.0, 1824.0)
    set gg_rct_Rect_182=Rect(14848.0, 864.0, 14880.0, 928.0)
    set gg_rct_Rect_183=Rect(15584.0, 864.0, 15616.0, 928.0)
    set gg_rct_Rect_184=Rect(15584.0, 480.0, 15616.0, 544.0)
    set gg_rct_Rect_185=Rect(14848.0, 480.0, 14880.0, 544.0)
    set gg_rct_Rect_186=Rect(14848.0, - 544.0, 14880.0, - 480.0)
    set gg_rct_Rect_187=Rect(15584.0, - 544.0, 15616.0, - 480.0)
    set gg_rct_Rect_188=Rect(15584.0, - 1056.0, 15616.0, - 992.0)
    set gg_rct_Rect_189=Rect(14848.0, - 1056.0, 14880.0, - 992.0)
    set gg_rct_Rect_190=Rect(15104.0, - 2336.0, 15136.0, - 2272.0)
    set gg_rct_Rect_191=Rect(15584.0, - 2336.0, 15616.0, - 2272.0)
    set gg_rct_Rect_192=Rect(15584.0, - 2464.0, 15616.0, - 2400.0)
    set gg_rct_Rect_193=Rect(15104.0, - 2464.0, 15136.0, - 2400.0)
    set gg_rct_Rect_194=Rect(14976.0, - 2592.0, 15008.0, - 2528.0)
    set gg_rct_Rect_195=Rect(15584.0, - 2592.0, 15616.0, - 2528.0)
    set gg_rct_Rect_196=Rect(12800.0, - 256.0, 12864.0, - 192.0)
    set gg_rct_Rect_197=Rect(13280.0, - 672.0, 13344.0, - 608.0)
    set gg_rct_Rect_198=Rect(13408.0, 608.0, 13472.0, 672.0)
    set gg_rct_Rect_199=Rect(14080.0, 608.0, 14144.0, 672.0)
    set gg_rct_Rect_200=Rect(14016.0, - 32.0, 14080.0, 32.0)
    set gg_rct_Rect_201=Rect(14688.0, - 32.0, 14752.0, 32.0)
    set gg_rct_Rect_202=Rect(11520.0, 1376.0, 11584.0, 1440.0)
    set gg_rct_Rect_203=Rect(11840.0, 1376.0, 11904.0, 1440.0)
    set gg_rct_Rect_204=Rect(11840.0, 1728.0, 11904.0, 1792.0)
    set gg_rct_Rect_205=Rect(11520.0, 1728.0, 11584.0, 1792.0)
    set gg_rct_IWCP_3_2=Rect(12928.0, 2944.0, 13920.0, 3168.0)
    set gg_rct_Rect_207=Rect(14176.0, 1376.0, 14240.0, 1440.0)
    set gg_rct_Rect_208=Rect(14816.0, 1376.0, 14880.0, 1440.0)
    set gg_rct_Rect_209=Rect(- 15008.0, - 14752.0, - 14944.0, - 14688.0)
    set gg_rct_Rect_210=Rect(- 14624.0, - 14752.0, - 14560.0, - 14688.0)
    set gg_rct_Rect_211=Rect(- 14752.0, - 15008.0, - 14688.0, - 14944.0)
    set gg_rct_Rect_212=Rect(- 14752.0, - 14400.0, - 14688.0, - 14336.0)
    set gg_rct_Rect_213=Rect(- 15104.0, - 14624.0, - 15040.0, - 14560.0)
    set gg_rct_Rect_214=Rect(- 15104.0, - 13600.0, - 15040.0, - 13536.0)
    set gg_rct_Rect_215=Rect(- 15232.0, - 14528.0, - 15168.0, - 14464.0)
    set gg_rct_Rect_216=Rect(- 15232.0, - 13696.0, - 15168.0, - 13632.0)
    set gg_rct_Rect_217=Rect(- 15360.0, - 14400.0, - 15296.0, - 14336.0)
    set gg_rct_Rect_218=Rect(- 15392.0, - 13856.0, - 15328.0, - 13792.0)
    set gg_rct_Rect_219=Rect(- 15648.0, - 14112.0, - 15584.0, - 14048.0)
    set gg_rct_Rect_220=Rect(- 15264.0, - 14112.0, - 15200.0, - 14048.0)
    set gg_rct_Rect_221=Rect(- 14880.0, - 13632.0, - 14816.0, - 13568.0)
    set gg_rct_Rect_222=Rect(- 14880.0, - 14336.0, - 14816.0, - 14272.0)
    set gg_rct_Rect_223=Rect(- 14784.0, - 13632.0, - 14720.0, - 13568.0)
    set gg_rct_Rect_224=Rect(- 14784.0, - 14336.0, - 14720.0, - 14272.0)
    set gg_rct_Rect_225=Rect(- 14688.0, - 13632.0, - 14624.0, - 13568.0)
    set gg_rct_Rect_226=Rect(- 14688.0, - 14336.0, - 14624.0, - 14272.0)
    set gg_rct_Rect_227=Rect(- 14592.0, - 13632.0, - 14528.0, - 13568.0)
    set gg_rct_Rect_228=Rect(- 14592.0, - 14336.0, - 14528.0, - 14272.0)
    set gg_rct_Rect_229=Rect(- 14496.0, - 14368.0, - 14432.0, - 14304.0)
    set gg_rct_Rect_230=Rect(- 13984.0, - 14368.0, - 13920.0, - 14304.0)
    set gg_rct_Rect_231=Rect(- 13984.0, - 15136.0, - 13920.0, - 15072.0)
    set gg_rct_Rect_232=Rect(- 14496.0, - 15136.0, - 14432.0, - 15072.0)
    set gg_rct_Rect_233=Rect(- 14368.0, - 14624.0, - 14304.0, - 14560.0)
    set gg_rct_Rect_234=Rect(- 14368.0, - 14880.0, - 14304.0, - 14816.0)
    set gg_rct_Rect_235=Rect(- 14112.0, - 14880.0, - 14048.0, - 14816.0)
    set gg_rct_Rect_236=Rect(- 14112.0, - 14624.0, - 14048.0, - 14560.0)
    set gg_rct_Rect_237=Rect(- 10656.0, - 13632.0, - 10592.0, - 13600.0)
    set gg_rct_Rect_238=Rect(- 10656.0, - 14176.0, - 10592.0, - 14144.0)
    set gg_rct_Rect_239=Rect(- 10592.0, - 14176.0, - 10528.0, - 14144.0)
    set gg_rct_Rect_240=Rect(- 10592.0, - 13632.0, - 10528.0, - 13600.0)
    set gg_rct_Rect_241=Rect(- 10528.0, - 13632.0, - 10464.0, - 13600.0)
    set gg_rct_Rect_242=Rect(- 10528.0, - 14176.0, - 10464.0, - 14144.0)
    set gg_rct_LWR_2_1=Rect(- 12832.0, - 11808.0, - 12768.0, - 11744.0)
    set gg_rct_LW_Entrance=Rect(- 2944.0, 1376.0, - 2272.0, 1728.0)
    set gg_rct_LW1_End=Rect(- 9408.0, - 15872.0, - 9216.0, - 15616.0)
    set gg_rct_HubWorld_Vision=Rect(- 4096.0, 320.0, 5344.0, 3264.0)
    set gg_rct_IntroWorldCP_1_1=Rect(12384.0, 14496.0, 12736.0, 14592.0)
    set gg_rct_IntroWorldCP_1_2=Rect(14592.0, 12352.0, 14688.0, 12928.0)
    set gg_rct_IntroWorld_R3=Rect(14848.0, 12672.0, 14912.0, 12736.0)
    set gg_rct_IW1_Vision=Rect(- 3392.0, 9952.0, 992.0, 15296.0)
    set gg_rct_IW2_Vision=Rect(992.0, 10368.0, 10336.0, 15392.0)
    set gg_rct_IW3_Vision=Rect(10336.0, - 3712.0, 16000.0, 10848.0)
    set gg_rct_LW1_Vision=Rect(- 16064.0, - 15968.0, - 9120.0, - 12832.0)
    set gg_rct_LW2_Vision=Rect(- 15232.0, - 12544.0, - 10880.0, - 6400.0)
    set gg_rct_SargeIntro1=Rect(11168.0, 12256.0, 11904.0, 12832.0)
    set gg_rct_temp2=Rect(- 608.0, 14368.0, 704.0, 15296.0)
    set gg_rct_temp3=Rect(9376.0, 10848.0, 10208.0, 11680.0)
    set gg_rct_temp4=Rect(14368.0, 9760.0, 15616.0, 10592.0)
    set gg_rct_IntroWorld_End=Rect(11840.0, 11264.0, 12320.0, 11584.0)
    set gg_rct_IWCP_3_1=Rect(14208.0, 7360.0, 14432.0, 8064.0)
    set gg_rct_IWR_3_2=Rect(14848.0, 7872.0, 14912.0, 7936.0)
    set gg_rct_IWR_3_3=Rect(13312.0, 2752.0, 13376.0, 2816.0)
    set gg_rct_IWCP_3_3=Rect(12704.0, 672.0, 12960.0, 1568.0)
    set gg_rct_IWR_3_4=Rect(12512.0, 992.0, 12576.0, 1056.0)
    set gg_rct_Rect_271=Rect(15328.0, 11200.0, 15392.0, 11232.0)
    set gg_rct_Rect_272=Rect(15328.0, 11872.0, 15392.0, 11904.0)
    set gg_rct_Rect_273=Rect(15200.0, 11872.0, 15264.0, 11904.0)
    set gg_rct_Rect_274=Rect(15200.0, 11200.0, 15264.0, 11232.0)
    set gg_rct_Rect_275=Rect(15584.0, 12032.0, 15648.0, 12096.0)
    set gg_rct_Rect_276=Rect(15072.0, 12288.0, 15136.0, 12352.0)
    set gg_rct_Rect_277=Rect(15008.0, 11744.0, 15040.0, 11808.0)
    set gg_rct_Rect_278=Rect(14528.0, 11744.0, 14560.0, 11808.0)
    set gg_rct_test_plat=Rect(- 13920.0, - 1024.0, - 13856.0, - 960.0)
    set gg_rct_Rect_280=Rect(14976.0, 2016.0, 15040.0, 2080.0)
    set gg_rct_Rect_281=Rect(14976.0, 2528.0, 15040.0, 2592.0)
    set gg_rct_IW2_Target2=Rect(8832.0, 13472.0, 9376.0, 14432.0)
    set gg_rct_PWR_1_1=Rect(6464.0, 4256.0, 6528.0, 4320.0)
    set gg_rct_Rect_284=Rect(6240.0, 3296.0, 6304.0, 3360.0)
    set gg_rct_Rect_285=Rect(6240.0, 3808.0, 6304.0, 3872.0)
    set gg_rct_Rect_288=Rect(5472.0, 3936.0, 5536.0, 4000.0)
    set gg_rct_Rect_289=Rect(5856.0, 3936.0, 5920.0, 4000.0)
    set gg_rct_PWCP_1_1=Rect(7360.0, 4672.0, 7488.0, 5408.0)
    set gg_rct_PWR_1_2=Rect(7488.0, 4832.0, 7552.0, 4896.0)
    set gg_rct_PW_Entrance=Rect(- 3776.0, 1120.0, - 3392.0, 1600.0)
    set gg_rct_Rect_291=Rect(9184.0, 4672.0, 9248.0, 4736.0)
    set gg_rct_Rect_292=Rect(9184.0, 4192.0, 9248.0, 4256.0)
    set gg_rct_Rect_293=Rect(9600.0, 4512.0, 9664.0, 4576.0)
    set gg_rct_Rect_294=Rect(9088.0, 5024.0, 9152.0, 5088.0)
    set gg_rct_Rect_297=Rect(8416.0, 4544.0, 8480.0, 4608.0)
    set gg_rct_Rect_298=Rect(8416.0, 4192.0, 8480.0, 4256.0)
    set gg_rct_Rect_299=Rect(8416.0, 4608.0, 8480.0, 4672.0)
    set gg_rct_Rect_300=Rect(8416.0, 5216.0, 8480.0, 5280.0)
    set gg_rct_Rect_303=Rect(7872.0, 3104.0, 7936.0, 3168.0)
    set gg_rct_Rect_304=Rect(8032.0, 2720.0, 8096.0, 2784.0)
    set gg_rct_Rect_305=Rect(7648.0, 2976.0, 7712.0, 3040.0)
    set gg_rct_Rect_306=Rect(7648.0, 2592.0, 7712.0, 2656.0)
    set gg_rct_Rect_311=Rect(7392.0, 3680.0, 7456.0, 3744.0)
    set gg_rct_Rect_312=Rect(8032.0, 4064.0, 8096.0, 4128.0)
    set gg_rct_Rect_313=Rect(7520.0, 1120.0, 7584.0, 1184.0)
    set gg_rct_Rect_314=Rect(7264.0, 1376.0, 7328.0, 1440.0)
    set gg_rct_Rect_315=Rect(7008.0, 1120.0, 7072.0, 1184.0)
    set gg_rct_Rect_319=Rect(8672.0, 992.0, 8736.0, 1056.0)
    set gg_rct_Rect_320=Rect(8672.0, 1376.0, 8736.0, 1440.0)
    set gg_rct_Rect_321=Rect(8544.0, 1504.0, 8608.0, 1568.0)
    set gg_rct_Rect_322=Rect(8544.0, 2784.0, 8608.0, 2848.0)
    set gg_rct_Rect_327=Rect(6848.0, 1376.0, 6912.0, 1440.0)
    set gg_rct_Rect_328=Rect(5536.0, 1376.0, 5600.0, 1440.0)
    set gg_rct_Rect_335=Rect(7040.0, 1696.0, 7104.0, 1760.0)
    set gg_rct_Rect_336=Rect(6880.0, 2112.0, 6944.0, 2176.0)
    set gg_rct_Rect_337=Rect(6624.0, 2368.0, 6688.0, 2432.0)
    set gg_rct_Rect_338=Rect(6624.0, 1920.0, 6688.0, 1984.0)
    set gg_rct_Rect_339=Rect(6752.0, 1088.0, 7584.0, 1472.0)
    set gg_rct_Rect_340=Rect(7072.0, 1536.0, 7136.0, 1600.0)
    set gg_rct_Rect_343=Rect(8672.0, 1504.0, 8736.0, 1568.0)
    set gg_rct_Rect_344=Rect(8672.0, 2784.0, 8736.0, 2848.0)
    set gg_rct_IW5_Drunks_3=Rect(1632.0, 7360.0, 3232.0, 8480.0)
    set gg_rct_IW5_Drunks_2=Rect(1856.0, 8352.0, 3360.0, 9824.0)
    set gg_rct_IW5_Drunks_1=Rect(3360.0, 8256.0, 5120.0, 9824.0)
    set gg_rct_PWCP_1_2=Rect(8000.0, 1888.0, 8256.0, 2176.0)
    set gg_rct_PWR_1_3=Rect(8032.0, 1920.0, 8096.0, 1984.0)
    set gg_rct_PW1_Vision=Rect(5344.0, 960.0, 10336.0, 5824.0)
    set gg_rct_Rect_351=Rect(9216.0, 1920.0, 9600.0, 2432.0)
    set gg_rct_Rect_352=Rect(8992.0, 2144.0, 9056.0, 2208.0)
    set gg_rct_PWR_2_1=Rect(6144.0, - 5728.0, 6208.0, - 5664.0)
    set gg_rct_PWCP_2_1=Rect(7968.0, - 4384.0, 8288.0, - 3520.0)
    set gg_rct_PW1_End=Rect(6752.0, 2592.0, 7200.0, 2720.0)
    set gg_rct_PWR_2_2=Rect(8096.0, - 4000.0, 8160.0, - 3936.0)
    set gg_rct_Rect_357=Rect(5600.0, - 4800.0, 5664.0, - 4736.0)
    set gg_rct_Rect_358=Rect(6400.0, - 4384.0, 6464.0, - 4320.0)
    set gg_rct_Rect_359=Rect(5568.0, - 4416.0, 5632.0, - 4352.0)
    set gg_rct_Rect_360=Rect(6368.0, - 4800.0, 6432.0, - 4736.0)
    set gg_rct_PW2_Target=Rect(5536.0, - 4960.0, 6464.0, - 4320.0)
    set gg_rct_PW2_Mortar=Rect(5984.0, - 4576.0, 6048.0, - 4512.0)
    set gg_rct_IntroWorldCP_1_2a=Rect(13664.0, 14048.0, 14240.0, 14176.0)
    set gg_rct_IntroWorld_R3a=Rect(13984.0, 14176.0, 14048.0, 14240.0)
    set gg_rct_IW3_Drunks_1=Rect(12864.0, - 2272.0, 14528.0, - 800.0)
    set gg_rct_IW3_Drunks_2=Rect(11968.0, - 3808.0, 12736.0, - 3040.0)
    set gg_rct_Region_380=Rect(- 12160.0, 11712.0, - 12096.0, 11776.0)
    set gg_rct_PWR_2_3=Rect(6144.0, - 3392.0, 6208.0, - 3328.0)
    set gg_rct_PWCP_2_2=Rect(6208.0, - 3616.0, 6432.0, - 3168.0)
    set gg_rct_IWR_4_1=Rect(8992.0, 9120.0, 9056.0, 9184.0)
    set gg_rct_IW4_Vision=Rect(3328.0, 5824.0, 10336.0, 10368.0)
    set gg_rct_IWCP_4_1=Rect(4640.0, 7168.0, 4768.0, 7616.0)
    set gg_rct_IWR_4_2=Rect(4544.0, 7488.0, 4608.0, 7552.0)
    set gg_rct_IWCP_4_2=Rect(8064.0, 5984.0, 8384.0, 6432.0)
    set gg_rct_IWR_4_3=Rect(8000.0, 6144.0, 8064.0, 6208.0)
    set gg_rct_IW4_Drunks=Rect(8384.0, 6208.0, 9472.0, 7232.0)
    set gg_rct_IW4_End=Rect(5024.0, 8064.0, 5248.0, 8320.0)
    set gg_rct_IWR_5_1=Rect(4352.0, 7968.0, 4416.0, 8032.0)
    set gg_rct_IWCP_5_1=Rect(1664.0, 6816.0, 1952.0, 6976.0)
    set gg_rct_IWR_5_2=Rect(1440.0, 7072.0, 1504.0, 7136.0)
    set gg_rct_IW5_End=Rect(992.0, 6272.0, 1312.0, 6592.0)
    set gg_rct_IW5_Vision=Rect(- 3392.0, 5824.0, 3328.0, 9952.0)
    set gg_rct_PW2_Vision=Rect(5344.0, - 7040.0, 10336.0, 960.0)
    set gg_rct_PWCP_1_3=Rect(7616.0, 896.0, 7840.0, 1536.0)
    set gg_rct_PWR_1_4=Rect(7712.0, 1216.0, 7776.0, 1280.0)
    set gg_rct_SW_Entrance=Rect(2432.0, - 3712.0, 2688.0, - 3456.0)
    set gg_rct_SWR_1_1=Rect(- 12416.0, 11712.0, - 12352.0, 11776.0)
    set gg_rct_SWR_2_1=Rect(- 13152.0, 5088.0, - 13088.0, 5152.0)
    set gg_rct_PWR_3_1=Rect(4512.0, - 6208.0, 4576.0, - 6144.0)
    set gg_rct_PW2_End=Rect(5856.0, - 6528.0, 6432.0, - 6400.0)
    set gg_rct_PW3_Vision=Rect(- 4096.0, - 10112.0, 5344.0, - 3648.0)
    set gg_rct_Rect_295=Rect(9088.0, 5216.0, 9152.0, 5280.0)
    set gg_rct_Rect_296=Rect(9600.0, 4704.0, 9664.0, 4768.0)
    set gg_rct_PW2_Drunks_3=Rect(8320.0, - 5984.0, 9408.0, - 3872.0)
    set gg_rct_PW2_Drunks_1=Rect(7104.0, - 6720.0, 8160.0, - 4736.0)
    set gg_rct_PW2_Drunks_2=Rect(8128.0, - 6784.0, 9600.0, - 5984.0)
    set gg_rct_PW2_Drunks_4=Rect(6976.0, 64.0, 9536.0, 704.0)
    set gg_rct_PWR_2_5=Rect(6112.0, - 3200.0, 6176.0, - 3136.0)
    set gg_rct_PWCP_2_4=Rect(5600.0, - 3264.0, 6400.0, - 3072.0)
    set gg_rct_Region_331=Rect(12192.0, 13216.0, 12256.0, 13280.0)
    set gg_rct_Region_332=Rect(12960.0, 13984.0, 13024.0, 14048.0)
    set gg_rct_PW3_MassCreate=Rect(544.0, - 8160.0, 576.0, - 7360.0)
    set gg_rct_PWCP_3_2=Rect(- 864.0, - 6144.0, - 672.0, - 5728.0)
    set gg_rct_PWR_3_3=Rect(- 928.0, - 6016.0, - 864.0, - 5952.0)
    set gg_rct_PWCP_3_3=Rect(- 2400.0, - 4832.0, - 1696.0, - 4448.0)
    set gg_rct_PWR_3_4=Rect(- 2208.0, - 4576.0, - 2144.0, - 4512.0)
    set gg_rct_PWCP_2_3=Rect(5376.0, - 160.0, 6304.0, 64.0)
    set gg_rct_PWR_2_4=Rect(5824.0, - 224.0, 5888.0, - 160.0)
    set gg_rct_PWCP_3_1=Rect(960.0, - 8640.0, 1664.0, - 8352.0)
    set gg_rct_PWR_3_2=Rect(1248.0, - 8608.0, 1312.0, - 8544.0)
    set gg_rct_SboxIceR=Rect(- 12288.0, 11712.0, - 12224.0, 11776.0)
    set gg_rct_IceTutorial=Rect(12576.0, 14112.0, 13120.0, 14752.0)
    set gg_rct_FS_1_Drunks=Rect(11968.0, - 8448.0, 13152.0, - 7104.0)
    set gg_rct_FS_Entrance=Rect(1280.0, 2080.0, 1664.0, 2400.0)
    set gg_rct_FSR_1_1=Rect(11616.0, - 7872.0, 11680.0, - 7808.0)
    set gg_rct_Region_403=Rect(12064.0, - 9600.0, 15552.0, - 6944.0)
    set we=AddWeatherEffect(gg_rct_Region_403, 'LRaa')
    call EnableWeatherEffect(we, true)
    set gg_rct_FS1_Vision=Rect(11424.0, - 9184.0, 15616.0, - 6944.0)
    set gg_rct_FS1_End=Rect(14784.0, - 12448.0, 15424.0, - 12384.0)
    set gg_rct_SargeIntro2=Rect(12480.0, 13472.0, 13120.0, 13696.0)
    set gg_rct_SargeFireWarning=Rect(11776.0, 13376.0, 11968.0, 13696.0)
    set gg_rct_SargeFoundRed=Rect(11968.0, 14112.0, 12256.0, 14336.0)
    set gg_rct_SargeBeatRed=Rect(11616.0, 13440.0, 11808.0, 13696.0)
    set gg_rct_SargeVines=Rect(10720.0, 14240.0, 11392.0, 14464.0)
    set gg_rct_SargeCheckpoint=Rect(13600.0, 13952.0, 14272.0, 14048.0)
    set gg_rct_SargePlatformingTile=Rect(14432.0, 11200.0, 15520.0, 11904.0)
    set gg_rct_SargePlatformingMovement=Rect(14272.0, 11072.0, 14656.0, 11168.0)
    set gg_rct_SargeJump=Rect(14048.0, 10848.0, 14336.0, 11168.0)
    set gg_rct_SargeWallJump=Rect(13856.0, 11168.0, 13984.0, 11712.0)
    set gg_rct_FSCP_1_1=Rect(14720.0, - 8128.0, 15136.0, - 8064.0)
    set gg_rct_FSR_1_2=Rect(15008.0, - 8192.0, 15072.0, - 8128.0)
    set gg_rct_Region_120=Rect(14272.0, - 12256.0, 14784.0, - 11264.0)
    set we=AddWeatherEffect(gg_rct_Region_120, 'FDbh')
    call EnableWeatherEffect(we, true)
    set gg_rct_Region_258=Rect(5728.0, - 10400.0, 10336.0, - 8096.0)
    set we=AddWeatherEffect(gg_rct_Region_258, 'SNls')
    call EnableWeatherEffect(we, true)
    set gg_rct_Region_258_Copy=Rect(2464.0, - 15200.0, 7744.0, - 10592.0)
    set we=AddWeatherEffect(gg_rct_Region_258_Copy, 'SNls')
    call EnableWeatherEffect(we, true)
    set gg_rct_PW3_End=Rect(4640.0, - 1280.0, 5056.0, - 1024.0)
    set gg_rct_SargeOcean_1=Rect(5568.0, - 832.0, 6144.0, - 64.0)
    set gg_rct_SargeOcean_2=Rect(6144.0, - 832.0, 6624.0, - 64.0)
    set gg_rct_SargeOcean_3=Rect(6624.0, - 832.0, 7040.0, - 160.0)
    set gg_rct_SargeOcean_4=Rect(6688.0, - 224.0, 7040.0, 96.0)
    set gg_rct_SargeInconvenient=Rect(6048.0, - 6144.0, 6208.0, - 5952.0)
    set gg_rct_SargeBlue=Rect(12448.0, 11040.0, 12832.0, 11360.0)
    set gg_rct_EIWR_1_1=Rect(- 5856.0, 14080.0, - 5792.0, 14144.0)
    set gg_rct_EIWCP_1_1=Rect(- 4864.0, 12768.0, - 4320.0, 12960.0)
    set gg_rct_EIWR_1_2=Rect(- 4576.0, 12544.0, - 4512.0, 12608.0)
    set gg_rct_EIW1_End=Rect(- 4736.0, 11328.0, - 4352.0, 11488.0)
    set gg_rct_IW1Runes=Rect(- 1696.0, 13216.0, - 1408.0, 13504.0)
    set gg_rct_IW1Listen=Rect(- 2176.0, 13088.0, - 1856.0, 13280.0)
    set gg_rct_IW1Becky=Rect(- 2048.0, 13600.0, - 1856.0, 13824.0)
    set gg_rct_IW1Cage=Rect(512.0, 11072.0, 768.0, 11264.0)
    set gg_rct_IW2Yikes=Rect(5824.0, 12480.0, 6112.0, 12672.0)
    set gg_rct_IW3Deal=Rect(11456.0, 6112.0, 11936.0, 6464.0)
    set gg_rct_EIW1_Vision=Rect(- 8000.0, 9952.0, - 3392.0, 15296.0)
    set gg_rct_PW3Sniff=Rect(2080.0, - 8736.0, 2208.0, - 8576.0)
    set gg_rct_IW4QuestionMark=Rect(7008.0, 6240.0, 7264.0, 6592.0)
    set gg_rct_IW4Performance=Rect(5248.0, 8064.0, 5536.0, 8320.0)
    set gg_rct_IW3_Target1=Rect(10304.0, 7232.0, 11040.0, 8128.0)
    set gg_rct_IW3_Mortar1=Rect(10912.0, 8064.0, 10976.0, 8128.0)
    set gg_rct_PWR_4_1=Rect(- 1792.0, - 2880.0, - 1728.0, - 2816.0)
    set gg_rct_PW4_Vision=Rect(- 4160.0, - 3648.0, - 832.0, - 2432.0)
    set gg_rct_PW4_End=Rect(- 8320.0, 2016.0, - 7744.0, 2240.0)
    set gg_rct_LW1_Generator1=Rect(- 13376.0, - 13088.0, - 12992.0, - 13024.0)
    set gg_rct_LW1_Generator2=Rect(- 11840.0, - 15776.0, - 11328.0, - 15712.0)
    set gg_rct_LW1_Generator3=Rect(- 11200.0, - 12960.0, - 10816.0, - 12896.0)
    set gg_rct_LW1_Generator4=Rect(- 10272.0, - 12960.0, - 10208.0, - 12896.0)
    set gg_rct_LW1_Generator6=Rect(- 9632.0, - 12960.0, - 9568.0, - 12896.0)
    set gg_rct_Region_246=Rect(- 14496.0, - 15648.0, - 14432.0, - 15584.0)
    set gg_rct_Region_247=Rect(- 13728.0, - 15648.0, - 13664.0, - 15584.0)
    set gg_rct_Region_439=Rect(- 13984.0, - 15264.0, - 13920.0, - 15200.0)
    set gg_rct_Region_440=Rect(- 13984.0, - 15520.0, - 13920.0, - 15456.0)
    set gg_rct_Region_441=Rect(- 14240.0, - 15520.0, - 14176.0, - 15456.0)
    set gg_rct_Region_442=Rect(- 14240.0, - 15264.0, - 14176.0, - 15200.0)
    set gg_rct_LWCP_1_1=Rect(- 12384.0, - 13856.0, - 12256.0, - 13376.0)
    set gg_rct_LWR_1_2=Rect(- 12128.0, - 13696.0, - 12064.0, - 13632.0)
    set gg_rct_Region_445=Rect(- 13728.0, - 15136.0, - 13664.0, - 15072.0)
    set gg_rct_Region_446=Rect(- 13216.0, - 15648.0, - 13152.0, - 15584.0)
    set gg_rct_Region_447=Rect(- 13344.0, - 15264.0, - 13280.0, - 15200.0)
    set gg_rct_Region_448=Rect(- 13088.0, - 14368.0, - 13024.0, - 14304.0)
    set gg_rct_Region_449=Rect(- 13344.0, - 14880.0, - 13280.0, - 14816.0)
    set gg_rct_Region_450=Rect(- 13344.0, - 13344.0, - 13280.0, - 13280.0)
    set gg_rct_Region_451=Rect(- 13088.0, - 14944.0, - 13024.0, - 14880.0)
    set gg_rct_Region_452=Rect(- 12800.0, - 13600.0, - 12736.0, - 13536.0)
    set gg_rct_Region_453=Rect(- 12704.0, - 13600.0, - 12640.0, - 13536.0)
    set gg_rct_Region_454=Rect(- 12608.0, - 13600.0, - 12544.0, - 13536.0)
    set gg_rct_Region_455=Rect(- 12512.0, - 13600.0, - 12448.0, - 13536.0)
    set gg_rct_Region_456=Rect(- 10272.0, - 14752.0, - 10208.0, - 14688.0)
    set gg_rct_Region_459=Rect(- 10272.0, - 15008.0, - 10208.0, - 14944.0)
    set gg_rct_Region_461=Rect(- 9760.0, - 15264.0, - 9696.0, - 15200.0)
    set gg_rct_Region_462=Rect(- 10016.0, - 15264.0, - 9952.0, - 15200.0)
    set gg_rct_Region_463=Rect(- 9504.0, - 15008.0, - 9440.0, - 14944.0)
    set gg_rct_Region_464=Rect(- 9504.0, - 14752.0, - 9440.0, - 14688.0)
    set gg_rct_Region_466=Rect(- 9760.0, - 14496.0, - 9696.0, - 14432.0)
    set gg_rct_Region_467=Rect(- 10016.0, - 14496.0, - 9952.0, - 14432.0)
    set gg_rct_Region_468=Rect(- 10784.0, - 15648.0, - 10720.0, - 15584.0)
    set gg_rct_Region_469=Rect(- 10784.0, - 15392.0, - 10720.0, - 15328.0)
    set gg_rct_Region_470=Rect(- 11040.0, - 15392.0, - 10976.0, - 15328.0)
    set gg_rct_Region_471=Rect(- 11040.0, - 15648.0, - 10976.0, - 15584.0)
    set gg_rct_Region_472=Rect(- 10528.0, - 15648.0, - 10464.0, - 15584.0)
    set gg_rct_Region_473=Rect(- 10528.0, - 15392.0, - 10464.0, - 15328.0)
    set gg_rct_Region_474=Rect(- 10272.0, - 15392.0, - 10208.0, - 15328.0)
    set gg_rct_Region_475=Rect(- 10272.0, - 15648.0, - 10208.0, - 15584.0)
    set gg_rct_Region_476=Rect(- 10400.0, - 15776.0, - 10336.0, - 15712.0)
    set gg_rct_Region_477=Rect(- 10400.0, - 15264.0, - 10336.0, - 15200.0)
    set gg_rct_Region_478=Rect(- 10912.0, - 15264.0, - 10848.0, - 15200.0)
    set gg_rct_Region_479=Rect(- 10912.0, - 15776.0, - 10848.0, - 15712.0)
    set gg_rct_Region_438=Rect(- 11808.0, - 14944.0, - 11744.0, - 14880.0)
    set gg_rct_Region_480=Rect(- 11168.0, - 14080.0, - 11104.0, - 14016.0)
    set gg_rct_Region_481=Rect(- 9888.0, - 15264.0, - 9824.0, - 15200.0)
    set gg_rct_Region_482=Rect(- 9888.0, - 13600.0, - 9824.0, - 13536.0)
    set gg_rct_Region_483=Rect(- 9472.0, - 15776.0, - 9408.0, - 15712.0)
    set gg_rct_Region_484=Rect(- 9568.0, - 15776.0, - 9504.0, - 15712.0)
    set gg_rct_Region_485=Rect(- 9664.0, - 15776.0, - 9600.0, - 15712.0)
    set gg_rct_Region_486=Rect(- 9760.0, - 15776.0, - 9696.0, - 15712.0)
    set gg_rct_Region_487=Rect(- 9856.0, - 15776.0, - 9792.0, - 15712.0)
    set gg_rct_SargeHeart=Rect(- 1632.0, 2432.0, - 928.0, 2976.0)
    set gg_rct_EIW_Entrance=Rect(3104.0, 2176.0, 3552.0, 2464.0)
    set gg_rct_LW2_End=Rect(- 15296.0, - 8384.0, - 15168.0, - 8000.0)
    set gg_rct_LW2_RG1=Rect(- 13216.0, - 7200.0, - 13152.0, - 7136.0)
    set gg_rct_LW2_RG2=Rect(- 14688.0, - 12448.0, - 14624.0, - 12384.0)
    set gg_rct_LW2_RG3=Rect(- 14944.0, - 6560.0, - 14880.0, - 6496.0)
    set gg_rct_LW2_C1=Rect(- 11616.0, - 7552.0, - 11552.0, - 7488.0)
    set gg_rct_LW2_C2=Rect(- 12800.0, - 7680.0, - 12736.0, - 7616.0)
    set gg_rct_LW2_WW2=Rect(- 14368.0, - 8224.0, - 14304.0, - 8160.0)
    set gg_rct_LW2_C4=Rect(- 14368.0, - 11616.0, - 14304.0, - 11552.0)
    set gg_rct_LW2_RG4=Rect(- 11040.0, - 9952.0, - 10976.0, - 9888.0)
    set gg_rct_LW2_WW1=Rect(- 12512.0, - 9568.0, - 12448.0, - 9504.0)
    set gg_rct_LW2_SG1_3=Rect(- 12576.0, - 12192.0, - 12512.0, - 12128.0)
    set gg_rct_LW2_SG1_2=Rect(- 12192.0, - 12192.0, - 12128.0, - 12128.0)
    set gg_rct_LW2_SG1_1=Rect(- 12192.0, - 10784.0, - 12128.0, - 10720.0)
    set gg_rct_LW2_SG1_4=Rect(- 12576.0, - 10784.0, - 12512.0, - 10720.0)
    set gg_rct_LW2_SG2_3=Rect(- 12448.0, - 12064.0, - 12384.0, - 12000.0)
    set gg_rct_LW2_SG2_2=Rect(- 12320.0, - 12064.0, - 12256.0, - 12000.0)
    set gg_rct_LW2_SG2_1=Rect(- 12320.0, - 10912.0, - 12256.0, - 10848.0)
    set gg_rct_LW2_SG2_4=Rect(- 12448.0, - 10912.0, - 12384.0, - 10848.0)
    set gg_rct_LW2_SG3_3=Rect(- 12704.0, - 10528.0, - 12640.0, - 10464.0)
    set gg_rct_LW2_SG3_4=Rect(- 12704.0, - 10144.0, - 12640.0, - 10080.0)
    set gg_rct_LW2_SG3_1=Rect(- 11936.0, - 10144.0, - 11872.0, - 10080.0)
    set gg_rct_LW2_SG3_2=Rect(- 11936.0, - 10528.0, - 11872.0, - 10464.0)
    set gg_rct_LW2_SG4_3=Rect(- 12576.0, - 10400.0, - 12512.0, - 10336.0)
    set gg_rct_LW2_SG4_4=Rect(- 12576.0, - 10272.0, - 12512.0, - 10208.0)
    set gg_rct_LW2_SG4_1=Rect(- 12064.0, - 10272.0, - 12000.0, - 10208.0)
    set gg_rct_LW2_SG4_2=Rect(- 12064.0, - 10400.0, - 12000.0, - 10336.0)
    set gg_rct_LW2_P1_1=Rect(- 12192.0, - 10656.0, - 12128.0, - 10592.0)
    set gg_rct_LW2_P1_2=Rect(- 12576.0, - 10656.0, - 12512.0, - 10592.0)
    set gg_rct_LW2_C5=Rect(- 13824.0, - 10272.0, - 13760.0, - 10208.0)
    set gg_rct_IW2_TC1=Rect(2528.0, 11360.0, 2592.0, 11424.0)
    set gg_rct_IW2_Target3=Rect(9344.0, 14368.0, 9888.0, 15328.0)
    set gg_rct_IW2_Target4=Rect(9344.0, 13472.0, 9888.0, 14432.0)
    set gg_rct_IW3_Target2=Rect(10304.0, 8128.0, 11040.0, 8864.0)
    set gg_rct_IW3_Target3=Rect(11040.0, 7424.0, 11680.0, 8064.0)
    set gg_rct_LW2_WW3=Rect(- 14368.0, - 7328.0, - 14304.0, - 7264.0)
    set gg_rct_IntroWorld_TC1=Rect(13408.0, 11744.0, 13472.0, 11808.0)
    set gg_rct_LW2_Mortar3=Rect(- 11488.0, - 8032.0, - 11424.0, - 7968.0)
    set gg_rct_LW2_Mortar2=Rect(- 11488.0, - 8448.0, - 11424.0, - 8384.0)
    set gg_rct_LW2_Mortar1=Rect(- 11488.0, - 8896.0, - 11424.0, - 8832.0)
    set gg_rct_LW2_Target3=Rect(- 12000.0, - 8096.0, - 11680.0, - 7488.0)
    set gg_rct_LW2_Target2=Rect(- 12000.0, - 8736.0, - 11680.0, - 8128.0)
    set gg_rct_LW2_Target1=Rect(- 12000.0, - 9376.0, - 11680.0, - 8768.0)
    set gg_rct_LWR_1_2a=Rect(- 13536.0, - 15584.0, - 13472.0, - 15520.0)
    set gg_rct_LWCP_1_1a=Rect(- 13664.0, - 15872.0, - 13568.0, - 15232.0)
    set gg_rct_PW3_Vision2=Rect(- 832.0, - 3712.0, 5344.0, - 864.0)
    set gg_rct_HubWorld_Vision2=Rect(- 4096.0, - 2432.0, - 832.0, 384.0)
    set gg_rct_HubWorld_Vision3=Rect(448.0, 3200.0, 5344.0, 5824.0)
    set gg_rct_HubWorld_Vision4=Rect(- 896.0, - 1664.0, 3072.0, 384.0)
    set gg_rct_HubWorld_Vision5=Rect(3008.0, - 864.0, 5344.0, 384.0)
    set gg_rct_PW4_Vision2=Rect(- 8576.0, - 5312.0, - 4096.0, 3264.0)
    set gg_rct_LW2_C1b=Rect(- 11456.0, - 7776.0, - 11392.0, - 7712.0)
    set gg_rct_BB_Revive=Rect(- 4896.0, - 14944.0, - 4832.0, - 14880.0)
    set gg_rct_BB_Vision=Rect(- 9120.0, - 15872.0, - 4000.0, - 15712.0)
    set gg_rct_BB_Bricks1=Rect(- 8096.0, - 13728.0, - 8032.0, - 13664.0)
endfunction

//***************************************************************************
//*
//*  Custom Script Code
//*
//***************************************************************************

//***************************************************************************
//*
//*  Triggers
//*
//***************************************************************************

//===========================================================================
// Trigger: Alloc
//===========================================================================

//===========================================================================
// Trigger: PermanentAlloc
//===========================================================================
//alternate version of Alloc for designs that I want struct syntax for, but do not really need to take advantage of dynamic allocation/deallocation & index recycling
//===========================================================================
// Trigger: Error Message
//===========================================================================
//===========================================================================
// Trigger: Memory Analysis
//===========================================================================
//===========================================================================
// Trigger: Boolean
//===========================================================================
//===========================================================================
// Trigger: PlayerUtils
//===========================================================================

//===========================================================================
// Trigger: PreventSave
//===========================================================================

//===========================================================================
// Trigger: GroupUtils
//===========================================================================
//===========================================================================
// Trigger: DummyCaster
//===========================================================================
//===========================================================================
// Trigger: locust
//
// A function library for all locust needs
//===========================================================================

//===========================================================================
// Trigger: FilterFuncs
//===========================================================================
//===========================================================================
// Trigger: TimerUtils
//===========================================================================

//===========================================================================
// Trigger: Vector2
//===========================================================================
//===========================================================================
// Trigger: RelativeVector2
//===========================================================================
//===========================================================================
// Trigger: SimpleList
//===========================================================================
//===========================================================================
// Trigger: Stack
//===========================================================================


//===========================================================================
// Trigger: WeightedList
//===========================================================================
//===========================================================================
// Trigger: Table
//===========================================================================

//===========================================================================
// Trigger: ListModule
//===========================================================================

//===========================================================================
// Trigger: HandleList
//===========================================================================

//===========================================================================
// Trigger: SyncRequest
//===========================================================================
//===========================================================================
// Trigger: Event
//===========================================================================
//===========================================================================
// Trigger: Deferred
//===========================================================================
//===========================================================================
// Trigger: All
//===========================================================================
//===========================================================================
// Trigger: Any
//===========================================================================
//===========================================================================
// Trigger: GameGlobalConstants
//===========================================================================
//===========================================================================
// Trigger: GameModesGlobals
//===========================================================================
//===========================================================================
// Trigger: UnitGlobals
//===========================================================================
//===========================================================================
// Trigger: ContinueGlobals
//===========================================================================

//===========================================================================

//===========================================================================
// Trigger: MazerGlobals
//===========================================================================
//===========================================================================
// Trigger: PlatformerGlobals
//===========================================================================

//===========================================================================
// Trigger: PlatformerTerrainEffectGlobals
//===========================================================================
//===========================================================================
// Trigger: PlatformerUnitGlobals
//===========================================================================
//===========================================================================
// Trigger: TerrainGlobals
//===========================================================================
//===========================================================================
// Trigger: SkatingGlobals
//===========================================================================
//all the globals used in the skating functions


function InitTrig_SkatingGlobals takes nothing returns nothing
    local integer i= 0
    
    loop
    exitwhen i >= NumberPlayers
        set s__SkateSpeed[i]= 0
        set s__VelocityX[i]= 0
        set s__VelocityY[i]= 0
        set s__CanSteer[i]= false
        
        set i=i + 1
    endloop
endfunction
//===========================================================================
// Trigger: RunningGlobals
//===========================================================================
//===========================================================================
// Trigger: LevelIDGlobals
//===========================================================================
//===========================================================================
// Trigger: DestructableGlobals
//===========================================================================
//===========================================================================
// Trigger: OrderID
//===========================================================================
//===========================================================================
// Trigger: ConfigurationMode
//===========================================================================
//===========================================================================
// Trigger: EDWGameStart
//===========================================================================
//===========================================================================
// Trigger: EDWPlayerStart
//===========================================================================
//===========================================================================
// Trigger: EDWPlayerSlots
//===========================================================================
//===========================================================================
// Trigger: EDWGameTime
//===========================================================================
//===========================================================================
// Trigger: EDWVisualVote
//===========================================================================
//===========================================================================
// Trigger: EDWLevels
//===========================================================================
//===========================================================================
// Trigger: EDWLevelContent
//===========================================================================
//===========================================================================
// Trigger: EDWVFXPreload
//===========================================================================
//===========================================================================
// Trigger: EDWEffects
//===========================================================================
//===========================================================================
// Trigger: EDWCinematicContent
//===========================================================================
//===========================================================================
// Trigger: EDWPowerup
//===========================================================================
//===========================================================================
// Trigger: EDWCollectibleResolveHandlers
//===========================================================================
//===========================================================================
// Trigger: TerrainHelpers
//===========================================================================
//===========================================================================
// Trigger: User
//===========================================================================
//===========================================================================
// Trigger: Teams
//===========================================================================
//===========================================================================
// Trigger: TeamSaveLocation
//===========================================================================
//===========================================================================
// Trigger: Continues
//===========================================================================

//===========================================================================
// Trigger: Cinema
//===========================================================================
//===========================================================================
// Trigger: GameMessage
//===========================================================================
//===========================================================================
// Trigger: VisualVote
//===========================================================================
//===========================================================================
// Trigger: CameraTrackingEvents
//===========================================================================
//===========================================================================
// Trigger: Level
//===========================================================================
//===========================================================================
// Trigger: BossLevel
//===========================================================================
//===========================================================================
// Trigger: Minigame
//===========================================================================
//===========================================================================
// Trigger: Collision Iteration
//===========================================================================
//===========================================================================
// Trigger: IStartable
//===========================================================================
//===========================================================================
// Trigger: IndexedUnit
//===========================================================================
//===========================================================================
// Trigger: DisposableUnit
//===========================================================================
//===========================================================================
// Trigger: Recycle
//===========================================================================

//===========================================================================
// Trigger: RespawningUnit
//===========================================================================
//===========================================================================
// Trigger: PatternSpawn
//===========================================================================
//===========================================================================
// Trigger: EDWPatternSpawnDefinitions
//===========================================================================
//===========================================================================
// Trigger: RelayPatternSpawn
//===========================================================================
//===========================================================================
// Trigger: EDWRelayPatternSpawnDefinitions
//===========================================================================
//===========================================================================
// Trigger: RelayGenerator
//===========================================================================
//===========================================================================
// Trigger: SimpleGenerator
//===========================================================================
//===========================================================================
// Trigger: Wheel
//===========================================================================
//===========================================================================
// Trigger: BoundedWheel
//===========================================================================
//===========================================================================
// Trigger: BoundedSpoke
//===========================================================================
//===========================================================================
// Trigger: Blackhole
//===========================================================================
//===========================================================================
// Trigger: Collectible
//===========================================================================
//===========================================================================
// Trigger: DrunkWalker
//===========================================================================

//===========================================================================
// Trigger: FastLoad
//===========================================================================
//===========================================================================
// Trigger: IceSkater
//===========================================================================
//===========================================================================
// Trigger: MortarAndTarget
//===========================================================================
//===========================================================================
// Trigger: RespawningGateway
//===========================================================================
//===========================================================================
// Trigger: SynchronizedMoveGroup
//===========================================================================
//===========================================================================
// Trigger: SimplePatrol
//===========================================================================
//===========================================================================
// Trigger: UnitDefaultRadius
//===========================================================================
//===========================================================================
// Trigger: UnitLocalVisibility
//===========================================================================
//shows/hides a unit's model for the specified player only via VertexColor. works separately from native ShowUnit/HideUnit. does NOT hide particle effects
//the unit can still be selected by players it has been locally hidden for. you can permanently give the unit the locust ability (outside of a local block) to prevent any selection
//===========================================================================
// Trigger: UnitMovementSpeedHelpers
//===========================================================================
//===========================================================================
// Trigger: Game Loop With Effects
//
// loop that runs throughout the game, checking terrain types
//===========================================================================
//===========================================================================
// Trigger: Lava Damage
//===========================================================================
//===========================================================================
// Trigger: Ice Movement Advanced
//===========================================================================
//===========================================================================
// Trigger: Steering
//===========================================================================
//===========================================================================
// Trigger: IsMoving
//===========================================================================
//===========================================================================
// Trigger: SuperFastMovement
//===========================================================================
//===========================================================================
// Trigger: Sand Movement
//===========================================================================
//===========================================================================
// Trigger: Snow Movement
//===========================================================================
//===========================================================================
// Trigger: RSnow Movement
//===========================================================================


//===========================================================================
// Trigger: Platformer
//===========================================================================
//===========================================================================
// Trigger: ComplexTerrainPathing
//===========================================================================
//===========================================================================
// Trigger: Platformer Property Equation
//===========================================================================
//===========================================================================
// Trigger: Platformer Profile
//===========================================================================
//===========================================================================
// Trigger: PlatformerBounce
//===========================================================================
//===========================================================================
// Trigger: PlatformerOcean
//===========================================================================

//===========================================================================
// Trigger: Platformer Ice
//===========================================================================

//===========================================================================
// Trigger: Platformer SlipStream
//===========================================================================
//===========================================================================
// Trigger: Quests
//===========================================================================
//===========================================================================
// Trigger: IntroWorld
//===========================================================================
//===========================================================================
// Trigger: HubWorld Run
//
// LevelRuns[0]
//===========================================================================
function Trig_HubWorld_Run_Actions takes nothing returns nothing
endfunction

//===========================================================================
function InitTrig_HubWorld_Run takes nothing returns nothing
    set gg_trg_HubWorld_Run=CreateTrigger()
    call TriggerAddAction(gg_trg_HubWorld_Run, function Trig_HubWorld_Run_Actions)
endfunction

//===========================================================================
// Trigger: HubWorld Stop
//
// LevelStops[0]
//===========================================================================
function Trig_HubWorld_Stop_Actions takes nothing returns nothing
endfunction

//===========================================================================
function InitTrig_HubWorld_Stop takes nothing returns nothing
    set gg_trg_HubWorld_Stop=CreateTrigger()
    call TriggerAddAction(gg_trg_HubWorld_Stop, function Trig_HubWorld_Stop_Actions)
endfunction

//===========================================================================
// Trigger: IW1
//===========================================================================
//===========================================================================
// Trigger: IW2
//===========================================================================
//===========================================================================
// Trigger: IW3
//===========================================================================
//===========================================================================
// Trigger: IW4
//===========================================================================
//===========================================================================
// Trigger: IW5
//===========================================================================
//===========================================================================
// Trigger: IWB 1
//===========================================================================
//===========================================================================
// Trigger: LW1
//===========================================================================
//===========================================================================
// Trigger: LW2
//===========================================================================
//===========================================================================
// Trigger: PW1
//===========================================================================
//===========================================================================
// Trigger: PW2
//===========================================================================
//===========================================================================
// Trigger: PW3
//===========================================================================
//===========================================================================
// Trigger: PW4
//===========================================================================
//===========================================================================
// Trigger: FS1
//===========================================================================
//JZ TODO
//===========================================================================
// Trigger: BrickBreaker
//===========================================================================
//===========================================================================
// Trigger: FooBar
//===========================================================================
//===========================================================================
// Trigger: In Game Commands
//===========================================================================
//===========================================================================
// Trigger: Drawing
//===========================================================================
//===========================================================================
// Trigger: GetUnitCollision
//===========================================================================
//===========================================================================
function InitCustomTriggers takes nothing returns nothing
    //Function not found: call InitTrig_Alloc()
    //Function not found: call InitTrig_PermanentAlloc()
    //Function not found: call InitTrig_Error_Message()
    //Function not found: call InitTrig_Memory_Analysis()
    //Function not found: call InitTrig_Boolean()
    //Function not found: call InitTrig_PlayerUtils()
    //Function not found: call InitTrig_PreventSave()
    //Function not found: call InitTrig_GroupUtils()
    //Function not found: call InitTrig_DummyCaster()
    //Function not found: call InitTrig_locust()
    //Function not found: call InitTrig_FilterFuncs()
    //Function not found: call InitTrig_TimerUtils()
    //Function not found: call InitTrig_Vector2()
    //Function not found: call InitTrig_RelativeVector2()
    //Function not found: call InitTrig_SimpleList()
    //Function not found: call InitTrig_Stack()
    //Function not found: call InitTrig_WeightedList()
    //Function not found: call InitTrig_Table()
    //Function not found: call InitTrig_ListModule()
    //Function not found: call InitTrig_HandleList()
    //Function not found: call InitTrig_SyncRequest()
    //Function not found: call InitTrig_Event()
    //Function not found: call InitTrig_Deferred()
    //Function not found: call InitTrig_All()
    //Function not found: call InitTrig_Any()
    //Function not found: call InitTrig_GameGlobalConstants()
    //Function not found: call InitTrig_GameModesGlobals()
    //Function not found: call InitTrig_UnitGlobals()
    //Function not found: call InitTrig_ContinueGlobals()
    //Function not found: call InitTrig_MazerGlobals()
    //Function not found: call InitTrig_PlatformerGlobals()
    //Function not found: call InitTrig_PlatformerTerrainEffectGlobals()
    //Function not found: call InitTrig_PlatformerUnitGlobals()
    //Function not found: call InitTrig_TerrainGlobals()
    call InitTrig_SkatingGlobals()
    //Function not found: call InitTrig_RunningGlobals()
    //Function not found: call InitTrig_LevelIDGlobals()
    //Function not found: call InitTrig_DestructableGlobals()
    //Function not found: call InitTrig_OrderID()
    //Function not found: call InitTrig_ConfigurationMode()
    //Function not found: call InitTrig_EDWGameStart()
    //Function not found: call InitTrig_EDWPlayerStart()
    //Function not found: call InitTrig_EDWPlayerSlots()
    //Function not found: call InitTrig_EDWGameTime()
    //Function not found: call InitTrig_EDWVisualVote()
    //Function not found: call InitTrig_EDWLevels()
    //Function not found: call InitTrig_EDWLevelContent()
    //Function not found: call InitTrig_EDWVFXPreload()
    //Function not found: call InitTrig_EDWEffects()
    //Function not found: call InitTrig_EDWCinematicContent()
    //Function not found: call InitTrig_EDWPowerup()
    //Function not found: call InitTrig_EDWCollectibleResolveHandlers()
    //Function not found: call InitTrig_TerrainHelpers()
    //Function not found: call InitTrig_User()
    //Function not found: call InitTrig_Teams()
    //Function not found: call InitTrig_TeamSaveLocation()
    //Function not found: call InitTrig_Continues()
    //Function not found: call InitTrig_Cinema()
    //Function not found: call InitTrig_GameMessage()
    //Function not found: call InitTrig_VisualVote()
    //Function not found: call InitTrig_CameraTrackingEvents()
    //Function not found: call InitTrig_Level()
    //Function not found: call InitTrig_BossLevel()
    //Function not found: call InitTrig_Minigame()
    //Function not found: call InitTrig_Collision_Iteration()
    //Function not found: call InitTrig_IStartable()
    //Function not found: call InitTrig_IndexedUnit()
    //Function not found: call InitTrig_DisposableUnit()
    //Function not found: call InitTrig_Recycle()
    //Function not found: call InitTrig_RespawningUnit()
    //Function not found: call InitTrig_PatternSpawn()
    //Function not found: call InitTrig_EDWPatternSpawnDefinitions()
    //Function not found: call InitTrig_RelayPatternSpawn()
    //Function not found: call InitTrig_EDWRelayPatternSpawnDefinitions()
    //Function not found: call InitTrig_RelayGenerator()
    //Function not found: call InitTrig_SimpleGenerator()
    //Function not found: call InitTrig_Wheel()
    //Function not found: call InitTrig_BoundedWheel()
    //Function not found: call InitTrig_BoundedSpoke()
    //Function not found: call InitTrig_Blackhole()
    //Function not found: call InitTrig_Collectible()
    //Function not found: call InitTrig_DrunkWalker()
    //Function not found: call InitTrig_FastLoad()
    //Function not found: call InitTrig_IceSkater()
    //Function not found: call InitTrig_MortarAndTarget()
    //Function not found: call InitTrig_RespawningGateway()
    //Function not found: call InitTrig_SynchronizedMoveGroup()
    //Function not found: call InitTrig_SimplePatrol()
    //Function not found: call InitTrig_UnitDefaultRadius()
    //Function not found: call InitTrig_UnitLocalVisibility()
    //Function not found: call InitTrig_UnitMovementSpeedHelpers()
    //Function not found: call InitTrig_Game_Loop_With_Effects()
    //Function not found: call InitTrig_Lava_Damage()
    //Function not found: call InitTrig_Ice_Movement_Advanced()
    //Function not found: call InitTrig_Steering()
    //Function not found: call InitTrig_IsMoving()
    //Function not found: call InitTrig_SuperFastMovement()
    //Function not found: call InitTrig_Sand_Movement()
    //Function not found: call InitTrig_Snow_Movement()
    //Function not found: call InitTrig_RSnow_Movement()
    //Function not found: call InitTrig_Platformer()
    //Function not found: call InitTrig_ComplexTerrainPathing()
    //Function not found: call InitTrig_Platformer_Property_Equation()
    //Function not found: call InitTrig_Platformer_Profile()
    //Function not found: call InitTrig_PlatformerBounce()
    //Function not found: call InitTrig_PlatformerOcean()
    //Function not found: call InitTrig_Platformer_Ice()
    //Function not found: call InitTrig_Platformer_SlipStream()
    //Function not found: call InitTrig_Quests()
    //Function not found: call InitTrig_IntroWorld()
    call InitTrig_HubWorld_Run()
    call InitTrig_HubWorld_Stop()
    //Function not found: call InitTrig_IW1()
    //Function not found: call InitTrig_IW2()
    //Function not found: call InitTrig_IW3()
    //Function not found: call InitTrig_IW4()
    //Function not found: call InitTrig_IW5()
    //Function not found: call InitTrig_IWB_1()
    //Function not found: call InitTrig_LW1()
    //Function not found: call InitTrig_LW2()
    //Function not found: call InitTrig_PW1()
    //Function not found: call InitTrig_PW2()
    //Function not found: call InitTrig_PW3()
    //Function not found: call InitTrig_PW4()
    //Function not found: call InitTrig_FS1()
    //Function not found: call InitTrig_BrickBreaker()
    //Function not found: call InitTrig_FooBar()
    //Function not found: call InitTrig_In_Game_Commands()
    //Function not found: call InitTrig_Drawing()
    //Function not found: call InitTrig_GetUnitCollision()
endfunction

//***************************************************************************
//*
//*  Players
//*
//***************************************************************************

function InitCustomPlayerSlots takes nothing returns nothing

    // Player 0
    call SetPlayerStartLocation(Player(0), 0)
    call ForcePlayerStartLocation(Player(0), 0)
    call SetPlayerColor(Player(0), ConvertPlayerColor(0))
    call SetPlayerRacePreference(Player(0), RACE_PREF_NIGHTELF)
    call SetPlayerRaceSelectable(Player(0), false)
    call SetPlayerController(Player(0), MAP_CONTROL_USER)

    // Player 1
    call SetPlayerStartLocation(Player(1), 1)
    call ForcePlayerStartLocation(Player(1), 1)
    call SetPlayerColor(Player(1), ConvertPlayerColor(1))
    call SetPlayerRacePreference(Player(1), RACE_PREF_NIGHTELF)
    call SetPlayerRaceSelectable(Player(1), false)
    call SetPlayerController(Player(1), MAP_CONTROL_USER)

    // Player 2
    call SetPlayerStartLocation(Player(2), 2)
    call ForcePlayerStartLocation(Player(2), 2)
    call SetPlayerColor(Player(2), ConvertPlayerColor(2))
    call SetPlayerRacePreference(Player(2), RACE_PREF_NIGHTELF)
    call SetPlayerRaceSelectable(Player(2), false)
    call SetPlayerController(Player(2), MAP_CONTROL_USER)

    // Player 3
    call SetPlayerStartLocation(Player(3), 3)
    call ForcePlayerStartLocation(Player(3), 3)
    call SetPlayerColor(Player(3), ConvertPlayerColor(3))
    call SetPlayerRacePreference(Player(3), RACE_PREF_NIGHTELF)
    call SetPlayerRaceSelectable(Player(3), false)
    call SetPlayerController(Player(3), MAP_CONTROL_USER)

    // Player 4
    call SetPlayerStartLocation(Player(4), 4)
    call ForcePlayerStartLocation(Player(4), 4)
    call SetPlayerColor(Player(4), ConvertPlayerColor(4))
    call SetPlayerRacePreference(Player(4), RACE_PREF_NIGHTELF)
    call SetPlayerRaceSelectable(Player(4), false)
    call SetPlayerController(Player(4), MAP_CONTROL_USER)

    // Player 5
    call SetPlayerStartLocation(Player(5), 5)
    call ForcePlayerStartLocation(Player(5), 5)
    call SetPlayerColor(Player(5), ConvertPlayerColor(5))
    call SetPlayerRacePreference(Player(5), RACE_PREF_NIGHTELF)
    call SetPlayerRaceSelectable(Player(5), false)
    call SetPlayerController(Player(5), MAP_CONTROL_USER)

    // Player 6
    call SetPlayerStartLocation(Player(6), 6)
    call ForcePlayerStartLocation(Player(6), 6)
    call SetPlayerColor(Player(6), ConvertPlayerColor(6))
    call SetPlayerRacePreference(Player(6), RACE_PREF_NIGHTELF)
    call SetPlayerRaceSelectable(Player(6), false)
    call SetPlayerController(Player(6), MAP_CONTROL_USER)

    // Player 7
    call SetPlayerStartLocation(Player(7), 7)
    call ForcePlayerStartLocation(Player(7), 7)
    call SetPlayerColor(Player(7), ConvertPlayerColor(7))
    call SetPlayerRacePreference(Player(7), RACE_PREF_NIGHTELF)
    call SetPlayerRaceSelectable(Player(7), false)
    call SetPlayerController(Player(7), MAP_CONTROL_USER)

    // Player 9
    call SetPlayerStartLocation(Player(9), 8)
    call ForcePlayerStartLocation(Player(9), 8)
    call SetPlayerColor(Player(9), ConvertPlayerColor(9))
    call SetPlayerRacePreference(Player(9), RACE_PREF_ORC)
    call SetPlayerRaceSelectable(Player(9), false)
    call SetPlayerController(Player(9), MAP_CONTROL_COMPUTER)

endfunction

function InitCustomTeams takes nothing returns nothing
    // Force: TRIGSTR_023
    call SetPlayerTeam(Player(0), 0)
    call SetPlayerState(Player(0), PLAYER_STATE_ALLIED_VICTORY, 1)
    call SetPlayerTeam(Player(1), 0)
    call SetPlayerState(Player(1), PLAYER_STATE_ALLIED_VICTORY, 1)
    call SetPlayerTeam(Player(2), 0)
    call SetPlayerState(Player(2), PLAYER_STATE_ALLIED_VICTORY, 1)
    call SetPlayerTeam(Player(3), 0)
    call SetPlayerState(Player(3), PLAYER_STATE_ALLIED_VICTORY, 1)
    call SetPlayerTeam(Player(4), 0)
    call SetPlayerState(Player(4), PLAYER_STATE_ALLIED_VICTORY, 1)
    call SetPlayerTeam(Player(5), 0)
    call SetPlayerState(Player(5), PLAYER_STATE_ALLIED_VICTORY, 1)
    call SetPlayerTeam(Player(6), 0)
    call SetPlayerState(Player(6), PLAYER_STATE_ALLIED_VICTORY, 1)
    call SetPlayerTeam(Player(7), 0)
    call SetPlayerState(Player(7), PLAYER_STATE_ALLIED_VICTORY, 1)

    //   Allied
    call SetPlayerAllianceStateAllyBJ(Player(0), Player(1), true)
    call SetPlayerAllianceStateAllyBJ(Player(0), Player(2), true)
    call SetPlayerAllianceStateAllyBJ(Player(0), Player(3), true)
    call SetPlayerAllianceStateAllyBJ(Player(0), Player(4), true)
    call SetPlayerAllianceStateAllyBJ(Player(0), Player(5), true)
    call SetPlayerAllianceStateAllyBJ(Player(0), Player(6), true)
    call SetPlayerAllianceStateAllyBJ(Player(0), Player(7), true)
    call SetPlayerAllianceStateAllyBJ(Player(1), Player(0), true)
    call SetPlayerAllianceStateAllyBJ(Player(1), Player(2), true)
    call SetPlayerAllianceStateAllyBJ(Player(1), Player(3), true)
    call SetPlayerAllianceStateAllyBJ(Player(1), Player(4), true)
    call SetPlayerAllianceStateAllyBJ(Player(1), Player(5), true)
    call SetPlayerAllianceStateAllyBJ(Player(1), Player(6), true)
    call SetPlayerAllianceStateAllyBJ(Player(1), Player(7), true)
    call SetPlayerAllianceStateAllyBJ(Player(2), Player(0), true)
    call SetPlayerAllianceStateAllyBJ(Player(2), Player(1), true)
    call SetPlayerAllianceStateAllyBJ(Player(2), Player(3), true)
    call SetPlayerAllianceStateAllyBJ(Player(2), Player(4), true)
    call SetPlayerAllianceStateAllyBJ(Player(2), Player(5), true)
    call SetPlayerAllianceStateAllyBJ(Player(2), Player(6), true)
    call SetPlayerAllianceStateAllyBJ(Player(2), Player(7), true)
    call SetPlayerAllianceStateAllyBJ(Player(3), Player(0), true)
    call SetPlayerAllianceStateAllyBJ(Player(3), Player(1), true)
    call SetPlayerAllianceStateAllyBJ(Player(3), Player(2), true)
    call SetPlayerAllianceStateAllyBJ(Player(3), Player(4), true)
    call SetPlayerAllianceStateAllyBJ(Player(3), Player(5), true)
    call SetPlayerAllianceStateAllyBJ(Player(3), Player(6), true)
    call SetPlayerAllianceStateAllyBJ(Player(3), Player(7), true)
    call SetPlayerAllianceStateAllyBJ(Player(4), Player(0), true)
    call SetPlayerAllianceStateAllyBJ(Player(4), Player(1), true)
    call SetPlayerAllianceStateAllyBJ(Player(4), Player(2), true)
    call SetPlayerAllianceStateAllyBJ(Player(4), Player(3), true)
    call SetPlayerAllianceStateAllyBJ(Player(4), Player(5), true)
    call SetPlayerAllianceStateAllyBJ(Player(4), Player(6), true)
    call SetPlayerAllianceStateAllyBJ(Player(4), Player(7), true)
    call SetPlayerAllianceStateAllyBJ(Player(5), Player(0), true)
    call SetPlayerAllianceStateAllyBJ(Player(5), Player(1), true)
    call SetPlayerAllianceStateAllyBJ(Player(5), Player(2), true)
    call SetPlayerAllianceStateAllyBJ(Player(5), Player(3), true)
    call SetPlayerAllianceStateAllyBJ(Player(5), Player(4), true)
    call SetPlayerAllianceStateAllyBJ(Player(5), Player(6), true)
    call SetPlayerAllianceStateAllyBJ(Player(5), Player(7), true)
    call SetPlayerAllianceStateAllyBJ(Player(6), Player(0), true)
    call SetPlayerAllianceStateAllyBJ(Player(6), Player(1), true)
    call SetPlayerAllianceStateAllyBJ(Player(6), Player(2), true)
    call SetPlayerAllianceStateAllyBJ(Player(6), Player(3), true)
    call SetPlayerAllianceStateAllyBJ(Player(6), Player(4), true)
    call SetPlayerAllianceStateAllyBJ(Player(6), Player(5), true)
    call SetPlayerAllianceStateAllyBJ(Player(6), Player(7), true)
    call SetPlayerAllianceStateAllyBJ(Player(7), Player(0), true)
    call SetPlayerAllianceStateAllyBJ(Player(7), Player(1), true)
    call SetPlayerAllianceStateAllyBJ(Player(7), Player(2), true)
    call SetPlayerAllianceStateAllyBJ(Player(7), Player(3), true)
    call SetPlayerAllianceStateAllyBJ(Player(7), Player(4), true)
    call SetPlayerAllianceStateAllyBJ(Player(7), Player(5), true)
    call SetPlayerAllianceStateAllyBJ(Player(7), Player(6), true)

    // Force: TRIGSTR_148
    call SetPlayerTeam(Player(9), 1)

endfunction

function InitAllyPriorities takes nothing returns nothing

    call SetStartLocPrioCount(0, 7)
    call SetStartLocPrio(0, 0, 1, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(0, 1, 2, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(0, 2, 3, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(0, 3, 4, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(0, 4, 5, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(0, 5, 6, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(0, 6, 7, MAP_LOC_PRIO_HIGH)

    call SetStartLocPrioCount(1, 7)
    call SetStartLocPrio(1, 0, 0, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(1, 1, 2, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(1, 2, 3, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(1, 3, 4, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(1, 4, 5, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(1, 5, 6, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(1, 6, 7, MAP_LOC_PRIO_HIGH)

    call SetStartLocPrioCount(2, 7)
    call SetStartLocPrio(2, 0, 0, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(2, 1, 1, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(2, 2, 3, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(2, 3, 4, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(2, 4, 5, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(2, 5, 6, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(2, 6, 7, MAP_LOC_PRIO_HIGH)

    call SetStartLocPrioCount(3, 7)
    call SetStartLocPrio(3, 0, 0, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(3, 1, 1, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(3, 2, 2, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(3, 3, 4, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(3, 4, 5, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(3, 5, 6, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(3, 6, 7, MAP_LOC_PRIO_HIGH)

    call SetStartLocPrioCount(4, 7)
    call SetStartLocPrio(4, 0, 0, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(4, 1, 1, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(4, 2, 2, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(4, 3, 3, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(4, 4, 5, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(4, 5, 6, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(4, 6, 7, MAP_LOC_PRIO_HIGH)

    call SetStartLocPrioCount(5, 7)
    call SetStartLocPrio(5, 0, 0, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(5, 1, 1, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(5, 2, 2, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(5, 3, 3, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(5, 4, 4, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(5, 5, 6, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(5, 6, 7, MAP_LOC_PRIO_HIGH)

    call SetStartLocPrioCount(6, 7)
    call SetStartLocPrio(6, 0, 0, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(6, 1, 1, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(6, 2, 2, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(6, 3, 3, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(6, 4, 4, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(6, 5, 5, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(6, 6, 7, MAP_LOC_PRIO_HIGH)

    call SetStartLocPrioCount(7, 7)
    call SetStartLocPrio(7, 0, 0, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(7, 1, 1, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(7, 2, 2, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(7, 3, 3, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(7, 4, 4, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(7, 5, 5, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(7, 6, 6, MAP_LOC_PRIO_HIGH)

    call SetStartLocPrioCount(8, 8)
    call SetStartLocPrio(8, 0, 0, MAP_LOC_PRIO_LOW)
    call SetStartLocPrio(8, 1, 1, MAP_LOC_PRIO_LOW)
    call SetStartLocPrio(8, 2, 2, MAP_LOC_PRIO_LOW)
    call SetStartLocPrio(8, 3, 3, MAP_LOC_PRIO_LOW)
    call SetStartLocPrio(8, 4, 4, MAP_LOC_PRIO_LOW)
    call SetStartLocPrio(8, 5, 5, MAP_LOC_PRIO_LOW)
    call SetStartLocPrio(8, 6, 6, MAP_LOC_PRIO_LOW)
    call SetStartLocPrio(8, 7, 7, MAP_LOC_PRIO_LOW)
endfunction

//***************************************************************************
//*
//*  Main Initialization
//*
//***************************************************************************

//===========================================================================
function main takes nothing returns nothing
    call SetCameraBounds(- 15616.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), - 15872.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM), 15616.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), 15360.0 - GetCameraMargin(CAMERA_MARGIN_TOP), - 15616.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), 15360.0 - GetCameraMargin(CAMERA_MARGIN_TOP), 15616.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), - 15872.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM))
    call SetDayNightModels("Environment\\DNC\\DNCLordaeron\\DNCLordaeronTerrain\\DNCLordaeronTerrain.mdl", "Environment\\DNC\\DNCLordaeron\\DNCLordaeronUnit\\DNCLordaeronUnit.mdl")
    call NewSoundEnvironment("Default")
    call SetAmbientDaySound("BlackCitadelDay")
    call SetAmbientNightSound("BlackCitadelNight")
    call SetMapMusic("Music", true, 0)
    call InitSounds()
    call CreateRegions()
    call CreateAllItems()
    call CreateAllUnits()
    call InitBlizzard()

call ExecuteFunc("jasshelper__initstructs74146625")
call ExecuteFunc("EDWQuests__init")
call ExecuteFunc("FilterFuncInit")
call ExecuteFunc("FooBar__Init")
call ExecuteFunc("GroupUtils___init")
call ExecuteFunc("PreventSave___onInit")
call ExecuteFunc("TimerUtils___init")
call ExecuteFunc("PlatformerProfile__Init")
call ExecuteFunc("TerrainGlobals___initTerrainGlobals")
call ExecuteFunc("ComplexTerrainPathing__init")
call ExecuteFunc("IceSteering___Init")
call ExecuteFunc("PlatformerOcean__Init")
call ExecuteFunc("PlatformerIce__Init")
call ExecuteFunc("PlatformerSlipStream__Init")
call ExecuteFunc("TeamSaveLocation___Init")
call ExecuteFunc("MazerGlobals_Init")
call ExecuteFunc("IceMovement_Init")
call ExecuteFunc("MazingCollision___Init")
call ExecuteFunc("StandardGameLoop___init")
call ExecuteFunc("EDWVFXPreload___init")
call ExecuteFunc("InGameCommands__init")
call ExecuteFunc("CameraTrackingEvents___Init")
call ExecuteFunc("Continues___Init")
call ExecuteFunc("EDWGameStart___Init")

    call InitGlobals()
    call InitCustomTriggers()

endfunction

//***************************************************************************
//*
//*  Map Configuration
//*
//***************************************************************************

function config takes nothing returns nothing
    call SetMapName("TRIGSTR_001")
    call SetMapDescription("TRIGSTR_145")
    call SetPlayers(9)
    call SetTeams(9)
    call SetGamePlacement(MAP_PLACEMENT_TEAMS_TOGETHER)

    call DefineStartLocation(0, 3968.0, 5632.0)
    call DefineStartLocation(1, 3968.0, 5632.0)
    call DefineStartLocation(2, 3968.0, 5632.0)
    call DefineStartLocation(3, 3968.0, 5632.0)
    call DefineStartLocation(4, 3968.0, 5632.0)
    call DefineStartLocation(5, 3968.0, 5632.0)
    call DefineStartLocation(6, 3968.0, 5632.0)
    call DefineStartLocation(7, 3968.0, 5632.0)
    call DefineStartLocation(8, 128.0, 2176.0)

    // Player setup
    call InitCustomPlayerSlots()
    call InitCustomTeams()
    call InitAllyPriorities()
endfunction




//Struct method generated initializers/callers:

//Functions for BigArrays:
function sa__Levels_Level_GetWeightedRandomInt takes nothing returns boolean
local integer this=f__arg_this
local integer lowBound=f__arg_integer1
local integer highBound=f__arg_integer2
set f__result_integer= GetRandomInt(lowBound, highBound)
   return true
endfunction
function sa__Levels_Level_GetWorldID takes nothing returns boolean
local integer this=f__arg_this
			if this >= 3 then //last level ID
set f__result_integer= ModuloInteger(this - 3, 7) + 1
return true
			else
set f__result_integer= - this
return true
            endif
   return true
endfunction
function sa__Levels_Level_RemoveGreenFromLevel takes nothing returns boolean
local integer this=f__arg_this
            local unit u
   local integer i= 0
            local rect r
			loop
			exitwhen i >= s__RectList__get_size(s__Levels_Level_Boundaries[this])
			set r=s__RectList__getindex(s__Levels_Level_Boundaries[this],i)
				call GroupEnumUnitsInRect(TempGroup, r, null)
				loop
				set u=FirstOfGroup(TempGroup)
				exitwhen u == null
					if GetPlayerId(GetOwningPlayer(u)) == 10 then
						call SetUnitVertexColor(u, 255, 255, 255, 255)
						call SetUnitMoveSpeed(u, GetUnitDefaultMoveSpeed(u))
						call Recycle_ReleaseUnit(u)
					endif
				call GroupRemoveUnit(TempGroup, u)
				endloop
			set i=i + 1
            endloop
			set r=null
   return true
endfunction
function sa__Levels_Level_SetCheckpointForTeam takes nothing returns boolean
local integer this=f__arg_this
local integer mt=f__arg_integer1
local integer cpID=f__arg_integer2
            local integer cp= (s__SimpleList_ListNode_value[s__SimpleList_List_get(s__Levels_Level_Checkpoints[this],cpID)])
			if cp != 0 then
				set EventCheckpoint=cp
				set EventCurrentLevel=this
				set s__Levels_Level_CBTeam=mt
				set s__Teams_MazingTeam_OnCheckpoint[mt]=cpID
                set s__Teams_MazingTeam_DefaultGameMode[mt]=s__Checkpoint_DefaultGameMode[cp]
                call s__Teams_MazingTeam_MoveRevive(mt,s__Checkpoint_ReviveCenter[cp])
                call s__Teams_MazingTeam_RespawnTeamAtRect(mt,s__Checkpoint_ReviveCenter[cp] , true)
                call s__Teams_MazingTeam_ApplyKeyToTeam(mt,s__Checkpoint_DefaultColor[cp])
				call s__Teams_MazingTeam_ResetHealthForTeam(mt)
                call s__Teams_MazingTeam_UpdateMultiboard(mt)
				if s__Levels_Level_OnCheckpointChange[this] != 0 then
					call s__Event_fire(s__Levels_Level_OnCheckpointChange[this])
				endif
            endif
   return true
endfunction
function sa__Levels_Level_AnimatedSetCheckpointForTeam takes nothing returns boolean
local integer this=f__arg_this
local integer mt=f__arg_integer1
local integer cpID=f__arg_integer2
   local integer cp= (s__SimpleList_ListNode_value[s__SimpleList_List_get(s__Levels_Level_Checkpoints[this],cpID)])
			if s__SimpleList_List_count[s__Teams_MazingTeam_Users[mt]] > 1 then
				if cp != 0 then
					call s__Teams_MazingTeam_PauseTeam(mt,true)
					if s__Teams_MazingTeam_LastEventUser[mt] != - 1 then
						call s__Teams_MazingTeam_PrintMessage(mt,s__User_GetStylizedPlayerName(s__Teams_MazingTeam_LastEventUser[mt]) + " has reached a checkpoint!")
					endif
					set s__Teams_MazingTeam_OnCheckpoint[mt]=cpID
					set s__Teams_MazingTeam_DefaultGameMode[mt]=s__Checkpoint_DefaultGameMode[cp]
					call s__Teams_MazingTeam_MoveRevive(mt,s__Checkpoint_ReviveCenter[cp])
					call TimerStart(NewTimerEx(mt), .25, false, function s__Levels_Level_OnCheckpointChangeFX_DisappearingVFX)
				endif
			else
				call s__Levels_Level_SetCheckpointForTeam(this,mt , cpID)
			endif
   return true
endfunction
function sa__Levels_Level_SwitchLevels takes nothing returns boolean
local integer this=f__arg_this
local integer mt=f__arg_integer1
local integer nextLevel=f__arg_integer2
local integer activatingUser=f__arg_integer3
local boolean updateProgress=f__arg_boolean1
			if updateProgress then
				call s__Levels_Level_ApplyLevelRewards(this,activatingUser , mt , nextLevel)
				call s__Teams_MazingTeam_UpdateWorldProgress(mt,this)
			endif
			call s__Levels_Level_StopLevelForTeam(this,mt)
			call s__Levels_Level_StartLevelForTeam(nextLevel,mt)
   return true
endfunction
function sa__Levels_Level_SwitchLevelsAnimated takes nothing returns boolean
local integer this=f__arg_this
local integer mt=f__arg_integer1
local integer nextLevel=f__arg_integer2
local boolean updateProgress=f__arg_boolean1
   local integer transferData= s__Levels___AnimatedLevelTransferData_allocate()
			set s__Levels___AnimatedLevelTransferData_Team[transferData]=mt
			set s__Levels___AnimatedLevelTransferData_NextLevel[transferData]=nextLevel
			set s__Levels___AnimatedLevelTransferData_UpdateProgress[transferData]=updateProgress
			call s__Teams_MazingTeam_PauseTeam(mt,true)
			if this != DOORS_LEVEL_ID then
				if s__Teams_MazingTeam_LastEventUser[mt] != - 1 then
					call s__Teams_MazingTeam_PrintMessage(mt,s__User_GetStylizedPlayerName(s__Teams_MazingTeam_LastEventUser[mt]) + " has cleared the level!")
				endif
			else
				call s__Teams_MazingTeam_PrintMessageAll(s__Teams_MazingTeam_TeamName[mt] + " team has just started " + s__Levels_Level_GetWorldString(nextLevel) , mt)
				call s__Teams_MazingTeam_PrintMessage(mt,"Entering new world: " + s__Levels_Level_GetWorldString(nextLevel))
			endif
			call TimerStart(NewTimerEx(transferData), .5, false, function s__Levels_Level_SwitchLevels_DisappearingVFX)
   return true
endfunction
function sa__Teams_MazingTeam_MoveRevive takes nothing returns boolean
    call s__Teams_MazingTeam_MoveRevive(f__arg_this,f__arg_rect1)
   return true
endfunction
function sa__Teams_MazingTeam_RespawnTeamAtRect takes nothing returns boolean
    call s__Teams_MazingTeam_RespawnTeamAtRect(f__arg_this,f__arg_rect1,f__arg_boolean1)
   return true
endfunction
function sa__Teams_MazingTeam_PrintMessage takes nothing returns boolean
local integer this=f__arg_this
local string message=f__arg_string1
        local integer fp= s__Teams_MazingTeam_FirstUser[this]
        loop
        exitwhen fp == 0
            if GetLocalPlayer() == Player(s__SimpleList_ListNode_value[fp]) then
                call DisplayTextToPlayer(Player(s__SimpleList_ListNode_value[fp]), 0, 0, message)
            endif
        set fp=s__SimpleList_ListNode_next[fp]
        endloop
   return true
endfunction
function sa__Teams_MazingTeam_UpdateMultiboard takes nothing returns boolean
local integer this=f__arg_this
        local integer pID
        local integer fp= s__Teams_MazingTeam_FirstUser[this]
        local integer u
        loop
        exitwhen fp == 0
            set u=(s__SimpleList_ListNode_value[fp])
            set pID=u
            if GetPlayerSlotState(Player(pID)) == PLAYER_SLOT_STATE_PLAYING then
				call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 0), sc__Teams_MazingTeam_GetStylizedPlayerName(this,pID))
                call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 1), s__Levels_Level_Name[s__Teams_MazingTeam_OnLevel[this]])
                call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 2), I2S(s__Teams_MazingTeam_Score[this]))
                call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 3), I2S(s__Teams_MazingTeam_ContinueCount[this]))
                call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 0))
                call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 1))
                call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 2))
                call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 3))
				if RewardMode == GameModesGlobals_HARD then
					call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 4), I2S(s__User_Deaths[u]))
					call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 4))
				endif
			elseif GetPlayerSlotState(Player(pID)) == PLAYER_SLOT_STATE_LEFT then
                call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 0), "Left the game")
                call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 1), "Gone")
                call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 2), "Negative")
                call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 3), "Zilch")
                call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 0))
                call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 1))
                call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 2))
                call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 3))
				if RewardMode == GameModesGlobals_HARD then
					call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 4), "Too many")
					call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 4))
				endif
            else
                call MultiboardSetItemValue(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 0), "Not playing")
                call MultiboardReleaseItem(MultiboardGetItem(s__Teams_MazingTeam_PlayerStats, pID + 1, 0))
            endif
        set fp=s__SimpleList_ListNode_next[fp]
        endloop
   return true
endfunction
function sa__Teams_MazingTeam_GetStylizedPlayerName takes nothing returns boolean
local integer this=f__arg_this
local integer pID=f__arg_integer1
        if GetPlayerSlotState(Player(pID)) == PLAYER_SLOT_STATE_PLAYING then
			if s__User_IsAFK[(pID)] then
set f__result_string= ColorMessage("(AFK) " , DISABLED_COLOR) + ColorMessage(GetPlayerName(Player(pID)) , s__Teams_MazingTeam_GetTeamColor(this))
return true
			else
set f__result_string= ColorMessage(GetPlayerName(Player(pID)) , s__Teams_MazingTeam_GetTeamColor(this))
return true
			endif
        else
set f__result_string= ColorMessage("Gone" , s__Teams_MazingTeam_GetTeamColor(this))
return true
        endif
   return true
endfunction
function sa__Teams_MazingTeam_ComputeTeamWeights takes nothing returns boolean

        local integer curTeamNode= s__SimpleList_List_first[s__Teams_MazingTeam_AllTeams]
        local real avgSize= 0
        loop
        exitwhen curTeamNode == 0
            set avgSize=avgSize + s__SimpleList_List_count[s__Teams_MazingTeam_Users[(s__SimpleList_ListNode_value[curTeamNode])]]
		set curTeamNode=s__SimpleList_ListNode_next[curTeamNode]
        endloop
        set avgSize=avgSize / s__Teams_MazingTeam_NumberTeams
        set curTeamNode=s__SimpleList_List_first[s__Teams_MazingTeam_AllTeams]
        loop
        exitwhen curTeamNode == 0
            if s__SimpleList_List_count[s__Teams_MazingTeam_Users[(s__SimpleList_ListNode_value[curTeamNode])]] > avgSize then
                set s__Teams_MazingTeam_Weight[(s__SimpleList_ListNode_value[curTeamNode])]=1.0 / ( s__SimpleList_List_count[s__Teams_MazingTeam_Users[(s__SimpleList_ListNode_value[curTeamNode])]] - avgSize )
            elseif s__SimpleList_List_count[s__Teams_MazingTeam_Users[(s__SimpleList_ListNode_value[curTeamNode])]] < avgSize then
                set s__Teams_MazingTeam_Weight[(s__SimpleList_ListNode_value[curTeamNode])]=1.0 * ( avgSize - s__SimpleList_List_count[s__Teams_MazingTeam_Users[(s__SimpleList_ListNode_value[curTeamNode])]] )
            else // team size == avg size
                set s__Teams_MazingTeam_Weight[(s__SimpleList_ListNode_value[curTeamNode])]=1.
            endif
		set curTeamNode=s__SimpleList_ListNode_next[curTeamNode]
        endloop
   return true
endfunction
function sa__Teams_MazingTeam_GetRandomTeam takes nothing returns boolean
local integer filter=f__arg_integer1
  local integer rand= GetRandomInt(0, s__Teams_MazingTeam_NumberTeams - 1)
		if s__Teams_MazingTeam_NumberTeams != 1 or filter == 0 then
			if filter != 0 then
				loop
				exitwhen rand != filter
				set rand=GetRandomInt(0, s__Teams_MazingTeam_NumberTeams - 1)
				endloop
			endif
set f__result_integer= s__SimpleList_ListNode_value[s__SimpleList_List_get(s__Teams_MazingTeam_AllTeams,rand)]
return true
		else
set f__result_integer= 0
return true
		endif
   return true
endfunction
function sa__Teams_MazingTeam_GetContinueCount takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= s__Teams_MazingTeam_ContinueCount[this]
   return true
endfunction
function sa__Teams_MazingTeam_SetContinueCount takes nothing returns boolean
local integer this=f__arg_this
local integer continueCount=f__arg_integer1
		set s__Teams_MazingTeam_ContinueCount[this]=continueCount
		call s__Teams_MazingTeam_UpdateMultiboard(this)
   return true
endfunction
function sa__Teams_MazingTeam_ChangeContinueCount takes nothing returns boolean
local integer this=f__arg_this
local integer continueOffset=f__arg_integer1
		if continueOffset != 0 then
			if s__Teams_MazingTeam_ContinueCount[this] + continueOffset < 0 then
				call s__Teams_MazingTeam_PrintMessage(this,"Your team ran out of lives!")
				call sc__Levels_Level_SwitchLevels(s__Teams_MazingTeam_OnLevel[this],this , (DOORS_LEVEL_ID) , 0 , false)
				if RewardMode == 0 or RewardMode == 1 then //standard mode or challenge mode
					set s__Teams_MazingTeam_ContinueCount[this]=0
				elseif RewardMode == 2 then
				endif
			else
				set s__Teams_MazingTeam_ContinueCount[this]=s__Teams_MazingTeam_ContinueCount[this] + continueOffset
			endif
			call s__Teams_MazingTeam_UpdateMultiboard(this)
		endif
   return true
endfunction
function sa__Teams_MazingTeam_GetScore takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= s__Teams_MazingTeam_Score[this]
   return true
endfunction
function sa__Teams_MazingTeam_ChangeScore takes nothing returns boolean
local integer this=f__arg_this
local integer scoreOffset=f__arg_integer1
  local integer ogScore= VictoryScore - s__Teams_MazingTeam_Score[this]
		if scoreOffset != 0 then
			set s__Teams_MazingTeam_Score[this]=s__Teams_MazingTeam_Score[this] + scoreOffset
			if VictoryScore != 0 then
				if VictoryScore - s__Teams_MazingTeam_Score[this] <= 0 then
					call sc__Teams_MazingTeam_ApplyEndGameAll(this)
				elseif ( VictoryScore - s__Teams_MazingTeam_Score[this] <= 10 and ogScore > 10 ) or ( VictoryScore - s__Teams_MazingTeam_Score[this] <= 5 and ogScore > 5 ) then
					call s__Teams_MazingTeam_PrintMessageAll("Team " + s__Teams_MazingTeam_TeamName[this] + " needs " + (ColorMessage((I2S(VictoryScore - s__Teams_MazingTeam_Score[this])) , SPEAKER_COLOR)) + " more points to win" , 0) // INLINED!!
				elseif VictoryScore - s__Teams_MazingTeam_Score[this] <= 3 and ogScore > 3 then
					if VictoryScore - s__Teams_MazingTeam_Score[this] == 1 then
						call s__Teams_MazingTeam_PrintMessageAll("Team " + s__Teams_MazingTeam_TeamName[this] + " only needs " + (ColorMessage((I2S(VictoryScore - s__Teams_MazingTeam_Score[this])) , SPEAKER_COLOR)) + " more point to win!" , 0) // INLINED!!
					else
						call s__Teams_MazingTeam_PrintMessageAll("Team " + s__Teams_MazingTeam_TeamName[this] + " only needs " + (ColorMessage((I2S(VictoryScore - s__Teams_MazingTeam_Score[this])) , SPEAKER_COLOR)) + " more points to win!" , 0) // INLINED!!
					endif
				endif
			endif
			call s__Teams_MazingTeam_UpdateMultiboard(this)
		endif
   return true
endfunction
function sa__Teams_MazingTeam_ApplyEndGameAll takes nothing returns boolean
local integer victor=f__arg_integer1
  local integer curTeamNode= s__SimpleList_List_first[s__Teams_MazingTeam_AllTeams]
		loop
        exitwhen curTeamNode == 0
            if (s__SimpleList_ListNode_value[curTeamNode]) == victor then
				call s__Teams_MazingTeam_ApplyEndGame((s__SimpleList_ListNode_value[curTeamNode]),true)
			else
				call s__Teams_MazingTeam_ApplyEndGame((s__SimpleList_ListNode_value[curTeamNode]),false)
			endif
            set curTeamNode=s__SimpleList_ListNode_next[curTeamNode]
        endloop
   return true
endfunction
function sa__Teams_MazingTeam_PauseTeam takes nothing returns boolean
local integer this=f__arg_this
local boolean flag=f__arg_boolean1
  local integer curPlayerNode= s__Teams_MazingTeam_FirstUser[this]
		loop
		exitwhen curPlayerNode == 0
			call s__User_Pause((s__SimpleList_ListNode_value[curPlayerNode]),flag)
		set curPlayerNode=s__SimpleList_ListNode_next[curPlayerNode]
		endloop
   return true
endfunction
function sa__Teams_MazingTeam_SetUnitLocalOpacityForTeam takes nothing returns boolean
    call s__Teams_MazingTeam_SetUnitLocalOpacityForTeam(f__arg_this,f__arg_unit1,f__arg_integer1)
   return true
endfunction
function sa__Teams_MazingTeam_PlaySoundForTeam takes nothing returns boolean
    call s__Teams_MazingTeam_PlaySoundForTeam(f__arg_this,f__arg_sound1)
   return true
endfunction
function sa__Teams_MazingTeam_PanCameraForTeam takes nothing returns boolean
local integer this=f__arg_this
local real x=f__arg_real1
local real y=f__arg_real2
local real duration=f__arg_real3
  local integer curPlayerNode= s__Teams_MazingTeam_FirstUser[this]
		loop
		exitwhen curPlayerNode == 0
			if GetLocalPlayer() == Player(s__SimpleList_ListNode_value[curPlayerNode]) then
				if s__User_IsAFK[(s__SimpleList_ListNode_value[curPlayerNode])] then
					call SetCameraPosition(x, y)
					set s__vector2_x[s__User_LocalCameraTargetPosition]=x
					set s__vector2_y[s__User_LocalCameraTargetPosition]=y
				else
					call PanCameraToTimed(x, y, duration)
				endif
			endif
		set curPlayerNode=s__SimpleList_ListNode_next[curPlayerNode]
		endloop
   return true
endfunction
function sa__Teams_MazingTeam_SetSharedControlForTeam takes nothing returns boolean
local integer this=f__arg_this
local integer user=f__arg_integer1
local boolean flag=f__arg_boolean1
  local integer curPlayerNode= s__Teams_MazingTeam_FirstUser[this]
		loop
		exitwhen curPlayerNode == 0
			if s__SimpleList_ListNode_value[curPlayerNode] != user then
				call SetPlayerAlliance(Player(user), Player(s__SimpleList_ListNode_value[curPlayerNode]), ALLIANCE_SHARED_CONTROL, flag)
			endif
		set curPlayerNode=s__SimpleList_ListNode_next[curPlayerNode]
		endloop
   return true
endfunction
function sa__User_SetActiveEffect takes nothing returns boolean
local integer this=f__arg_this
local string strEffect=f__arg_string1
local string attachPoint=f__arg_string2
		if s__User_ActiveEffect[this] != null then
			call DestroyEffect(s__User_ActiveEffect[this])
			set s__User_ActiveEffect[this]=null
		endif
		if strEffect != null then
			set s__User_ActiveEffect[this]=AddSpecialEffectTarget(strEffect, s__User_ActiveUnit[this], attachPoint)
		endif
   return true
endfunction
function sa__User_ClearActiveEffect takes nothing returns boolean
local integer this=f__arg_this
		call s__User_SetActiveEffect(this,null , null)
   return true
endfunction
function sa__User_CreateUserTimedEffect takes nothing returns boolean
local integer this=f__arg_this
local string fxFileLocation=f__arg_string1
local string attachPointName=f__arg_string2
local real duration=f__arg_real1
		call s__UserActiveTimedEffect_create(fxFileLocation , attachPointName , this , duration)
   return true
endfunction
function sa__User_OnCinemaEndCB takes nothing returns boolean

        set s__User_CinematicPlaying[EventUser]=0
        call sc__User_CheckCinematicQueue(EventUser)
set f__result_boolean= false
   return true
endfunction
function sa__User_CheckCinematicQueue takes nothing returns boolean
local integer this=f__arg_this
        if s__User_CinematicPlaying[this] == 0 and s__SimpleList_List_count[s__User_CinematicQueue[this]] > 0 then
            set s__User_CinematicPlaying[this]=s__Cinematic_Activate((s__SimpleList_ListNode_value[s__SimpleList_List_pop(s__User_CinematicQueue[this])]),this)
        endif
   return true
endfunction
function sa__User_DisplayMessage takes nothing returns boolean
local integer this=f__arg_this
local string message=f__arg_string1
local real duration=f__arg_real1
        if s__User_IsPlaying[this] then
            if duration == 0 then
                call DisplayTextToPlayer(Player(this), 0, 0, message)
            else
                call DisplayTimedTextToPlayer(Player(this), 0, 0, duration, message)
            endif
        endif
   return true
endfunction
function sa__User_ApplyDefaultCameras takes nothing returns boolean
local integer this=f__arg_this
local real time=f__arg_real1
		if s__User_GameMode[this] == Teams_GAMEMODE_PLATFORMING or s__User_GameMode[this] == Teams_GAMEMODE_PLATFORMING_PAUSED then
            call s__Platformer_ApplyCamera(s__User_Platformer[this])
        elseif s__User_GameMode[this] == Teams_GAMEMODE_STANDARD or s__User_GameMode[this] == Teams_GAMEMODE_STANDARD_PAUSED then
            if GetLocalPlayer() == Player(this) then
                call CameraSetupApply(s__DefaultCamera[this], false, false)
                if s__User_IsAFK[this] then
					call SetCameraPosition(GetUnitX(s__User_ActiveUnit[this]), GetUnitY(s__User_ActiveUnit[this]))
					set s__vector2_x[s__User_LocalCameraTargetPosition]=GetUnitX(s__User_ActiveUnit[this])
					set s__vector2_y[s__User_LocalCameraTargetPosition]=GetUnitY(s__User_ActiveUnit[this])
				else
					call PanCameraToTimed(GetUnitX(s__User_ActiveUnit[this]), GetUnitY(s__User_ActiveUnit[this]), time)
				endif
                if s__DefaultCameraTracking[this] then
                    call SetCameraTargetController(s__User_ActiveUnit[this], 0, 0, false)
                endif
            endif
        endif
   return true
endfunction
function sa__User_ResetDefaultCamera takes nothing returns boolean
local integer this=f__arg_this
local real duration=f__arg_real1
		if ( GetLocalPlayer() == Player(this) ) then
            call ResetToGameCamera(duration)
			if duration > 0 then
				call CameraSetupApply(s__DefaultCamera[this], false, false)
			else
				call CameraSetupApply(s__DefaultCamera[this], false, false)
			endif
        endif
   return true
endfunction
function sa__User_ApplyDefaultSelections takes nothing returns boolean
local integer this=f__arg_this
		if s__User_GameMode[this] != Teams_GAMEMODE_PLATFORMING and s__User_GameMode[this] != Teams_GAMEMODE_PLATFORMING_PAUSED then
            if GetLocalPlayer() == Player(this) then
                call ClearSelection()
                if s__User_ActiveUnit[this] != null then
                    call SelectUnit(s__User_ActiveUnit[this], true)
                endif
            endif
        endif
   return true
endfunction
function sa__User_Pause takes nothing returns boolean
local integer this=f__arg_this
local boolean flag=f__arg_boolean1
        if s__User_IsPlaying[this] and s__User_IsAlive[this] then
            if flag then
                if s__User_GameMode[this] == Teams_GAMEMODE_STANDARD then
					call PauseUnit(s__MazersArray[this], true)
					call PauseUnit(s__MazersArray[this], false)
					call IssueImmediateOrder(s__User_ActiveUnit[this], "stop")
                    call sc__User_SwitchGameModesDefaultLocation(this,Teams_GAMEMODE_STANDARD_PAUSED)
                elseif s__User_GameMode[this] == Teams_GAMEMODE_PLATFORMING then
                    call sc__User_SwitchGameModesDefaultLocation(this,Teams_GAMEMODE_PLATFORMING_PAUSED)
                endif
            else
                if s__User_GameMode[this] == Teams_GAMEMODE_STANDARD_PAUSED then
                    call sc__User_SwitchGameModesDefaultLocation(this,Teams_GAMEMODE_STANDARD)
                elseif s__User_GameMode[this] == Teams_GAMEMODE_PLATFORMING_PAUSED then
                    call sc__User_SwitchGameModesDefaultLocation(this,Teams_GAMEMODE_PLATFORMING)
                endif
            endif
        endif
   return true
endfunction
function sa__User_RespawnAtRect takes nothing returns boolean
    call s__User_RespawnAtRect(f__arg_this,f__arg_rect1,f__arg_boolean1)
   return true
endfunction
function sa__User_SetKeyColor takes nothing returns boolean
local integer this=f__arg_this
local integer keyColor=f__arg_integer1
		if s__MazerColor[this] != keyColor then
			set s__MazerColor[this]= keyColor
			if keyColor == KEY_RED then
				call SetUnitVertexColor(s__MazersArray[this], 255, 0, 0, 255)
			elseif keyColor == KEY_BLUE then
				call SetUnitVertexColor(s__MazersArray[this], 0, 0, 255, 255)
			elseif keyColor == KEY_GREEN then
				call SetUnitVertexColor(s__MazersArray[this], 0, 255, 0, 255)
			elseif keyColor == KEY_NONE then
				call SetUnitVertexColor(s__MazersArray[this], 255, 255, 255, 255)
			endif
		endif
   return true
endfunction
function sa__User_GetStylizedPlayerName takes nothing returns boolean
local integer this=f__arg_this
        local string hex= s__User_GetPlayerColorHex(this)
        if GetPlayerSlotState(Player(this)) == PLAYER_SLOT_STATE_PLAYING then
			if s__User_IsAFK[this] then
set f__result_string= ColorMessage("(AFK) " , DISABLED_COLOR) + ColorMessage(GetPlayerName(Player(this)) , hex)
return true
			else
set f__result_string= ColorMessage(GetPlayerName(Player(this)) , hex)
return true
			endif
        else
set f__result_string= ColorMessage("(Left) " + GetPlayerName(Player(this)) , hex)
return true
        endif
   return true
endfunction
function sa__User_SwitchGameModesDefaultLocation takes nothing returns boolean
local integer this=f__arg_this
local integer newGameMode=f__arg_integer1
        local real x
        local real y
        local integer ttype
        if s__User_GameMode[this] == Teams_GAMEMODE_DEAD then
            loop
                set x=GetRandomReal(GetRectMinX(s__Teams_MazingTeam_Revive[s__User_Team[this]]), GetRectMaxX(s__Teams_MazingTeam_Revive[s__User_Team[this]]))
                set y=GetRandomReal(GetRectMinY(s__Teams_MazingTeam_Revive[s__User_Team[this]]), GetRectMaxY(s__Teams_MazingTeam_Revive[s__User_Team[this]]))
                set ttype=GetTerrainType(x, y)
                if newGameMode == Teams_GAMEMODE_STANDARD or newGameMode == Teams_GAMEMODE_STANDARD_PAUSED then
                    exitwhen ( ttype != ABYSS and ttype != LAVA and ttype != LRGBRICKS )
                elseif newGameMode == Teams_GAMEMODE_PLATFORMING or newGameMode == Teams_GAMEMODE_PLATFORMING_PAUSED then
                    exitwhen ( ttype != LAVA and ttype != LRGBRICKS and TerrainGlobals_IsTerrainPathable(ttype) )
                else
                endif
            endloop
        elseif s__User_ActiveUnit[this] != null then
            set x=GetUnitX(s__User_ActiveUnit[this])
            set y=GetUnitY(s__User_ActiveUnit[this])
		else
			set x=0
			set y=0
        endif
        call sc__User_SwitchGameModes(this,newGameMode , x , y)
   return true
endfunction
function sa__User_SwitchGameModes takes nothing returns boolean
local integer this=f__arg_this
local integer newGameMode=f__arg_integer1
local real x=f__arg_real1
local real y=f__arg_real2
        local integer curGameMode= s__User_GameMode[this]
        local real facing
        if newGameMode != curGameMode then
            if newGameMode == Teams_GAMEMODE_DEAD then
                if not RespawnASAPMode then
                    set facing=GetUnitFacing(s__User_ActiveUnit[this])
                endif
			elseif newGameMode == Teams_GAMEMODE_HIDDEN then
				call s__User_ResetDefaultCamera(this,0.)
            endif
            if curGameMode == Teams_GAMEMODE_STANDARD then
                call ShowUnit(s__MazersArray[this], false)
                if s__PreviousTerrainTypedx[this] != NOEFFECT then
					call GameLoopRemoveTerrainAction(s__MazersArray[this] , this , s__PreviousTerrainTypedx[this] , NOEFFECT)
					set s__PreviousTerrainTypedx[this]= NOEFFECT
				endif
                call SetUnitPosition(s__MazersArray[this], MazerGlobals_SAFE_X, MazerGlobals_SAFE_Y)
				call s__SimpleList_List_remove(StandardMazingUsers,this)
                set NumberMazing=NumberMazing - 1
            elseif curGameMode == Teams_GAMEMODE_PLATFORMING then
                call s__Platformer_StopPlatforming(s__User_Platformer[this])
            elseif curGameMode == Teams_GAMEMODE_STANDARD_PAUSED then
				call s__User_SetActiveEffect((this),null , null) // INLINED!!
                call s__DummyCaster_castTarget(('A004'),Player(10) , 1 , OrderId("dispel") , s__User_ActiveUnit[this])
				call SetUnitPropWindow(s__User_ActiveUnit[this], GetUnitDefaultPropWindow(s__User_ActiveUnit[this]) * bj_DEGTORAD)
                if newGameMode != Teams_GAMEMODE_STANDARD then
					call ShowUnit(s__MazersArray[this], false)
					call SetUnitPosition(s__MazersArray[this], MazerGlobals_SAFE_X, MazerGlobals_SAFE_Y)
                endif
            elseif curGameMode == Teams_GAMEMODE_PLATFORMING_PAUSED then
                if newGameMode != Teams_GAMEMODE_PLATFORMING then
                    call ShowUnit(s__Platformer_Unit[s__User_Platformer[this]], false)
					call SetUnitPosition(s__Platformer_Unit[s__User_Platformer[this]], PlatformerGlobals_SAFE_X, PlatformerGlobals_SAFE_Y)
                endif
            elseif curGameMode == Teams_GAMEMODE_DYING then
            elseif curGameMode == Teams_GAMEMODE_DEAD then
                call ReviveHero(s__MazersArray[this], MazerGlobals_SAFE_X, MazerGlobals_SAFE_Y, false)
                call ShowUnit(s__MazersArray[this], false)
                call IssueImmediateOrder(s__MazersArray[this], "stop")
                call SetUnitPosition(s__PlayerReviveCircles[this], MazerGlobals_REVIVE_CIRCLE_SAFE_X, MazerGlobals_REVIVE_CIRCLE_SAFE_Y)
                call ShowUnit(s__PlayerReviveCircles[this], false)
            endif
            call sc__User_SetCurrentGameMode(this,newGameMode)
            if newGameMode == Teams_GAMEMODE_STANDARD then
				call SetUnitPosition(s__MazersArray[this], x, y)
				call s__SimpleList_List_addEnd(StandardMazingUsers,this)
                set NumberMazing=NumberMazing + 1
                call ShowUnit(s__MazersArray[this], true)
                call PauseUnit(s__MazersArray[this], true)
                call PauseUnit(s__MazersArray[this], false)
				call s__User_ApplyDefaultSelections(this)
            elseif newGameMode == Teams_GAMEMODE_PLATFORMING then
                call s__Platformer_StartPlatforming(s__User_Platformer[this],x , y)
				set s__User_PlatformerStartStable[this]=false
				if s__User_IsAFK[this] then
					call sc__User_ApplyAFKPlatformer(this)
				endif
            elseif newGameMode == Teams_GAMEMODE_STANDARD_PAUSED then
                call SetUnitPosition(s__MazersArray[this], x, y)
                call ShowUnit(s__MazersArray[this], true)
				call s__User_SetActiveEffect(this,"Abilities\\Spells\\NightElf\\EntanglingRoots\\EntanglingRootsTarget.mdl" , "origin")
				call SetUnitPropWindow(s__User_ActiveUnit[this], 0)
				call s__User_ApplyDefaultSelections(this)
            elseif newGameMode == Teams_GAMEMODE_PLATFORMING_PAUSED then
                set s__Platformer_XPosition[s__User_Platformer[this]]=x
                set s__Platformer_YPosition[s__User_Platformer[this]]=y
                call SetUnitPosition(s__Platformer_Unit[s__User_Platformer[this]], x, y)
                call ShowUnit(s__Platformer_Unit[s__User_Platformer[this]], true)
                call s__Platformer_ApplyCamera(s__User_Platformer[this])
            elseif newGameMode == Teams_GAMEMODE_DYING then
				call SetUnitPosition(s__MazersArray[this], x, y)
                call ShowUnit(s__MazersArray[this], true)
                call KillUnit(s__MazersArray[this])
            elseif newGameMode == Teams_GAMEMODE_DEAD then
                call s__User_ApplyDeathMode(this,x , y , facing , s__User_PreviousGameMode[this])
            endif
        else
            if newGameMode == Teams_GAMEMODE_STANDARD or newGameMode == Teams_GAMEMODE_STANDARD_PAUSED then
                call SetUnitPosition(s__MazersArray[this], x, y)
            elseif newGameMode == Teams_GAMEMODE_PLATFORMING or newGameMode == Teams_GAMEMODE_PLATFORMING_PAUSED then
                call s__Platformer_StopPlatforming(s__User_Platformer[this])
                call s__Platformer_StartPlatforming(s__User_Platformer[this],x , y)
            endif
        endif
   return true
endfunction
function sa__User_SetCurrentGameMode takes nothing returns boolean
local integer this=f__arg_this
local integer newGameMode=f__arg_integer1
        if newGameMode != s__User_GameMode[this] then
            if s__User_GameMode[this] >= 0 then
                set s__User_PreviousGameMode[this]=s__User_GameMode[this]
            endif
            set s__User_GameMode[this]=newGameMode
			if newGameMode != Teams_GAMEMODE_DEAD and newGameMode != Teams_GAMEMODE_DYING then
				set s__User_IsAlive[this]=true
			endif
            if newGameMode == Teams_GAMEMODE_STANDARD or newGameMode == Teams_GAMEMODE_STANDARD_PAUSED or newGameMode == Teams_GAMEMODE_DYING then
                set s__User_ActiveUnit[this]=s__MazersArray[this]
				set s__User_ActiveUnitRadius[this]=GetUnitDefaultRadius(GetUnitTypeId(s__User_ActiveUnit[this]))
            elseif newGameMode == Teams_GAMEMODE_PLATFORMING or newGameMode == Teams_GAMEMODE_PLATFORMING_PAUSED then
                set s__User_ActiveUnit[this]=s__Platformer_Unit[s__User_Platformer[this]]
				set s__User_ActiveUnitRadius[this]=GetUnitDefaultRadius(GetUnitTypeId(s__User_ActiveUnit[this]))
            elseif newGameMode == Teams_GAMEMODE_DEAD then
                if RespawnASAPMode then
                    set s__User_ActiveUnit[this]=null
					set s__User_ActiveUnitRadius[this]=0.
                else
                    set s__User_ActiveUnit[this]=s__PlayerReviveCircles[this]
					set s__User_ActiveUnitRadius[this]=GetUnitDefaultRadius(GetUnitTypeId(s__User_ActiveUnit[this]))
                endif
			elseif newGameMode == Teams_GAMEMODE_HIDDEN then
				set s__User_ActiveUnit[this]=null
            endif
        endif
   return true
endfunction
function sa__User_IsActiveUnitInRect takes nothing returns boolean
    set f__result_boolean=s__User_IsActiveUnitInRect(f__arg_this,f__arg_rect1)
   return true
endfunction
function sa__User_ApplyAFKPlatformer takes nothing returns boolean
local integer this=f__arg_this
		set s__User_AFKPlatformerDeathClock[this]=User___AFK_PLATFORMER_DEATH_CLOCK_START
		call TimerStart(NewTimerEx(this), User___AFK_PLATFORMER_CLOCK, true, function s__User_ApplyAFKPlatformerCB)
   return true
endfunction
function sa__InWorldPowerup_IsPowerupUnit takes nothing returns boolean
local integer unitTypeID=f__arg_integer1
set f__result_boolean= unitTypeID == POWERUP_SOLO_INVULN or unitTypeID == POWERUP_TEAM_INVULN or unitTypeID == POWERUP_TEAM_ADDCONT or unitTypeID == POWERUP_TEAM_STEALCONT or unitTypeID == POWERUP_TEAM_ADDSCORE or unitTypeID == POWERUP_TEAM_STEALSCORE
   return true
endfunction
function sa__InWorldPowerup_create takes nothing returns boolean
local integer unitTypeID=f__arg_integer1
local real x=f__arg_real1
local real y=f__arg_real2
            local integer new
			if s__InWorldPowerup_IsPowerupUnit(unitTypeID) then
				set new=s__InWorldPowerup_allocate()
				set s__InWorldPowerup_TeamsUsed[new]=s__SimpleList_List_create()
				set s__InWorldPowerup_Unit[new]=CreateUnit(POWERUP_PLAYER, unitTypeID, x, y, 0)
				call s__IndexedUnit_create(s__InWorldPowerup_Unit[new])
				call UnitAddAbility(s__InWorldPowerup_Unit[new], 'Aloc')
				call ShowUnit(s__InWorldPowerup_Unit[new], false)
				call ShowUnit(s__InWorldPowerup_Unit[new], true)
				call SaveInteger(Table___ht, (s__InWorldPowerup_AllPowerups), (GetHandleId(s__InWorldPowerup_Unit[new])), ( new)) // INLINED!!
set f__result_integer= new
return true
			else
set f__result_integer= 0
return true
			endif
   return true
endfunction
function sa__VisualVote_voteMenu_applyPlayerVote takes nothing returns boolean
local integer this=f__arg_this
            local integer fp
            local integer iVC= 0
            local integer vc
            local integer iVCont
            local integer vCont
            if s__VisualVote_voteMenu_enabled[this] then
                set s__VisualVote_voteMenu_enabled[this]=false
                set fp=s__SimpleList_List_first[s__VisualVote_voteMenu_forPlayers[this]]
                loop
                exitwhen fp == 0
                    if GetLocalPlayer() == Player(s__SimpleList_ListNode_value[fp]) then
                        call TimerDialogDisplay(s__VisualVote_voteMenu_td[this], false)
                        call SetCameraBoundsToRect(bj_mapInitialCameraBounds)
                    endif
                set fp=s__SimpleList_ListNode_next[fp]
                endloop
                set iVC=0
                loop
                exitwhen iVC >= s__VisualVote_voteMenu_voteColumnCount[this]
                    set vc=(LoadInteger(Table___ht, (s__VisualVote_voteMenu_voteColumns[this]), (iVC))) // INLINED!!
                    set iVCont=0
                    loop
                    exitwhen iVCont > s__VisualVote_voteColumn_voteContainerCount[vc]
                        set vCont=(LoadInteger(Table___ht, (s__VisualVote_voteColumn_voteContainers[vc]), (iVCont))) // INLINED!!
                        call s__VisualVote_voteContainer_executeMajorityOption(vCont)
                    set iVCont=iVCont + 1
                    endloop
                set iVC=iVC + 1
                endloop
                set VisualVote_LastFinishedMenu=this
				if s__VisualVote_voteMenu_onOptionExecuteFinish[this] != null then
					call ExecuteFunc(s__VisualVote_voteMenu_onOptionExecuteFinish[this])
                endif
                call TimerStart(NewTimerEx(this), VisualVote_MENU_DESTROY_TIMEOUT, false, function s__VisualVote_voteMenu_destroyMenuCallback)
            endif
   return true
endfunction
function sa__VisualVote_voteMenu_checkPlayersFinishedVoting takes nothing returns boolean
local integer this=f__arg_this
            local integer iVC= 0
            if s__VisualVote_voteMenu_enabled[this] then
                loop
                exitwhen iVC >= s__VisualVote_voteMenu_voteColumnCount[this]
                    if not s__VisualVote_voteColumn_havePlayersFinishedVoting(((LoadInteger(Table___ht, (s__VisualVote_voteMenu_voteColumns[this]), (iVC)))),s__SimpleList_List_count[s__VisualVote_voteMenu_forPlayers[this]]) then // INLINED!!
set f__result_boolean= false
return true
                    endif
                set iVC=iVC + 1
                endloop
set f__result_boolean= true
return true
            endif
set f__result_boolean= false
   return true
endfunction
function sa__VisualVote_voteMenu_destroy takes nothing returns boolean
local integer this=f__arg_this
            local integer iVC= 0
            local integer vc
            call s__VisualVote_voteMenu_listRemove(this)
            loop
            exitwhen iVC >= s__VisualVote_voteMenu_voteColumnCount[this]
                set vc=(LoadInteger(Table___ht, (s__VisualVote_voteMenu_voteColumns[this]), (iVC))) // INLINED!!
                call s__VisualVote_voteColumn_destroy(vc)
            set iVC=iVC + 1
            endloop
            call DestroyTimerDialog(s__VisualVote_voteMenu_td[this])
            set s__VisualVote_voteMenu_td[this]=null
            call s__Table_destroy(s__VisualVote_voteMenu_voteColumns[this])
            call s__SimpleList_List_destroy(s__VisualVote_voteMenu_forPlayers[this])
            call s__vector2_deallocate((s__VisualVote_voteMenu_topLeft[this])) // INLINED!!
            call s__vector2_deallocate((s__VisualVote_voteMenu_botRight[this])) // INLINED!!
            call s__VisualVote_voteMenu_deallocate(this)
            if s__VisualVote_voteMenu_onDestroyFinish[this] != null then
                call ExecuteFunc(s__VisualVote_voteMenu_onDestroyFinish[this])
            endif
   return true
endfunction
function sa__VisualVote_voteContainer_clearVoteOptionsForPlayer takes nothing returns boolean
local integer this=f__arg_this
local integer pID=f__arg_integer1
            local integer iVO= 0
            local integer vo
            loop
            exitwhen iVO >= s__VisualVote_voteContainer_optionCount[this]
                set vo=(LoadInteger(Table___ht, (s__VisualVote_voteContainer_options[this]), (iVO))) // INLINED!!
                if (HaveSavedInteger(Table___ht, (s__VisualVote_voteOption_playerVotes[(vo)]), ((pID)))) then // INLINED!!
                    call s__VisualVote_voteOption_removePlayerVote(vo,pID)
return true
                endif
            set iVO=iVO + 1
            endloop
   return true
endfunction
function sa__RespawningGateway_Stop takes nothing returns boolean
local integer this=f__arg_this
		call s__SimpleList_List_remove(s__RespawningGateway_ActiveGateways,this)
		if s__SimpleList_List_count[s__RespawningGateway_ActiveGateways] == 0 then
			call PauseTimer(s__RespawningGateway_ActiveGatewayTimer)
		endif
   return true
endfunction
function sa__RespawningGateway_Start takes nothing returns boolean
local integer this=f__arg_this
		if s__SimpleList_List_count[s__RespawningGateway_ActiveGateways] == 0 then
			call TimerStart(s__RespawningGateway_ActiveGatewayTimer, RespawningGateway___ACTIVATION_CHECK_TIMESTEP, true, function s__RespawningGateway_CheckActiveGateways)
		endif
		call s__SimpleList_List_add(s__RespawningGateway_ActiveGateways,this)
		if s__RespawningGateway_RespawnTimeRemaining[this] > 0 then
			call s__RespawningGateway_UpdateTimeRemainingDisplay(this)
		endif
   return true
endfunction
function sa__Wheel_Rotate takes nothing returns boolean
local integer this=f__arg_this
            local integer wUnitNode= s__SimpleList_List_first[s__Wheel_Units[this]]
            local integer iLayer= 0
            local integer iSpoke= 0
            local real x
            local real y
            local real theta
            loop
            exitwhen wUnitNode == 0
                if iSpoke == s__Wheel_SpokeCount[this] then
                    set iSpoke=0
                    set iLayer=iLayer + 1
                    set theta=0
                endif
                if s__SimpleList_ListNode_value[wUnitNode] != 0 then
                    set theta=s__Wheel_CurrentAngle[this] + iSpoke * s__Wheel_AngleBetween[this]
                    set x=s__vector2_x[s__Wheel_Center[this]] + s__Wheel_InitialOffset[this] * Cos(theta) + iLayer * s__Wheel_DistanceBetween[this] * Cos(theta)
                    set y=s__vector2_y[s__Wheel_Center[this]] + s__Wheel_InitialOffset[this] * Sin(theta) + iLayer * s__Wheel_DistanceBetween[this] * Sin(theta)
                    call SetUnitPosition(s__IndexedUnit_Unit[(s__SimpleList_ListNode_value[wUnitNode])], x, y)
                endif
            set iSpoke=iSpoke + 1
            set wUnitNode=s__SimpleList_ListNode_next[wUnitNode]
            endloop
            set s__Wheel_CurrentAngle[this]=s__Wheel_CurrentAngle[this] + s__Wheel_RotationSpeed[this]
            if s__Wheel_CurrentAngle[this] >= 2 * bj_PI then
                set s__Wheel_CurrentAngle[this]=s__Wheel_CurrentAngle[this] - 2 * bj_PI
            endif
   return true
endfunction
function sa__Wheel_Stop takes nothing returns boolean
local integer this=f__arg_this
            call s__SimpleList_List_remove(s__Wheel_ActiveWheels,this)
            if s__SimpleList_List_count[s__Wheel_ActiveWheels] == 0 then
                call PauseTimer(s__Wheel_Timer)
            endif
   return true
endfunction
function sa__Wheel_Start takes nothing returns boolean
local integer this=f__arg_this
            if s__SimpleList_List_count[s__Wheel_ActiveWheels] == 0 then
                call TimerStart(s__Wheel_Timer, Wheel_TIMEOUT, true, function s__Wheel_Periodic)
            endif
			set s__Wheel_CurrentAngle[this]=s__Wheel_InitialAngle[this]
            call s__SimpleList_List_addEnd(s__Wheel_ActiveWheels,this)
   return true
endfunction
function sa__Wheel_create takes nothing returns boolean
local real x=f__arg_real1
local real y=f__arg_real2
            local integer new= s__Wheel__allocate()
            set s__Wheel_Center[new]=s__vector2_create(x , y)
            set s__Wheel_LayerCount[new]=1
            set s__Wheel_InitialOffset[new]=0
            set s__Wheel_RotationSpeed[new]=Wheel___DEFAULT_ROTATION_SPEED
			set s__Wheel_InitialAngle[new]=0
            set s__Wheel_CurrentAngle[new]=s__Wheel_InitialAngle[new]
            set s__Wheel_Units[new]=s__SimpleList_List_create()
set f__result_integer= new
   return true
endfunction
function sa__SynchronizedGroup_Stop takes nothing returns boolean
local integer this=f__arg_this
   local integer curUnit= s__SimpleList_List_first[s__SynchronizedGroup_AllUnits[this]]
			call s__SimpleList_List_remove(s__SynchronizedGroup_ActiveGroups,this)
			if s__SimpleList_List_count[s__SynchronizedGroup_ActiveGroups] == 0 then
				call PauseTimer(s__SynchronizedGroup_t)
			endif
			loop
			exitwhen curUnit == 0
				call s__SynchronizedUnit_Stop((s__SimpleList_ListNode_value[curUnit]))
			set curUnit=s__SimpleList_ListNode_next[curUnit]
			endloop
   return true
endfunction
function sa__SynchronizedGroup_Start takes nothing returns boolean
local integer this=f__arg_this
   local integer curUnit= s__SimpleList_List_first[s__SynchronizedGroup_AllUnits[this]]
			if s__SimpleList_List_count[s__SynchronizedGroup_ActiveGroups] == 0 then
				call TimerStart(s__SynchronizedGroup_t, SynchronizedGroup___TIMESTEP, true, function s__SynchronizedGroup_Periodic)
			endif
			call s__SimpleList_List_add(s__SynchronizedGroup_ActiveGroups,this)
			loop
			exitwhen curUnit == 0
				call s__SynchronizedUnit_Start((s__SimpleList_ListNode_value[curUnit]))
			set curUnit=s__SimpleList_ListNode_next[curUnit]
			endloop
   return true
endfunction
function sa__SimplePatrol_Start takes nothing returns boolean
local integer this=f__arg_this
			if s__SimpleList_List_count[s__SimplePatrol_ActivePatrols] == 0 then
				call TimerStart(s__SimplePatrol_DestinationTimer, SimplePatrol___DESTINATION_TIME_DELTA, true, function s__SimplePatrol_CheckDestinations)
			endif
			set s__SimplePatrol_Unit[this]=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((s__SimplePatrol_UnitID[this] )))),(( s__vector2_x[s__SimplePatrol_DestinationA[this]] )*1.0) , (( s__vector2_y[s__SimplePatrol_DestinationA[this]])*1.0))) // INLINED!!
			if s__SimplePatrol_MoveSpeed[this] != - 1 then
				call s__IndexedUnit_SetMoveSpeed((GetUnitUserData((s__SimplePatrol_Unit[this]))),s__SimplePatrol_MoveSpeed[this]) // INLINED!!
			endif
			set s__SimplePatrol_OnDestination[this]=s__SimplePatrol_DestinationB[this]
			set s__SimplePatrol_MoveAngle[this]=Atan2(s__vector2_y[s__SimplePatrol_OnDestination[this]] - GetUnitY(s__SimplePatrol_Unit[this]), s__vector2_x[s__SimplePatrol_OnDestination[this]] - GetUnitX(s__SimplePatrol_Unit[this]))
			call s__SimpleList_List_add(s__SimplePatrol_ActivePatrols,this)
   return true
endfunction
function sa__SimplePatrol_Stop takes nothing returns boolean
local integer this=f__arg_this
			call Recycle_ReleaseUnit(s__SimplePatrol_Unit[this])
			set s__SimplePatrol_Unit[this]=null
			call s__SimpleList_List_remove(s__SimplePatrol_ActivePatrols,this)
			if s__SimpleList_List_count[s__SimplePatrol_ActivePatrols] == 0 then
				call PauseTimer(s__SimplePatrol_DestinationTimer)
			endif
   return true
endfunction
function sa__SimpleGenerator_PeriodicSpawn takes nothing returns boolean

        local integer generator= (LoadInteger(TimerUtils___ht, 0, GetHandleId((GetExpiredTimer())))) // INLINED!!
  local group spawnGroup= s__PatternSpawn_Spawn(s__LinePatternSpawn_PatternSpawn[s__SimpleGenerator_SpawnPattern[generator]],s__IStartable_ParentLevel[generator])
  local unit u
		loop
		set u=FirstOfGroup(spawnGroup)
		exitwhen u == null
			if IsUnitAnimated(GetUnitTypeId(u)) then
				call SetUnitFacingTimed(u, s__SimpleGenerator_SpawnDirection[generator], 0)
				call SetUnitAnimationByIndex(u, GetWalkAnimationIndex(GetUnitTypeId(u)))
				if s__SimpleGenerator_SpawnMoveSpeed[generator] == 0 then
					call SetUnitTimeScale(u, s__IndexedUnit_GetMoveSpeed((GetUnitUserData(u))) / GetUnitDefaultMoveSpeed(u))
				else
					call SetUnitTimeScale(u, s__SimpleGenerator_SpawnMoveSpeed[generator] / SimpleGenerator___MOVEMENT_UPDATE_TIMESTEP / GetUnitDefaultMoveSpeed(u))
				endif
			endif
		call GroupAddUnit(s__SimpleGenerator_SpawnedUnits[generator], u)
		call GroupRemoveUnit(spawnGroup, u)
		endloop
		call ReleaseGroup(spawnGroup)
   return true
endfunction
function sa__SimpleGenerator_Start takes nothing returns boolean
local integer this=f__arg_this
        if s__SimpleList_List_count[s__SimpleGenerator_ActiveWidgets] == 0 then
            call TimerStart(s__SimpleGenerator_MoveTimer, SimpleGenerator___MOVEMENT_UPDATE_TIMESTEP, true, function s__SimpleGenerator_PeriodicMove)
        endif
        call s__SimpleList_List_addEnd(s__SimpleGenerator_ActiveWidgets,this)
        set s__SimpleGenerator_SpawnTimer[this]=NewTimerEx(this)
        set s__SimpleGenerator_SpawnedUnits[this]=NewGroup()
		if s__SimpleGenerator_SpawnPattern[this] != 0 then
			call s__PatternSpawn_Reset(s__LinePatternSpawn_PatternSpawn[s__SimpleGenerator_SpawnPattern[this]])
		endif
        call TimerStart(s__SimpleGenerator_SpawnTimer[this], s__SimpleGenerator_SpawnTimeStep[this] / s__SimpleGenerator_OverclockFactor[this], true, function s__SimpleGenerator_PeriodicSpawn)
   return true
endfunction
function sa__SimpleGenerator_Stop takes nothing returns boolean
local integer this=f__arg_this
        call s__SimpleList_List_remove(s__SimpleGenerator_ActiveWidgets,this)
        call ReleaseTimer(s__SimpleGenerator_SpawnTimer[this])
        set s__SimpleGenerator_SpawnTimer[this]=null
		call ReleaseGroup(s__SimpleGenerator_SpawnedUnits[this])
		set s__SimpleGenerator_SpawnedUnits[this]=null
		set s__SimpleGenerator_OverclockFactor[this]=1.
        if s__SimpleList_List_count[s__SimpleGenerator_ActiveWidgets] == 0 then
            call PauseTimer(s__SimpleGenerator_MoveTimer)
        endif
   return true
endfunction
function sa__SimpleGenerator_destroy takes nothing returns boolean
local integer this=f__arg_this
        if s__SimpleList_List_contains(s__SimpleGenerator_ActiveWidgets,this) then
			call s__SimpleGenerator_Stop(this)
		endif
		if s__SimpleGenerator_SpawnPattern[this] != 0 then
		endif
   return true
endfunction
function sa__RelayGenerator_GetNumberLanes takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= R2I(s__RelayGenerator_Diameter[this] * TERRAIN_TILE_SIZE / s__RelayGenerator_UnitLaneSize[this]) - RelayGenerator___UNIT_SIDE_BUFFER * 2
   return true
endfunction
function sa__RelayGenerator_GetRadius takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= R2I(s__RelayGenerator_Diameter[this] / 2.)
   return true
endfunction
function sa__RelayGenerator_Start takes nothing returns boolean
local integer this=f__arg_this
            if not s__SimpleList_List_contains(s__RelayGenerator_ActiveRelays,this) then
                call s__SimpleList_List_add(s__RelayGenerator_ActiveRelays,this)
				set s__RelayGenerator_Units[this]=NewGroup()
				call s__PatternSpawn_Reset(s__RelayPatternSpawn_Pattern[s__RelayGenerator_SpawnPattern[this]])
                set s__RelayGenerator_UnitTimer[this]=NewTimerEx(this)
                call TimerStart(s__RelayGenerator_UnitTimer[this], s__RelayGenerator_UnitTimeout[this] / s__RelayGenerator_OverclockFactor[this], true, function s__RelayGenerator_CreateUnitCB)
                if s__SimpleList_List_count[s__RelayGenerator_ActiveRelays] == 1 then
                    call TimerStart(s__RelayGenerator_MovementTimer, RelayGenerator___RELAY_MOVEMENT_TIMESTEP, true, function s__RelayGenerator_UpdateRelays)
                endif
            endif
   return true
endfunction
function sa__RelayGenerator_Stop takes nothing returns boolean
local integer this=f__arg_this
            local unit u
			if s__SimpleList_List_contains(s__RelayGenerator_ActiveRelays,this) then
                call s__SimpleList_List_remove(s__RelayGenerator_ActiveRelays,this)
				loop
				set u=FirstOfGroup(s__RelayGenerator_Units[this])
				exitwhen u == null
					call s__RelayGenerator_ReleaseUnit(this,u)
				endloop
				call ReleaseGroup(s__RelayGenerator_Units[this])
                call ReleaseTimer(s__RelayGenerator_UnitTimer[this])
                if s__SimpleList_List_count[s__RelayGenerator_ActiveRelays] == 0 then
                    call PauseTimer(s__RelayGenerator_MovementTimer)
                endif
            endif
   return true
endfunction
function sa__DrunkWalker_DrunkWalkerSpawn_Stop takes nothing returns boolean
local integer this=f__arg_this
			loop
			exitwhen s__SimpleList_List_first[s__DrunkWalker_DrunkWalkerSpawn_Drunks[this]] == 0
				call s__DrunkWalker_DrunkWalker_destroy((s__SimpleList_ListNode_value[s__SimpleList_List_first[s__DrunkWalker_DrunkWalkerSpawn_Drunks[this]]]))
			endloop
			call ReleaseTimer(s__DrunkWalker_DrunkWalkerSpawn_t[this])
			set s__DrunkWalker_DrunkWalkerSpawn_t[this]=null
   return true
endfunction
function sa__DrunkWalker_DrunkWalkerSpawn_Start takes nothing returns boolean
local integer this=f__arg_this
			set s__DrunkWalker_DrunkWalkerSpawn_t[this]=NewTimerEx(this)
			call TimerStart(s__DrunkWalker_DrunkWalkerSpawn_t[this], s__DrunkWalker_DrunkWalkerSpawn_SpawnTimeout[this], true, function s__DrunkWalker_DrunkWalkerSpawn_periodic)
   return true
endfunction
function sa__DrunkWalker_DrunkWalker_drinkEffect takes nothing returns boolean

            local timer t= GetExpiredTimer()
            local integer dw= ((LoadInteger(TimerUtils___ht, 0, GetHandleId((t))))) // INLINED!!
   local real timeoutRand
            if s__DrunkWalker_DrunkWalker_TimeAlive[dw] < s__DrunkWalker_DrunkWalkerSpawn_WalkerLife[s__DrunkWalker_DrunkWalker_Parent[dw]] then
                set s__DrunkWalker_DrunkWalker_beer[dw]=AddSpecialEffect("Abilities\\Spells\\Other\\StrongDrink\\BrewmasterMissile.mdl", GetUnitX(s__DrunkWalker_DrunkWalker_Walker[dw]), GetUnitY(s__DrunkWalker_DrunkWalker_Walker[dw]))
				call BlzSetSpecialEffectScale(s__DrunkWalker_DrunkWalker_beer[dw], DrunkWalker___STATIC_BEER_VFX_SCALE)
				call BlzSetSpecialEffectHeight(s__DrunkWalker_DrunkWalker_beer[dw], DrunkWalker___STATIC_BEER_VFX_HEIGHT)
                set timeoutRand=GetRandomReal(1, 3)
				set s__DrunkWalker_DrunkWalker_TimeAlive[dw]=s__DrunkWalker_DrunkWalker_TimeAlive[dw] + timeoutRand
                if s__DrunkWalker_DrunkWalker_TimeAlive[dw] / s__DrunkWalker_DrunkWalkerSpawn_WalkerLife[s__DrunkWalker_DrunkWalker_Parent[dw]] >= DrunkWalker___PCT_BEFORE_ANGRY and GetRandomInt(0, 1) == 1 then
					call CreateTimedSpecialEffectTarget("Abilities\\Spells\\Orc\\AncestralSpirit\\AncestralSpiritCaster.mdl" , s__DrunkWalker_DrunkWalker_Walker[dw] , SpecialEffect_ORIGIN , null , timeoutRand - .05)
					call SetUnitVertexColor(s__DrunkWalker_DrunkWalker_Walker[dw], 255, 0, 0, 255)
                    call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(s__DrunkWalker_DrunkWalker_Walker[dw])),GetDefaultMoveSpeed(s__DrunkWalker_DrunkWalkerSpawn_uID[s__DrunkWalker_DrunkWalker_Parent[dw]]) * 1.5)
                endif
                call TimerStart(t, timeoutRand, false, function s__DrunkWalker_DrunkWalker_move)
                set t=null
            else
                call sc__DrunkWalker_DrunkWalker_destroy(dw)
            endif
   return true
endfunction
function sa__DrunkWalker_DrunkWalker_destroy takes nothing returns boolean
local integer this=f__arg_this
			if s__DrunkWalker_DrunkWalker_beer[this] != null then
				call DestroyEffect(s__DrunkWalker_DrunkWalker_beer[this])
				set s__DrunkWalker_DrunkWalker_beer[this]=null
			endif
			call SetUnitVertexColor(s__DrunkWalker_DrunkWalker_Walker[this], 255, 255, 255, 255)
			call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(s__DrunkWalker_DrunkWalker_Walker[this])),GetDefaultMoveSpeed(s__DrunkWalker_DrunkWalkerSpawn_uID[s__DrunkWalker_DrunkWalker_Parent[this]]))
			call Recycle_ReleaseUnit(s__DrunkWalker_DrunkWalker_Walker[this])
			set s__DrunkWalker_DrunkWalker_Walker[this]=null
			call ReleaseTimer(s__DrunkWalker_DrunkWalker_t[this])
			set s__DrunkWalker_DrunkWalker_t[this]=null
			call s__SimpleList_List_remove(s__DrunkWalker_DrunkWalkerSpawn_Drunks[s__DrunkWalker_DrunkWalker_Parent[this]],this)
			call s__DrunkWalker_DrunkWalker_deallocate(this)
   return true
endfunction
function sa__Deferred_Remove takes nothing returns boolean
local integer this=f__arg_this
local integer awaiter=f__arg_integer1
			call s__SimpleList_List_remove(s__Deferred_Waiting[this],awaiter)
			call s__DeferredAwaiter_destroy(awaiter)
   return true
endfunction
function sa__Deferred_create takes nothing returns boolean

   local integer new= s__Deferred_allocate()
			set s__Deferred_Resolved[new]=false
			set s__Deferred_Cancel[new]=0
			set s__Deferred_Result[new]=0
			set s__Deferred_Waiting[new]=s__SimpleList_List_create()
set f__result_integer= new
   return true
endfunction
function sa__Deferred_destroy takes nothing returns boolean
local integer this=f__arg_this
   local integer curAwaiterNode
   local integer awaiterResult
			loop
			set curAwaiterNode=s__SimpleList_List_pop(s__Deferred_Waiting[this])
			exitwhen curAwaiterNode == 0
				if not s__Deferred_Resolved[this] and s__Deferred_Cancel[this] != 0 then
					call sc___prototype54_evaluate(s__Deferred_Cancel[this],s__Deferred_Result[this] , s__DeferredAwaiter_CallbackData[(s__SimpleList_ListNode_value[curAwaiterNode])])
				endif
				call s__DeferredAwaiter_destroy((s__SimpleList_ListNode_value[curAwaiterNode]))
				call s__SimpleList_ListNode_deallocate(curAwaiterNode)
			endloop
			call s__SimpleList_List_destroy(s__Deferred_Waiting[this])
			call s__Deferred_deallocate(this)
   return true
endfunction
function sa__CinemaCallbackModel_destroy takes nothing returns boolean
local integer this=f__arg_this
		call ReleaseTimer(s__CinemaCallbackModel_Timer[this])
		set s__CinemaCallbackModel_Timer[this]=null
		call s__CinemaCallbackModel_deallocate(this)
   return true
endfunction
function sa__BoundedWheel_Rotate takes nothing returns boolean
local integer this=f__arg_this
            local integer wUnitNode= s__SimpleList_List_first[s__Wheel_Units[this]]
            local integer iLayer= 0
            local integer iSpoke= 0
            local real x
            local real y
            local real theta= s__Wheel_CurrentAngle[this] + s__Wheel_RotationSpeed[this]
            if theta >= s__BoundedWheel_MaxAngle[this] then
                set s__Wheel_CurrentAngle[this]=s__BoundedWheel_MaxAngle[this]
                set s__Wheel_RotationSpeed[this]=- s__Wheel_RotationSpeed[this]
            elseif theta <= s__BoundedWheel_MinAngle[this] then
                set s__Wheel_CurrentAngle[this]=s__BoundedWheel_MinAngle[this]
                set s__Wheel_RotationSpeed[this]=- s__Wheel_RotationSpeed[this]
            endif
            loop
            exitwhen wUnitNode == 0
                if iSpoke == s__Wheel_SpokeCount[this] then
                    set iSpoke=0
                    set iLayer=iLayer + 1
                endif
                if s__SimpleList_ListNode_value[wUnitNode] != 0 then
                    set theta=s__Wheel_CurrentAngle[this] + iSpoke * s__Wheel_AngleBetween[this]
                    set x=s__vector2_x[s__Wheel_Center[this]] + s__Wheel_InitialOffset[this] * Cos(theta) + iLayer * s__Wheel_DistanceBetween[this] * Cos(theta)
                    set y=s__vector2_y[s__Wheel_Center[this]] + s__Wheel_InitialOffset[this] * Sin(theta) + iLayer * s__Wheel_DistanceBetween[this] * Sin(theta)
                    call SetUnitPosition(s__IndexedUnit_Unit[(s__SimpleList_ListNode_value[wUnitNode])], x, y)
                endif
            set iSpoke=iSpoke + 1
            set wUnitNode=s__SimpleList_ListNode_next[wUnitNode]
            endloop
            set s__Wheel_CurrentAngle[this]=s__Wheel_CurrentAngle[this] + s__Wheel_RotationSpeed[this]
            if s__Wheel_CurrentAngle[this] >= 2 * bj_PI then
                set s__Wheel_CurrentAngle[this]=s__Wheel_CurrentAngle[this] - 2 * bj_PI
            endif
   return true
endfunction
function sa__BoundedSpoke_Stop takes nothing returns boolean
local integer this=f__arg_this
            call s__SimpleList_List_remove(s__BoundedSpoke_ActiveSpokes,this)
            if s__SimpleList_List_count[s__BoundedSpoke_ActiveSpokes] == 0 then
                call PauseTimer(s__BoundedSpoke_Timer)
            endif
   return true
endfunction
function sa__BoundedSpoke_Start takes nothing returns boolean
local integer this=f__arg_this
            if s__SimpleList_List_count[s__BoundedSpoke_ActiveSpokes] == 0 then
                call TimerStart(s__BoundedSpoke_Timer, BoundedSpoke_TIMESTEP, true, function s__BoundedSpoke_Periodic)
            endif
            call s__SimpleList_List_addEnd(s__BoundedSpoke_ActiveSpokes,this)
   return true
endfunction
function sa__SimpleList_List_add takes nothing returns boolean
local integer this=f__arg_this
local integer value=f__arg_integer1
            local integer curHead= s__SimpleList_List_first[this]
            set s__SimpleList_List_first[this]=s__SimpleList_ListNode_allocate()
            set s__SimpleList_ListNode_value[s__SimpleList_List_first[this]]=value
            set s__SimpleList_ListNode_prev[s__SimpleList_List_first[this]]=0
            set s__SimpleList_ListNode_next[s__SimpleList_List_first[this]]=curHead
            if curHead != 0 then
                set s__SimpleList_ListNode_prev[curHead]=s__SimpleList_List_first[this]
            else
                set s__SimpleList_List_last[this]=s__SimpleList_List_first[this]
            endif
            set s__SimpleList_List_count[this]=s__SimpleList_List_count[this] + 1
   return true
endfunction
function sa__SimpleList_List_remove takes nothing returns boolean
local integer this=f__arg_this
local integer value=f__arg_integer1
            local integer cur= s__SimpleList_List_first[this]
            loop
            exitwhen cur == 0
                if s__SimpleList_ListNode_value[cur] == value then
                    if s__SimpleList_ListNode_next[cur] != 0 then
                        set s__SimpleList_ListNode_prev[s__SimpleList_ListNode_next[cur]]=s__SimpleList_ListNode_prev[cur]
                    else
                        set s__SimpleList_List_last[this]=s__SimpleList_ListNode_prev[cur]
                    endif
                    if s__SimpleList_ListNode_prev[cur] != 0 then
                        set s__SimpleList_ListNode_next[s__SimpleList_ListNode_prev[cur]]=s__SimpleList_ListNode_next[cur]
                    else
                        set s__SimpleList_List_first[this]=s__SimpleList_ListNode_next[cur]
                    endif
                    call s__SimpleList_ListNode_deallocate(cur)
                    set s__SimpleList_List_count[this]=s__SimpleList_List_count[this] - 1
return true
                endif
            set cur=s__SimpleList_ListNode_next[cur]
            endloop
   return true
endfunction
function sa__SimpleList_List_create takes nothing returns boolean

            local integer new= s__SimpleList_List_allocate()
            set s__SimpleList_List_count[new]=0
            set s__SimpleList_List_first[new]=0
            set s__SimpleList_List_last[new]=0
set f__result_integer= new
   return true
endfunction
function sa__Recycle_UnitRecycler_MakeWithFacing takes nothing returns boolean
local integer this=f__arg_this
local real x=f__arg_real1
local real y=f__arg_real2
local real angle=f__arg_real3
   local unit u
			if s__Recycle_UnitRecycler_count[this] == 0 then
				call s__Recycle_UnitRecycler_Preload(this,Recycle_BUFFER_UNIT_COUNT)
			endif
			set u=FirstOfGroup(s__Recycle_UnitRecycler_uStack[this])
			call GroupRemoveUnit(s__Recycle_UnitRecycler_uStack[this], u)
			set s__Recycle_UnitRecycler_count[this]=s__Recycle_UnitRecycler_count[this] - 1
				call ShowUnit(u, true)
				call SetUnitPosition(u, x, y)
				call SetUnitX(u, x)
				call SetUnitY(u, y)
			call SetUnitFacing(u, angle)
set f__result_unit= u
   return true
endfunction
function sa__Recycle_UnitRecycler_Make takes nothing returns boolean
local integer this=f__arg_this
local real x=f__arg_real1
local real y=f__arg_real2
            local unit u
			if s__Recycle_UnitRecycler_count[this] == 0 then //either no recycler for unit type or no units in stack
                call s__Recycle_UnitRecycler_Preload(this,Recycle_BUFFER_UNIT_COUNT)
			endif
			set u=FirstOfGroup(s__Recycle_UnitRecycler_uStack[this])
			call GroupRemoveUnit(s__Recycle_UnitRecycler_uStack[this], u)
			set s__Recycle_UnitRecycler_count[this]=s__Recycle_UnitRecycler_count[this] - 1
				call ShowUnit(u, true)
				call SetUnitPosition(u, x, y)
				call SetUnitX(u, x)
				call SetUnitY(u, y)
set f__result_unit= u
   return true
endfunction
function sa__Recycle_UnitRecycler_Release takes nothing returns boolean
    call s__Recycle_UnitRecycler_Release(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__Recycle_UnitRecycler_GetRecycler takes nothing returns boolean
local integer unitTypeID=f__arg_integer1
set f__result_integer= LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, unitTypeID)
   return true
endfunction
function sa__MortarNTarget_Start takes nothing returns boolean
local integer this=f__arg_this
        call PauseUnit(s__MortarNTarget_Mortar[this], false)
		if s__MortarNTarget_count == 0 then
            call TimerStart(MnT___MnTTimer, MnT___MnTTimeStep, true, function s__MortarNTarget_MnTPeriodic)
        endif
        call s__MortarNTarget_listAdd(this)
   return true
endfunction
function sa__MortarNTarget_Stop takes nothing returns boolean
local integer this=f__arg_this
        call IssueImmediateOrder(s__MortarNTarget_Mortar[this], "stop")
        call PauseUnit(s__MortarNTarget_Mortar[this], true)
		call s__MortarNTarget_listRemove(this)
        if s__MortarNTarget_count == 0 then
            call PauseTimer(MnT___MnTTimer)
        endif
   return true
endfunction
function sa__MortarNTarget_onDestroy takes nothing returns boolean
local integer this=f__arg_this
        call RemoveUnit(s__MortarNTarget_Mortar[this])
        call RemoveUnit(s__MortarNTarget_Target[this])
        call s__MortarNTarget_listRemove(this)
        if s__MortarNTarget_count == 0 then
            call PauseTimer(MnT___MnTTimer)
        endif
        set s__MortarNTarget_Mortar[this]=null
        set s__MortarNTarget_Target[this]=null
    set f__arg_this=this
   return true
endfunction
function sa__Stack_onDestroy takes nothing returns boolean
local integer this=f__arg_this
            local integer n
            loop
                set n=s__Stack_top[this]
                exitwhen n == 0
                set s__Stack_top[this]=s__Stack_next[n]
                set s__Stack_next[n]=s__Stack_free
                set s__Stack_free=n
            endloop
   return true
endfunction
function sa__FastLoad_Start takes nothing returns boolean
local integer this=f__arg_this
			if not s__SimpleList_List_contains(s__FastLoad_ActiveLoaders,this) then
				if s__FastLoad_LoadState[this] == FastLoad___UNLOADED then
					set s__FastLoad_LoadState[this]=FastLoad___LOADING
					call s__FastLoad_BroadcastOverclockFactor(this,s__FastLoad_OverclockFactor[this])
					set s__FastLoad_OverclockTimer[this]=NewTimerEx(this)
					call TimerStart(s__FastLoad_OverclockTimer[this], s__FastLoad_FastLoadTime[this], false, function s__FastLoad_OverclockLoadCB)
				endif
				call s__SimpleList_List_add(s__FastLoad_ActiveLoaders,this)
            endif
   return true
endfunction
function sa__FastLoad_Stop takes nothing returns boolean
local integer this=f__arg_this
			if s__SimpleList_List_contains(s__FastLoad_ActiveLoaders,this) then
				set s__FastLoad_LoadState[this]=FastLoad___UNLOADED
                call s__SimpleList_List_remove(s__FastLoad_ActiveLoaders,this)
            endif
   return true
endfunction
function sa__IceSkater_Start takes nothing returns boolean
local integer this=f__arg_this
			if not s__SimpleList_List_contains(s__IceSkater_ActiveSkaters,this) then
				call s__IceSkater_SetDefaults(this)
				call ShowUnit(s__IceSkater_SkateUnit[this], true)
				call s__SimpleList_List_add(s__IceSkater_ActiveSkaters,this)
				call IceMovement_Add(s__IceSkater_SkateUnit[this])
				if s__SimpleList_List_count[s__IceSkater_ActiveSkaters] == 1 then
                    call TimerStart(IceSkater___t, IceSkater___TIMESTEP, true, function s__IceSkater_UpdateSkaters)
                    call DisplayTextToForce(bj_FORCE_PLAYER[0], "Started NPC skater timer")
                endif
			endif
   return true
endfunction
function sa__IceSkater_Stop takes nothing returns boolean
local integer this=f__arg_this
			if s__SimpleList_List_contains(s__IceSkater_ActiveSkaters,this) then
				call s__SimpleList_List_remove(s__IceSkater_ActiveSkaters,this)
				call IceMovement_Remove(s__IceSkater_SkateUnit[this])
				call ShowUnit(s__IceSkater_SkateUnit[this], false)
				if s__SimpleList_List_count[s__IceSkater_ActiveSkaters] == 0 then
                    call PauseTimer(IceSkater___t)
                    call DisplayTextToForce(bj_FORCE_PLAYER[0], "Paused NPC skater timer")
                endif
			endif
   return true
endfunction
function sa__IceSkater_destroy takes nothing returns boolean
local integer this=f__arg_this
   local integer curDestination= s__SimpleList_List_first[s__IceSkater_Destinations[this]]
			call s__IceSkater_Stop(this)
			loop
			exitwhen curDestination == 0
				call s__IceSkater___Destination_destroy((s__SimpleList_ListNode_value[curDestination]))
			set curDestination=s__SimpleList_ListNode_next[curDestination]
			endloop
			call s__SimpleList_List_destroy(s__IceSkater_Destinations[this])
			set s__IceSkater_CurrentDestination[this]=0
			call RemoveUnit(s__IceSkater_SkateUnit[this])
			set s__IceSkater_SkateUnit[this]=null
   return true
endfunction
function sa__Blackhole_WatchPlayer takes nothing returns boolean
local integer this=f__arg_this
local integer pID=f__arg_integer1
            if not s__SimpleList_List_contains(s__Blackhole_PlayersInRange[this],pID) then
                call s__SimpleList_List_add(s__Blackhole_PlayersInRange[this],pID)
            endif
   return true
endfunction
function sa__Blackhole_Start takes nothing returns boolean
local integer this=f__arg_this
            if s__SimpleList_List_count[s__Blackhole_ActiveBlackholes] == 0 then
                set Blackhole___PullTimer=(NewTimerEx(0)) // INLINED!!
				call TimerStart(Blackhole___PullTimer, Blackhole___PULL_TIMESTEP, true, function s__Blackhole_PullNearbyUnits)
				set Blackhole___CheckTimer=(NewTimerEx(0)) // INLINED!!
				call TimerStart(Blackhole___CheckTimer, Blackhole___CHECK_TIMESTEP, true, function s__Blackhole_CheckUsers)
            endif
            call s__SimpleList_List_add(s__Blackhole_ActiveBlackholes,this)
   return true
endfunction
function sa__Blackhole_Stop takes nothing returns boolean
local integer this=f__arg_this
            call IssueImmediateOrder(s__Blackhole_BlackholeUnit[this], "stop")
            call s__SimpleList_List_clear(s__Blackhole_PlayersInRange[this])
            call s__SimpleList_List_remove(s__Blackhole_ActiveBlackholes,this)
			if s__SimpleList_List_count[s__Blackhole_ActiveBlackholes] == 0 then
				call ReleaseTimer(Blackhole___PullTimer)
				call ReleaseTimer(Blackhole___CheckTimer)
			endif
   return true
endfunction
function sa__Blackhole_destroy takes nothing returns boolean
local integer this=f__arg_this
			if s__SimpleList_List_contains(s__Blackhole_ActiveBlackholes,this) then
				call s__Blackhole_Stop(this)
			endif
            call s__SimpleList_List_destroy(s__Blackhole_PlayersInRange[this])
            set s__Blackhole_BlackholeUnit[this]=null
			call sc__IStartable_deallocate(this)
   return true
endfunction
function sa__Blackhole_create takes nothing returns boolean
local real x=f__arg_real1
local real y=f__arg_real2
local boolean persist=f__arg_boolean1
            local integer new= s__Blackhole__allocate()
			if persist then
				set s__Blackhole_BlackholeUnit[new]=CreateUnit(BLACKHOLE_PLAYER, BLACKHOLE, x, y, 0)
			else
				set s__Blackhole_BlackholeUnit[new]=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((BLACKHOLE )))),(( x )*1.0) , (( y)*1.0))) // INLINED!!
			endif
            call AddUnitLocust(s__Blackhole_BlackholeUnit[new])
            set s__Blackhole_PlayersInRange[new]=s__SimpleList_List_create()
set f__result_integer= new
   return true
endfunction
function sa__CollectibleSet_Start takes nothing returns boolean
local integer this=f__arg_this
			if s__SimpleList_List_count[s__CollectibleSet_ActiveCollectibles] == 0 then
				set s__CollectibleSet_Timer=(NewTimerEx(0)) // INLINED!!
				call TimerStart(s__CollectibleSet_Timer, Collectible___COLLECTIBLE_COLLISION_TIMEOUT, true, function s__CollectibleSet_CheckActiveCollectibles)
			endif
			call s__SimpleList_List_addEnd(s__CollectibleSet_ActiveCollectibles,this)
   return true
endfunction
function sa__CollectibleSet_Stop takes nothing returns boolean
local integer this=f__arg_this
			call s__SimpleList_List_remove(s__CollectibleSet_ActiveCollectibles,this)
			if s__SimpleList_List_count[s__CollectibleSet_ActiveCollectibles] == 0 then
				call ReleaseTimer(s__CollectibleSet_Timer)
				set s__CollectibleSet_Timer=null
			endif
   return true
endfunction
function sa___prototype8_TimerUtils___init takes nothing returns boolean

     local integer i=0
     local integer o=- 1
     local boolean oops= false
        if ( TimerUtils___didinit ) then
    return true
        else
            set TimerUtils___didinit=true
        endif
            set TimerUtils___ht=InitHashtable()
            loop
                exitwhen ( i == TimerUtils___QUANTITY )
                set s__TimerUtils___tT[i]= CreateTimer()
                call SaveInteger(TimerUtils___ht, 0, GetHandleId((s__TimerUtils___tT[i] )), ( TimerUtils___HELD)) // INLINED!!
                set i=i + 1
            endloop
            set TimerUtils___tN=TimerUtils___QUANTITY
    return true
endfunction
function sa___prototype29_OriginSpawn takes nothing returns boolean
 local integer spawn=f__arg_integer1
 local integer parentLevel=f__arg_integer2

  local group g= NewGroup()
		call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((s__PatternSpawn_Data[spawn] )))),(( s__vector2_x[s__LinePatternSpawn_SpawnOrigin[(spawn)]] )*1.0) , (( s__vector2_y[s__LinePatternSpawn_SpawnOrigin[(spawn)]])*1.0)))) // INLINED!!
    set f__result_group= g
    return true
endfunction
function sa___prototype29_RandomLineSlotSpawn takes nothing returns boolean
 local integer spawn=f__arg_integer1
 local integer parentLevel=f__arg_integer2

  local group g= NewGroup()
  local integer spawnPosition= s__LinePatternSpawn_GetSpawnPosition((spawn),GetRandomInt(0, s__LinePatternSpawn_GetSpawnPositionCount((spawn)) - 1))
		call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((s__PatternSpawn_Data[spawn] )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
		call s__vector2_deallocate(spawnPosition)
    set f__result_group= g
    return true
endfunction
function sa___prototype29_IntroPatternSpawn takes nothing returns boolean
 local integer spawn=f__arg_integer1
 local integer parentLevel=f__arg_integer2

  local group g= NewGroup()
		call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((LGUARD )))),(( s__vector2_x[s__LinePatternSpawn_SpawnOrigin[(spawn)]] + GetRandomReal(0, s__LinePatternSpawn_SpawnLineLength[(spawn)]) )*1.0) , (( s__vector2_y[s__LinePatternSpawn_SpawnOrigin[(spawn)]])*1.0)))) // INLINED!!
    set f__result_group= g
    return true
endfunction
function sa___prototype29_IW2PatternSpawn takes nothing returns boolean
 local integer spawn=f__arg_integer1
 local integer parentLevel=f__arg_integer2

  local group g= NewGroup()
  local unit u= (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((LGUARD )))),(( s__vector2_x[s__LinePatternSpawn_SpawnOrigin[(spawn)]] )*1.0) , (( s__vector2_y[s__LinePatternSpawn_SpawnOrigin[(spawn)]] + GetRandomReal(0, s__LinePatternSpawn_SpawnLineLength[(spawn)]))*1.0))) // INLINED!!
		call SetUnitMoveSpeed(u, 200.)
		call GroupAddUnit(g, u)
		if RewardMode == GameModesGlobals_HARD then
			if GetRandomInt(0, 1) == 0 then
				set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[s__LinePatternSpawn_SpawnOrigin[(spawn)]] )*1.0) , (( s__vector2_y[s__LinePatternSpawn_SpawnOrigin[(spawn)]] + GetRandomReal(0, s__LinePatternSpawn_SpawnLineLength[(spawn)]))*1.0))) // INLINED!!
				call SetUnitMoveSpeed(u, 300.)
				call GroupAddUnit(g, u)
			endif
		endif
    set f__result_group= g
    return true
endfunction
function sa___prototype29_LW1PatternSpawn1 takes nothing returns boolean
 local integer spawn=f__arg_integer1
 local integer parentLevel=f__arg_integer2

  local group g= NewGroup()
  local integer spawnPosition
		if s__PatternSpawn_CurrentCycle[s__LinePatternSpawn_PatternSpawn[spawn]] < 2 then
			set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),s__PatternSpawn_CurrentCycle[s__LinePatternSpawn_PatternSpawn[spawn]])
		else
			set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),2 - ( s__PatternSpawn_CurrentCycle[s__LinePatternSpawn_PatternSpawn[spawn]] - 2 ))
		endif
		call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((s__PatternSpawn_Data[s__LinePatternSpawn_PatternSpawn[spawn]] )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
		call s__vector2_deallocate(spawnPosition)
    set f__result_group= g
    return true
endfunction
function sa___prototype29_W3APatternSpawn takes nothing returns boolean
 local integer spawn=f__arg_integer1
 local integer parentLevel=f__arg_integer2

  local group g= NewGroup()
  local integer variation= s__PatternSpawn_GetVariation(spawn)
  local integer cycle= s__PatternSpawn_GetCycle(spawn,variation)
  local integer spawnPositionLastIndex= s__LinePatternSpawn_GetSpawnPositionCount((spawn)) - 1
  local integer spawnPosition
  local integer rand
  local integer i
  local integer bhole
		if variation == 0 then
			if cycle == 0 then
		set i=0
		loop
		exitwhen i > spawnPositionLastIndex
			if i != 2 then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),i)
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
			endif
		set i=i + 1
		endloop
			elseif cycle == 1 then
		set i=0
		loop
		exitwhen i > spawnPositionLastIndex
			if i != 1 then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),i)
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
			endif
		set i=i + 1
		endloop
			elseif cycle == 2 then
		set i=0
		loop
		exitwhen i > spawnPositionLastIndex
			if i != 0 then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),i)
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
			endif
		set i=i + 1
		endloop
			endif
		elseif variation == 1 then
			if cycle == 0 or cycle == 2 then
		set i=0
		loop
		exitwhen i > spawnPositionLastIndex
			if i != 1 then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),i)
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
			endif
		set i=i + 1
		endloop
			elseif cycle == 1 then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),1)
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
			endif
		elseif variation == 2 then
			if cycle == 0 or cycle == 2 then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),1)
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
			elseif cycle == 1 then
		set i=0
		loop
		exitwhen i > spawnPositionLastIndex
			if i != 1 then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),i)
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
			endif
		set i=i + 1
		endloop
			endif
		elseif variation == 3 then
			if cycle == 0 then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),GetRandomInt(0, 2))
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
			elseif cycle == 1 then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),GetRandomInt(0, 2))
				set bhole=sc__Blackhole_create(s__vector2_x[spawnPosition] , s__vector2_y[spawnPosition] , false)
				set s__IStartable_ParentLevel[bhole]=parentLevel
				call s__DisposableUnit_register(s__Blackhole_BlackholeUnit[bhole] , bhole)
				call sc__Blackhole_Start(bhole)
				call GroupAddUnit(g, s__Blackhole_BlackholeUnit[bhole])
				call s__vector2_deallocate(spawnPosition)
			elseif cycle == 2 then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),GetRandomInt(0, 2))
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
			endif
		endif
    set f__result_group= g
    return true
endfunction
function sa___prototype29_W4APatternSpawn takes nothing returns boolean
 local integer spawn=f__arg_integer1
 local integer parentLevel=f__arg_integer2

  local group g= NewGroup()
  local integer variation= s__PatternSpawn_GetVariation(spawn)
  local integer cycle= s__PatternSpawn_GetCycle(spawn,variation)
  local integer spawnPositionLastIndex= s__LinePatternSpawn_GetSpawnPositionCount((spawn)) - 1
  local integer spawnPosition
  local integer rand
  local integer i
		if variation == 0 then
			if cycle == 0 then
				set rand=GetRandomInt(0, 3)
		set i=0
		loop
		exitwhen i > spawnPositionLastIndex
			if i != rand then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),i)
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
			endif
		set i=i + 1
		endloop
			elseif cycle == 1 or cycle == 4 then
		set i=0
		loop
		exitwhen i > spawnPositionLastIndex
			set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),i)
			call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
			call s__vector2_deallocate(spawnPosition)
		set i=i + 2
		endloop
			elseif cycle == 2 then
		set i=1
		loop
		exitwhen i > spawnPositionLastIndex
			set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),i)
			call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
			call s__vector2_deallocate(spawnPosition)
		set i=i + 2
		endloop
			elseif cycle == 3 then
				set rand=GetRandomInt(0, 3)
		set i=0
		loop
		exitwhen i > spawnPositionLastIndex
			if i != rand then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),i)
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
			endif
		set i=i + 1
		endloop
			endif
		elseif variation == 1 then
			if cycle == 0 or cycle == 3 then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),0)
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),3)
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
			elseif cycle == 1 or cycle == 2 or cycle == 4 then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),1)
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),2)
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
			endif
		elseif variation == 2 then
			if cycle == 0 or cycle == 2 then
				set rand=GetRandomInt(0, 3)
		set i=0
		loop
		exitwhen i > spawnPositionLastIndex
			if i != rand then
				set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),i)
				call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
				call s__vector2_deallocate(spawnPosition)
			endif
		set i=i + 1
		endloop
			elseif cycle == 1 or cycle == 4 then
				set rand=GetRandomInt(0, 1)
				if rand == 0 then
		set i=0
		loop
		exitwhen i > spawnPositionLastIndex
			set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),i)
			call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
			call s__vector2_deallocate(spawnPosition)
		set i=i + 2
		endloop
				else
		set i=1
		loop
		exitwhen i > spawnPositionLastIndex
			set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),i)
			call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
			call s__vector2_deallocate(spawnPosition)
		set i=i + 2
		endloop
				endif
			elseif cycle == 3 then
				set rand=GetRandomInt(0, 1)
				if rand == 0 then
					set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),0)
					call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
					call s__vector2_deallocate(spawnPosition)
					set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),3)
					call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
					call s__vector2_deallocate(spawnPosition)
				else
					set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),1)
					call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
					call s__vector2_deallocate(spawnPosition)
					set spawnPosition=s__LinePatternSpawn_GetSpawnPosition((spawn),2)
					call GroupAddUnit(g, (sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[spawnPosition] )*1.0) , (( s__vector2_y[spawnPosition])*1.0)))) // INLINED!!
					call s__vector2_deallocate(spawnPosition)
				endif
			endif
		endif
    set f__result_group= g
    return true
endfunction
function sa___prototype29_RelayGeneratorRandomSpawn takes nothing returns boolean
 local integer spawn=f__arg_integer1
 local integer parentLevel=f__arg_integer2

  local group g= NewGroup()
  local integer lane= GetRandomInt(0, sc__RelayGenerator_GetNumberLanes(s__RelayPatternSpawn_Parent[spawn]) - 1)
  local integer spawnTurn= s__SimpleList_ListNode_value[s__SimpleList_List_first[s__RelayGenerator_Turns[s__RelayPatternSpawn_Parent[spawn]]]]
  local real x= s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]]
  local real y= s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]]
  local unit u
		if s__RelayTurn_Direction[spawnTurn] == 90 or s__RelayTurn_Direction[spawnTurn] == 270 then
			set x=x + s__RelayTurn_FirstLaneX[spawnTurn] * lane * s__RelayGenerator_UnitLaneSize[s__RelayPatternSpawn_Parent[spawn]]
		else
			set y=y + s__RelayTurn_FirstLaneY[spawnTurn] * lane * s__RelayGenerator_UnitLaneSize[s__RelayPatternSpawn_Parent[spawn]]
		endif
		set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((s__PatternSpawn_Data[s__RelayPatternSpawn_Pattern[spawn]] )))),(( x )*1.0) , (( y)*1.0))) // INLINED!!
		call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(u)),GetUnitMoveSpeed(u) * s__RelayGenerator_OverclockFactor[s__RelayPatternSpawn_Parent[spawn]])
		call GroupAddUnit(g, u)
    set f__result_group= g
    return true
endfunction
function sa___prototype29_LW2PatternSpawn1 takes nothing returns boolean
 local integer spawn=f__arg_integer1
 local integer parentLevel=f__arg_integer2

  local group g= NewGroup()
  local integer spawnTurn= s__SimpleList_ListNode_value[s__SimpleList_List_first[s__RelayGenerator_Turns[s__RelayPatternSpawn_Parent[spawn]]]]
  local unit u
		if s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 1 or ( s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 2 and sc__Levels_Level_GetWeightedRandomInt(parentLevel,0 , 1) == 1 ) then
			set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((AMBULANCE )))),(( s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] )*1.0) , (( s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]])*1.0))) // INLINED!!
			call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(u)),3. * EDWRelayPatternSpawnDefinitions___LW2_RG1_BASEMS * s__RelayGenerator_OverclockFactor[s__RelayPatternSpawn_Parent[spawn]])
			call GroupAddUnit(g, u)
		elseif s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 3 then
			set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((TRUCK )))),(( s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] + 2 * s__RelayTurn_FirstLaneX[spawnTurn] * s__RelayGenerator_UnitLaneSize[s__RelayPatternSpawn_Parent[spawn]] )*1.0) , (( s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]])*1.0))) // INLINED!!
			call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(u)),EDWRelayPatternSpawnDefinitions___LW2_RG1_BASEMS * s__RelayGenerator_OverclockFactor[s__RelayPatternSpawn_Parent[spawn]])
			call GroupAddUnit(g, u)
		endif
		if ( s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] / 2. ) - ( s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] / 2 ) == 0. then
			set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((JEEP )))),(( s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] + s__RelayTurn_FirstLaneX[spawnTurn] * s__RelayGenerator_UnitLaneSize[s__RelayPatternSpawn_Parent[spawn]] )*1.0) , (( s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]])*1.0))) // INLINED!!
			call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(u)),2.25 * EDWRelayPatternSpawnDefinitions___LW2_RG1_BASEMS * s__RelayGenerator_OverclockFactor[s__RelayPatternSpawn_Parent[spawn]])
			call GroupAddUnit(g, u)
		endif
    set f__result_group= g
    return true
endfunction
function sa___prototype29_LW2PatternSpawn2 takes nothing returns boolean
 local integer spawn=f__arg_integer1
 local integer parentLevel=f__arg_integer2

  local group g= NewGroup()
  local integer spawnTurn= s__SimpleList_ListNode_value[s__SimpleList_List_first[s__RelayGenerator_Turns[s__RelayPatternSpawn_Parent[spawn]]]]
  local unit u
		if s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 0 then
			set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((CORVETTE )))),(( s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] + s__RelayTurn_FirstLaneX[spawnTurn] * s__RelayGenerator_UnitLaneSize[s__RelayPatternSpawn_Parent[spawn]] )*1.0) , (( s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]])*1.0))) // INLINED!!
			call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(u)),2.5 * EDWRelayPatternSpawnDefinitions___LW2_RG2_BASEMS * s__RelayGenerator_OverclockFactor[s__RelayPatternSpawn_Parent[spawn]])
			call GroupAddUnit(g, u)
		elseif s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 1 and sc__Levels_Level_GetWeightedRandomInt(parentLevel,0 , 1) == 1 then
			set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((POLICECAR )))),(( s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] + s__RelayTurn_FirstLaneX[spawnTurn] * s__RelayGenerator_UnitLaneSize[s__RelayPatternSpawn_Parent[spawn]] )*1.0) , (( s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]])*1.0))) // INLINED!!
			call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(u)),2.5 * EDWRelayPatternSpawnDefinitions___LW2_RG2_BASEMS * s__RelayGenerator_OverclockFactor[s__RelayPatternSpawn_Parent[spawn]])
			call GroupAddUnit(g, u)
		endif
		if s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 1 or s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 3 or s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 5 then
			set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((PASSENGERCAR )))),(( s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] )*1.0) , (( s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]])*1.0))) // INLINED!!
			call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(u)),EDWRelayPatternSpawnDefinitions___LW2_RG2_BASEMS * s__RelayGenerator_OverclockFactor[s__RelayPatternSpawn_Parent[spawn]])
			call GroupAddUnit(g, u)
		endif
    set f__result_group= g
    return true
endfunction
function sa___prototype29_LW2PatternSpawn3 takes nothing returns boolean
 local integer spawn=f__arg_integer1
 local integer parentLevel=f__arg_integer2

  local group g= NewGroup()
  local integer spawnTurn= s__SimpleList_ListNode_value[s__SimpleList_List_first[s__RelayGenerator_Turns[s__RelayPatternSpawn_Parent[spawn]]]]
  local unit u
		if s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 0 or s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 2 then
			set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((FIRETRUCK )))),(( s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] + s__RelayTurn_FirstLaneX[spawnTurn] * s__RelayGenerator_UnitLaneSize[s__RelayPatternSpawn_Parent[spawn]] )*1.0) , (( s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]])*1.0))) // INLINED!!
			call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(u)),EDWRelayPatternSpawnDefinitions___LW2_RG3_BASEMS * s__RelayGenerator_OverclockFactor[s__RelayPatternSpawn_Parent[spawn]])
			call GroupAddUnit(g, u)
		elseif s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 1 then
			set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((JEEP )))),(( s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] )*1.0) , (( s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]])*1.0))) // INLINED!!
			call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(u)),1.5 * EDWRelayPatternSpawnDefinitions___LW2_RG3_BASEMS * s__RelayGenerator_OverclockFactor[s__RelayPatternSpawn_Parent[spawn]])
			call GroupAddUnit(g, u)
		endif
    set f__result_group= g
    return true
endfunction
function sa___prototype29_LW2PatternSpawn4 takes nothing returns boolean
 local integer spawn=f__arg_integer1
 local integer parentLevel=f__arg_integer2

  local group g= NewGroup()
  local integer spawnTurn= s__SimpleList_ListNode_value[s__SimpleList_List_first[s__RelayGenerator_Turns[s__RelayPatternSpawn_Parent[spawn]]]]
  local unit u
		if s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 0 or s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 2 then
			if s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 0 then
				set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((PASSENGERCAR )))),(( s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] )*1.0) , (( s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]])*1.0))) // INLINED!!
			elseif s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 2 then
				set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((PASSENGERCAR )))),(( s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] )*1.0) , (( s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]] + s__RelayTurn_FirstLaneY[spawnTurn] * s__RelayGenerator_UnitLaneSize[s__RelayPatternSpawn_Parent[spawn]])*1.0))) // INLINED!!
			endif
			call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(u)),EDWRelayPatternSpawnDefinitions___LW2_RG4_BASEMS * s__RelayGenerator_OverclockFactor[s__RelayPatternSpawn_Parent[spawn]])
			call GroupAddUnit(g, u)
		endif
    set f__result_group= g
    return true
endfunction
function sa___prototype29_PW2PatternSpawn takes nothing returns boolean
 local integer spawn=f__arg_integer1
 local integer parentLevel=f__arg_integer2

  local group g= NewGroup()
  local unit u
  local integer spawnTurn= s__SimpleList_ListNode_value[s__SimpleList_List_first[s__RelayGenerator_Turns[s__RelayPatternSpawn_Parent[spawn]]]]
		if s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 1 or s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 3 then
			set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] )*1.0) , (( s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]])*1.0))) // INLINED!!
			call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(u)),200. * s__RelayGenerator_OverclockFactor[s__RelayPatternSpawn_Parent[spawn]])
			call GroupAddUnit(g, u)
			set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] )*1.0) , (( s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]] + 2 * s__RelayTurn_FirstLaneY[spawnTurn] * s__RelayGenerator_UnitLaneSize[s__RelayPatternSpawn_Parent[spawn]])*1.0))) // INLINED!!
			call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(u)),200. * s__RelayGenerator_OverclockFactor[s__RelayPatternSpawn_Parent[spawn]])
			call GroupAddUnit(g, u)
		elseif s__PatternSpawn_CurrentCycle[s__RelayPatternSpawn_Pattern[spawn]] == 2 then
			set u=(sc__Recycle_UnitRecycler_Make((LoadInteger(s__Recycle_UnitRecycler_Recyclers, 0, ((ICETROLL )))),(( s__vector2_x[s__RelayTurn_FirstLane[spawnTurn]] )*1.0) , (( s__vector2_y[s__RelayTurn_FirstLane[spawnTurn]] + s__RelayTurn_FirstLaneY[spawnTurn] * s__RelayGenerator_UnitLaneSize[s__RelayPatternSpawn_Parent[spawn]])*1.0))) // INLINED!!
			call s__IndexedUnit_SetMoveSpeed((GetUnitUserData(u)),400. * s__RelayGenerator_OverclockFactor[s__RelayPatternSpawn_Parent[spawn]])
			call GroupAddUnit(g, u)
		endif
    set f__result_group= g
    return true
endfunction
function sa___prototype54_All___onPromiseResolve takes nothing returns boolean
 local integer result=f__arg_integer1
 local integer all=f__arg_integer2

		set All___CountFinished[all]=All___CountFinished[all] + 1
		if All___CountFinished[all] == All___CountWaiting[all] then
			call s__Deferred_Resolve(all,result)
		else
			call s__Deferred_Progress(all,result)
		endif
    set f__result_integer= 0
    return true
endfunction
function sa___prototype54_All___onPromiseProgress takes nothing returns boolean
 local integer result=f__arg_integer1
 local integer all=f__arg_integer2

		call s__Deferred_Progress(all,result)
    set f__result_integer= 0
    return true
endfunction
function sa___prototype54_Any___onPromiseResolve takes nothing returns boolean
 local integer result=f__arg_integer1
 local integer any=f__arg_integer2

		call s__Deferred_Resolve(any,result)
    set f__result_integer= 0
    return true
endfunction
function sa___prototype54_Any___onPromiseProgress takes nothing returns boolean
 local integer result=f__arg_integer1
 local integer any=f__arg_integer2

		call s__Deferred_Progress(any,result)
    set f__result_integer= 0
    return true
endfunction
function sa___prototype54_EDWCollectibleResolveHandlers_AdvanceLevel takes nothing returns boolean
 local integer user=f__arg_integer1
 local integer activeTeam=f__arg_integer2

		call sc__Teams_MazingTeam_PauseTeam(s__CollectibleTeam_Team[activeTeam],true)
		call sc__Teams_MazingTeam_PanCameraForTeam(s__CollectibleTeam_Team[activeTeam],GetUnitX(s__User_ActiveUnit[user]) , GetUnitY(s__User_ActiveUnit[user]) , EDWCollectibleResolveHandlers___ADVANCE_LEVEL_PAN_CAMERA_DURATION)
		call TimerStart(NewTimerEx(user), EDWCollectibleResolveHandlers___ADVANCE_LEVEL_PAN_CAMERA_DURATION, false, function EDWCollectibleResolveHandlers___AdvanceLevelPlaySFX)
    set f__result_integer= 0
    return true
endfunction
function sa___prototype3_EDWCinematicContent___IsUserRed takes nothing returns boolean
 local integer user=f__arg_integer1

    set f__result_boolean= s__MazerColor[user] == KEY_RED
    return true
endfunction
function sa___prototype3_EDWCinematicContent___IsUserNotRed takes nothing returns boolean
 local integer user=f__arg_integer1

    set f__result_boolean= s__MazerColor[user] != KEY_RED
    return true
endfunction
function sa___prototype3_EDWCinematicContent___IsUserBlue takes nothing returns boolean
 local integer user=f__arg_integer1

    set f__result_boolean= s__MazerColor[user] == KEY_BLUE
    return true
endfunction
function sa___prototype3_EDWCinematicContent___IsUserNotInCinema takes nothing returns boolean
 local integer user=f__arg_integer1

    set f__result_boolean= s__User_CinematicPlaying[user] == 0
    return true
endfunction
function sa___prototype3_EDWCinematicContent___IsUserStandard takes nothing returns boolean
 local integer user=f__arg_integer1

    set f__result_boolean= s__User_GameMode[user] == Teams_GAMEMODE_STANDARD or s__User_GameMode[user] == Teams_GAMEMODE_STANDARD_PAUSED
    return true
endfunction
function sa___prototype3_EDWCinematicContent___IsUserPlatforming takes nothing returns boolean
 local integer user=f__arg_integer1

    set f__result_boolean= s__User_GameMode[user] == Teams_GAMEMODE_PLATFORMING or s__User_GameMode[user] == Teams_GAMEMODE_PLATFORMING_PAUSED
    return true
endfunction
function sa___prototype3_EDWCinematicContent___IsUserDying takes nothing returns boolean
 local integer user=f__arg_integer1

    set f__result_boolean= s__User_GameMode[user] == Teams_GAMEMODE_DYING or s__User_GameMode[user] == Teams_GAMEMODE_DEAD
    return true
endfunction
function sa___prototype54_s__User_OnUnapplyAFKStandard takes nothing returns boolean
 local integer request=f__arg_integer1
 local integer user=f__arg_integer2

		if S2B(s__SyncRequest_RequestData[request]) then
			set s__User_AFKPlatformerDeathClock[user]=User___AFK_UNPAUSE_BUFFER
			call s__User_Pause(user,true)
			call s__User_ApplyDefaultCameras(user,User___AFK_PAN_CAMERA_DURATION)
			call s__User_ApplyDefaultSelections(user)
			call TimerStart(NewTimerEx(user), User___AFK_PAN_CAMERA_DURATION, false, function s__User_PanAFKCameraCB)
		endif
		call s__SyncRequest_destroy(request)
    set f__result_integer= 0
    return true
endfunction

function jasshelper__initstructs74146625 takes nothing returns nothing
    set st__Levels_Level_GetWeightedRandomInt=CreateTrigger()
    call TriggerAddCondition(st__Levels_Level_GetWeightedRandomInt,Condition( function sa__Levels_Level_GetWeightedRandomInt))
    set st__Levels_Level_GetWorldID=CreateTrigger()
    call TriggerAddCondition(st__Levels_Level_GetWorldID,Condition( function sa__Levels_Level_GetWorldID))
    set st__Levels_Level_RemoveGreenFromLevel=CreateTrigger()
    call TriggerAddCondition(st__Levels_Level_RemoveGreenFromLevel,Condition( function sa__Levels_Level_RemoveGreenFromLevel))
    set st__Levels_Level_SetCheckpointForTeam=CreateTrigger()
    call TriggerAddCondition(st__Levels_Level_SetCheckpointForTeam,Condition( function sa__Levels_Level_SetCheckpointForTeam))
    set st__Levels_Level_AnimatedSetCheckpointForTeam=CreateTrigger()
    call TriggerAddCondition(st__Levels_Level_AnimatedSetCheckpointForTeam,Condition( function sa__Levels_Level_AnimatedSetCheckpointForTeam))
    set st__Levels_Level_SwitchLevels=CreateTrigger()
    call TriggerAddCondition(st__Levels_Level_SwitchLevels,Condition( function sa__Levels_Level_SwitchLevels))
    set st__Levels_Level_SwitchLevelsAnimated=CreateTrigger()
    call TriggerAddCondition(st__Levels_Level_SwitchLevelsAnimated,Condition( function sa__Levels_Level_SwitchLevelsAnimated))
    set st__Teams_MazingTeam_MoveRevive=CreateTrigger()
    call TriggerAddCondition(st__Teams_MazingTeam_MoveRevive,Condition( function sa__Teams_MazingTeam_MoveRevive))
    set st__Teams_MazingTeam_RespawnTeamAtRect=CreateTrigger()
    call TriggerAddCondition(st__Teams_MazingTeam_RespawnTeamAtRect,Condition( function sa__Teams_MazingTeam_RespawnTeamAtRect))
    set st__Teams_MazingTeam_PrintMessage=CreateTrigger()
    call TriggerAddCondition(st__Teams_MazingTeam_PrintMessage,Condition( function sa__Teams_MazingTeam_PrintMessage))
    set st__Teams_MazingTeam_UpdateMultiboard=CreateTrigger()
    call TriggerAddCondition(st__Teams_MazingTeam_UpdateMultiboard,Condition( function sa__Teams_MazingTeam_UpdateMultiboard))
    set st__Teams_MazingTeam_GetStylizedPlayerName=CreateTrigger()
    call TriggerAddCondition(st__Teams_MazingTeam_GetStylizedPlayerName,Condition( function sa__Teams_MazingTeam_GetStylizedPlayerName))
    set st__Teams_MazingTeam_ComputeTeamWeights=CreateTrigger()
    call TriggerAddCondition(st__Teams_MazingTeam_ComputeTeamWeights,Condition( function sa__Teams_MazingTeam_ComputeTeamWeights))
    set st__Teams_MazingTeam_GetRandomTeam=CreateTrigger()
    call TriggerAddCondition(st__Teams_MazingTeam_GetRandomTeam,Condition( function sa__Teams_MazingTeam_GetRandomTeam))
    set st__Teams_MazingTeam_GetContinueCount=CreateTrigger()
    call TriggerAddCondition(st__Teams_MazingTeam_GetContinueCount,Condition( function sa__Teams_MazingTeam_GetContinueCount))
    set st__Teams_MazingTeam_SetContinueCount=CreateTrigger()
    call TriggerAddCondition(st__Teams_MazingTeam_SetContinueCount,Condition( function sa__Teams_MazingTeam_SetContinueCount))
    set st__Teams_MazingTeam_ChangeContinueCount=CreateTrigger()
    call TriggerAddCondition(st__Teams_MazingTeam_ChangeContinueCount,Condition( function sa__Teams_MazingTeam_ChangeContinueCount))
    set st__Teams_MazingTeam_GetScore=CreateTrigger()
    call TriggerAddCondition(st__Teams_MazingTeam_GetScore,Condition( function sa__Teams_MazingTeam_GetScore))
    set st__Teams_MazingTeam_ChangeScore=CreateTrigger()
    call TriggerAddCondition(st__Teams_MazingTeam_ChangeScore,Condition( function sa__Teams_MazingTeam_ChangeScore))
    set st__Teams_MazingTeam_ApplyEndGameAll=CreateTrigger()
    call TriggerAddCondition(st__Teams_MazingTeam_ApplyEndGameAll,Condition( function sa__Teams_MazingTeam_ApplyEndGameAll))
    set st__Teams_MazingTeam_PauseTeam=CreateTrigger()
    call TriggerAddCondition(st__Teams_MazingTeam_PauseTeam,Condition( function sa__Teams_MazingTeam_PauseTeam))
    set st__Teams_MazingTeam_SetUnitLocalOpacityForTeam=CreateTrigger()
    call TriggerAddCondition(st__Teams_MazingTeam_SetUnitLocalOpacityForTeam,Condition( function sa__Teams_MazingTeam_SetUnitLocalOpacityForTeam))
    set st__Teams_MazingTeam_PlaySoundForTeam=CreateTrigger()
    call TriggerAddCondition(st__Teams_MazingTeam_PlaySoundForTeam,Condition( function sa__Teams_MazingTeam_PlaySoundForTeam))
    set st__Teams_MazingTeam_PanCameraForTeam=CreateTrigger()
    call TriggerAddCondition(st__Teams_MazingTeam_PanCameraForTeam,Condition( function sa__Teams_MazingTeam_PanCameraForTeam))
    set st__Teams_MazingTeam_SetSharedControlForTeam=CreateTrigger()
    call TriggerAddCondition(st__Teams_MazingTeam_SetSharedControlForTeam,Condition( function sa__Teams_MazingTeam_SetSharedControlForTeam))
    set st__User_SetActiveEffect=CreateTrigger()
    call TriggerAddCondition(st__User_SetActiveEffect,Condition( function sa__User_SetActiveEffect))
    set st__User_ClearActiveEffect=CreateTrigger()
    call TriggerAddCondition(st__User_ClearActiveEffect,Condition( function sa__User_ClearActiveEffect))
    set st__User_CreateUserTimedEffect=CreateTrigger()
    call TriggerAddCondition(st__User_CreateUserTimedEffect,Condition( function sa__User_CreateUserTimedEffect))
    set st__User_OnCinemaEndCB=CreateTrigger()
    call TriggerAddCondition(st__User_OnCinemaEndCB,Condition( function sa__User_OnCinemaEndCB))
    set st__User_CheckCinematicQueue=CreateTrigger()
    call TriggerAddCondition(st__User_CheckCinematicQueue,Condition( function sa__User_CheckCinematicQueue))
    set st__User_DisplayMessage=CreateTrigger()
    call TriggerAddCondition(st__User_DisplayMessage,Condition( function sa__User_DisplayMessage))
    set st__User_ApplyDefaultCameras=CreateTrigger()
    call TriggerAddCondition(st__User_ApplyDefaultCameras,Condition( function sa__User_ApplyDefaultCameras))
    set st__User_ResetDefaultCamera=CreateTrigger()
    call TriggerAddCondition(st__User_ResetDefaultCamera,Condition( function sa__User_ResetDefaultCamera))
    set st__User_ApplyDefaultSelections=CreateTrigger()
    call TriggerAddCondition(st__User_ApplyDefaultSelections,Condition( function sa__User_ApplyDefaultSelections))
    set st__User_Pause=CreateTrigger()
    call TriggerAddCondition(st__User_Pause,Condition( function sa__User_Pause))
    set st__User_RespawnAtRect=CreateTrigger()
    call TriggerAddCondition(st__User_RespawnAtRect,Condition( function sa__User_RespawnAtRect))
    set st__User_SetKeyColor=CreateTrigger()
    call TriggerAddCondition(st__User_SetKeyColor,Condition( function sa__User_SetKeyColor))
    set st__User_GetStylizedPlayerName=CreateTrigger()
    call TriggerAddCondition(st__User_GetStylizedPlayerName,Condition( function sa__User_GetStylizedPlayerName))
    set st__User_SwitchGameModesDefaultLocation=CreateTrigger()
    call TriggerAddCondition(st__User_SwitchGameModesDefaultLocation,Condition( function sa__User_SwitchGameModesDefaultLocation))
    set st__User_SwitchGameModes=CreateTrigger()
    call TriggerAddCondition(st__User_SwitchGameModes,Condition( function sa__User_SwitchGameModes))
    set st__User_SetCurrentGameMode=CreateTrigger()
    call TriggerAddCondition(st__User_SetCurrentGameMode,Condition( function sa__User_SetCurrentGameMode))
    set st__User_IsActiveUnitInRect=CreateTrigger()
    call TriggerAddCondition(st__User_IsActiveUnitInRect,Condition( function sa__User_IsActiveUnitInRect))
    set st__User_ApplyAFKPlatformer=CreateTrigger()
    call TriggerAddCondition(st__User_ApplyAFKPlatformer,Condition( function sa__User_ApplyAFKPlatformer))
    set st__InWorldPowerup_IsPowerupUnit=CreateTrigger()
    call TriggerAddCondition(st__InWorldPowerup_IsPowerupUnit,Condition( function sa__InWorldPowerup_IsPowerupUnit))
    set st__InWorldPowerup_create=CreateTrigger()
    call TriggerAddCondition(st__InWorldPowerup_create,Condition( function sa__InWorldPowerup_create))
    set st__VisualVote_voteMenu_applyPlayerVote=CreateTrigger()
    call TriggerAddCondition(st__VisualVote_voteMenu_applyPlayerVote,Condition( function sa__VisualVote_voteMenu_applyPlayerVote))
    set st__VisualVote_voteMenu_checkPlayersFinishedVoting=CreateTrigger()
    call TriggerAddCondition(st__VisualVote_voteMenu_checkPlayersFinishedVoting,Condition( function sa__VisualVote_voteMenu_checkPlayersFinishedVoting))
    set st__VisualVote_voteMenu_destroy=CreateTrigger()
    call TriggerAddCondition(st__VisualVote_voteMenu_destroy,Condition( function sa__VisualVote_voteMenu_destroy))
    set st__VisualVote_voteContainer_clearVoteOptionsForPlayer=CreateTrigger()
    call TriggerAddCondition(st__VisualVote_voteContainer_clearVoteOptionsForPlayer,Condition( function sa__VisualVote_voteContainer_clearVoteOptionsForPlayer))
    set st__IStartable_Stop[103]=CreateTrigger()
    call TriggerAddCondition(st__IStartable_Stop[103],Condition( function sa__RespawningGateway_Stop))
    call TriggerAddAction(st__IStartable_Stop[103], function sa__RespawningGateway_Stop)
    set st__IStartable_Start[103]=CreateTrigger()
    call TriggerAddCondition(st__IStartable_Start[103],Condition( function sa__RespawningGateway_Start))
    call TriggerAddAction(st__IStartable_Start[103], function sa__RespawningGateway_Start)
    set st__IStartable_onDestroy[103]=null
    set st__Wheel_Rotate[101]=CreateTrigger()
    call TriggerAddCondition(st__Wheel_Rotate[101],Condition( function sa__Wheel_Rotate))
    call TriggerAddAction(st__Wheel_Rotate[101], function sa__Wheel_Rotate)
    set st__IStartable_Stop[101]=CreateTrigger()
    set st__IStartable_Stop[75]=st__IStartable_Stop[101]
    call TriggerAddCondition(st__IStartable_Stop[101],Condition( function sa__Wheel_Stop))
    call TriggerAddAction(st__IStartable_Stop[101], function sa__Wheel_Stop)
    set st__IStartable_Start[101]=CreateTrigger()
    set st__IStartable_Start[75]=st__IStartable_Start[101]
    call TriggerAddCondition(st__IStartable_Start[101],Condition( function sa__Wheel_Start))
    call TriggerAddAction(st__IStartable_Start[101], function sa__Wheel_Start)
    set st__Wheel_create=CreateTrigger()
    call TriggerAddCondition(st__Wheel_create,Condition( function sa__Wheel_create))
    set st__IStartable_onDestroy[101]=null
    set st__IStartable_onDestroy[75]=null
    set st__IStartable_Stop[96]=CreateTrigger()
    call TriggerAddCondition(st__IStartable_Stop[96],Condition( function sa__SynchronizedGroup_Stop))
    call TriggerAddAction(st__IStartable_Stop[96], function sa__SynchronizedGroup_Stop)
    set st__IStartable_Start[96]=CreateTrigger()
    call TriggerAddCondition(st__IStartable_Start[96],Condition( function sa__SynchronizedGroup_Start))
    call TriggerAddAction(st__IStartable_Start[96], function sa__SynchronizedGroup_Start)
    set st__IStartable_onDestroy[96]=null
    set st__IStartable_Start[94]=CreateTrigger()
    call TriggerAddCondition(st__IStartable_Start[94],Condition( function sa__SimplePatrol_Start))
    call TriggerAddAction(st__IStartable_Start[94], function sa__SimplePatrol_Start)
    set st__IStartable_Stop[94]=CreateTrigger()
    call TriggerAddCondition(st__IStartable_Stop[94],Condition( function sa__SimplePatrol_Stop))
    call TriggerAddAction(st__IStartable_Stop[94], function sa__SimplePatrol_Stop)
    set st__IStartable_onDestroy[94]=null
    set st__SimpleGenerator_PeriodicSpawn=CreateTrigger()
    call TriggerAddCondition(st__SimpleGenerator_PeriodicSpawn,Condition( function sa__SimpleGenerator_PeriodicSpawn))
    set st__IStartable_Start[93]=CreateTrigger()
    call TriggerAddCondition(st__IStartable_Start[93],Condition( function sa__SimpleGenerator_Start))
    call TriggerAddAction(st__IStartable_Start[93], function sa__SimpleGenerator_Start)
    set st__IStartable_Stop[93]=CreateTrigger()
    call TriggerAddCondition(st__IStartable_Stop[93],Condition( function sa__SimpleGenerator_Stop))
    call TriggerAddAction(st__IStartable_Stop[93], function sa__SimpleGenerator_Stop)
    set st__IStartable_destroy[93]=CreateTrigger()
    call TriggerAddCondition(st__IStartable_destroy[93],Condition( function sa__SimpleGenerator_destroy))
    call TriggerAddAction(st__IStartable_destroy[93], function sa__SimpleGenerator_destroy)
    set st__IStartable_onDestroy[93]=null
    set st__RelayGenerator_GetNumberLanes=CreateTrigger()
    call TriggerAddCondition(st__RelayGenerator_GetNumberLanes,Condition( function sa__RelayGenerator_GetNumberLanes))
    set st__RelayGenerator_GetRadius=CreateTrigger()
    call TriggerAddCondition(st__RelayGenerator_GetRadius,Condition( function sa__RelayGenerator_GetRadius))
    set st__IStartable_Start[90]=CreateTrigger()
    call TriggerAddCondition(st__IStartable_Start[90],Condition( function sa__RelayGenerator_Start))
    call TriggerAddAction(st__IStartable_Start[90], function sa__RelayGenerator_Start)
    set st__IStartable_Stop[90]=CreateTrigger()
    call TriggerAddCondition(st__IStartable_Stop[90],Condition( function sa__RelayGenerator_Stop))
    call TriggerAddAction(st__IStartable_Stop[90], function sa__RelayGenerator_Stop)
    set st__IStartable_onDestroy[90]=null
    set st__IStartable_Stop[83]=CreateTrigger()
    call TriggerAddCondition(st__IStartable_Stop[83],Condition( function sa__DrunkWalker_DrunkWalkerSpawn_Stop))
    call TriggerAddAction(st__IStartable_Stop[83], function sa__DrunkWalker_DrunkWalkerSpawn_Stop)
    set st__IStartable_Start[83]=CreateTrigger()
    call TriggerAddCondition(st__IStartable_Start[83],Condition( function sa__DrunkWalker_DrunkWalkerSpawn_Start))
    call TriggerAddAction(st__IStartable_Start[83], function sa__DrunkWalker_DrunkWalkerSpawn_Start)
    set st__IStartable_onDestroy[83]=null
    set st__DrunkWalker_DrunkWalker_drinkEffect=CreateTrigger()
    call TriggerAddCondition(st__DrunkWalker_DrunkWalker_drinkEffect,Condition( function sa__DrunkWalker_DrunkWalker_drinkEffect))
    set st__DrunkWalker_DrunkWalker_destroy=CreateTrigger()
    call TriggerAddCondition(st__DrunkWalker_DrunkWalker_destroy,Condition( function sa__DrunkWalker_DrunkWalker_destroy))
    set st__Deferred_Remove=CreateTrigger()
    call TriggerAddCondition(st__Deferred_Remove,Condition( function sa__Deferred_Remove))
    set st__Deferred_create=CreateTrigger()
    call TriggerAddCondition(st__Deferred_create,Condition( function sa__Deferred_create))
    set st__Deferred_destroy=CreateTrigger()
    call TriggerAddCondition(st__Deferred_destroy,Condition( function sa__Deferred_destroy))
    set st__CinemaCallbackModel_destroy=CreateTrigger()
    call TriggerAddCondition(st__CinemaCallbackModel_destroy,Condition( function sa__CinemaCallbackModel_destroy))
    set st__Wheel_Rotate[75]=CreateTrigger()
    call TriggerAddCondition(st__Wheel_Rotate[75],Condition( function sa__BoundedWheel_Rotate))
    call TriggerAddAction(st__Wheel_Rotate[75], function sa__BoundedWheel_Rotate)
    set st__IStartable_Stop[74]=CreateTrigger()
    call TriggerAddCondition(st__IStartable_Stop[74],Condition( function sa__BoundedSpoke_Stop))
    call TriggerAddAction(st__IStartable_Stop[74], function sa__BoundedSpoke_Stop)
    set st__IStartable_Start[74]=CreateTrigger()
    call TriggerAddCondition(st__IStartable_Start[74],Condition( function sa__BoundedSpoke_Start))
    call TriggerAddAction(st__IStartable_Start[74], function sa__BoundedSpoke_Start)
    set st__IStartable_onDestroy[74]=null
    set st__SimpleList_List_add=CreateTrigger()
    call TriggerAddCondition(st__SimpleList_List_add,Condition( function sa__SimpleList_List_add))
    set st__SimpleList_List_remove=CreateTrigger()
    call TriggerAddCondition(st__SimpleList_List_remove,Condition( function sa__SimpleList_List_remove))
    set st__SimpleList_List_create=CreateTrigger()
    call TriggerAddCondition(st__SimpleList_List_create,Condition( function sa__SimpleList_List_create))
    set st__Recycle_UnitRecycler_MakeWithFacing=CreateTrigger()
    call TriggerAddCondition(st__Recycle_UnitRecycler_MakeWithFacing,Condition( function sa__Recycle_UnitRecycler_MakeWithFacing))
    set st__Recycle_UnitRecycler_Make=CreateTrigger()
    call TriggerAddCondition(st__Recycle_UnitRecycler_Make,Condition( function sa__Recycle_UnitRecycler_Make))
    set st__Recycle_UnitRecycler_Release=CreateTrigger()
    call TriggerAddCondition(st__Recycle_UnitRecycler_Release,Condition( function sa__Recycle_UnitRecycler_Release))
    set st__Recycle_UnitRecycler_GetRecycler=CreateTrigger()
    call TriggerAddCondition(st__Recycle_UnitRecycler_GetRecycler,Condition( function sa__Recycle_UnitRecycler_GetRecycler))
    set st__IStartable_Start[65]=CreateTrigger()
    call TriggerAddCondition(st__IStartable_Start[65],Condition( function sa__MortarNTarget_Start))
    call TriggerAddAction(st__IStartable_Start[65], function sa__MortarNTarget_Start)
    set st__IStartable_Stop[65]=CreateTrigger()
    call TriggerAddCondition(st__IStartable_Stop[65],Condition( function sa__MortarNTarget_Stop))
    call TriggerAddAction(st__IStartable_Stop[65], function sa__MortarNTarget_Stop)
    set st__IStartable_onDestroy[65]=CreateTrigger()
    call TriggerAddCondition(st__IStartable_onDestroy[65],Condition( function sa__MortarNTarget_onDestroy))
    set st__Stack_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__Stack_onDestroy,Condition( function sa__Stack_onDestroy))
    set st__IStartable_Start[130]=CreateTrigger()
    call TriggerAddCondition(st__IStartable_Start[130],Condition( function sa__FastLoad_Start))
    call TriggerAddAction(st__IStartable_Start[130], function sa__FastLoad_Start)
    set st__IStartable_Stop[130]=CreateTrigger()
    call TriggerAddCondition(st__IStartable_Stop[130],Condition( function sa__FastLoad_Stop))
    call TriggerAddAction(st__IStartable_Stop[130], function sa__FastLoad_Stop)
    set st__IStartable_onDestroy[130]=null
    set st__IStartable_Start[115]=CreateTrigger()
    call TriggerAddCondition(st__IStartable_Start[115],Condition( function sa__IceSkater_Start))
    call TriggerAddAction(st__IStartable_Start[115], function sa__IceSkater_Start)
    set st__IStartable_Stop[115]=CreateTrigger()
    call TriggerAddCondition(st__IStartable_Stop[115],Condition( function sa__IceSkater_Stop))
    call TriggerAddAction(st__IStartable_Stop[115], function sa__IceSkater_Stop)
    set st__IStartable_destroy[115]=CreateTrigger()
    call TriggerAddCondition(st__IStartable_destroy[115],Condition( function sa__IceSkater_destroy))
    call TriggerAddAction(st__IStartable_destroy[115], function sa__IceSkater_destroy)
    set st__IStartable_onDestroy[115]=null
    set st__Blackhole_WatchPlayer=CreateTrigger()
    call TriggerAddCondition(st__Blackhole_WatchPlayer,Condition( function sa__Blackhole_WatchPlayer))
    set st__IStartable_Start[119]=CreateTrigger()
    call TriggerAddCondition(st__IStartable_Start[119],Condition( function sa__Blackhole_Start))
    call TriggerAddAction(st__IStartable_Start[119], function sa__Blackhole_Start)
    set st__IStartable_Stop[119]=CreateTrigger()
    call TriggerAddCondition(st__IStartable_Stop[119],Condition( function sa__Blackhole_Stop))
    call TriggerAddAction(st__IStartable_Stop[119], function sa__Blackhole_Stop)
    set st__IStartable_destroy[119]=CreateTrigger()
    call TriggerAddCondition(st__IStartable_destroy[119],Condition( function sa__Blackhole_destroy))
    call TriggerAddAction(st__IStartable_destroy[119], function sa__Blackhole_destroy)
    set st__Blackhole_create=CreateTrigger()
    call TriggerAddCondition(st__Blackhole_create,Condition( function sa__Blackhole_create))
    set st__IStartable_onDestroy[119]=null
    set st__IStartable_Start[129]=CreateTrigger()
    call TriggerAddCondition(st__IStartable_Start[129],Condition( function sa__CollectibleSet_Start))
    call TriggerAddAction(st__IStartable_Start[129], function sa__CollectibleSet_Start)
    set st__IStartable_Stop[129]=CreateTrigger()
    call TriggerAddCondition(st__IStartable_Stop[129],Condition( function sa__CollectibleSet_Stop))
    call TriggerAddAction(st__IStartable_Stop[129], function sa__CollectibleSet_Stop)
    set st__IStartable_onDestroy[129]=null
    set st___prototype8[1]=CreateTrigger()
    call TriggerAddAction(st___prototype8[1],function sa___prototype8_TimerUtils___init)
    call TriggerAddCondition(st___prototype8[1],Condition(function sa___prototype8_TimerUtils___init))
    set st___prototype29[6]=CreateTrigger()
    call TriggerAddAction(st___prototype29[6],function sa___prototype29_OriginSpawn)
    call TriggerAddCondition(st___prototype29[6],Condition(function sa___prototype29_OriginSpawn))
    set st___prototype29[13]=CreateTrigger()
    call TriggerAddAction(st___prototype29[13],function sa___prototype29_RandomLineSlotSpawn)
    call TriggerAddCondition(st___prototype29[13],Condition(function sa___prototype29_RandomLineSlotSpawn))
    set st___prototype29[2]=CreateTrigger()
    call TriggerAddAction(st___prototype29[2],function sa___prototype29_IntroPatternSpawn)
    call TriggerAddCondition(st___prototype29[2],Condition(function sa___prototype29_IntroPatternSpawn))
    set st___prototype29[1]=CreateTrigger()
    call TriggerAddAction(st___prototype29[1],function sa___prototype29_IW2PatternSpawn)
    call TriggerAddCondition(st___prototype29[1],Condition(function sa___prototype29_IW2PatternSpawn))
    set st___prototype29[3]=CreateTrigger()
    call TriggerAddAction(st___prototype29[3],function sa___prototype29_LW1PatternSpawn1)
    call TriggerAddCondition(st___prototype29[3],Condition(function sa___prototype29_LW1PatternSpawn1))
    set st___prototype29[5]=CreateTrigger()
    call TriggerAddAction(st___prototype29[5],function sa___prototype29_W3APatternSpawn)
    call TriggerAddCondition(st___prototype29[5],Condition(function sa___prototype29_W3APatternSpawn))
    set st___prototype29[4]=CreateTrigger()
    call TriggerAddAction(st___prototype29[4],function sa___prototype29_W4APatternSpawn)
    call TriggerAddCondition(st___prototype29[4],Condition(function sa___prototype29_W4APatternSpawn))
    set st___prototype29[11]=CreateTrigger()
    call TriggerAddAction(st___prototype29[11],function sa___prototype29_RelayGeneratorRandomSpawn)
    call TriggerAddCondition(st___prototype29[11],Condition(function sa___prototype29_RelayGeneratorRandomSpawn))
    set st___prototype29[7]=CreateTrigger()
    call TriggerAddAction(st___prototype29[7],function sa___prototype29_LW2PatternSpawn1)
    call TriggerAddCondition(st___prototype29[7],Condition(function sa___prototype29_LW2PatternSpawn1))
    set st___prototype29[8]=CreateTrigger()
    call TriggerAddAction(st___prototype29[8],function sa___prototype29_LW2PatternSpawn2)
    call TriggerAddCondition(st___prototype29[8],Condition(function sa___prototype29_LW2PatternSpawn2))
    set st___prototype29[9]=CreateTrigger()
    call TriggerAddAction(st___prototype29[9],function sa___prototype29_LW2PatternSpawn3)
    call TriggerAddCondition(st___prototype29[9],Condition(function sa___prototype29_LW2PatternSpawn3))
    set st___prototype29[10]=CreateTrigger()
    call TriggerAddAction(st___prototype29[10],function sa___prototype29_LW2PatternSpawn4)
    call TriggerAddCondition(st___prototype29[10],Condition(function sa___prototype29_LW2PatternSpawn4))
    set st___prototype29[12]=CreateTrigger()
    call TriggerAddAction(st___prototype29[12],function sa___prototype29_PW2PatternSpawn)
    call TriggerAddCondition(st___prototype29[12],Condition(function sa___prototype29_PW2PatternSpawn))
    set st___prototype54[1]=CreateTrigger()
    call TriggerAddAction(st___prototype54[1],function sa___prototype54_All___onPromiseResolve)
    call TriggerAddCondition(st___prototype54[1],Condition(function sa___prototype54_All___onPromiseResolve))
    set st___prototype54[2]=CreateTrigger()
    call TriggerAddAction(st___prototype54[2],function sa___prototype54_All___onPromiseProgress)
    call TriggerAddCondition(st___prototype54[2],Condition(function sa___prototype54_All___onPromiseProgress))
    set st___prototype54[3]=CreateTrigger()
    call TriggerAddAction(st___prototype54[3],function sa___prototype54_Any___onPromiseResolve)
    call TriggerAddCondition(st___prototype54[3],Condition(function sa___prototype54_Any___onPromiseResolve))
    set st___prototype54[4]=CreateTrigger()
    call TriggerAddAction(st___prototype54[4],function sa___prototype54_Any___onPromiseProgress)
    call TriggerAddCondition(st___prototype54[4],Condition(function sa___prototype54_Any___onPromiseProgress))
    set st___prototype54[6]=CreateTrigger()
    call TriggerAddAction(st___prototype54[6],function sa___prototype54_EDWCollectibleResolveHandlers_AdvanceLevel)
    call TriggerAddCondition(st___prototype54[6],Condition(function sa___prototype54_EDWCollectibleResolveHandlers_AdvanceLevel))
    set st___prototype3[2]=CreateTrigger()
    call TriggerAddAction(st___prototype3[2],function sa___prototype3_EDWCinematicContent___IsUserRed)
    call TriggerAddCondition(st___prototype3[2],Condition(function sa___prototype3_EDWCinematicContent___IsUserRed))
    set st___prototype3[1]=CreateTrigger()
    call TriggerAddAction(st___prototype3[1],function sa___prototype3_EDWCinematicContent___IsUserNotRed)
    call TriggerAddCondition(st___prototype3[1],Condition(function sa___prototype3_EDWCinematicContent___IsUserNotRed))
    set st___prototype3[5]=CreateTrigger()
    call TriggerAddAction(st___prototype3[5],function sa___prototype3_EDWCinematicContent___IsUserBlue)
    call TriggerAddCondition(st___prototype3[5],Condition(function sa___prototype3_EDWCinematicContent___IsUserBlue))
    set st___prototype3[3]=CreateTrigger()
    call TriggerAddAction(st___prototype3[3],function sa___prototype3_EDWCinematicContent___IsUserNotInCinema)
    call TriggerAddCondition(st___prototype3[3],Condition(function sa___prototype3_EDWCinematicContent___IsUserNotInCinema))
    set st___prototype3[6]=CreateTrigger()
    call TriggerAddAction(st___prototype3[6],function sa___prototype3_EDWCinematicContent___IsUserStandard)
    call TriggerAddCondition(st___prototype3[6],Condition(function sa___prototype3_EDWCinematicContent___IsUserStandard))
    set st___prototype3[7]=CreateTrigger()
    call TriggerAddAction(st___prototype3[7],function sa___prototype3_EDWCinematicContent___IsUserPlatforming)
    call TriggerAddCondition(st___prototype3[7],Condition(function sa___prototype3_EDWCinematicContent___IsUserPlatforming))
    set st___prototype3[4]=CreateTrigger()
    call TriggerAddAction(st___prototype3[4],function sa___prototype3_EDWCinematicContent___IsUserDying)
    call TriggerAddCondition(st___prototype3[4],Condition(function sa___prototype3_EDWCinematicContent___IsUserDying))
    set st___prototype54[5]=CreateTrigger()
    call TriggerAddAction(st___prototype54[5],function sa___prototype54_s__User_OnUnapplyAFKStandard)
    call TriggerAddCondition(st___prototype54[5],Condition(function sa___prototype54_s__User_OnUnapplyAFKStandard))

call ExecuteFunc("s__DummyCaster_DummyCaster___N__onInit")



call ExecuteFunc("s__RectList_Alloc___onInit")



















































call ExecuteFunc("s__vector2_Alloc___onInit")

call ExecuteFunc("s__GetUnitCollision__init_GetUnitCollision__Initializer___onInit")

call ExecuteFunc("s__IndexedUnit_Alloc___onInit")











call ExecuteFunc("s__SimpleList_ListNode_Alloc___onInit")

call ExecuteFunc("s__SimpleList_List_Alloc___onInit")



call ExecuteFunc("s__TimedEffect_Alloc___onInit")





call ExecuteFunc("s__CinemaCallbackModel_Alloc___onInit")

call ExecuteFunc("s__CinemaMessage_Alloc___onInit")

call ExecuteFunc("s__Cinematic_Alloc___onInit")

call ExecuteFunc("s__DeferredAwaiter_Alloc___onInit")

call ExecuteFunc("s__Deferred_Alloc___onInit")

call ExecuteFunc("s__DrunkWalker_DrunkWalker_Alloc___onInit")




call ExecuteFunc("s__PlatformerPropertyAdjustment_Alloc___onInit")

call ExecuteFunc("s__PlatformerPropertyEquation_Alloc___onInit")

call ExecuteFunc("s__RelayUnit_Alloc___onInit")

call ExecuteFunc("s__RelayTurn_Alloc___onInit")


call ExecuteFunc("s__RespawningUnit_Alloc___onInit")




call ExecuteFunc("s__SynchronizedUnit_Alloc___onInit")


call ExecuteFunc("s__PlayerSaveLocation_Alloc___onInit")

call ExecuteFunc("s__TeamSaveLocation_Alloc___onInit")

call ExecuteFunc("s__WeightedListNode_Alloc___onInit")

call ExecuteFunc("s__WeightedList_Alloc___onInit")






call ExecuteFunc("s__VisualVote_voteInfo_Alloc___onInit")

call ExecuteFunc("s__VisualVote_voteOption_Alloc___onInit")

call ExecuteFunc("s__VisualVote_voteContainer_Alloc___onInit")

call ExecuteFunc("s__VisualVote_voteColumn_Alloc___onInit")


call ExecuteFunc("s__InWorldPowerup_Alloc___onInit")



call ExecuteFunc("s__IceSkater___Destination_Alloc___onInit")



call ExecuteFunc("s__Platformer_Alloc___onInit")




call ExecuteFunc("s__Teams_MazingTeam_Alloc___onInit")


call ExecuteFunc("s__Levels___AnimatedLevelTransferData_Alloc___onInit")


call ExecuteFunc("s__Boss_Alloc___onInit")



call ExecuteFunc("s__CollectibleTeam_Alloc___onInit")









    call ExecuteFunc("s__RectList_onInit")
    call ExecuteFunc("s__Stack_onInit")
    call ExecuteFunc("s__Recycle_UnitRecycler_onInit")
    call ExecuteFunc("s__BoundedSpoke_onInit")
    call ExecuteFunc("s__Cinematic_onInit")
    call ExecuteFunc("s__LavaDamage_onInit")
    call ExecuteFunc("s__PlatformerBounce_onInit")
    call ExecuteFunc("s__RelayGenerator_onInit")
    call ExecuteFunc("s__SimpleGenerator_onInit")
    call ExecuteFunc("s__SimplePatrol_onInit")
    call ExecuteFunc("s__SynchronizedGroup_onInit")
    call ExecuteFunc("s__Wheel_onInit")
    call ExecuteFunc("s__IsMoving_onInit")
    call ExecuteFunc("s__RespawningGateway_onInit")
    call ExecuteFunc("s__SyncRequest_onInit")
    call ExecuteFunc("s__InWorldPowerup_onInit")
    call ExecuteFunc("s__SandMovement_onInit")
    call ExecuteFunc("s__IceSkater_onInit")
    call ExecuteFunc("s__SuperFastMovement_onInit")
    call ExecuteFunc("s__Platformer_onInit")
    call ExecuteFunc("s__User_onInit")
    call ExecuteFunc("s__Blackhole_onInit")
    call ExecuteFunc("s__Teams_MazingTeam_onInit")
    call ExecuteFunc("s__Levels_Level_onInit")
    call ExecuteFunc("s__BossLevel_onInit")
    call ExecuteFunc("s__CollectibleSet_onInit")
    call ExecuteFunc("s__FastLoad_onInit")
    call ExecuteFunc("s__Minigame_onInit")
endfunction

